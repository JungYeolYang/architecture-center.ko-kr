---
title: 데이터 분할 전략
titleSuffix: Best practices for cloud applications
description: 데이터 파티션을 분리하여 별도로 관리하고 액세스하는 방법에 대한 지침입니다.
author: dragon119
ms.date: 11/04/2018
ms.topic: best-practice
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: bb810f549c78d16eabd4a96cd811cdc120cc8b6f
ms.sourcegitcommit: 579c39ff4b776704ead17a006bf24cd4cdc65edd
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/17/2019
ms.locfileid: "59640943"
---
# <a name="data-partitioning-strategies"></a><span data-ttu-id="39f7f-103">데이터 분할 전략</span><span class="sxs-lookup"><span data-stu-id="39f7f-103">Data partitioning strategies</span></span>

<span data-ttu-id="39f7f-104">이 문서에서는 다양한 Azure 데이터 저장소의 데이터 분할 전략을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-104">This article describes some strategies for partitioning data in various Azure data stores.</span></span> <span data-ttu-id="39f7f-105">데이터 분할 시기 및 모범 사례에 대한 일반 지침은 [데이터 분할](./data-partitioning.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="39f7f-105">For general guidance about when to partition data and best practices, see [Data partitioning](./data-partitioning.md)</span></span>

## <a name="partitioning-azure-sql-database"></a><span data-ttu-id="39f7f-106">Azure SQL Database 분할</span><span class="sxs-lookup"><span data-stu-id="39f7f-106">Partitioning Azure SQL Database</span></span>

<span data-ttu-id="39f7f-107">단일 SQL 데이터베이스에는 포함할 수 있는 데이터 볼륨에 대한 제한이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-107">A single SQL database has a limit to the volume of data that it can contain.</span></span> <span data-ttu-id="39f7f-108">처리량은 아키텍처 요소 및 지원되는 동시 연결 수에 의해 제약을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-108">Throughput is constrained by architectural factors and the number of concurrent connections that it supports.</span></span>

<span data-ttu-id="39f7f-109">[탄력적 풀](/azure/sql-database/sql-database-elastic-pool)은 SQL 데이터베이스에 수평 확장을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-109">[Elastic pools](/azure/sql-database/sql-database-elastic-pool) support horizontal scaling for a SQL database.</span></span> <span data-ttu-id="39f7f-110">탄력적 풀을 사용하면 여러 SQL 데이터베이스에 분산되어 있는 분할된 데이터베이스로 데이터를 분할할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-110">Using elastic pools, you can partition your data into shards that are spread across multiple SQL databases.</span></span> <span data-ttu-id="39f7f-111">처리해야 하는 데이터 볼륨이 늘거나 줄어들면 분할된 데이터베이스를 추가 또는 제거할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-111">You can also add or remove shards as the volume of data that you need to handle grows and shrinks.</span></span> <span data-ttu-id="39f7f-112">탄력적 풀은 여러 데이터베이스에 부하를 분산하여 경합을 줄일 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-112">Elastic pools can also help reduce contention by distributing the load across databases.</span></span>

<span data-ttu-id="39f7f-113">각 분할된 데이터베이스는 SQL 데이터베이스로 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-113">Each shard is implemented as a SQL database.</span></span> <span data-ttu-id="39f7f-114">분할된 데이터베이스 하나는 두 개 이상의 데이터 세트(*shardlet*이라고 함)를 보관할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-114">A shard can hold more than one dataset (called a *shardlet*).</span></span> <span data-ttu-id="39f7f-115">각 데이터베이스는 포함된 shardlet을 설명하는 메타데이터를 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-115">Each database maintains metadata that describes the shardlets that it contains.</span></span> <span data-ttu-id="39f7f-116">shardlet은 단일 데이터 항목이거나 동일한 shardlet 키를 공유하는 항목 그룹입니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-116">A shardlet can be a single data item, or a group of items that share the same shardlet key.</span></span> <span data-ttu-id="39f7f-117">예를 들어 다중 테넌트 애플리케이션에서 shardlet 키는 테넌트 ID일 수 있으며, 테넌트에 대한 모든 데이터를 동일한 shardlet에 보관할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-117">For example, in a multitenant application, the shardlet key can be the tenant ID, and all data for a tenant can be held in the same shardlet.</span></span>

<span data-ttu-id="39f7f-118">클라이언트 애플리케이션은 데이터 세트를 shardlet 키와 연결하는 역할을 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-118">Client applications are responsible for associating a dataset with a shardlet key.</span></span> <span data-ttu-id="39f7f-119">별도의 SQL 데이터베이스는 전역 분할된 데이터베이스 맵 관리자 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-119">A separate SQL database acts as a global shard map manager.</span></span> <span data-ttu-id="39f7f-120">이 데이터베이스에는 시스템의 모든 분할된 데이터베이스 및 shardlet 목록이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-120">This database has a list of all the shards and shardlets in the system.</span></span> <span data-ttu-id="39f7f-121">애플리케이션은 분할된 데이터베이스 맵 관리자 데이터베이스에 연결하여 분할된 데이터베이스 맵 복사본을 획득합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-121">The application connects to the shard map manager database to obtain a copy of the shard map.</span></span> <span data-ttu-id="39f7f-122">분할된 데이터베이스 맵을 로컬로 캐시하고, 맵을 사용하여 데이터 요청을 적절한 분할된 데이터베이스로 라우팅합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-122">It caches the shard map locally, and uses the map to route data requests to the appropriate shard.</span></span> <span data-ttu-id="39f7f-123">이 기능은 [Elastic Database 클라이언트 라이브러리](/azure/sql-database/sql-database-elastic-database-client-library)에 포함된 일련의 API에 포함되어 있으며, Java 및 .NET에 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-123">This functionality is hidden behind a series of APIs that are contained in the [Elastic Database client library](/azure/sql-database/sql-database-elastic-database-client-library), which is available for Java and .NET.</span></span>

<span data-ttu-id="39f7f-124">탄력적 풀에 대한 자세한 내용은 [Azure SQL Database를 사용하여 확장](/azure/sql-database/sql-database-elastic-scale-introduction)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="39f7f-124">For more information about elastic pools, see [Scaling out with Azure SQL Database](/azure/sql-database/sql-database-elastic-scale-introduction).</span></span>

<span data-ttu-id="39f7f-125">글로벌 분할된 데이터베이스 맵 관리자 데이터베이스를 복제하여 대기 시간을 줄이고 가용성을 향상할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-125">To reduce latency and improve availability, you can replicate the global shard map manager database.</span></span> <span data-ttu-id="39f7f-126">프리미엄 가격 책정 계층을 사용하면 활성 지역 복제를 구성하여 다른 지역에 있는 데이터베이스에 지속적으로 데이터를 복사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-126">With the Premium pricing tiers, you can configure active geo-replication to continuously copy data to databases in different regions.</span></span>

<span data-ttu-id="39f7f-127">또 다른 방법으로 [Azure SQL 데이터 동기화](/azure/sql-database/sql-database-sync-data) 또는 [Azure Data Factory](/azure/data-factory/)를 사용하여 여러 지역에 분할된 데이터베이스 맵 관리자 데이터베이스를 복제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-127">Alternatively, use [Azure SQL Data Sync](/azure/sql-database/sql-database-sync-data) or [Azure Data Factory](/azure/data-factory/) to replicate the shard map manager database across regions.</span></span> <span data-ttu-id="39f7f-128">이러한 형태의 복제는 정기적으로 실행되며, 분할된 데이터베이스 맵이 드물게 변경되고 프리미엄 계층이 필요 없는 경우에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-128">This form of replication runs periodically and is more suitable if the shard map changes infrequently, and does not require Premium tier.</span></span>

<span data-ttu-id="39f7f-129">Elastic Database는 다음과 같이 shardlet에 데이터를 매핑하고 분할된 데이터베이스에 저장할 수 있는 두 가지 구성표를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-129">Elastic Database provides two schemes for mapping data to shardlets and storing them in shards:</span></span>

- <span data-ttu-id="39f7f-130">**목록 분할된 데이터베이스 맵**은 shardlet에 단일 키를 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-130">A **list shard map** associates a single key to a shardlet.</span></span> <span data-ttu-id="39f7f-131">예를 들어 다중 테넌트 시스템에서 각 테넌트에 대한 데이터를 고유 키와 연결하고 자체 shardlet에 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-131">For example, in a multitenant system, the data for each tenant can be associated with a unique key and stored in its own shardlet.</span></span> <span data-ttu-id="39f7f-132">격리를 보장하기 위해 각 shardlet을 자체 분할된 데이터베이스에 보관할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-132">To guarantee isolation, each shardlet can be held within its own shard.</span></span>

    ![목록 분할된 데이터베이스 맵을 사용하여 테넌트 데이터를 별도의 분할된 데이터베이스에 저장](./images/data-partitioning/PointShardlet.png)

- <span data-ttu-id="39f7f-134">**범위 분할된 데이터베이스 맵**은 연속 키 값 집합을 shardlet에 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-134">A **range shard map** associates a set of contiguous key values to a shardlet.</span></span> <span data-ttu-id="39f7f-135">예를 들어 동일한 shardlet 내에 있는 테넌트 집합(각각 자체 키를 갖고 있는)의 데이터를 그룹화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-135">For example, you can group the data for a set of tenants (each with their own key) within the same shardlet.</span></span> <span data-ttu-id="39f7f-136">이 구성표는 테넌트가 데이터 스토리지를 공유하기 때문에 첫 번째보다 저렴하지만 격리가 부족합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-136">This scheme is less expensive than the first, because tenants share data storage, but has less isolation.</span></span>

    ![범위 분할된 데이터베이스 맵을 사용하여 테넌트 범위에 대한 데이터를 분할된 데이터베이스에 저장](./images/data-partitioning/RangeShardlet.png)

<span data-ttu-id="39f7f-138">분할된 데이터베이스 하나에 여러 shardlet의 데이터가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-138">A single shard can contain the data for several shardlets.</span></span> <span data-ttu-id="39f7f-139">예를 들어 목록 shardlet을 사용하여 연속되지 않은 다양한 테넌트 데이터를 동일한 분할된 데이터베이스에 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-139">For example, you can use list shardlets to store data for different non-contiguous tenants in the same shard.</span></span> <span data-ttu-id="39f7f-140">범위 shardlet과 목록 shardlet을 동일한 분할된 데이터베이스에 혼합할 수도 있지만, 다른 맵을 통해 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-140">You can also mix range shardlets and list shardlets in the same shard, although they will be addressed through different maps.</span></span> <span data-ttu-id="39f7f-141">다음 다이어그램은 이 방법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-141">The following diagram shows this approach:</span></span>

![여러 개의 분할된 데이터베이스 맵 구현](./images/data-partitioning/MultipleShardMaps.png)

<span data-ttu-id="39f7f-143">탄력적 풀은 데이터 볼륨이 늘거나 줄면 분할된 데이터베이스를 추가하거나 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-143">Elastic pools makes it possible to add and remove shards as the volume of data shrinks and grows.</span></span> <span data-ttu-id="39f7f-144">클라이언트 애플리케이션은 분할된 데이터베이스를 동적으로 생성 및 삭제하고, 분할된 데이터베이스 맵 관리자를 투명하게 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-144">Client applications can create and delete shards dynamically, and transparently update the shard map manager.</span></span> <span data-ttu-id="39f7f-145">그러나 분할된 데이터베이스를 제거하는 것도 분할된 데이터베이스에 있는 모든 데이터를 삭제해야 하는 삭제 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-145">However, removing a shard is a destructive operation that also requires deleting all the data in that shard.</span></span>

<span data-ttu-id="39f7f-146">애플리케이션에서 분할된 데이터베이스 하나를 두 개의 분할된 데이터베이스로 분할하거나 분할된 데이터베이스를 결합해야 하는 경우 [분할-병합 도구](/azure/sql-database/sql-database-elastic-scale-overview-split-and-merge)를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-146">If an application needs to split a shard into two separate shards or combine shards, use the [split-merge tool](/azure/sql-database/sql-database-elastic-scale-overview-split-and-merge).</span></span> <span data-ttu-id="39f7f-147">이 도구는 Azure 웹 서비스로 실행되며, 분할된 데이터베이스 간에 데이터를 안전하게 마이그레이션합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-147">This tool runs as an Azure web service, and migrates data safely between shards.</span></span>

<span data-ttu-id="39f7f-148">파티션 구성표 시스템의 성능에 크게 영향을 줄 수입니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-148">The partitioning scheme can significantly affect the performance of your system.</span></span> <span data-ttu-id="39f7f-149">분할된 데이터베이스를 추가하거나 제거해야 하는 속도 또는 데이터를 분할된 데이터베이스에 다시 분할해야 하는 속도에도 영향을 미칠 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-149">It can also affect the rate at which shards have to be added or removed, or that data must be repartitioned across shards.</span></span> <span data-ttu-id="39f7f-150">다음 사항을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-150">Consider the following points:</span></span>

- <span data-ttu-id="39f7f-151">함께 사용되는 데이터를 동일한 분할된 데이터베이스에 그룹화하고, 여러 분할된 데이터베이스의 데이터에 액세스하는 작업을 피해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-151">Group data that is used together in the same shard, and avoid operations that access data from multiple shards.</span></span> <span data-ttu-id="39f7f-152">분할된 데이터베이스는 그 자체로 SQL 데이터베이스이며, 데이터베이스 간 조인은 클라이언트 쪽에서 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-152">A shard is a SQL database in its own right, and cross-database joins must be performed on the client side.</span></span>

    <span data-ttu-id="39f7f-153">SQL Database, 데이터베이스 간 조인을 지원 하지 않더라도 수행 하려면 Elastic Database 도구를 사용할 수 있습니다 [다중 분할 된 데이터베이스 쿼리](/azure/sql-database/sql-database-elastic-scale-multishard-querying)합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-153">Although SQL Database does not support cross-database joins, you can use the Elastic Database tools to perform [multi-shard queries](/azure/sql-database/sql-database-elastic-scale-multishard-querying).</span></span> <span data-ttu-id="39f7f-154">다중 분할된 데이터베이스 쿼리는 각 데이터베이스에 개별 쿼리를 보내고 결과를 병합합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-154">A multi-shard query sends individual queries to each database and merges the results.</span></span>

- <span data-ttu-id="39f7f-155">분할된 데이터베이스 간에 종속성이 있는 시스템을 디자인하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-155">Don't design a system that has dependencies between shards.</span></span> <span data-ttu-id="39f7f-156">한 데이터베이스의 참조 무결성 제약 조건, 트리거 및 저장 프로시저는 다른 데이터베이스의 개체를 참조할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-156">Referential integrity constraints, triggers, and stored procedures in one database cannot reference objects in another.</span></span>

- <span data-ttu-id="39f7f-157">쿼리에서 자주 사용하는 참조 데이터가 있는 경우 이 데이터를 여러 분할된 데이터베이스에 복제하는 방안을 고려해보세요.</span><span class="sxs-lookup"><span data-stu-id="39f7f-157">If you have reference data that is frequently used by queries, consider replicating this data across shards.</span></span> <span data-ttu-id="39f7f-158">이 방법은 데이터를 여러 데이터베이스에서 조인할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-158">This approach can remove the need to join data across databases.</span></span> <span data-ttu-id="39f7f-159">원칙적으로 복제 작업을 최소화하고 오래될 가능성을 줄이려면 이러한 데이터가 정적이거나 이동 속도가 느려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-159">Ideally, such data should be static or slow-moving, to minimize the replication effort and reduce the chances of it becoming stale.</span></span>

- <span data-ttu-id="39f7f-160">동일한 분할된 데이터베이스 맵에 속하는 shardlet의 스키마는 동일해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-160">Shardlets that belong to the same shard map should have the same schema.</span></span> <span data-ttu-id="39f7f-161">이 규칙은 SQL Database에는 적용되지 않지만 데이터 관리에 적용되며, 각 shardlet에 다른 스키마가 있는 경우 쿼리가 매우 복잡해집니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-161">This rule is not enforced by SQL Database, but data management and querying becomes very complex if each shardlet has a different schema.</span></span> <span data-ttu-id="39f7f-162">대신, 각 스키마에 대한 별도의 분할된 데이터베이스 맵을 만드세요.</span><span class="sxs-lookup"><span data-stu-id="39f7f-162">Instead, create separate shard maps for each schema.</span></span> <span data-ttu-id="39f7f-163">서로 다른 shardlet에 속하는 데이터를 동일한 분할된 데이터베이스에 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-163">Remember that data belonging to different shardlets can be stored in the same shard.</span></span>

- <span data-ttu-id="39f7f-164">트랜잭션 작업은 한 분할된 데이터베이스의 데이터에만 지원되며, 분할된 데이터베이스 간에는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-164">Transactional operations are only supported for data within a shard, and not across shards.</span></span> <span data-ttu-id="39f7f-165">shardlet이 동일한 분할된 데이터베이스의 일부인 경우 트랜잭션이 여러 shardlet에 걸쳐 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-165">Transactions can span shardlets as long as they are part of the same shard.</span></span> <span data-ttu-id="39f7f-166">따라서 비즈니스 논리에서 트랜잭션을 수행해야 하는 경우 데이터를 동일한 분할된 데이터베이스에 저장하거나 최종 일관성을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-166">Therefore, if your business logic needs to perform transactions, either store the data in the same shard or implement eventual consistency.</span></span>

- <span data-ttu-id="39f7f-167">분할된 데이터베이스는 해당 분할된 데이터베이스의 데이터에 액세스하는 사용자와 가깝게 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-167">Place shards close to the users that access the data in those shards.</span></span> <span data-ttu-id="39f7f-168">이 전략은 대기 시간을 줄이는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-168">This strategy helps reduce latency.</span></span>

- <span data-ttu-id="39f7f-169">고도로 활성 상태인 분할된 데이터베이스와 상대적으로 비활성인 분할된 데이터베이스를 혼합하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-169">Avoid having a mixture of highly active and relatively inactive shards.</span></span> <span data-ttu-id="39f7f-170">분할된 데이터베이스 간에 부하를 균등하게 분산하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-170">Try to spread the load evenly across shards.</span></span> <span data-ttu-id="39f7f-171">이를 위해 분할 키를 해시해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-171">This might require hashing the sharding keys.</span></span> <span data-ttu-id="39f7f-172">분할된 데이터베이스의 지리적 위치를 지정하는 경우 해시된 키가 해당 데이터에 액세스하는 사용자 가까이 저장된 분할된 데이터베이스에서 보관하는 shardlet으로 매핑되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-172">If you are geo-locating shards, make sure that the hashed keys map to shardlets held in shards stored close to the users that access that data.</span></span>

### <a name="partitioning-azure-table-storage"></a><span data-ttu-id="39f7f-173">Azure Table Storage 분할</span><span class="sxs-lookup"><span data-stu-id="39f7f-173">Partitioning Azure table storage</span></span>

<span data-ttu-id="39f7f-174">Azure Table Storage는 분할을 중심으로 디자인하여 저장한 키-값입니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-174">Azure table storage is a key-value store that's designed around partitioning.</span></span> <span data-ttu-id="39f7f-175">모든 엔터티가 파티션에 저장되고 파티션은 Azure Table Storage에서 내부적으로 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-175">All entities are stored in a partition, and partitions are managed internally by Azure table storage.</span></span> <span data-ttu-id="39f7f-176">테이블에 저장된 각 엔터티는 다음과 같이 두 개의 부분 키를 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-176">Each entity stored in a table must provide a two-part key that includes:</span></span>

- <span data-ttu-id="39f7f-177">**파티션 키**.</span><span class="sxs-lookup"><span data-stu-id="39f7f-177">**The partition key**.</span></span> <span data-ttu-id="39f7f-178">Azure 테이블 스토리지에서 엔터티를 배치할 파티션을 결정하는 문자열 값입니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-178">This is a string value that determines the partition where Azure table storage will place the entity.</span></span> <span data-ttu-id="39f7f-179">파티션 키가 동일한 모든 엔터티는 동일한 파티션에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-179">All entities with the same partition key are stored in the same partition.</span></span>

- <span data-ttu-id="39f7f-180">**행 키**.</span><span class="sxs-lookup"><span data-stu-id="39f7f-180">**The row key**.</span></span> <span data-ttu-id="39f7f-181">파티션 내에서 엔터티를 식별하는 문자열 값입니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-181">This is a string value that identifies the entity within the partition.</span></span> <span data-ttu-id="39f7f-182">파티션 내의 모든 엔터티는 이 키에 따라 어휘순 및 오름차순으로 정렬됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-182">All entities within a partition are sorted lexically, in ascending order, by this key.</span></span> <span data-ttu-id="39f7f-183">파티션 키와 행 키의 조합은 엔터티별로 고유해야 하며 길이가 1KB 이하여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-183">The partition key/row key combination must be unique for each entity and cannot exceed 1 KB in length.</span></span>

<span data-ttu-id="39f7f-184">이전에 사용되지 않은 파티션 키를 사용하여 엔터티를 테이블에 추가하면 Azure Table Storage에서 이 엔터티를 위한 새 파티션을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-184">If an entity is added to a table with a previously unused partition key, Azure table storage creates a new partition for this entity.</span></span> <span data-ttu-id="39f7f-185">파티션 키가 동일한 기타 엔터티도 동일한 파티션에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-185">Other entities with the same partition key will be stored in the same partition.</span></span>

<span data-ttu-id="39f7f-186">이 메커니즘은 자동 확장 전략을 효과적으로 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-186">This mechanism effectively implements an automatic scale-out strategy.</span></span> <span data-ttu-id="39f7f-187">단일 파티션에서 데이터를 검색하는 쿼리가 신속하게 실행될 수 있도록 각 파티션은 Azure 데이터 센터의 동일한 서버에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-187">Each partition is stored on the same server in an Azure datacenter to help ensure that queries that retrieve data from a single partition run quickly.</span></span>

<span data-ttu-id="39f7f-188">Microsoft는 Azure Storage에 대한 [확장성 목표]를 게시했습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-188">Microsoft has published [scalability targets] for Azure Storage.</span></span> <span data-ttu-id="39f7f-189">시스템이 이러한 제한을 초과할 가능성이 있으면 엔터티를 여러 테이블로 분할하는 방안을 고려해보세요.</span><span class="sxs-lookup"><span data-stu-id="39f7f-189">If your system is likely to exceed these limits, consider splitting entities into multiple tables.</span></span> <span data-ttu-id="39f7f-190">수직 분할을 사용하여 함께 액세스할 가능성이 높은 그룹으로 필드를 나눕니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-190">Use vertical partitioning to divide the fields into the groups that are most likely to be accessed together.</span></span>

<span data-ttu-id="39f7f-191">다음 다이어그램은 예제 스토리지 계정의 논리 구조를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-191">The following diagram shows the logical structure of an example storage account.</span></span> <span data-ttu-id="39f7f-192">스토리지 계정에 3개 테이블이 있습니다. 각각 고객 정보, 제품 정보, 주문 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-192">The storage account contains three tables: Customer Info, Product Info, and Order Info.</span></span>

![저장소 계정 예의 테이블 및 파티션](./images/data-partitioning/TableStorage.png)

<span data-ttu-id="39f7f-194">각 테이블에는 여러 개의 파티션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-194">Each table has multiple partitions.</span></span>

- <span data-ttu-id="39f7f-195">고객 정보 테이블에서, 데이터는 고객이 있는 도시에 따라 분할됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-195">In the Customer Info table, the data is partitioned according to the city where the customer is located.</span></span> <span data-ttu-id="39f7f-196">행 키에는 고객 ID가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-196">The row key contains the customer ID.</span></span>
- <span data-ttu-id="39f7f-197">제품 정보 테이블에서, 제품은 제품 범주별로 분할되고 행 키에는 제품 번호가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-197">In the Product Info table, products are partitioned by product category, and the row key contains the product number.</span></span>
- <span data-ttu-id="39f7f-198">주문 정보 테이블에서, 주문은 주문 날짜에 따라 분할되고 행 키는 주문을 받은 시간을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-198">In the Order Info table, the orders are partitioned by order date, and the row key specifies the time the order was received.</span></span> <span data-ttu-id="39f7f-199">각 파티션의 행 키에 따라 모든 데이터가 정렬됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-199">Note that all data is ordered by the row key in each partition.</span></span>

<span data-ttu-id="39f7f-200">Azure Table Storage에 엔터티를 디자인할 때 다음 사항을 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="39f7f-200">Consider the following points when you design your entities for Azure table storage:</span></span>

- <span data-ttu-id="39f7f-201">데이터 액세스 방법에 따라 파티션 키와 행 키를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-201">Select a partition key and row key by how the data is accessed.</span></span> <span data-ttu-id="39f7f-202">대부분의 쿼리를 지원하는 파티션 키/행 키 조합을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-202">Choose a partition key/row key combination that supports the majority of your queries.</span></span> <span data-ttu-id="39f7f-203">가장 효율적인 쿼리는 파티션 키와 행 키를 지정하여 데이터를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-203">The most efficient queries retrieve data by specifying the partition key and the row key.</span></span> <span data-ttu-id="39f7f-204">파티션 키와 행 키의 범위를 지정하는 쿼리는 하나의 파티션을 검색하여 완료할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-204">Queries that specify a partition key and a range of row keys can be completed by scanning a single partition.</span></span> <span data-ttu-id="39f7f-205">이 방법은 데이터를 행 키 순서대로 보관하기 때문에 상대적으로 빠릅니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-205">This is relatively fast because the data is held in row key order.</span></span> <span data-ttu-id="39f7f-206">쿼리에서 검색할 파티션을 지정하지 않으면 모든 파티션을 검색해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-206">If queries don't specify which partition to scan, every partition must be scanned.</span></span>

- <span data-ttu-id="39f7f-207">엔터티에 하나의 기본 키가 있으면 이를 파티션 키로 사용하고 빈 문자열을 행 키로 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-207">If an entity has one natural key, then use it as the partition key and specify an empty string as the row key.</span></span> <span data-ttu-id="39f7f-208">엔터티에 두 속성으로 구성되는 복합 키가 있으면 가장 느리게 변경되는 속성을 파티션 키로 선택하고 다른 속성을 행 키로 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-208">If an entity has a composite key consisting of two properties, select the slowest changing property as the partition key and the other as the row key.</span></span> <span data-ttu-id="39f7f-209">엔터티에 키 속성이 세 개 이상 있으면 속성 연결을 사용하여 파티션 키와 행 키를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-209">If an entity has more than two key properties, use a concatenation of properties to provide the partition and row keys.</span></span>

- <span data-ttu-id="39f7f-210">파티션 키 및 행 키 이외의 필드를 사용하여 데이터를 조회하는 쿼리를 정기적으로 수행하는 경우 [인덱스 테이블 패턴](../patterns/index-table.md)을 구현하거나 Cosmos DB처럼 인덱싱을 지원하는 다른 데이터 저장소를 고려해보세요.</span><span class="sxs-lookup"><span data-stu-id="39f7f-210">If you regularly perform queries that look up data by using fields other than the partition and row keys, consider implementing the [Index Table pattern](../patterns/index-table.md), or consider using a different data store that supports indexing, such as Cosmos DB.</span></span>

- <span data-ttu-id="39f7f-211">단조 시퀀스를 사용하여 파티션 키를 생성하고(예: "0001", "0002", "0003") 각 파티션에 제한된 양의 데이터만 포함되는 경우 Azure 테이블 스토리지는 이러한 파티션을 동일한 서버에 물리적으로 그룹화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-211">If you generate partition keys by using a monotonic sequence (such as "0001", "0002", "0003") and each partition only contains a limited amount of data, Azure table storage can physically group these partitions together on the same server.</span></span> <span data-ttu-id="39f7f-212">Azure Storage는 애플리케이션이 파티션(범위 쿼리)의 연속된 범위에서 쿼리를 수행할 가능성이 가장 높으며 이러한 경우에 최적화된 것으로 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-212">Azure Storage assumes that the application is most likely to perform queries across a contiguous range of partitions (range queries) and is optimized for this case.</span></span> <span data-ttu-id="39f7f-213">그러나 이 방법은 새 엔터티를 삽입할 때마다 연속된 범위의 한 쪽 끝에 집중될 가능성이 있으므로 핫스폿이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-213">However, this approach can lead to hotspots, because all insertions of new entities are likely to be concentrated at one end the contiguous range.</span></span> <span data-ttu-id="39f7f-214">또한 확장성이 떨어질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-214">It can also reduce scalability.</span></span> <span data-ttu-id="39f7f-215">부하를 보다 균등하게 분산하려면 파티션 키를 해시하는 방안을 고려해보세요.</span><span class="sxs-lookup"><span data-stu-id="39f7f-215">To spread the load more evenly, consider hashing the partition key.</span></span>

- <span data-ttu-id="39f7f-216">Azure Table Storage는 동일한 파티션에 속하는 엔터티에 대한 트랜잭션 작업을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-216">Azure table storage supports transactional operations for entities that belong to the same partition.</span></span> <span data-ttu-id="39f7f-217">애플리케이션이 다중 삽입, 업데이트, 삭제, 바꾸기 또는 병합 작업을 원자 단위(트랜잭션의 엔터티가 100개 이하이고 요청 페이로드가 4MB 이하인 경우)로 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-217">An application can perform multiple insert, update, delete, replace, or merge operations as an atomic unit, as long as the transaction doesn't include more than 100 entities and the payload of the request doesn't exceed 4 MB.</span></span> <span data-ttu-id="39f7f-218">여러 파티션에 분산된 작업은 트랜잭션이 아니며, 최종 일관성을 구현해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-218">Operations that span multiple partitions are not transactional, and might require you to implement eventual consistency.</span></span> <span data-ttu-id="39f7f-219">테이블 스토리지 및 트랜잭션에 대한 자세한 내용은 [엔터티 그룹 트랜잭션 수행]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="39f7f-219">For more information about table storage and transactions, see [Performing entity group transactions].</span></span>

- <span data-ttu-id="39f7f-220">파티션 키의 세분성을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-220">Consider the granularity of the partition key:</span></span>

  - <span data-ttu-id="39f7f-221">모든 엔터티에 동일한 파티션 키를 사용하면 단일 파티션이 한 서버에 보관됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-221">Using the same partition key for every entity results in a single partition that's held on one server.</span></span> <span data-ttu-id="39f7f-222">이렇게 하면 파티션이 확장되지 않고 단일 서버의 부하에 집중됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-222">This prevents the partition from scaling out and focuses the load on a single server.</span></span> <span data-ttu-id="39f7f-223">결과적으로 이 방법은 적은 수의 엔터티를 저장하는 시스템에만 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-223">As a result, this approach is only suitable for storing a small number of entities.</span></span> <span data-ttu-id="39f7f-224">그러나 이 방법은 모든 엔터티가 엔터티 그룹 트랜잭션에 참여할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-224">However, it does ensure that all entities can participate in entity group transactions.</span></span>

  - <span data-ttu-id="39f7f-225">모든 엔터티에 고유 파티션 키를 사용하면 테이블 스토리지 서비스에서 각 엔터티에 대해 별도의 파티션을 만들어 다수의 작은 파티션이 생길 가능성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-225">Using a unique partition key for every entity causes the table storage service to create a separate partition for each entity, possibly resulting in a large number of small partitions.</span></span> <span data-ttu-id="39f7f-226">이 방법은 단일 파티션 키를 사용하는 방법보다 확장성이 뛰어나지만 엔터티 그룹 트랜잭션을 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-226">This approach is more scalable than using a single partition key, but entity group transactions are not possible.</span></span> <span data-ttu-id="39f7f-227">또한 엔터티를 두 개 이상 가져오는 쿼리에 두 개 이상의 서버를 읽는 작업이 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-227">Also, queries that fetch more than one entity might involve reading from more than one server.</span></span> <span data-ttu-id="39f7f-228">그러나 애플리케이션에서 범위 쿼리를 수행한 다음, 파티션 키에 단조 시퀀스를 사용하면 쿼리를 최적화하는 데 도움이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-228">However, if the application performs range queries, then using a monotonic sequence for the partition keys might help to optimize these queries.</span></span>

  - <span data-ttu-id="39f7f-229">엔터티 하위 집합에서 파티션 키를 공유하면 동일한 파티션에서 관련 엔터티를 그룹화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-229">Sharing the partition key across a subset of entities makes it possible to group related entities in the same partition.</span></span> <span data-ttu-id="39f7f-230">관련 엔터티가 포함된 작업은 엔터티 그룹 트랜잭션을 사용하여 수행할 수 있으며, 관련 엔터티 집합을 가져오는 쿼리는 단일 서버에 액세스하여 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-230">Operations that involve related entities can be performed by using entity group transactions, and queries that fetch a set of related entities can be satisfied by accessing a single server.</span></span>

<span data-ttu-id="39f7f-231">자세한 내용은 [Azure 저장소 테이블 설계 가이드]를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="39f7f-231">For more information, see [Azure storage table design guide].</span></span>

## <a name="partitioning-azure-blob-storage"></a><span data-ttu-id="39f7f-232">Azure Blob Storage 분할</span><span class="sxs-lookup"><span data-stu-id="39f7f-232">Partitioning Azure blob storage</span></span>

<span data-ttu-id="39f7f-233">Azure Blob 스토리지를 사용하면 큰 이진 개체를 보관할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-233">Azure blob storage makes it possible to hold large binary objects.</span></span> <span data-ttu-id="39f7f-234">대용량 데이터를 신속하게 업로드 또는 다운로드해야 하는 시나리오에는 블록 Blob을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-234">Use block blobs in scenarios when you need to upload or download large volumes of data quickly.</span></span> <span data-ttu-id="39f7f-235">페이지 BLOB은 데이터 일부에 직렬 액세스가 아닌 랜덤 액세스가 필요한 애플리케이션에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-235">Use page blobs for applications that require random rather than serial access to parts of the data.</span></span>

<span data-ttu-id="39f7f-236">각 Blob(블록 또는 페이지)은 Azure 저장소 계정의 컨테이너에 보관됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-236">Each blob (either block or page) is held in a container in an Azure storage account.</span></span> <span data-ttu-id="39f7f-237">컨테이너를 사용하여 보안 요구 사항이 동일한 관련 Blob을 그룹화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-237">You can use containers to group related blobs that have the same security requirements.</span></span> <span data-ttu-id="39f7f-238">해당 그룹화는 물리적이 아니라 논리적입니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-238">This grouping is logical rather than physical.</span></span> <span data-ttu-id="39f7f-239">컨테이너 내에 있는 각 Blob에는 고유의 이름이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-239">Inside a container, each blob has a unique name.</span></span>

<span data-ttu-id="39f7f-240">Blob의 파티션 키는 계정 이름 + 컨테이너 이름 + Blob 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-240">The partition key for a blob is account name + container name + blob name.</span></span> <span data-ttu-id="39f7f-241">파티션 키는 데이터를 범위로 파티션하는 데 사용되며 이러한 범위는 시스템 전체에서 부하가 분산됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-241">The partition key is used to partition data into ranges and these ranges are load-balanced across the system.</span></span> <span data-ttu-id="39f7f-242">액세스를 확장하기 위해 blob을 여러 서버에 분산시킬 수 있지만 단일 blob은 단일 서버에 의해서만 처리될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-242">Blobs can be distributed across many servers in order to scale out access to them, but a single blob can only be served by a single server.</span></span>

<span data-ttu-id="39f7f-243">명명 체계에 타임스탬프 또는 숫자 식별자를 사용하면 한 파티션에 과도한 트래픽이 전송되어 시스템이 부하 균형을 효율적으로 조정할 수 없게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-243">If your naming scheme uses timestamps or numerical identifiers, it can lead to excessive traffic going to one partition, limiting the system from effectively load balancing.</span></span> <span data-ttu-id="39f7f-244">예를 들어 일상적인 작업에서 *yyyy-mm-dd* 같은 타임스탬프가 포함된 Blob 개체를 사용하는 경우 해당 작업의 모든 트래픽이 단일 파티션 서버로 전송될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-244">For instance, if you have daily operations that use a blob object with a timestamp such as *yyyy-mm-dd*, all the traffic for that operation would go to a single partition server.</span></span> <span data-ttu-id="39f7f-245">이 방법 대신 3자리 해시를 이름의 접두사로 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="39f7f-245">Instead, consider prefixing the name with a 3-digit hash.</span></span> <span data-ttu-id="39f7f-246">자세한 내용은 [파티션 명명 규칙](/azure/storage/common/storage-performance-checklist#subheading47)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="39f7f-246">For more information, see [Partition Naming Convention](/azure/storage/common/storage-performance-checklist#subheading47)</span></span>

<span data-ttu-id="39f7f-247">단일 블록 또는 페이지를 쓰는 작업은 원자성이지만, 여러 블록, 페이지 또는 Blob을 아우르는 작업은 그렇지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-247">The actions of writing a single block or page are atomic, but operations that span blocks, pages, or blobs are not.</span></span> <span data-ttu-id="39f7f-248">여러 블록, 페이지 및 Blob에서 쓰기 작업을 수행할 때 일관성을 유지해야 하는 경우에는 Blob 임대를 사용하여 쓰기 잠금을 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-248">If you need to ensure consistency when performing write operations across blocks, pages, and blobs, take out a write lock by using a blob lease.</span></span>

## <a name="partitioning-azure-storage-queues"></a><span data-ttu-id="39f7f-249">Azure 저장소 큐 분할</span><span class="sxs-lookup"><span data-stu-id="39f7f-249">Partitioning Azure storage queues</span></span>

<span data-ttu-id="39f7f-250">Azure 저장소 큐를 사용하면 프로세스 간에 비동기 메시징을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-250">Azure storage queues enable you to implement asynchronous messaging between processes.</span></span> <span data-ttu-id="39f7f-251">Azure 저장소 계정에는 큐가 개수에 관계없이 포함될 수 있으며 각 큐에는 메시지가 개수에 관계없이 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-251">An Azure storage account can contain any number of queues, and each queue can contain any number of messages.</span></span> <span data-ttu-id="39f7f-252">유일한 제한은 저장소 계정에서 사용 가능한 공간입니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-252">The only limitation is the space that's available in the storage account.</span></span> <span data-ttu-id="39f7f-253">개별 메시지의 최대 크기는 64KB입니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-253">The maximum size of an individual message is 64 KB.</span></span> <span data-ttu-id="39f7f-254">이보다 큰 메시지가 필요한 경우 Azure Service Bus 큐를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-254">If you require messages bigger than this, then consider using Azure Service Bus queues instead.</span></span>

<span data-ttu-id="39f7f-255">각 저장소 큐에는 저장소 큐가 포함된 저장소 계정 내에서 고유한 이름이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-255">Each storage queue has a unique name within the storage account that contains it.</span></span> <span data-ttu-id="39f7f-256">Azure 파티션 큐는 이름을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-256">Azure partitions queues based on the name.</span></span> <span data-ttu-id="39f7f-257">동일한 큐의 모든 메시지는 단일 서버에서 제어하는 동일한 파티션에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-257">All messages for the same queue are stored in the same partition, which is controlled by a single server.</span></span> <span data-ttu-id="39f7f-258">부하 분산을 위해 큐마다 다른 서버에서 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-258">Different queues can be managed by different servers to help balance the load.</span></span> <span data-ttu-id="39f7f-259">서버에 대한 큐 할당이 애플리케이션 및 사용자에게 투명합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-259">The allocation of queues to servers is transparent to applications and users.</span></span>

<span data-ttu-id="39f7f-260">규모가 큰 애플리케이션에서 애플리케이션의 모든 인스턴스에 동일한 스토리지 큐를 사용하면 큐를 호스트하는 서버가 핫스팟이 될 수 있으므로 동일한 스토리지 큐를 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-260">In a large-scale application, don't use the same storage queue for all instances of the application because this approach might cause the server that's hosting the queue to become a hotspot.</span></span> <span data-ttu-id="39f7f-261">대신 애플리케이션 기능 영역별로 다른 큐를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-261">Instead, use different queues for different functional areas of the application.</span></span> <span data-ttu-id="39f7f-262">Azure storage 큐 메시징 일관성에 거의 영향을 미치지를 다른 큐로 메시지를 전송 하므로 트랜잭션을 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-262">Azure storage queues do not support transactions, so directing messages to different queues should have little effect on messaging consistency.</span></span>

<span data-ttu-id="39f7f-263">Azure 저장소 큐는 초당 최대 2000개의 메시지를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-263">An Azure storage queue can handle up to 2,000 messages per second.</span></span> <span data-ttu-id="39f7f-264">이보다 더 빠른 속도로 메시지를 처리해야 하는 경우에는 다중 큐를 만드는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-264">If you need to process messages at a greater rate than this, consider creating multiple queues.</span></span> <span data-ttu-id="39f7f-265">예를 들어 전역 애플리케이션에서는 별도의 스토리지 계정에 별도의 스토리지 큐를 만들어 각 지역에서 실행되는 애플리케이션 인스턴스를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-265">For example, in a global application, create separate storage queues in separate storage accounts to handle application instances that are running in each region.</span></span>

## <a name="partitioning-azure-service-bus"></a><span data-ttu-id="39f7f-266">Azure Service Bus 분할</span><span class="sxs-lookup"><span data-stu-id="39f7f-266">Partitioning Azure Service Bus</span></span>

<span data-ttu-id="39f7f-267">Azure Service Bus는 메시지 브로커를 사용하여 Service Bus 큐 또는 토픽으로 전송된 메시지를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-267">Azure Service Bus uses a message broker to handle messages that are sent to a Service Bus queue or topic.</span></span> <span data-ttu-id="39f7f-268">기본적으로 큐 또는 토픽으로 전송된 모든 메시지를 동일한 메시지 브로커 프로세스로 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-268">By default, all messages that are sent to a queue or topic are handled by the same message broker process.</span></span> <span data-ttu-id="39f7f-269">이 아키텍처는 전체 메시지 큐 처리량을 제한할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-269">This architecture can place a limitation on the overall throughput of the message queue.</span></span> <span data-ttu-id="39f7f-270">그러나 큐 또는 토픽을 만들 때 분할할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-270">However, you can also partition a queue or topic when it is created.</span></span> <span data-ttu-id="39f7f-271">큐 또는 토픽 설명의 *EnablePartitioning* 속성을 *true*로 설정하여 처리량을 분할할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-271">You do this by setting the *EnablePartitioning* property of the queue or topic description to *true*.</span></span>

<span data-ttu-id="39f7f-272">분할된 큐 또는 토픽은 여러 조각으로 나뉘며 각 조각은 별도의 메시지 저장소 및 메시지 브로커에서 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-272">A partitioned queue or topic is divided into multiple fragments, each of which is backed by a separate message store and message broker.</span></span> <span data-ttu-id="39f7f-273">Service Bus는 이러한 조각을 만들고 관리하는 작업을 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-273">Service Bus takes responsibility for creating and managing these fragments.</span></span> <span data-ttu-id="39f7f-274">애플리케이션에서 분할된 큐 또는 항목에 메시지를 게시하면 Service Bus가 해당 큐 또는 항목의 조각에 메시지를 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-274">When an application posts a message to a partitioned queue or topic, Service Bus assigns the message to a fragment for that queue or topic.</span></span> <span data-ttu-id="39f7f-275">큐 또는 구독에서 애플리케이션으로 메시지가 전송되면 Service Bus에서 사용 가능한 다음, 메시지가 있는지 각 조각을 확인한 다음, 처리를 위해 애플리케이션에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-275">When an application receives a message from a queue or subscription, Service Bus checks each fragment for the next available message and then passes it to the application for processing.</span></span>

<span data-ttu-id="39f7f-276">이러한 구조는 여러 메시지 브로커와 메시지 저장소에 부하를 분산하여 확장성을 높이고 가용성을 향상시키는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-276">This structure helps distribute the load across message brokers and message stores, increasing scalability and improving availability.</span></span> <span data-ttu-id="39f7f-277">하나의 조각에 대한 메시지 브로커 또는 메시지 저장소를 일시적으로 사용할 수 없는 경우 Service Bus는 나머지 사용 가능한 조각 중 하나에서 메시지를 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-277">If the message broker or message store for one fragment is temporarily unavailable, Service Bus can retrieve messages from one of the remaining available fragments.</span></span>

<span data-ttu-id="39f7f-278">Service Bus에서 조각에 메시지를 할당하는 방법은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-278">Service Bus assigns a message to a fragment as follows:</span></span>

- <span data-ttu-id="39f7f-279">메시지가 세션에 속하는 경우 *SessionId* 속성 값이 동일한 모든 메시지를 동일한 조각으로 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-279">If the message belongs to a session, all messages with the same value for the *SessionId*  property are sent to the same fragment.</span></span>

- <span data-ttu-id="39f7f-280">메시지가 세션에 속하지 않지만 발신자가 *PartitionKey* 속성 값을 지정한 경우 *PartitionKey* 값이 동일한 모든 메시지를 동일한 조각으로 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-280">If the message does not belong to a session, but the sender has specified a value for the *PartitionKey* property, then all messages with the same *PartitionKey* value are sent to the same fragment.</span></span>

  > [!NOTE]
  > <span data-ttu-id="39f7f-281">*SessionId* 및 *PartitionKey* 속성이 모두 지정된 경우, 동일한 값으로 설정되어야 하며 그러지 않으면 메시지가 거부됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-281">If the *SessionId* and *PartitionKey* properties are both specified, then they must be set to the same value or the message will be rejected.</span></span>

- <span data-ttu-id="39f7f-282">메시지에 *SessionId* 및 *PartitionKey* 속성이 지정되어 있지 않지만 중복 검색을 사용할 수 있는 경우 *MessageId* 속성을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-282">If the *SessionId* and *PartitionKey* properties for a message are not specified, but duplicate detection is enabled, the *MessageId* property will be used.</span></span> <span data-ttu-id="39f7f-283">*MessageId*가 동일한 모든 메시지를 동일한 조각으로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-283">All messages with the same *MessageId* will be directed to the same fragment.</span></span>

- <span data-ttu-id="39f7f-284">메시지에 *SessionId, PartitionKey* 또는 *MessageId* 속성이 포함되지 않은 경우에는 Service Bus에서 순차적으로 메시지를 조각에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-284">If messages do not include a *SessionId, PartitionKey,* or *MessageId* property, then Service Bus assigns messages to fragments sequentially.</span></span> <span data-ttu-id="39f7f-285">조각을 사용할 수 없는 경우 Service Bus가 다음 단계로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-285">If a fragment is unavailable, Service Bus will move on to the next.</span></span> <span data-ttu-id="39f7f-286">즉, 메시징 인프라에 일시적인 오류가 발생해도 메시지 송신 작업이 실패하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-286">This means that a temporary fault in the messaging infrastructure does not cause the message-send operation to fail.</span></span>

<span data-ttu-id="39f7f-287">Service Bus 메시지 큐 또는 토픽을 분할할지 여부 또는 분할하는 방법을 결정할 때 다음 사항을 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="39f7f-287">Consider the following points when deciding if or how to partition a Service Bus message queue or topic:</span></span>

- <span data-ttu-id="39f7f-288">Service Bus 큐 및 항목은 Service Bus 네임스페이스 범위 내에서 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-288">Service Bus queues and topics are created within the scope of a Service Bus namespace.</span></span> <span data-ttu-id="39f7f-289">Service Bus는 현재 네임스페이스당 최대 100개의 분할된 큐 또는 항목을 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-289">Service Bus currently allows up to 100 partitioned queues or topics per namespace.</span></span>

- <span data-ttu-id="39f7f-290">각 Service Bus 네임스페이스는 사용할 수 있는 리소스에 할당량(예: 토픽당 구독 수, 초당 동시 전송 및 수신 요청 수, 설정 가능한 최대 동시 연결 수)을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-290">Each Service Bus namespace imposes quotas on the available resources, such as the number of subscriptions per topic, the number of concurrent send and receive requests per second, and the maximum number of concurrent connections that can be established.</span></span> <span data-ttu-id="39f7f-291">이러한 할당량은 [Service Bus 할당량]에 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-291">These quotas are documented in [Service Bus quotas].</span></span> <span data-ttu-id="39f7f-292">해당 값을 초과할 것으로 예상되는 경우에는 자체 큐 및 항목을 사용하여 네임스페이스를 추가로 만들어 해당 네임스페이스에 작업을 분산합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-292">If you expect to exceed these values, then create additional namespaces with their own queues and topics, and spread the work across these namespaces.</span></span> <span data-ttu-id="39f7f-293">예를 들면, 전역 애플리케이션에서 각 지역에 별도의 네임스페이스를 만들고 애플리케이션 인스턴스에서 가장 가까운 네임스페이스에 있는 큐 및 항목을 사용하도록 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-293">For example, in a global application, create separate namespaces in each region and configure application instances to use the queues and topics in the nearest namespace.</span></span>

- <span data-ttu-id="39f7f-294">트랜잭션의 일부로 전송되는 메시지는 파티션 키를 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-294">Messages that are sent as part of a transaction must specify a partition key.</span></span> <span data-ttu-id="39f7f-295">이는 *SessionId*, *PartitionKey* 또는 *MessageId* 속성이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-295">This can be a *SessionId*, *PartitionKey*, or *MessageId* property.</span></span> <span data-ttu-id="39f7f-296">동일한 트랜잭션의 일부로 전송되는 모든 메시지는 동일한 메시지 브로커 프로세스로 처리해야 하기 때문에 동일한 파티션 키를 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-296">All messages that are sent as part of the same transaction must specify the same partition key because they must be handled by the same message broker process.</span></span> <span data-ttu-id="39f7f-297">동일한 트랜잭션에서 다른 큐 또는 항목으로 메시지를 보낼 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-297">You cannot send messages to different queues or topics within the same transaction.</span></span>

- <span data-ttu-id="39f7f-298">분할된 큐 및 토픽은 유휴 상태가 될 때 자동으로 삭제되도록 구성할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-298">Partitioned queues and topics can't be configured to be automatically deleted when they become idle.</span></span>

- <span data-ttu-id="39f7f-299">플랫폼 간 또는 하이브리드 솔루션을 구축하는 경우 현재 분할된 큐 및 토픽을 AMQP(고급 메시지 큐 프로토콜)와 함께 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-299">Partitioned queues and topics can't currently be used with the Advanced Message Queuing Protocol (AMQP) if you are building cross-platform or hybrid solutions.</span></span>

## <a name="partitioning-cosmos-db"></a><span data-ttu-id="39f7f-300">Cosmos DB 분할</span><span class="sxs-lookup"><span data-stu-id="39f7f-300">Partitioning Cosmos DB</span></span>

<span data-ttu-id="39f7f-301">Azure Cosmos DB는 [Azure Cosmos DB SQL API][cosmosdb-sql-api]를 사용하여 JSON 문서를 저장할 수 있는 NoSQL 데이터베이스입니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-301">Azure Cosmos DB is a NoSQL database that can store JSON documents using the [Azure Cosmos DB SQL API][cosmosdb-sql-api].</span></span> <span data-ttu-id="39f7f-302">Cosmos DB 데이터베이스의 문서는 개체 또는 데이터의 다른 부분에 대한 JSON 직렬화 표현입니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-302">A document in a Cosmos DB database is a JSON-serialized representation of an object or other piece of data.</span></span> <span data-ttu-id="39f7f-303">모든 문서에 고유의 ID가 있어야 한다는 점 이외에는 고정 스키마가 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-303">No fixed schemas are enforced except that every document must contain a unique ID.</span></span>

<span data-ttu-id="39f7f-304">문서는 컬렉션으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-304">Documents are organized into collections.</span></span> <span data-ttu-id="39f7f-305">관련 문서를 한 컬렉션에 함께 그룹화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-305">You can group related documents together in a collection.</span></span> <span data-ttu-id="39f7f-306">예를 들어 블로그 게시물을 유지 관리하는 시스템에서 각 블로그 게시물 내용을 컬렉션에 문서로 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-306">For example, in a system that maintains blog postings, you can store the contents of each blog post as a document in a collection.</span></span> <span data-ttu-id="39f7f-307">또한 주체 종류별로 컬렉션을 만들 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-307">You can also create collections for each subject type.</span></span> <span data-ttu-id="39f7f-308">또는 여러 저자가 자신의 블로그 게시물을 제어하고 관리하는 시스템과 같은 다중 테넌트 애플리케이션에서 저자에 따라 블로그를 분할하고 저자별로 별도의 컬렉션을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-308">Alternatively, in a multitenant application, such as a system where different authors control and manage their own blog posts, you can partition blogs by author and create separate collections for each author.</span></span> <span data-ttu-id="39f7f-309">컬렉션에 할당된 저장소 공간은 탄력적이며 필요에 따라 줄이거나 늘릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-309">The storage space that's allocated to collections is elastic and can shrink or grow as needed.</span></span>

<span data-ttu-id="39f7f-310">Cosmos DB는 애플리케이션 정의 파티션 키에 따라 데이터의 자동 분할을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-310">Cosmos DB supports automatic partitioning of data based on an application-defined partition key.</span></span> <span data-ttu-id="39f7f-311">*논리 파티션*은 단일 파티션 키 값에 대한 모든 데이터를 저장하는 파티션입니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-311">A *logical partition* is a partition that stores all the data for a single partition key value.</span></span> <span data-ttu-id="39f7f-312">파티션 키에 동일한 값을 공유하는 모든 문서는 동일한 논리 파티션 내에 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-312">All documents that share the same value for the partition key are placed within the same logical partition.</span></span> <span data-ttu-id="39f7f-313">Cosmos DB는 파티션 키의 해시에 따라 값을 배포합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-313">Cosmos DB distributes values according to hash of the partition key.</span></span> <span data-ttu-id="39f7f-314">논리 파티션의 최대 크기는 10GB입니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-314">A logical partition has a maximum size of 10 GB.</span></span> <span data-ttu-id="39f7f-315">따라서 파티션 키를 선택하는 것은 디자인 타임에서 중요한 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-315">Therefore, the choice of the partition key is an important decision at design time.</span></span> <span data-ttu-id="39f7f-316">다양한 범위의 값 및 액세스 패턴을 가진 속성을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-316">Choose a property with a wide range of values and even access patterns.</span></span> <span data-ttu-id="39f7f-317">자세한 내용은 [Azure Cosmos DB의 파티션 및 규모 감축](/azure/cosmos-db/partition-data)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="39f7f-317">For more information, see [Partition and scale in Azure Cosmos DB](/azure/cosmos-db/partition-data).</span></span>

> [!NOTE]
> <span data-ttu-id="39f7f-318">각 Cosmos DB 데이터베이스에는 리소스의 양을 결정하는 *성능 수준*이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-318">Each Cosmos DB database has a *performance level* that determines the amount of resources it gets.</span></span> <span data-ttu-id="39f7f-319">성능 수준은 RU(*요청 단위*) 비율 한도와 연관되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-319">A performance level is associated with a *request unit* (RU) rate limit.</span></span> <span data-ttu-id="39f7f-320">RU 비율 한도는 해당 컬렉션에 예약되어 배타적으로 사용할 수 있는 리소스 볼륨을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-320">The RU rate limit specifies the volume of resources that's reserved and available for exclusive use by that collection.</span></span> <span data-ttu-id="39f7f-321">컬렉션 비용은 해당 컬렉션에 대해 선택한 성능 수준에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-321">The cost of a collection depends on the performance level that's selected for that collection.</span></span> <span data-ttu-id="39f7f-322">성능 수준 및 RU 비율 한도가 높을수록 금액도 높아집니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-322">The higher the performance level (and RU rate limit) the higher the charge.</span></span> <span data-ttu-id="39f7f-323">컬렉션의 성능 수준은 Azure 포털을 사용하여 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-323">You can adjust the performance level of a collection by using the Azure portal.</span></span> <span data-ttu-id="39f7f-324">자세한 내용은 [Azure Cosmos DB의 요청 단위][cosmos-db-ru]를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="39f7f-324">For more information, see [Request Units in Azure Cosmos DB][cosmos-db-ru].</span></span>

<span data-ttu-id="39f7f-325">Cosmos DB에서 제공하는 분할 메커니즘으로 충분하지 않은 경우 애플리케이션 수준에서 데이터를 분할해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-325">If the partitioning mechanism that Cosmos DB provides is not sufficient, you may need to shard the data at the application level.</span></span> <span data-ttu-id="39f7f-326">문서 컬렉션은 단일 데이터베이스 내에서 데이터를 분할하는 기본 메커니즘을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-326">Document collections provide a natural mechanism for partitioning data within a single database.</span></span> <span data-ttu-id="39f7f-327">분할을 구현하는 가장 간단한 방법은 분할된 데이터베이스별로 컬렉션을 만드는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-327">The simplest way to implement sharding is to create a collection for each shard.</span></span> <span data-ttu-id="39f7f-328">컨테이너는 하나 이상의 서버에 걸쳐 있을 수 있는 논리적 리소스입니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-328">Containers are logical resources and can span one or more servers.</span></span> <span data-ttu-id="39f7f-329">고정 크기 컨테이너는 최대 제한 10GB 및 10,000RU/s 처리량을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-329">Fixed-size containers have a maximum limit of 10 GB and 10,000 RU/s throughput.</span></span> <span data-ttu-id="39f7f-330">무제한 컨테이너에는 최대 스토리지 크기가 적용되지 않지만 파티션 키를 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-330">Unlimited containers do not have a maximum storage size, but must specify a partition key.</span></span> <span data-ttu-id="39f7f-331">클라이언트 애플리케이션은 애플리케이션 분할을 사용하여 요청을 적절한 분할된 데이터베이스로 직접 보내야 합니다. 이 작업은 일반적으로 분할 키를 정의하는 데이터의 일부 특성을 기반으로 고유한 매핑 메커니즘을 구현하여 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-331">With application sharding, the client application must direct requests to the appropriate shard, usually by implementing its own mapping mechanism based on some attributes of the data that define the shard key.</span></span>

<span data-ttu-id="39f7f-332">모든 데이터베이스는 Cosmos DB 데이터베이스 계정의 컨텍스트에서 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-332">All databases are created in the context of a Cosmos DB database account.</span></span> <span data-ttu-id="39f7f-333">단일 계정은 여러 개의 데이터베이스를 포함할 수 있으며, 데이터베이스를 만들 영역을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-333">A single account can contain several databases, and it specifies in which regions the databases are created.</span></span> <span data-ttu-id="39f7f-334">각 계정에도 자체 액세스 제어가 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-334">Each account also enforces its own access control.</span></span> <span data-ttu-id="39f7f-335">Cosmos DB 계정을 사용하여 분할된 데이터베이스에 액세스해야 하는 사용자와 가까운 곳으로 분할된 데이터베이스(데이터베이스 내 컬렉션)의 지역을 지정하여 해당 사용자만 연결할 수 있도록 하는 제한을 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-335">You can use Cosmos DB accounts to geo-locate shards (collections within databases) close to the users who need to access them, and enforce restrictions so that only those users can connect to them.</span></span>

<span data-ttu-id="39f7f-336">Cosmos DB SQL API를 사용하여 데이터를 분할하는 방법을 결정할 때 다음 사항을 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="39f7f-336">Consider the following points when deciding how to partition data with the Cosmos DB SQL API:</span></span>

- <span data-ttu-id="39f7f-337">**Cosmos DB 데이터베이스에 사용할 수 있는 리소스에는 계정의 할당량 한도가 적용됩니다**.</span><span class="sxs-lookup"><span data-stu-id="39f7f-337">**The resources available to a Cosmos DB database are subject to the quota limitations of the account**.</span></span> <span data-ttu-id="39f7f-338">각 데이터베이스는 다수의 컬렉션을 보관할 수 있으며 각 컬렉션은 해당 컬렉션에 대한 RU 비율 한도(예약된 처리량)를 제어하는 성능 수준과 연관이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-338">Each database can hold a number of collections, and each collection is associated with a performance level that governs the RU rate limit (reserved throughput) for that collection.</span></span> <span data-ttu-id="39f7f-339">자세한 내용은 [Azure 구독 및 서비스 제한, 할당량 및 제약 조건][azure-limits]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="39f7f-339">For more information, see [Azure subscription and service limits, quotas, and constraints][azure-limits].</span></span>

- <span data-ttu-id="39f7f-340">**각 문서에는 해당 문서가 보관된 컬렉션 내에서 이 문서를 고유하게 식별하는 데 사용할 수 있는 특성이 있어야 합니다**.</span><span class="sxs-lookup"><span data-stu-id="39f7f-340">**Each document must have an attribute that can be used to uniquely identify that document within the collection in which it is held**.</span></span> <span data-ttu-id="39f7f-341">이 특성은 문서를 보관하는 컬렉션을 정의하는 분할 키와는 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-341">This attribute is different from the shard key, which defines which collection holds the document.</span></span> <span data-ttu-id="39f7f-342">컬렉션에는 수많은 문서가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-342">A collection can contain a large number of documents.</span></span> <span data-ttu-id="39f7f-343">이론적으로 문서 ID의 최대 길이만으로 제한할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-343">In theory, it's limited only by the maximum length of the document ID.</span></span> <span data-ttu-id="39f7f-344">문서 ID는 255자 이하여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-344">The document ID can be up to 255 characters.</span></span>

- <span data-ttu-id="39f7f-345">**문서에 대한 모든 작업은 트랜잭션 컨텍스트 내에서 수행됩니다. 트랜잭션은 이 문서가 포함된 컬렉션으로 범위가 지정됩니다.**</span><span class="sxs-lookup"><span data-stu-id="39f7f-345">**All operations against a document are performed within the context of a transaction. Transactions are scoped to the collection in which the document is contained.**</span></span> <span data-ttu-id="39f7f-346">하나의 작업이 실패하면 이미 수행된 작업이 롤백됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-346">If an operation fails, the work that it has performed is rolled back.</span></span> <span data-ttu-id="39f7f-347">문서는 작업 대상인 반면, 모든 변경 내용은 스냅숏 수준 격리가 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-347">While a document is subject to an operation, any changes that are made are subject to snapshot-level isolation.</span></span> <span data-ttu-id="39f7f-348">예를 들어 이 메커니즘은 새 문서를 만드는 요청이 실패하면 동시에 데이터베이스를 쿼리하는 다른 사용자에게 문서의 일부가 표시되지 않으며 해당 문서를 제거하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-348">This mechanism guarantees that if, for example, a request to create a new document fails, another user who's querying the database simultaneously will not see a partial document that is then removed.</span></span>

- <span data-ttu-id="39f7f-349">**데이터베이스 쿼리도 컬렉션 수준으로 범위가 지정됩니다**.</span><span class="sxs-lookup"><span data-stu-id="39f7f-349">**Database queries are also scoped to the collection level**.</span></span> <span data-ttu-id="39f7f-350">단일 쿼리는 하나의 컬렉션에서만 데이터를 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-350">A single query can retrieve data from only one collection.</span></span> <span data-ttu-id="39f7f-351">여러 컬렉션에서 데이터를 검색해야 하는 경우 각 컬렉션을 개별적으로 쿼리하고 애플리케이션 코드에서 결과를 병합해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-351">If you need to retrieve data from multiple collections, you must query each collection individually and merge the results in your application code.</span></span>

- <span data-ttu-id="39f7f-352">**Cosmos DB는 문서와 함께 모두 컬렉션에 저장할 수 있는 프로그래밍 가능 항목을 지원합니다**.</span><span class="sxs-lookup"><span data-stu-id="39f7f-352">**Cosmos DB supports programmable items that can all be stored in a collection alongside documents**.</span></span> <span data-ttu-id="39f7f-353">여기에는 저장 프로시저, 사용자 정의 함수, 트리거(JavaScript로 작성)가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-353">These include stored procedures, user-defined functions, and triggers (written in JavaScript).</span></span> <span data-ttu-id="39f7f-354">해당 항목은 동일한 컬렉션 내의 모든 문서에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-354">These items can access any document within the same collection.</span></span> <span data-ttu-id="39f7f-355">또한 이러한 항목은 앰비언트 트랜잭션 범위 내에서 실행되거나(문서에 수행된 만들기, 삭제 또는 바꾸기 작업의 결과로 발생하는 트리거의 경우), 새 트랜잭션을 시작하여(명시적 클라이언트 요청의 결과로 실행되는 저장 프로시저의 경우) 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-355">Furthermore, these items run either inside the scope of the ambient transaction (in the case of a trigger that fires as the result of a create, delete, or replace operation performed against a document), or by starting a new transaction (in the case of a stored procedure that is run as the result of an explicit client request).</span></span> <span data-ttu-id="39f7f-356">프로그래밍 가능 항목의 코드에서 예외가 발생하면 트랜잭션이 롤백됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-356">If the code in a programmable item throws an exception, the transaction is rolled back.</span></span> <span data-ttu-id="39f7f-357">문서 간 무결성 및 일관성을 유지하기 위해 저장 프로시저 및 트리거를 사용할 수 있지만 해당 문서가 모두 동일한 컬렉션에 포함되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-357">You can use stored procedures and triggers to maintain integrity and consistency between documents, but these documents must all be part of the same collection.</span></span>

- <span data-ttu-id="39f7f-358">**데이터베이스에 보관하려는 컬렉션이 컬렉션 성능 수준에 따라 정의된 처리량 한도를 초과할 가능성이 없도록 해야 합니다**.</span><span class="sxs-lookup"><span data-stu-id="39f7f-358">**The collections that you intend to hold in the databases should be unlikely to exceed the throughput limits defined by the performance levels of the collections**.</span></span> <span data-ttu-id="39f7f-359">자세한 내용은 [Azure Cosmos DB의 요청 단위][cosmos-db-ru]를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="39f7f-359">For more information, see [Request Units in Azure Cosmos DB][cosmos-db-ru].</span></span> <span data-ttu-id="39f7f-360">이러한 한도에 도달할 것으로 예상되는 경우 계정이 다른 여러 데이터베이스에 컬렉션을 분할하여 컬렉션당 부하를 줄이는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-360">If you anticipate reaching these limits, consider splitting collections across databases in different accounts to reduce the load per collection.</span></span>

## <a name="partitioning-azure-search"></a><span data-ttu-id="39f7f-361">Azure Search 분할</span><span class="sxs-lookup"><span data-stu-id="39f7f-361">Partitioning Azure Search</span></span>

<span data-ttu-id="39f7f-362">데이터를 검색할 수 있는 기능은 흔히 다양한 웹 애플리케이션에서 제공하는 기본 탐색 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-362">The ability to search for data is often the primary method of navigation and exploration that's provided by many web applications.</span></span> <span data-ttu-id="39f7f-363">이를 통해 검색 조건 조합 기반의 리소스(예: 전자 상거래 애플리케이션의 제품)를 신속하게 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-363">It helps users find resources quickly (for example, products in an e-commerce application) based on combinations of search criteria.</span></span> <span data-ttu-id="39f7f-364">Azure Search 서비스는 웹 콘텐츠에 대해 전체 텍스트 검색 기능을 제공하며, 자동 완성, 근사한 쿼리 제안 및 패싯 탐색과 같은 기능이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-364">The Azure Search service provides full-text search capabilities over web content, and includes features such as type-ahead, suggested queries based on near matches, and faceted navigation.</span></span> <span data-ttu-id="39f7f-365">자세한 내용은 [Azure Search란?]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="39f7f-365">For more information, see [What is Azure Search?].</span></span>

<span data-ttu-id="39f7f-366">Azure Search는 검색 가능 콘텐츠를 JSON 문서로 데이터베이스에 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-366">Azure Search stores searchable content as JSON documents in a database.</span></span> <span data-ttu-id="39f7f-367">해당 문서에서 검색 가능한 필드를 지정하고 Azure Search에 이러한 정의를 제공하는 인덱스를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-367">You define indexes that specify the searchable fields in these documents and provide these definitions to Azure Search.</span></span> <span data-ttu-id="39f7f-368">사용자가 검색 요청을 제출하면 Azure Search에서 적절한 인덱스를 사용하여 일치하는 항목을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-368">When a user submits a search request, Azure Search uses the appropriate indexes to find matching items.</span></span>

<span data-ttu-id="39f7f-369">경합을 줄이기 위해 Azure Search에 사용되는 저장소를 최대 1, 2, 3, 4, 6 또는 12개의 파티션으로 나눌 수 있으며 각 파티션은 최대 6번 복제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-369">To reduce contention, the storage that's used by Azure Search can be divided into 1, 2, 3, 4, 6, or 12 partitions, and each partition can be replicated up to 6 times.</span></span> <span data-ttu-id="39f7f-370">파티션 수를 복제본 수로 곱한 결과를 SU(*검색 단위*)라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-370">The product of the number of partitions multiplied by the number of replicas is called the *search unit* (SU).</span></span> <span data-ttu-id="39f7f-371">Azure Search의 단일 인스턴스에는 최대 36개의 SU를 포함할 수 있습니다(12개의 파티션이 있는 데이터베이스는 최대 3개의 복제본만 지원).</span><span class="sxs-lookup"><span data-stu-id="39f7f-371">A single instance of Azure Search can contain a maximum of 36 SUs (a database with 12 partitions only supports a maximum of 3 replicas).</span></span>

<span data-ttu-id="39f7f-372">해당 서비스에 할당되는 SU별로 청구됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-372">You are billed for each SU that is allocated to your service.</span></span> <span data-ttu-id="39f7f-373">검색 가능 콘텐츠의 볼륨이 증가하거나 검색 요청 비율이 늘어나면 기존의 Azure Search 인스턴스에 SU를 추가하여 추가된 부하를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-373">As the volume of searchable content increases or the rate of search requests grows, you can add SUs to an existing instance of Azure Search to handle the extra load.</span></span> <span data-ttu-id="39f7f-374">Azure Search 자체에서 문서를 여러 파티션에 균등하게 분산합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-374">Azure Search itself distributes the documents evenly across the partitions.</span></span> <span data-ttu-id="39f7f-375">수동 분할 전략은 현재 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-375">No manual partitioning strategies are currently supported.</span></span>

<span data-ttu-id="39f7f-376">각 파티션은 최대 1,500만 개의 문서를 포함하거나 300GB의 저장소 공간을 차지할 수 있습니다(더 낮은 쪽).</span><span class="sxs-lookup"><span data-stu-id="39f7f-376">Each partition can contain a maximum of 15 million documents or occupy 300 GB of storage space (whichever is smaller).</span></span> <span data-ttu-id="39f7f-377">최대 50개의 인덱스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-377">You can create up to 50 indexes.</span></span> <span data-ttu-id="39f7f-378">서비스 성능은 문서의 복잡성, 사용 가능한 인덱스, 네트워크 대기 시간이 미치는 영향에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-378">The performance of the service varies and depends on the complexity of the documents, the available indexes, and the effects of network latency.</span></span> <span data-ttu-id="39f7f-379">단일 복제본(1SU)은 평균적으로 초당 15개의 쿼리를 처리할 수 있지만, 처리량을 더 정밀하게 측정하려면 자체 데이터를 사용하여 벤치마킹을 수행하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-379">On average, a single replica (1 SU) should be able to handle 15 queries per second (QPS), although we recommend performing benchmarking with your own data to obtain a more precise measure of throughput.</span></span> <span data-ttu-id="39f7f-380">자세한 내용은 [Azure Search의 서비스 제한 사항] 을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="39f7f-380">For more information, see [Service limits in Azure Search].</span></span>

> [!NOTE]
> <span data-ttu-id="39f7f-381">제한된 데이터 형식 집합을 검색 가능 문서로 저장할 수 있으며, 문자열, 부울, 숫자 데이터, 날짜/시간 데이터 및 일부 지리적 데이터가 여기에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-381">You can store a limited set of data types in searchable documents, including strings, Booleans, numeric data, datetime data, and some geographical data.</span></span> <span data-ttu-id="39f7f-382">자세한 내용은 Microsoft 웹 사이트의 [지원되는 데이터 형식(Azure Search)] 페이지를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="39f7f-382">For more details, see the page [Supported data types (Azure Search)] on the Microsoft website.</span></span>

<span data-ttu-id="39f7f-383">Azure Search에서 서비스의 각 인스턴스에 데이터를 분할하는 방법은 제한적으로만 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-383">You have limited control over how Azure Search partitions data for each instance of the service.</span></span> <span data-ttu-id="39f7f-384">그러나 전역 환경에서 다음 전략 중 하나를 사용하여 서비스 자체를 분할하면 성능을 개선하고 대기 시간 및 경합을 추가로 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-384">However, in a global environment you might be able to improve performance and reduce latency and contention further by partitioning the service itself using either of the following strategies:</span></span>

- <span data-ttu-id="39f7f-385">각 지리적 지역에 Azure Search 인스턴스를 만들고 클라이언트 애플리케이션이 가장 가까이에서 사용할 수 있는 인스턴스로 향하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-385">Create an instance of Azure Search in each geographic region, and ensure that client applications are directed towards the nearest available instance.</span></span> <span data-ttu-id="39f7f-386">이 전략에서는 모든 서비스 인스턴스에서 검색 가능 콘텐츠에 대한 모든 업데이트를 적시에 복제해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-386">This strategy requires that any updates to searchable content are replicated in a timely manner across all instances of the service.</span></span>

- <span data-ttu-id="39f7f-387">2계층 Azure Search를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-387">Create two tiers of Azure Search:</span></span>

  - <span data-ttu-id="39f7f-388">해당 지역에서 사용자가 가장 자주 액세스하는 데이터가 있는 각 지역의 로컬 서비스.</span><span class="sxs-lookup"><span data-stu-id="39f7f-388">A local service in each region that contains the data that's most frequently accessed by users in that region.</span></span> <span data-ttu-id="39f7f-389">사용자가 빠르지만 제한된 결과를 위해 로컬 서비스로 직접 요청을 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-389">Users can direct requests here for fast but limited results.</span></span>
  - <span data-ttu-id="39f7f-390">모든 데이터를 포함하는 글로벌 서비스.</span><span class="sxs-lookup"><span data-stu-id="39f7f-390">A global service that encompasses all the data.</span></span> <span data-ttu-id="39f7f-391">사용자가 느리지만 더 완전한 결과를 위해 글로벌 서비스로 직접 요청을 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-391">Users can direct requests here for slower but more complete results.</span></span>

<span data-ttu-id="39f7f-392">이 방법은 검색 중인 데이터의 지역별 편차가 큰 경우 가장 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-392">This approach is most suitable when there is a significant regional variation in the data that's being searched.</span></span>

## <a name="partitioning-azure-redis-cache"></a><span data-ttu-id="39f7f-393">Azure Redis Cache 분할</span><span class="sxs-lookup"><span data-stu-id="39f7f-393">Partitioning Azure Redis Cache</span></span>

<span data-ttu-id="39f7f-394">Azure Redis Cache는 Redis 키/값 데이터 저장소를 기반으로 하는 클라우드에 공유 캐싱 서비스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-394">Azure Redis Cache provides a shared caching service in the cloud that's based on the Redis key-value data store.</span></span> <span data-ttu-id="39f7f-395">이름에서 알 수 있듯이 Azure Redis Cache는 캐싱 솔루션을 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-395">As its name implies, Azure Redis Cache is intended as a caching solution.</span></span> <span data-ttu-id="39f7f-396">영구적 데이터 저장소가 아니라 데이터를 일시적으로 보관하는 용도로만 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-396">Use it only for holding transient data and not as a permanent data store.</span></span> <span data-ttu-id="39f7f-397">Azure Redis Cache를 활용하는 애플리케이션은 캐시를 사용할 수 없는 경우에도 계속 작동될 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-397">Applications that use Azure Redis Cache should be able to continue functioning if the cache is unavailable.</span></span> <span data-ttu-id="39f7f-398">Azure Redis Cache는 주/보조 복제를 지원하여 고가용성을 제공하지만 현재 최대 캐시 크기가 53GB로 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-398">Azure Redis Cache supports primary/secondary replication to provide high availability, but currently limits the maximum cache size to 53 GB.</span></span> <span data-ttu-id="39f7f-399">이보다 더 많은 공간이 필요한 경우 캐시를 추가로 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-399">If you need more space than this, you must create additional caches.</span></span> <span data-ttu-id="39f7f-400">자세한 내용은 [Azure Redis 캐시(영문)]를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="39f7f-400">For more information, see [Azure Redis Cache].</span></span>

<span data-ttu-id="39f7f-401">Redis 데이터 저장소를 분할하려면 데이터를 Redis 서비스의 여러 인스턴스에 분할해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-401">Partitioning a Redis data store involves splitting the data across instances of the Redis service.</span></span> <span data-ttu-id="39f7f-402">각 인스턴스는 단일 파티션으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-402">Each instance constitutes a single partition.</span></span> <span data-ttu-id="39f7f-403">Azure Redis Cache는 Redis 서비스를 외관 뒤에 추상화하여 직접 노출하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-403">Azure Redis Cache abstracts the Redis services behind a façade and does not expose them directly.</span></span> <span data-ttu-id="39f7f-404">분할을 구현하는 가장 간단한 방법은 다수의 Azure Redis Cache 인스턴스를 만들어 데이터를 분산하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-404">The simplest way to implement partitioning is to create multiple Azure Redis Cache instances and spread the data across them.</span></span>

<span data-ttu-id="39f7f-405">각 데이터 항목은 저장할 캐시를 지정하는 식별자(파티션 키)와 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-405">You can associate each data item with an identifier (a partition key) that specifies which cache stores the data item.</span></span> <span data-ttu-id="39f7f-406">클라이언트 애플리케이션 논리에 이 식별자를 사용하여 요청을 적절한 파티션으로 라우트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-406">The client application logic can then use this identifier to route requests to the appropriate partition.</span></span> <span data-ttu-id="39f7f-407">이 구성표는 매우 간단하지만 파티션 구성표가 변경되면(예: Azure Redis Cache 인스턴스를 추가로 만드는 경우) 클라이언트 애플리케이션을 다시 구성해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-407">This scheme is very simple, but if the partitioning scheme changes (for example, if additional Azure Redis Cache instances are created), client applications might need to be reconfigured.</span></span>

<span data-ttu-id="39f7f-408">기본 Redis(Azure Redis Cache 아님)는 Redis 클러스터링을 기반으로 서버 쪽 분할을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-408">Native Redis (not Azure Redis Cache) supports server-side partitioning based on Redis clustering.</span></span> <span data-ttu-id="39f7f-409">이 방법에서 해싱 메커니즘을 사용하여 데이터를 여러 서버에 균등하게 나눌 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-409">In this approach, you can divide the data evenly across servers by using a hashing mechanism.</span></span> <span data-ttu-id="39f7f-410">각 Redis 서버는 파티션에서 보관하는 해시 키 범위를 설명하는 메타데이터를 저장하고 다른 서버의 파티션에 있는 해시 키에 대한 정보도 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-410">Each Redis server stores metadata that describes the range of hash keys that the partition holds, and also contains information about which hash keys are located in the partitions on other servers.</span></span>

<span data-ttu-id="39f7f-411">클라이언트 애플리케이션은 단순히 참여하는 Redis 서버(대부분 가장 가까운 서버) 중 하나로 요청을 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-411">Client applications simply send requests to any of the participating Redis servers (probably the closest one).</span></span> <span data-ttu-id="39f7f-412">Redis 서버는 클라이언트 요청을 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-412">The Redis server examines the client request.</span></span> <span data-ttu-id="39f7f-413">로컬로 해결할 수 있는 경우 요청된 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-413">If it can be resolved locally, it performs the requested operation.</span></span> <span data-ttu-id="39f7f-414">그렇지 않으면 요청을 적절한 서버로 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-414">Otherwise it forwards the request on to the appropriate server.</span></span>

<span data-ttu-id="39f7f-415">이 모델은 Redis 클러스터링을 사용하여 구현되며, Redis 웹 사이트의 [Redis 클러스터 자습서] 페이지에 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-415">This model is implemented by using Redis clustering, and is described in more detail on the [Redis cluster tutorial] page on the Redis website.</span></span> <span data-ttu-id="39f7f-416">Redis 클러스터링은 클라이언트 애플리케이션에 대해 투명합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-416">Redis clustering is transparent to client applications.</span></span> <span data-ttu-id="39f7f-417">클라이언트를 다시 구성하지 않고도 Redis 서버를 클러스터 및 다시 분할될 수 있는 데이터에 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-417">Additional Redis servers can be added to the cluster (and the data can be re-partitioned) without requiring that you reconfigure the clients.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="39f7f-418">Azure Redis Cache는 현재 [프리미엄](/azure/azure-cache-for-redis/cache-how-to-premium-clustering) 계층에서만 Redis 클러스터링을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-418">Azure Redis Cache currently supports Redis clustering in [premium](/azure/azure-cache-for-redis/cache-how-to-premium-clustering) tier only.</span></span>

<span data-ttu-id="39f7f-419">Redis 웹 사이트의 [분할: 여러 Redis 인스턴스 간에 데이터를 분할하는 방법] 페이지는 Redis와 분할을 구현하는 자세한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-419">The page [Partitioning: how to split data among multiple Redis instances] on the Redis website provides more information about implementing partitioning with Redis.</span></span> <span data-ttu-id="39f7f-420">이 섹션의 나머지 부분에서는 클라이언트 쪽 또는 프록시 기반 분할을 구현하는 것으로 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-420">The remainder of this section assumes that you are implementing client-side or proxy-assisted partitioning.</span></span>

<span data-ttu-id="39f7f-421">Azure Redis Cache를 사용하여 데이터를 분할하는 방법을 결정할 때 다음 사항을 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="39f7f-421">Consider the following points when deciding how to partition data with Azure Redis Cache:</span></span>

- <span data-ttu-id="39f7f-422">Azure Redis Cache는 영구적 데이터 저장소 역할을 하기 위한 것이 아니므로, 구현하는 분할 구성표에 관계없이 애플리케이션 코드는 캐시가 아닌 위치에서 데이터를 검색할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-422">Azure Redis Cache is not intended to act as a permanent data store, so whatever partitioning scheme you implement, your application code must be able to retrieve data from a location that's not the cache.</span></span>

- <span data-ttu-id="39f7f-423">자주 액세스되는 데이터는 동일한 파티션에서 함께 보관해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-423">Data that is frequently accessed together should be kept in the same partition.</span></span> <span data-ttu-id="39f7f-424">Redis는 데이터 구조화를 위해 고도로 최적화된 다양한 메커니즘을 제공하는 강력한 키-값 저장소입니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-424">Redis is a powerful key-value store that provides several highly optimized mechanisms for structuring data.</span></span> <span data-ttu-id="39f7f-425">이러한 메커니즘은 다음 중 하나일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-425">These mechanisms can be one of the following:</span></span>
  - <span data-ttu-id="39f7f-426">간단한 문자열(길이 512MB 이하의 이진 데이터)</span><span class="sxs-lookup"><span data-stu-id="39f7f-426">Simple strings (binary data up to 512 MB in length)</span></span>
  - <span data-ttu-id="39f7f-427">목록(큐 및 스택의 역할을 할 수 있음)과 같은 집계 형식</span><span class="sxs-lookup"><span data-stu-id="39f7f-427">Aggregate types such as lists (which can act as queues and stacks)</span></span>
  - <span data-ttu-id="39f7f-428">집합(정렬 및 정렬되지 않음)</span><span class="sxs-lookup"><span data-stu-id="39f7f-428">Sets (ordered and unordered)</span></span>
  - <span data-ttu-id="39f7f-429">해시(관련 필드(예: 개체의 필드를 나타내는 항목)를 함께 그룹화할 수 있음)</span><span class="sxs-lookup"><span data-stu-id="39f7f-429">Hashes (which can group related fields together, such as the items that represent the fields in an object)</span></span>

- <span data-ttu-id="39f7f-430">집계 형식을 사용하면 키가 동일한 다수의 관련 값을 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-430">The aggregate types enable you to associate many related values with the same key.</span></span> <span data-ttu-id="39f7f-431">Redis 키는 포함된 데이터 항목이 아닌 목록, 집합 또는 해시를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-431">A Redis key identifies a list, set, or hash rather than the data items that it contains.</span></span> <span data-ttu-id="39f7f-432">해당 형식은 모두 Azure Redis Cache와 함께 사용할 수 있으며, Redis 웹 사이트의 [데이터 형식] 페이지에 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-432">These types are all available with Azure Redis Cache and are described by the [Data types] page on the Redis website.</span></span> <span data-ttu-id="39f7f-433">예를 들어 고객의 주문을 추적하는 전자 상거래 시스템 일부에서 고객 ID를 사용하여 키가 지정된 Redis 해시에 각 고객의 세부 정보를 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-433">For example, in part of an e-commerce system that tracks the orders that are placed by customers, the details of each customer can be stored in a Redis hash that is keyed by using the customer ID.</span></span> <span data-ttu-id="39f7f-434">각 해시에는 고객의 주문 ID 컬렉션이 보관될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-434">Each hash can hold a collection of order IDs for the customer.</span></span> <span data-ttu-id="39f7f-435">별도의 Redis 집합은 주문 ID를 사용하여 키가 지정되고 해시로 다시 구조화된 주문을 보관할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-435">A separate Redis set can hold the orders, again structured as hashes, and keyed by using the order ID.</span></span> <span data-ttu-id="39f7f-436">그림 8에서는 이러한 구조를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-436">Figure 8 shows this structure.</span></span> <span data-ttu-id="39f7f-437">Redi는 어떤 형태의 참조 무결성도 구현하지 않으므로, 고객과 주문 간 관계를 유지 관리하는 것은 개발자의 책임입니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-437">Note that Redis does not implement any form of referential integrity, so it is the developer's responsibility to maintain the relationships between customers and orders.</span></span>

![고객 주문 및 세부 정보를 기록하기 위해 제안된 Redis 저장소의 구조](./images/data-partitioning/RedisCustomersandOrders.png)

<span data-ttu-id="39f7f-439">*그림 8. 고객 주문 및 세부 정보를 기록하기 위해 제안된 Redis 스토리지의 구조.*</span><span class="sxs-lookup"><span data-stu-id="39f7f-439">*Figure 8. Suggested structure in Redis storage for recording customer orders and their details.*</span></span>

> [!NOTE]
> <span data-ttu-id="39f7f-440">Redis의 모든 키는 이진 데이터 값(예: Redis 문자열)이며 최대 512MB의 데이터를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-440">In Redis, all keys are binary data values (like Redis strings) and can contain up to 512 MB of data.</span></span> <span data-ttu-id="39f7f-441">이론적으로 하나의 키가 거의 모든 정보를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-441">In theory, a key can contain almost any information.</span></span> <span data-ttu-id="39f7f-442">그러나 데이터 형식을 설명하고 엔터티를 식별하면서도 지나치게 길지 않은 일관된 명명 규칙을 키에 채택하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-442">However, we recommend adopting a consistent naming convention for keys that is descriptive of the type of data and that identifies the entity, but is not excessively long.</span></span> <span data-ttu-id="39f7f-443">일반적인 방법은 "entity_type:ID" 형식의 키를 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-443">A common approach is to use keys of the form "entity_type:ID".</span></span> <span data-ttu-id="39f7f-444">예를 들어 "customer:99"는 ID가 99인 고객에 대한 키를 나타내는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-444">For example, you can use "customer:99" to indicate the key for a customer with the ID 99.</span></span>

- <span data-ttu-id="39f7f-445">동일한 데이터베이스의 다양한 집계에 대한 관련 정보를 저장하여 수직 분할을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-445">You can implement vertical partitioning by storing related information in different aggregations in the same database.</span></span> <span data-ttu-id="39f7f-446">예를 들어 전자 상거래 애플리케이션에서 자주 액세스하는 제품 정보를 하나의 Redis 해시에 저장하고 덜 자주 사용하는 세부 정보를 다른 해시에 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-446">For example, in an e-commerce application, you can store commonly accessed information about products in one Redis hash and less frequently used detailed information in another.</span></span> <span data-ttu-id="39f7f-447">두 해시 모두 동일한 제품 ID를 키의 일부로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-447">Both hashes can use the same product ID as part of the key.</span></span> <span data-ttu-id="39f7f-448">예를 들어 제품 정보에 대해서는 "product: *nn*"(여기서 *nn*은 제품 ID) 및 세부 데이터에 대해서는 "product_details: *nn*"을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-448">For example, you can use "product: *nn*" (where *nn* is the product ID) for the product information and "product_details: *nn*" for the detailed data.</span></span> <span data-ttu-id="39f7f-449">이 전략은 대부분의 쿼리에서 검색할 가능성이 있는 데이터의 볼륨을 줄이는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-449">This strategy can help reduce the volume of data that most queries are likely to retrieve.</span></span>

- <span data-ttu-id="39f7f-450">Redis 데이터 저장소를 다시 분할할 수 있지만 복잡하고 시간이 많이 걸리는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-450">You can repartition a Redis data store, but keep in mind that it's a complex and time-consuming task.</span></span> <span data-ttu-id="39f7f-451">Redis 클러스터링은 데이터를 자동으로 다시 분할할 수 있지만 Azure Redis Cache에는 이 기능을 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-451">Redis clustering can repartition data automatically, but this capability is not available with Azure Redis Cache.</span></span> <span data-ttu-id="39f7f-452">따라서 파티션 구성표를 디자인할 때 시간이 지남에 따라 예상되는 데이터 증가를 허용할 수 있도록 각 파티션에 충분한 여유 공간을 남기려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-452">Therefore, when you design your partitioning scheme, try to leave sufficient free space in each partition to allow for expected data growth over time.</span></span> <span data-ttu-id="39f7f-453">단, Azure Redis Cache는 데이터를 일시적으로 캐시하기 위한 것이며 캐시에 보관된 데이터의 수명은 제한되어 있으며 TTL(time-to-live) 값으로 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-453">However, remember that Azure Redis Cache is intended to cache data temporarily, and that data held in the cache can have a limited lifetime specified as a time-to-live (TTL) value.</span></span> <span data-ttu-id="39f7f-454">상대적으로 일시적인 데이터는 TTL이 짧을 수 있지만 정적 데이터는 TTL이 훨씬 더 길 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-454">For relatively volatile data, the TTL can be short, but for static data the TTL can be a lot longer.</span></span> <span data-ttu-id="39f7f-455">데이터의 볼륨이 캐시를 채울 가능성이 높은 경우 수명이 긴 데이터를 캐시에 많이 저장하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="39f7f-455">Avoid storing large amounts of long-lived data in the cache if the volume of this data is likely to fill the cache.</span></span> <span data-ttu-id="39f7f-456">공간이 부족한 경우 Azure Redis Cache에서 데이터를 제거하도록 하는 제거 정책을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-456">You can specify an eviction policy that causes Azure Redis Cache to remove data if space is at a premium.</span></span>

  > [!NOTE]
  > <span data-ttu-id="39f7f-457">Azure Redis Cache를 사용하는 경우 적절한 가격 책정 계층을 선택하여 최대 캐시 크기(250MB~53GB)를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-457">When you use Azure Redis cache, you specify the maximum size of the cache (from 250 MB to 53 GB) by selecting the appropriate pricing tier.</span></span> <span data-ttu-id="39f7f-458">그러나 Azure Redis Cache를 만든 후에는 크기를 늘리거나 줄일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-458">However, after an Azure Redis Cache has been created, you cannot increase (or decrease) its size.</span></span>

- <span data-ttu-id="39f7f-459">Redis 배치 및 트랜잭션은 여러 연결에 걸쳐 있을 수 없으므로 배치 또는 트랜잭션의 영향을 받는 모든 데이터를 동일한 데이터베이스(분할된 데이터베이스)에 보관해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-459">Redis batches and transactions cannot span multiple connections, so all data that is affected by a batch or transaction should be held in the same database (shard).</span></span>

  > [!NOTE]
  > <span data-ttu-id="39f7f-460">Redis 트랜잭션의 작업 시퀀스는 원자성이 없어도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-460">A sequence of operations in a Redis transaction is not necessarily atomic.</span></span> <span data-ttu-id="39f7f-461">트랜잭션을 작성하는 명령은 실행하기 전에 확인하고 큐에서 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-461">The commands that compose a transaction are verified and queued before they run.</span></span> <span data-ttu-id="39f7f-462">이 단계에서 오류가 발생하면 전체 큐가 삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-462">If an error occurs during this phase, the entire queue is discarded.</span></span> <span data-ttu-id="39f7f-463">그러나 트랜잭션을 성공적으로 제출한 후 큐에 대기 중인 명령이 순서대로 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-463">However, after the transaction has been successfully submitted, the queued commands run in sequence.</span></span> <span data-ttu-id="39f7f-464">실패한 명령이 있으면 해당 명령만 실행을 중지합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-464">If any command fails, only that command stops running.</span></span> <span data-ttu-id="39f7f-465">큐에 있는 이전 및 이후의 모든 명령은 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-465">All previous and subsequent commands in the queue are performed.</span></span> <span data-ttu-id="39f7f-466">자세한 내용은 Redis 웹 사이트의 [트랜잭션] 페이지를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="39f7f-466">For more information, go to the [Transactions] page on the Redis website.</span></span>

- <span data-ttu-id="39f7f-467">Redis는 제한된 수의 원자성 작업을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-467">Redis supports a limited number of atomic operations.</span></span> <span data-ttu-id="39f7f-468">다중 키 및 값을 지원하는 이 유형의 작업에는 MGET 및 MSET 작업만 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-468">The only operations of this type that support multiple keys and values are MGET and MSET operations.</span></span> <span data-ttu-id="39f7f-469">MGET 작업은 지정된 키 목록의 값 컬렉션을 반환하고 MSET 작업은 지정된 키 목록의 값 컬렉션을 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-469">MGET operations return a collection of values for a specified list of keys, and MSET operations store a collection of values for a specified list of keys.</span></span> <span data-ttu-id="39f7f-470">이러한 작업을 사용해야 하는 경우 MSET 및 MGET 명령을 사용하여 참조하는 키/값 쌍을 동일한 데이터베이스에 저장해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-470">If you need to use these operations, the key-value pairs that are referenced by the MSET and MGET commands must be stored within the same database.</span></span>

## <a name="partitioning-azure-service-fabric"></a><span data-ttu-id="39f7f-471">Azure Service Fabric 분할</span><span class="sxs-lookup"><span data-stu-id="39f7f-471">Partitioning Azure Service Fabric</span></span>

<span data-ttu-id="39f7f-472">Azure Service Fabric은 클라우드에서 배포 애플리케이션에 대해 런타임을 제공하는 마이크로 서비스 플랫폼입니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-472">Azure Service Fabric is a microservices platform that provides a runtime for distributed applications in the cloud.</span></span> <span data-ttu-id="39f7f-473">Service Fabric은 .Net 게스트 실행 파일, 상태 저장 및 상태 비저장 서비스, 컨테이너를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-473">Service Fabric supports .Net guest executables, stateful and stateless services, and containers.</span></span> <span data-ttu-id="39f7f-474">상태 저장 서비스는 Service Fabric 클러스터 내의 키/값 컬렉션에 데이터를 영구적으로 저장하기 위한 [신뢰할 수 있는 컬렉션][service-fabric-reliable-collections]을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-474">Stateful services provide a [reliable collection][service-fabric-reliable-collections] to persistently store data in a key-value collection within the Service Fabric cluster.</span></span> <span data-ttu-id="39f7f-475">신뢰할 수 있는 컬렉션에서 키 분할 전략에 대한 자세한 내용은 [Azure Service Fabric에서 신뢰할 수 있는 컬렉션에 대한 지침 및 권장 사항]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="39f7f-475">For more information about strategies for partitioning keys in a reliable collection, see [guidelines and recommendations for reliable collections in Azure Service Fabric].</span></span>

### <a name="more-information"></a><span data-ttu-id="39f7f-476">자세한 정보</span><span class="sxs-lookup"><span data-stu-id="39f7f-476">More information</span></span>

- <span data-ttu-id="39f7f-477">[Azure Service Fabric의 개요]는 Azure Service Fabric에 대한 소개입니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-477">[Overview of Azure Service Fabric] is an introduction to Azure Service Fabric.</span></span>

- <span data-ttu-id="39f7f-478">[Service Fabric Reliable Services 분할]에서는 Azure Service Fabric의 Reliable Services에 대한 자세한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-478">[Partition Service Fabric reliable services] provides more information about reliable services in Azure Service Fabric.</span></span>

## <a name="partitioning-azure-event-hubs"></a><span data-ttu-id="39f7f-479">Azure Event Hubs 분할</span><span class="sxs-lookup"><span data-stu-id="39f7f-479">Partitioning Azure Event Hubs</span></span>

<span data-ttu-id="39f7f-480">[Azure Event Hubs][event-hubs]는 대규모로 데이터 스트리밍을 수행할 수 있게 디자인되었으며, 수평적 크기 조정을 위해 서비스에 분할 기능이 기본적으로 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-480">[Azure Event Hubs][event-hubs] is designed for data streaming at massive scale, and partitioning is built into the service to enable horizontal scaling.</span></span> <span data-ttu-id="39f7f-481">각 소비자는 메시지 스트림의 특정 파티션만 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-481">Each consumer only reads a specific partition of the message stream.</span></span>

<span data-ttu-id="39f7f-482">이벤트 게시자는 이벤트를 게시하는 파티션이 아니라 파티션 키만 인식합니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-482">The event publisher is only aware of its partition key, not the partition to which the events are published.</span></span> <span data-ttu-id="39f7f-483">이렇게 키와 파티션을 분리하면 발신자가 다운스트림 처리에 대해 너무 많이 알 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-483">This decoupling of key and partition insulates the sender from needing to know too much about the downstream processing.</span></span> <span data-ttu-id="39f7f-484">(이벤트를 지정된 파티션에 직접 전송할 수도 있지만 일반적으로는 권장되지 않습니다.)</span><span class="sxs-lookup"><span data-stu-id="39f7f-484">(It's also possible send events directly to a given partition, but generally that's not recommended.)</span></span>  

<span data-ttu-id="39f7f-485">파티션 수를 선택할 때는 장기적인 크기 조정을 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="39f7f-485">Consider long-term scale when you select the partition count.</span></span> <span data-ttu-id="39f7f-486">이벤트 허브를 만든 후에는 파티션 수를 변경할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="39f7f-486">After an event hub is created, you can't change the number of partitions.</span></span>

<span data-ttu-id="39f7f-487">Event Hubs에서 파티션을 사용하는 방법에 대한 자세한 내용은 [Event Hubs란?]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="39f7f-487">For more information about using partitions in Event Hubs, see [What is Event Hubs?].</span></span>

<span data-ttu-id="39f7f-488">가용성과 일관성 간의 절충에 대한 고려 사항은 [Event Hubs의 가용성 및 일관성]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="39f7f-488">For considerations about trade-offs between availability and consistency, see [Availability and consistency in Event Hubs].</span></span>

[Event Hubs의 가용성 및 일관성]: /azure/event-hubs/event-hubs-availability-and-consistency
[Availability and consistency in Event Hubs]: /azure/event-hubs/event-hubs-availability-and-consistency
[azure-limits]: /azure/azure-subscription-service-limits
[Azure Content Delivery Network]: /azure/cdn/cdn-overview
[Azure Redis 캐시(영문)]: https://azure.microsoft.com/services/cache/
[Azure Redis Cache]: https://azure.microsoft.com/services/cache/
[Azure Storage Scalability and Performance Targets]: /azure/storage/storage-scalability-targets
[Azure 저장소 테이블 설계 가이드]: /azure/storage/storage-table-design-guide
[Azure Storage Table Design Guide]: /azure/storage/storage-table-design-guide
[Building a Polyglot Solution]: https://msdn.microsoft.com/library/dn313279.aspx
[cosmos-db-ru]: /azure/cosmos-db/request-units
[Data Access for Highly-Scalable Solutions: Using SQL, NoSQL, and Polyglot Persistence]: https://msdn.microsoft.com/library/dn271399.aspx
[Data consistency primer]: https://aka.ms/Data-Consistency-Primer
[Data Partitioning Guidance]: https://msdn.microsoft.com/library/dn589795.aspx
[데이터 형식]: https://redis.io/topics/data-types
[Data Types]: https://redis.io/topics/data-types
[cosmosdb-sql-api]: /azure/cosmos-db/sql-api-introduction
[Elastic Database features overview]: /azure/sql-database/sql-database-elastic-scale-introduction
[event-hubs]: /azure/event-hubs
[Federations Migration Utility]: https://code.msdn.microsoft.com/vstudio/Federations-Migration-ce61e9c1
[Azure Service Fabric에서 신뢰할 수 있는 컬렉션에 대한 지침 및 권장 사항]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections-guidelines
[guidelines and recommendations for reliable collections in Azure Service Fabric]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections-guidelines
[Multi-shard querying]: /azure/sql-database/sql-database-elastic-scale-multishard-querying
[Azure Service Fabric의 개요]: /azure/service-fabric/service-fabric-overview
[Overview of Azure Service Fabric]: /azure/service-fabric/service-fabric-overview
[Service Fabric Reliable Services 분할]: /azure/service-fabric/service-fabric-concepts-partitioning
[Partition Service Fabric reliable services]: /azure/service-fabric/service-fabric-concepts-partitioning
[분할: 여러 Redis 인스턴스 간에 데이터를 분할하는 방법]: https://redis.io/topics/partitioning
[Partitioning: how to split data among multiple Redis instances]: https://redis.io/topics/partitioning
[엔터티 그룹 트랜잭션 수행]: /rest/api/storageservices/Performing-Entity-Group-Transactions
[Performing Entity Group Transactions]: /rest/api/storageservices/Performing-Entity-Group-Transactions
[Redis 클러스터 자습서]: https://redis.io/topics/cluster-tutorial
[Redis cluster tutorial]: https://redis.io/topics/cluster-tutorial
[Running Redis on a CentOS Linux VM in Azure]: https://blogs.msdn.microsoft.com/tconte/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure/
[Scaling using the Elastic Database split-merge tool]: /azure/sql-database/sql-database-elastic-scale-overview-split-and-merge
[Using Azure Content Delivery Network]: /azure/cdn/cdn-create-new-endpoint
[Service Bus 할당량]: /azure/service-bus-messaging/service-bus-quotas
[Service Bus quotas]: /azure/service-bus-messaging/service-bus-quotas
[service-fabric-reliable-collections]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections
[Azure Search의 서비스 제한 사항]:  /azure/search/search-limits-quotas-capacity
[Service limits in Azure Search]:  /azure/search/search-limits-quotas-capacity
[Sharding pattern]: ../patterns/sharding.md
[지원되는 데이터 형식(Azure Search)]:  https://msdn.microsoft.com/library/azure/dn798938.aspx
[Supported Data Types (Azure Search)]:  https://msdn.microsoft.com/library/azure/dn798938.aspx
[트랜잭션]: https://redis.io/topics/transactions
[Transactions]: https://redis.io/topics/transactions
[Event Hubs란?]: /azure/event-hubs/event-hubs-what-is-event-hubs
[What is Event Hubs?]: /azure/event-hubs/event-hubs-what-is-event-hubs
[Azure Search란?]: /azure/search/search-what-is-azure-search
[What is Azure Search?]: /azure/search/search-what-is-azure-search
[What is Azure SQL Database?]: /azure/sql-database/sql-database-technical-overview
[확장성 목표]: /azure/storage/common/storage-scalability-targets
[scalability targets]: /azure/storage/common/storage-scalability-targets
