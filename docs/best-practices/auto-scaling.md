---
title: 자동 크기 조정 지침
description: 자동 크기 조정이 응용 프로그램에 필요한 리소스를 동적으로 할당하는 방법에 대한 지침입니다.
author: dragon119
ms.date: 05/17/2017
pnp.series.title: Best Practices
ms.openlocfilehash: a8489aaabab2b8523fbc9f026f4f435bb6d1ad29
ms.sourcegitcommit: 3d9ee03e2dda23753661a80c7106d1789f5223bb
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/23/2018
---
# <a name="autoscaling"></a><span data-ttu-id="4b516-103">자동 확장</span><span class="sxs-lookup"><span data-stu-id="4b516-103">Autoscaling</span></span>
[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="4b516-104">자동 크기 조정은 성능 요구 사항에 맞게 리소스를 동적으로 할당하는 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-104">Autoscaling is the process of dynamically allocating resources to match performance requirements.</span></span> <span data-ttu-id="4b516-105">작업 용량이 증가하면 응용 프로그램에는 원하는 성능 수준을 유지하고 SLA(서비스 수준 계약)를 만족하기 위해 추가 리소스가 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-105">As the volume of work grows, an application may need additional resources to maintain the desired performance levels and satisfy service-level agreements (SLAs).</span></span> <span data-ttu-id="4b516-106">수요가 감소하고 추가 리소스가 더 이상 필요 없어지면 비용을 최소화하기 위해 할당을 취소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-106">As demand slackens and the additional resources are no longer needed, they can be de-allocated to minimize costs.</span></span>

<span data-ttu-id="4b516-107">자동 크기 조정은 관리 부담을 완화하면서 클라우드에 호스트된 환경의 탄력성을 이용합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-107">Autoscaling takes advantage of the elasticity of cloud-hosted environments while easing management overhead.</span></span> <span data-ttu-id="4b516-108">이렇게 하면 운영자가 시스템 성능을 지속적으로 모니터링하고 리소스 추가 또는 제거를 결정할 필요가 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-108">It reduces the need for an operator to continually monitor the performance of a system and make decisions about adding or removing resources.</span></span>

<span data-ttu-id="4b516-109">응용 프로그램은 다음 두 가지 주요 방법으로 확장될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-109">There are two main ways that an application can scale:</span></span> 

* <span data-ttu-id="4b516-110">규모 확장 및 규모 축소라고도 하는 **수직적 크기 조정**은 리소스의 용량을 변경하는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-110">**Vertical scaling**, also called scaling up and down, means changing the capacity of a resource.</span></span> <span data-ttu-id="4b516-111">예를 들어, 응용 프로그램을 더 큰 VM 크기로 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-111">For example, you could move an application to a larger VM size.</span></span> <span data-ttu-id="4b516-112">수직 크기 조정은 종종 재배포되는 동안 해당 시스템을 일시적으로 사용할 수 없게 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-112">Vertical scaling often requires making the system temporarily unavailable while it is being redeployed.</span></span> <span data-ttu-id="4b516-113">따라서 수직 크기 조정을 자동화하는 것은 일반적이지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-113">Therefore, it's less common to automate vertical scaling.</span></span>
* <span data-ttu-id="4b516-114">스케일 아웃 및 스케일 인이라고도 하는 **수평적 크기 조정**은 리소스의 인스턴스를 추가 또는 제거하는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-114">**Horizontal scaling**, also called scaling out and in, means adding or removing instances of a resource.</span></span> <span data-ttu-id="4b516-115">응용 프로그램은 새 리소스가 프로비전되는 동안 중단 없이 계속 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-115">The application continues running without interruption as new resources are provisioned.</span></span> <span data-ttu-id="4b516-116">프로비저닝 프로세스가 완료되면 솔루션은 이러한 추가 리소스에 배포됩니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-116">When the provisioning process is complete, the solution is deployed on these additional resources.</span></span> <span data-ttu-id="4b516-117">수요가 감소하면 추가 리소스를 정상적으로 종료하고 할당을 취소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-117">If demand drops, the additional resources can be shut down cleanly and deallocated.</span></span> 

<span data-ttu-id="4b516-118">Microsoft Azure를 포함한 많은 클라우드 기반 시스템이 자동 수평적 크기 조정을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-118">Many cloud-based systems, including Microsoft Azure, support automatic horizontal scaling.</span></span> <span data-ttu-id="4b516-119">이 문서의 나머지 부분에서는 수평적 크기 조정에 대해 중점적으로 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-119">The rest of this article focuses on horizontal scaling.</span></span>

> [!NOTE]
> <span data-ttu-id="4b516-120">자동 크기 조정은 주로 계산 리소스에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-120">Autoscaling mostly applies to compute resources.</span></span> <span data-ttu-id="4b516-121">데이터베이스 또는 메시지 큐의 크기를 수평적으로 조정할 수 있지만 이러한 경우는 일반적으로 자동화되지 않는 [데이터 분할][data-partitioning]을 수반합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-121">While it's possible to horizontally scale a database or message queue, this usually involves [data partitioning][data-partitioning], which is generally not automated.</span></span>
>

## <a name="overview"></a><span data-ttu-id="4b516-122">개요</span><span class="sxs-lookup"><span data-stu-id="4b516-122">Overview</span></span>

<span data-ttu-id="4b516-123">자동 크기 조정 전략은 일반적으로 다음 측면을 아우릅니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-123">An autoscaling strategy typically involves the following pieces:</span></span>

* <span data-ttu-id="4b516-124">응용 프로그램, 서비스 및 인프라 수준의 계측 및 모니터링 시스템</span><span class="sxs-lookup"><span data-stu-id="4b516-124">Instrumentation and monitoring systems at the application, service, and infrastructure levels.</span></span> <span data-ttu-id="4b516-125">이 시스템에서 응답 시간, 큐 길이, CPU 사용률, 메모리 사용량 등의 주요 메트릭 캡처</span><span class="sxs-lookup"><span data-stu-id="4b516-125">These systems capture key metrics, such as response times, queue lengths, CPU utilization, and memory usage.</span></span>
* <span data-ttu-id="4b516-126">미리 정의된 임계값 또는 일정에 대해 이러한 메트릭을 평가하고 크기 조정 여부를 결정하는 의사 결정 논리</span><span class="sxs-lookup"><span data-stu-id="4b516-126">Decision-making logic that evaluates these metrics against predefined thresholds or schedules, and decides whether to scale.</span></span>
* <span data-ttu-id="4b516-127">시스템의 크기를 조정하는 구성 요소</span><span class="sxs-lookup"><span data-stu-id="4b516-127">Components that scale the system.</span></span>
* <span data-ttu-id="4b516-128">자동 크기 조정 전략을 테스트, 모니터링, 조정하여 예상대로 작동하는지 확인</span><span class="sxs-lookup"><span data-stu-id="4b516-128">Testing, monitoring, and tuning of the autoscaling strategy to ensure that it functions as expected.</span></span>

<span data-ttu-id="4b516-129">Azure는 일반적인 시나리오를 처리하는 기본 제공 자동 크기 조정 메커니즘을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-129">Azure provides built-in autoscaling mechanisms that address common scenarios.</span></span> <span data-ttu-id="4b516-130">특정 서비스 또는 기술에 기본 제공 자동 크기 조정 기능이 없거나 이러한 기능을 능가하는 특정 자동 크기 조정 요구가 있는 경우, 사용자 지정 구현을 고려할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-130">If a particular service or technology does not have built-in autoscaling functionality, or if you have specific autoscaling requirements beyond its capabilities, you might consider a custom implementation.</span></span> <span data-ttu-id="4b516-131">사용자 지정 구현은 운영 및 시스템 메트릭을 수집하고, 메트릭을 분석한 후 이에 따라 리소스의 크기를 조정합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-131">A custom implementation would collect operational and system metrics, analyze the metrics, and then scale resources accordingly.</span></span>

## <a name="configure-autoscaling-for-an-azure-solution"></a><span data-ttu-id="4b516-132">Azure 솔루션에 대한 자동 크기 조정 구성</span><span class="sxs-lookup"><span data-stu-id="4b516-132">Configure autoscaling for an Azure solution</span></span>

<span data-ttu-id="4b516-133">Azure는 대부분의 계산 옵션에 대해 기본 제공 자동 크기 조정 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-133">Azure provides built-in autoscaling for most compute options.</span></span>

* <span data-ttu-id="4b516-134">**가상 머신**은 Azure Virtual Machines 집합을 그룹으로 관리하는 방법인 [VM Scale Sets][vm-scale-sets]를 사용하여 자동 크기 조정을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-134">**Virtual Machines** support autoscaling through the use of [VM Scale Sets][vm-scale-sets], which are a way to manage a set of Azure virtual machines as a group.</span></span> <span data-ttu-id="4b516-135">[자동 크기 조정 및 Virtual Machine Scale Sets 사용 방법][vm-scale-sets-autoscale]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4b516-135">See [How to use automatic scaling and Virtual Machine Scale Sets][vm-scale-sets-autoscale].</span></span>

* <span data-ttu-id="4b516-136">**Service Fabric** 또한 VM Scale Sets를 통해 자동 크기 조정을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-136">**Service Fabric** also supports auto-scaling through VM Scale Sets.</span></span> <span data-ttu-id="4b516-137">Service Fabric 클러스터의 모든 노드 유형은 별도의 VM 확장 집합으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-137">Every node type in a Service Fabric cluster is set up as a separate VM scale set.</span></span> <span data-ttu-id="4b516-138">이런 방식으로 각 노드 유형은 따로 스케일 인 또는 스케일 아웃될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-138">That way, each node type can be scaled in or out independently.</span></span> <span data-ttu-id="4b516-139">[자동 크기 조정 규칙을 사용하여 Service Fabric 클러스터 크기 조정][service-fabric-autoscale]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4b516-139">See [Scale a Service Fabric cluster in or out using auto-scale rules][service-fabric-autoscale].</span></span>

* <span data-ttu-id="4b516-140">**Azure App Service**에는 자동 크기 조정 기능이 기본 제공되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-140">**Azure App Service** has built-in autoscaling.</span></span> <span data-ttu-id="4b516-141">자동 크기 조정 설정은 App Service 내의 모든 앱에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-141">Autoscale settings apply to all of the apps within an App Service.</span></span> <span data-ttu-id="4b516-142">[수동 또는 자동으로 인스턴스 개수 조정][app-service-autoscale]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4b516-142">See [Scale instance count manually or automatically][app-service-autoscale].</span></span>

* <span data-ttu-id="4b516-143">**Azure Cloud Services**에는 역할 수준에서 자동 크기 조정 기능이 기본 제공되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-143">**Azure Cloud Services** has built-in autoscaling at the role level.</span></span> <span data-ttu-id="4b516-144">[포털에서 클라우드 서비스 크기 자동 조정을 구성하는 방법][cloud-services-autoscale]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4b516-144">See [How to configure auto scaling for a Cloud Service in the portal][cloud-services-autoscale].</span></span>

<span data-ttu-id="4b516-145">이러한 계산 옵션은 모두 [Azure Monitor 자동 크기 조정][monitoring]을 사용하여 일반적인 자동 크기 조정 기능 집합을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-145">These compute options all use [Azure Monitor autoscale][monitoring] to provide a common set of autoscaling functionality.</span></span>

* <span data-ttu-id="4b516-146">**Azure Functions**는 자동 크기 조정 규칙을 구성할 필요가 없으므로 이전 계산 옵션과 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-146">**Azure Functions** differs from the previous compute options, because you don't need to configure any autoscale rules.</span></span> <span data-ttu-id="4b516-147">대신, Azure Functions는 코드가 실행되고 있을 때 계산 능력을 자동으로 할당하며, 필요에 따라 부하 처리를 위해 스케일 아웃됩니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-147">Instead, Azure Functions automatically allocates compute power when your code is running, scaling out as necessary to handle load.</span></span> <span data-ttu-id="4b516-148">자세한 내용은 [Azure Functions에 대한 올바른 호스팅 계획 선택][functions-scale]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4b516-148">For more information, see [Choose the correct hosting plan for Azure Functions][functions-scale].</span></span>

<span data-ttu-id="4b516-149">마지막으로, 경우에 따라 사용자 지정 자동 크기 조정 솔루션이 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-149">Finally, a custom autoscaling solution can sometimes be useful.</span></span> <span data-ttu-id="4b516-150">예를 들어, Azure 진단 및 응용 프로그램 기반 메트릭과 사용자 지정 코드를 함께 사용하여 응용 프로그램 메트릭을 모니터링하고 내보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-150">For example, you could use Azure diagnostics and application-based metrics, along with custom code to monitor and export the application metrics.</span></span> <span data-ttu-id="4b516-151">그런 다음 이러한 메트릭을 기준으로 사용자 지정 규칙을 정의하고, 리소스 관리자 REST API를 사용하여 자동 크기 조정을 트리거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-151">Then you could define custom rules based on these metrics, and use Resource Manager REST APIs to trigger autoscaling.</span></span> <span data-ttu-id="4b516-152">그러나 사용자 지정 솔루션을 구현하는 것은 간단하지 않으며 이전 방법 중 요구 사항을 충족하는 것이 없는 경우에만 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-152">However, a custom solution is not simple to implement, and should be considered only if none of the previous approaches can fulfill your requirements.</span></span>

<span data-ttu-id="4b516-153">요구 사항을 충족하는 경우 플랫폼의 기본 제공 자동 조정 기능을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-153">Use the built-in autoscaling features of the platform, if they meet your requirements.</span></span> <span data-ttu-id="4b516-154">그렇지 않으면 더 복잡한 크기 조정 기능이 정말로 필요한지 신중하게 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="4b516-154">If not, carefully consider whether you really need more complex scaling features.</span></span> <span data-ttu-id="4b516-155">추가 요구 사항의 예에는 더 세분화된 제어, 다른 방식의 크기 조정에 대한 트리거 이벤트 감지, 구독 전체의 크기 조정, 다른 리소스 유형의 크기 조정 등이 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-155">Examples of additional requirements may include more granularity of control, different ways to detect trigger events for scaling, scaling across subscriptions, and scaling other types of resources.</span></span>

## <a name="use-azure-monitor-autoscale"></a><span data-ttu-id="4b516-156">Azure Monitor 자동 크기 조정 사용</span><span class="sxs-lookup"><span data-stu-id="4b516-156">Use Azure Monitor autoscale</span></span>

<span data-ttu-id="4b516-157">[Azure Monitor 자동 크기 조정][monitoring]은 VM Scale Sets, Azure App Service 및 Azure Cloud Service에 대한 일반적인 자동 크기 조정 기능 집합을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-157">[Azure Monitor autoscale][monitoring] provide a common set of autoscaling functionality for VM Scale Sets, Azure App Service, and Azure Cloud Service.</span></span> <span data-ttu-id="4b516-158">크기 조정은 일정에 따라 수행되거나, CPU 또는 메모리 사용량과 같은 런타임 메트릭을 기준으로 수행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-158">Scaling can be performed on a schedule, or based on a runtime metric, such as CPU or memory usage.</span></span> <span data-ttu-id="4b516-159">예제:</span><span class="sxs-lookup"><span data-stu-id="4b516-159">Examples:</span></span>

- <span data-ttu-id="4b516-160">평일에는 10개의 인스턴스로 스케일 아웃하고, 토요일과 일요일에는 4개의 인스턴스로 스케일 인합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-160">Scale out to 10 instances on weekdays, and scale in to 4 instances on Saturday and Sunday.</span></span> 
- <span data-ttu-id="4b516-161">평균 CPU 사용량이 70%보다 크면 인스턴스를 1개씩 스케일 아웃하고, CPU 사용량이 50% 미만으로 떨어지면 인스턴스를 1개씩 스케일 인합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-161">Scale out by one instance if average CPU usage is above 70%, and scale in by one instance if CPU usage falls below 50%.</span></span>
- <span data-ttu-id="4b516-162">큐의 메시지 수가 특정 임계값을 초과하는 경우 인스턴스를 1개씩 스케일 아웃합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-162">Scale out by one instance if the number of messages in a queue exceeds a certain threshold.</span></span>

<span data-ttu-id="4b516-163">기본 제공 메트릭 목록에 대해서는 [Azure Monitor 자동 크기 조정 공용 메트릭][autoscale-metrics]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4b516-163">For a list of built-in metrics, see [Azure Monitor autoscaling common metrics][autoscale-metrics].</span></span> <span data-ttu-id="4b516-164">Application Insights를 사용하여 사용자 지정 메트릭을 구현할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-164">You can also implement custom metrics by  using Application Insights.</span></span> 

<span data-ttu-id="4b516-165">PowerShell, Azure CLI, Azure Resource Manager 템플릿 또는 Azure Portal을 사용하여 자동 크기 조정 기능을 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-165">You can configure autoscaling by using PowerShell, the Azure CLI, an Azure Resource Manager template, or the Azure portal.</span></span> <span data-ttu-id="4b516-166">보다 자세한 제어를 위해서는 [Azure Resource Manager REST API](https://msdn.microsoft.com//library/azure/dn790568.aspx)를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-166">For more detailed control, use the [Azure Resource Manager REST API](https://msdn.microsoft.com//library/azure/dn790568.aspx).</span></span> <span data-ttu-id="4b516-167">[Azure 모니터링 서비스 관리 라이브러리](http://www.nuget.org/packages/Microsoft.WindowsAzure.Management.Monitoring) 및 [Microsoft Insights 라이브러리](https://www.nuget.org/packages/Microsoft.Azure.Insights/)(미리 보기)는 다른 리소스에서 메트릭 수집을 허용하고 REST API를 사용하여 자동 크기 조정을 수행하는 SDK입니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-167">The [Azure Monitoring Service Management Library](http://www.nuget.org/packages/Microsoft.WindowsAzure.Management.Monitoring) and the [Microsoft Insights Library](https://www.nuget.org/packages/Microsoft.Azure.Insights/) (in preview) are SDKs that allow collecting metrics from different resources, and perform autoscaling by making use of the REST APIs.</span></span> <span data-ttu-id="4b516-168">Azure Resource Manager 지원을 사용할 수 없는 리소스의 경우 또는 Azure Cloud Services를 사용하고 있는 경우 서비스 관리 REST API를 자동 크기 조정에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-168">For resources where Azure Resource Manager support isn't available, or if you are using Azure Cloud Services, the Service Management REST API can be used for autoscaling.</span></span> <span data-ttu-id="4b516-169">다른 경우에는 모두 Azure 리소스 관리자를 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="4b516-169">In all other cases, use Azure Resource Manager.</span></span>

<span data-ttu-id="4b516-170">Azure 자동 크기 조정을 사용하는 경우에는 다음 사항을 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="4b516-170">Consider the following points when using Azure autoscale:</span></span>

* <span data-ttu-id="4b516-171">응용 프로그램에 대한 부하를 충분히 잘 예측할 수 있어서 예정된 자동 크기 조정을 사용하여 예상되는 최대 수요를 충족하도록 인스턴스를 추가 및 제거할 수 있는지 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-171">Consider whether you can predict the load on the application well enough to use scheduled autoscaling, adding and removing instances to meet anticipated peaks in demand.</span></span> <span data-ttu-id="4b516-172">이것이 불가능한 경우에는 예측 불가능한 수요 변화를 처리할 수 있게 런타임 메트릭을 기준으로 하는 반응형 자동 크기 조정을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-172">If this isn't possible, use reactive autoscaling based on runtime metrics, in order to handle unpredictable changes in demand.</span></span> <span data-ttu-id="4b516-173">일반적으로 이 방법들을 결합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-173">Typically, you can combine these approaches.</span></span> <span data-ttu-id="4b516-174">예를 들어, 응용 프로그램이 가장 바쁠 것을 아는 시간 일정을 기반으로 하여 리소스를 추가하는 전략을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-174">For example, create a strategy that adds resources based on a schedule of the times when you know the application is most busy.</span></span> <span data-ttu-id="4b516-175">이렇게 하면 새 인스턴스를 시작할 때 지체하지 않고, 필요할 때 용량을 사용할 수 있게 하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-175">This helps to ensure that capacity is available when required, without any delay from starting new instances.</span></span> <span data-ttu-id="4b516-176">각 예정된 규칙에 대해 해당 기간 동안 반응형 자동 크기 조정을 할 수 있게 하는 메트릭을 정의하여 응용 프로그램이 지속적이면서 수요를 예측할 수 없는 피크를 처리할 수 있게 합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-176">For each scheduled rule, define metrics that allow reactive autoscaling during that period to ensure that the application can handle sustained but unpredictable peaks in demand.</span></span>
* <span data-ttu-id="4b516-177">종종 메트릭과 용량 요구 사항의 관계를 이해하기는 어려우며, 특히 응용 프로그램이 초기에 배포된 경우에 그렇습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-177">It's often difficult to understand the relationship between metrics and capacity requirements, especially when an application is initially deployed.</span></span> <span data-ttu-id="4b516-178">처음에 약간의 추가 용량을 프로비전한 후 자동 크기 조정 규칙을 모니터링하고 조정하여 용량을 실제 부하에 더 근접하게 합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-178">Provision a little extra capacity at the beginning, and then monitor and tune the autoscaling rules to bring the capacity closer to the actual load.</span></span>
* <span data-ttu-id="4b516-179">자동 크기 조정 규칙을 구성하고 시간 경과에 따른 응용 프로그램의 성능 변화를 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-179">Configure the autoscaling rules, and then monitor the performance of your application over time.</span></span> <span data-ttu-id="4b516-180">이 모니터링 결과를 사용하여 필요한 경우 시스템 크기 조정 방법을 조정합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-180">Use the results of this monitoring to adjust the way in which the system scales if necessary.</span></span> <span data-ttu-id="4b516-181">그러나 자동 크기 조정은 즉각적인 프로세스가 아님을 명심하세요.</span><span class="sxs-lookup"><span data-stu-id="4b516-181">However, keep in mind that autoscaling is not an instantaneous process.</span></span> <span data-ttu-id="4b516-182">지정된 임계값을 초과하는(또는 미달하는) 평균 CPU 사용률과 같은 메트릭에 반응하는 데에는 시간이 걸립니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-182">It takes time to react to a metric such as average CPU utilization exceeding (or falling below) a specified threshold.</span></span>
* <span data-ttu-id="4b516-183">측정된 트리거 특성(CPU 사용량이나 큐 길이 등)을 기반으로 하는 감지 메커니즘을 사용하는 자동 크기 조정 규칙은 즉각적인 값보다는 시간 경과에 따라 집계되는 값을 사용하여 자동 크기 조정 작업을 트리거합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-183">Autoscaling rules that use a detection mechanism based on a measured trigger attribute (such as CPU usage or queue length) use an aggregated value over time, rather than instantaneous values, to trigger an autoscaling action.</span></span> <span data-ttu-id="4b516-184">기본적으로 집계는 값의 평균입니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-184">By default, the aggregate is an average of the values.</span></span> <span data-ttu-id="4b516-185">이는 시스템이 너무 신속하게 반응하거나 빠른 진동을 일으키는 것을 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-185">This prevents the system from reacting too quickly, or causing rapid oscillation.</span></span> <span data-ttu-id="4b516-186">또한 자동으로 시작된 새 인스턴스가 실행 모드로 안정되는 시간을 허용하여 새 인스턴스가 시작되는 동안 추가 자동 크기 조정 작업이 발생하는 것을 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-186">It also allows time for new instances that are auto-started to settle into running mode, preventing additional autoscaling actions from occurring while the new instances are starting up.</span></span> <span data-ttu-id="4b516-187">Azure Cloud Services 및 Azure Virtual Machines의 경우 집계에 대한 기본 기간은 45분이므로, 수요 급증에 응답하여 자동 크기 조정을 트리거하는 메트릭에 대해 이 기간을 확보할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-187">For Azure Cloud Services and Azure Virtual Machines, the default period for the aggregation is 45 minutes, so it can take up to this period of time for the metric to trigger autoscaling in response to spikes in demand.</span></span> <span data-ttu-id="4b516-188">SDK를 사용하여 집계 기간을 변경할 수 있지만 25분 미만의 기간은 예기치 않은 결과를 초래할 수 있음에 주의하세요( [Azure 모니터링 서비스 관리 라이브러리를 사용하여 CPU 비율로 Cloud Services 자동 크기 조정](http://rickrainey.com/2013/12/15/auto-scaling-cloud-services-on-cpu-percentage-with-the-windows-azure-monitoring-services-management-library/)참조).</span><span class="sxs-lookup"><span data-stu-id="4b516-188">You can change the aggregation period by using the SDK, but be aware that periods of fewer than 25 minutes may cause unpredictable results (for more information, see [Auto Scaling Cloud Services on CPU Percentage with the Azure Monitoring Services Management Library](http://rickrainey.com/2013/12/15/auto-scaling-cloud-services-on-cpu-percentage-with-the-windows-azure-monitoring-services-management-library/)).</span></span> <span data-ttu-id="4b516-189">Web Apps의 경우, 평균 기간은 더 짧아서 평균 트리거 측정값을 변경한 후 약 5분 후에 새 인스턴스를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-189">For Web Apps, the averaging period is much shorter, allowing new instances to be available in about five minutes after a change to the average trigger measure.</span></span>
* <span data-ttu-id="4b516-190">포털 대신 SDK를 사용하여 자동 크기 조정을 구성하면 규칙이 활성화된 동안 더 상세한 일정을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-190">If you configure autoscaling using the SDK rather than the portal, you can specify a more detailed schedule during which the rules are active.</span></span> <span data-ttu-id="4b516-191">또한 고유의 메트릭을 만들고 사용자의 자동 크기 조정 규칙에 존재하는 내용과 함께 또는 별도로 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-191">You can also create your own metrics and use them with or without any of the existing ones in your autoscaling rules.</span></span> <span data-ttu-id="4b516-192">예를 들어, 초당 요청 수나 평균 메모리 가용성과 같은 대체 카운터를 사용하거나 특정 비즈니스 프로세스를 측정하는 사용자 지정 카운터를 사용하고자 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-192">For example, you may wish to use alternative counters, such as the number of requests per second or the average memory availability, or use custom counters that measure specific business processes.</span></span>
* <span data-ttu-id="4b516-193">Service Fabric의 크기를 자동으로 조정할 경우 클러스터의 노드 유형은 백 엔드에서 VM 확장 집합으로 구성되므로 각 노드 유형에 대한 자동 크기 조정 규칙을 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-193">When autoscaling Service Fabric, the node types in your cluster are made of VM scale sets at the backend, so you need to set up auto-scale rules for each node type.</span></span> <span data-ttu-id="4b516-194">자동 크기 조정을 수행하기 전에 포함해야 할 노드 수를 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-194">Take into account the number of nodes that you must have before you set up auto-scaling.</span></span> <span data-ttu-id="4b516-195">기본 노드 형식에 대해 포함해야 할 최소 노드 수는 선택한 안정성 수준에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-195">The minimum number of nodes that you must have for the primary node type is driven by the reliability level you have chosen.</span></span> <span data-ttu-id="4b516-196">자세한 내용은 [자동 크기 조정 규칙을 사용하여 Service Fabric 클러스터 크기 조정](https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-scale-up-down)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4b516-196">For more info, see [scale a Service Fabric cluster in or out using auto-scale rules](https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-scale-up-down).</span></span>
* <span data-ttu-id="4b516-197">포털을 사용하여 SQL Database 인스턴스 및 큐와 같은 리소스를 Cloud Service 인스턴스에 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-197">You can use the portal to link resources such as SQL Database instances and queues to a Cloud Service instance.</span></span> <span data-ttu-id="4b516-198">따라서 연결된 각 리소스에 대한 별도의 수동 및 자동 크기 조정 구성 옵션에 더 쉽게 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-198">This allows you to more easily access the separate manual and automatic scaling configuration options for each of the linked resources.</span></span> <span data-ttu-id="4b516-199">자세한 내용은 [방법: 클라우드 서비스에 리소스 연결](/azure/cloud-services/cloud-services-how-to-manage)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4b516-199">For more information, see [How to: Link a resource to a cloud service](/azure/cloud-services/cloud-services-how-to-manage).</span></span>
* <span data-ttu-id="4b516-200">복수의 정책 및 규칙을 구성하는 경우, 서로 충돌할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-200">When you configure multiple policies and rules, they could conflict with each other.</span></span> <span data-ttu-id="4b516-201">자동 크기 조정은 다음 충돌 해결 규칙을 사용하여 언제나 충분한 수의 인스턴스가 실행되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-201">Autoscale uses the following conflict resolution rules to ensure that there is always a sufficient number of instances running:</span></span>
  * <span data-ttu-id="4b516-202">규모 확장 작업은 언제나 규모 감축 작업보다 우선됩니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-202">Scale out operations always take precedence over scale in operations.</span></span>
  * <span data-ttu-id="4b516-203">규모 확장 작업이 충돌하는 경우, 인스턴스 수가 가장 많이 증가되는 규칙이 우선됩니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-203">When scale out operations conflict, the rule that initiates the largest increase in the number of instances takes precedence.</span></span>
  * <span data-ttu-id="4b516-204">규모 감축 작업이 충돌하는 경우, 인스턴스 수가 가장 적게 감소되는 규칙이 우선됩니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-204">When scale in operations conflict, the rule that initiates the smallest decrease in the number of instances takes precedence.</span></span>
* <span data-ttu-id="4b516-205">App Service 환경에서 작업자 풀 또는 프런트 엔드 메트릭을 사용하여 자동 크기 조정 규칙을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-205">In an App Service Environment any worker pool or front-end metrics can be used to define autoscale rules.</span></span> <span data-ttu-id="4b516-206">자세한 내용은 [자동 크기 조정 및 App Service Environment](/azure/app-service/app-service-environment-auto-scale)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4b516-206">For more information, see [Autoscaling and App Service Environment](/azure/app-service/app-service-environment-auto-scale).</span></span>

## <a name="application-design-considerations"></a><span data-ttu-id="4b516-207">응용 프로그램 디자인 고려 사항</span><span class="sxs-lookup"><span data-stu-id="4b516-207">Application design considerations</span></span>
<span data-ttu-id="4b516-208">자동 크기 조정은 인스턴트 솔루션이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-208">Autoscaling isn't an instant solution.</span></span> <span data-ttu-id="4b516-209">그저 리소스를 시스템에 추가하거나 프로세스의 더 많은 인스턴스를 추가하기만 해서는 시스템 성능의 향상이 보장되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-209">Simply adding resources to a system or running more instances of a process doesn't guarantee that the performance of the system will improve.</span></span> <span data-ttu-id="4b516-210">자동 크기 조정 전략을 디자인할 때 다음 사항을 고려하십시오.</span><span class="sxs-lookup"><span data-stu-id="4b516-210">Consider the following points when designing an autoscaling strategy:</span></span>

* <span data-ttu-id="4b516-211">시스템은 수평 확장이 가능하도록 디자인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-211">The system must be designed to be horizontally scalable.</span></span> <span data-ttu-id="4b516-212">인스턴스 선호도를 가정하지 마십시오. 프로세스의 특정 인스턴스에서 항상 실행되는 코드가 필요한 솔루션을 디자인하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="4b516-212">Avoid making assumptions about instance affinity; do not design solutions that require that the code is always running in a specific instance of a process.</span></span> <span data-ttu-id="4b516-213">클라우드 서비스나 웹 사이트를 수평으로 크기 조정하는 경우, 항상 동일한 인스턴스에 라우팅되는 동일한 소스로부터의 일련의 요청을 가정하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="4b516-213">When scaling a cloud service or web site horizontally, don't assume that a series of requests from the same source will always be routed to the same instance.</span></span> <span data-ttu-id="4b516-214">같은 이유로 서비스를 상태 비저장으로 디자인하여 항상 서비스의 동일한 인스턴스에 라우팅되는 응용 프로그램으로부터의 일련의 요청을 방지하십시오.</span><span class="sxs-lookup"><span data-stu-id="4b516-214">For the same reason, design services to be stateless to avoid requiring a series of requests from an application to always be routed to the same instance of a service.</span></span> <span data-ttu-id="4b516-215">큐에서 메시지를 읽고 처리하는 서비스를 디자인하는 경우 특정 메시지를 처리하는 서비스의 인스턴스를 가정하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="4b516-215">When designing a service that reads messages from a queue and processes them, don't make any assumptions about which instance of the service handles a specific message.</span></span> <span data-ttu-id="4b516-216">큐 길이가 늘어나면 자동 크기 조정이 서비스의 추가 인스턴스를 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-216">Autoscaling could start additional instances of a service as the queue length grows.</span></span> <span data-ttu-id="4b516-217">[경쟁 소비자 패턴][competing-consumers]에서 이 시나리오를 처리하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-217">The [Competing Consumers Pattern][competing-consumers] describes how to handle this scenario.</span></span>
* <span data-ttu-id="4b516-218">솔루션이 장기 실행 작업을 구현하는 경우, 이 작업이 규모 확장 및 규모 감축을 모두 지원하도록 디자인하십시오.</span><span class="sxs-lookup"><span data-stu-id="4b516-218">If the solution implements a long-running task, design this task to support both scaling out and scaling in.</span></span> <span data-ttu-id="4b516-219">기한에 상관 없이, 이러한 작업은 시스템이 규모 감축되었을 때 프로세스의 인스턴스가 완전히 종료되는 것을 방지할 수 있으며, 그러지 않으면 프로세스가 강제로 종료되었을 때 데이터가 손상될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-219">Without due care, such a task could prevent an instance of a process from being shut down cleanly when the system scales in, or it could lose data if the process is forcibly terminated.</span></span> <span data-ttu-id="4b516-220">이상적으로는 장기 실행 작업을 리팩터링하고 더 작고 이스크리트된 청크로 수행하는 처리를 중단합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-220">Ideally, refactor a long-running task and break up the processing that it performs into smaller, discrete chunks.</span></span> <span data-ttu-id="4b516-221">[파이프 및 필터 패턴][pipes-and-filters]에서는 이렇게 할 수 있는 방법의 예를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-221">The [Pipes and Filters Pattern][pipes-and-filters] provides an example of how you can achieve this.</span></span>
* <span data-ttu-id="4b516-222">또는 정기적으로 작업에 관한 상태 정보를 기록하고 이 상태를 작업을 실행하는 프로세스의 모든 인스턴스에서 액세스할 수 있는 영구 저장소에 저장하는 검사점 메커니즘을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-222">Alternatively, you can implement a checkpoint mechanism that records state information about the task at regular intervals, and save this state in durable storage that can be accessed by any instance of the process running the task.</span></span> <span data-ttu-id="4b516-223">이런 식으로, 프로세스가 종료되면 수행 중이던 작업은 다른 인스턴스를 사용하여 마지막 검사점에서 다시 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-223">In this way, if the process is shutdown, the work that it was performing can be resumed from the last checkpoint by using another instance.</span></span>
* <span data-ttu-id="4b516-224">백그라운드 작업이 별도 계산 인스턴스에서 실행되는 경우, 클라우드 서비스에 호스트된 응용 프로그램의 작업자 역할에서와 같이 서로 다른 크기 조정 정책을 사용하는 응용 프로그램의 서로 다른 부분을 크기 조정해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-224">When background tasks run on separate compute instances, such as in worker roles of a cloud services hosted application, you may need to scale different parts of the application using different scaling policies.</span></span> <span data-ttu-id="4b516-225">예를 들어 백그라운드 계산 인스턴스의 수를 증가시키지 않고 추가 UI(사용자 인터페이스) 계산 인스턴스를 배포하거나 그 반대로 해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-225">For example, you may need to deploy additional user interface (UI) compute instances without increasing the number of background compute instances, or the opposite of this.</span></span> <span data-ttu-id="4b516-226">서로 다른 수준의 서비스(기본 및 고급 서비스 패키지 등)를 제공하는 경우, SLA를 충족시키기 위해 기본 서비스 패키지에 대한 계산 리소스보다 고급 서비스 패키지에 대한 계산 리소스를 더 적극적으로 규모 확장해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-226">If you offer different levels of service (such as basic and premium service packages), you may need to scale out the compute resources for premium service packages more aggressively than those for basic service packages in order to meet SLAs.</span></span>
* <span data-ttu-id="4b516-227">UI 및 백그라운드 계산 인스턴스가 자동 크기 전략에 대한 기준으로 통신하는 큐의 길이를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-227">Consider using the length of the queue over which UI and background compute instances communicate as a criterion for your autoscaling strategy.</span></span> <span data-ttu-id="4b516-228">이는 현재 로드와 백그라운드 작업의 처리 능력 간의 불균형 및 차이를 가장 잘 나타내는 지표입니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-228">This is the best indicator of an imbalance or difference between the current load and the processing capacity of the background task.</span></span>
* <span data-ttu-id="4b516-229">시간당 명령 수나 복잡한 트랜잭션의 평균 실행 시간과 같은 비즈니스 프로세스를 측정하는 카운터의 자동 크기 조정 전략에 기반하는 경우, 이 카운터 유형의 결과와 실제 계산 용량 요구 간의 관계를 제대로 이해했는지 확인하십시오.</span><span class="sxs-lookup"><span data-stu-id="4b516-229">If you base your autoscaling strategy on counters that measure business processes, such as the number of orders placed per hour or the average execution time of a complex transaction, ensure that you fully understand the relationship between the results from these types of counters and the actual compute capacity requirements.</span></span> <span data-ttu-id="4b516-230">하나 이상의 구성 요소의 크기를 조정하거나 비즈니스 프로세스 카운터에서 변경한 내용에 대한 응답의 단위를 계산해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-230">It may be necessary to scale more than one component or compute unit in response to changes in business process counters.</span></span>  
* <span data-ttu-id="4b516-231">시스템이 과도하게 규모 확장되려는 것을 방지하고 수많은 인스턴스를 실행함으로 인한 비용 발생을 회피하기 위해 자동으로 추가될 수 있는 인스턴스의 최대 수를 제한하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-231">To prevent a system from attempting to scale out excessively, and to avoid the costs associated with running many thousands of instances, consider limiting the maximum number of instances that can be automatically added.</span></span> <span data-ttu-id="4b516-232">대부분의 자동 크기 조정 메커니즘을 사용하면 규칙에 대한 인스턴스의 최소 및 최대 수를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-232">Most autoscaling mechanisms allow you to specify the minimum and maximum number of instances for a rule.</span></span> <span data-ttu-id="4b516-233">또한 인스턴스의 최대 수가 배포되고 시스템이 여전히 오버로드된 경우 시스템이 제공하는 기능을 적절하게 저하시키는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-233">In addition, consider gracefully degrading the functionality that the system provides if the maximum number of instances have been deployed, and the system is still overloaded.</span></span>
* <span data-ttu-id="4b516-234">자동 크기 조정은 갑작스런 워크로드 버스트를 처리하기에 가장 적합한 메커니즘이 아닐 수도 있다는 점을 명심하십시오.</span><span class="sxs-lookup"><span data-stu-id="4b516-234">Keep in mind that autoscaling might not be the most appropriate mechanism to handle a sudden burst in workload.</span></span> <span data-ttu-id="4b516-235">서비스의 새 인스턴스를 프로비전하고 시작하거나 시스템에 리소스를 추가하는 데에는 시간이 걸리며, 이러한 추가 리소스를 사용할 수 있게 된 무렵에는 피크 수요가 이미 지나갔을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-235">It takes time to provision and start new instances of a service or add resources to a system, and the peak demand may have passed by the time these additional resources have been made available.</span></span> <span data-ttu-id="4b516-236">이 시나리오에서는 서비스를 제한하는 것이 더 나을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-236">In this scenario, it may be better to throttle the service.</span></span> <span data-ttu-id="4b516-237">자세한 내용은 [제한 패턴][throttling]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4b516-237">For more information, see the [Throttling Pattern][throttling].</span></span>
* <span data-ttu-id="4b516-238">반대로, 볼륨이 급속하게 증가될 때 모든 요청을 처리할 용량이 필요하고 비용은 주요 고려 사항이 아닌 경우, 추가 인스턴스를 더 빠르게 시작하는 적극적인 자동 크기 조정 전략을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-238">Conversely, if you do need the capacity to process all requests when the volume fluctuates rapidly, and cost isn't a major contributing factor, consider using an aggressive autoscaling strategy that starts additional instances more quickly.</span></span> <span data-ttu-id="4b516-239">해당 부하가 예상되기 전에 최대 부하에 적합한 충분한 수의 인스턴스를 시작하는 일정 정책을 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-239">You can also use a scheduled policy that starts a sufficient number of instances to meet the maximum load before that load is expected.</span></span>
* <span data-ttu-id="4b516-240">자동 크기 조정 메커니즘은 자동 크기 조정 프로세스를 모니터링하고 각 자동 크기 조정 이벤트의 세부 정보(언제 어떻게 트리거되고 어떤 리소스가 추가 또는 제거되었는지)를 기록해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-240">The autoscaling mechanism should monitor the autoscaling process, and log the details of each autoscaling event (what triggered it, what resources were added or removed, and when).</span></span> <span data-ttu-id="4b516-241">사용자 지정 자동 크기 조정 메커니즘을 만든 경우, 이 기능이 통합되어 있는지 확인하십시오.</span><span class="sxs-lookup"><span data-stu-id="4b516-241">If you create a custom autoscaling mechanism, ensure that it incorporates this capability.</span></span> <span data-ttu-id="4b516-242">정보를 분석하면 자동 크기 조정 전략의 효율성을 측정하고 필요한 경우 조정하는 데 도움이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-242">Analyze the information to help measure the effectiveness of the autoscaling strategy, and tune it if necessary.</span></span> <span data-ttu-id="4b516-243">단기적으로는 더 명확해지는 사용 패턴, 장기적으로는 사업 확장이나 응용 프로그램 요구 사항의 진화에 따라 둘 다 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-243">You can tune both in the short term, as the usage patterns become more obvious, and over the long term, as the business expands or the requirements of the application evolve.</span></span> <span data-ttu-id="4b516-244">또한 응용 프로그램이 자동 크기 조정에 대해 정의된 상한에 도달하면 메커니즘은 필요한 경우 추가 리소스를 수동으로 시작할 수 있는 운영자에게 알립니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-244">If an application reaches the upper limit defined for autoscaling, the mechanism might also alert an operator who could manually start additional resources if necessary.</span></span> <span data-ttu-id="4b516-245">이 상황에서 운영자는 워크로드를 완화한 후 이 리소스를 수동으로 제거할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-245">Note that, under these circumstances, the operator may also be responsible for manually removing these resources after the workload eases.</span></span>

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="4b516-246">관련 패턴 및 지침</span><span class="sxs-lookup"><span data-stu-id="4b516-246">Related patterns and guidance</span></span>
<span data-ttu-id="4b516-247">자동 크기 조정을 구현할 때 다음 패턴 및 지침도 시나리오와 관련이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-247">The following patterns and guidance may also be relevant to your scenario when implementing autoscaling:</span></span>

* <span data-ttu-id="4b516-248">[제한 패턴][throttling].</span><span class="sxs-lookup"><span data-stu-id="4b516-248">[Throttling Pattern][throttling].</span></span> <span data-ttu-id="4b516-249">이 패턴에서는 수요 증가가 리소스에 극단적인 부하를 배치한 경우에 응용 프로그램이 계속 기능하고 SLA를 충족시킬 수 있는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-249">This pattern describes how an application can continue to function and meet SLAs when an increase in demand places an extreme load on resources.</span></span> <span data-ttu-id="4b516-250">시스템을 규모 확장하는 동안 자동 크기 조정에 제한을 사용하여 시스템 과부하를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-250">Throttling can be used with autoscaling to prevent a system from being overwhelmed while the system scales out.</span></span>
* <span data-ttu-id="4b516-251">[경쟁 소비자 패턴][competing-consumers].</span><span class="sxs-lookup"><span data-stu-id="4b516-251">[Competing Consumers Pattern][competing-consumers].</span></span> <span data-ttu-id="4b516-252">이 패턴에서는 모든 응용 프로그램 인스턴스로부터의 메시지를 처리할 수 있는 서비스 인스턴스 풀을 구현하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-252">This pattern describes how to implement a pool of service instances that can handle messages from any application instance.</span></span> <span data-ttu-id="4b516-253">서비스 인스턴스 시작 및 중지에 자동 크기 조정을 사용하여 예상된 워크로드에 맞출 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-253">Autoscaling can be used to start and stop service instances to match the anticipated workload.</span></span> <span data-ttu-id="4b516-254">이 방법을 사용하면 시스템에서 여러 메시지를 동시에 처리하여 처리량을 최적화하고 확장성 및 가용성을 향상시키며 워크로드를 분산시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-254">This approach enables a system to process multiple messages concurrently to optimize throughput, improve scalability and availability, and balance the workload.</span></span>
* <span data-ttu-id="4b516-255">[모니터링 및 진단](./monitoring.md).</span><span class="sxs-lookup"><span data-stu-id="4b516-255">[Monitoring and diagnostics](./monitoring.md).</span></span> <span data-ttu-id="4b516-256">계측 및 원격 분석은 자동 크기 조정 프로세스를 수행할 수 있는 정보를 수집하기 위해 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="4b516-256">Instrumentation and telemetry are vital for gathering the information that can drive the autoscaling process.</span></span>


<!-- links -->

[monitoring]: /azure/monitoring-and-diagnostics/monitoring-overview-autoscale
[app-service-autoscale]: /azure/monitoring-and-diagnostics/insights-how-to-scale?toc=%2fazure%2fapp-service-web%2ftoc.json#scaling-based-on-a-pre-set-metric
[app-service-plan]: /azure/app-service/azure-web-sites-web-hosting-plans-in-depth-overview
[autoscale-metrics]: /azure/monitoring-and-diagnostics/insights-autoscale-common-metrics
[cloud-services-autoscale]: /azure/cloud-services/cloud-services-how-to-scale-portal
[competing-consumers]: ../patterns/competing-consumers.md
[data-partitioning]: ./data-partitioning.md
[functions-scale]: /azure/azure-functions/functions-scale
[link-resource-to-cloud-service]: /azure/cloud-services/cloud-services-how-to-manage#how-to-link-a-resource-to-a-cloud-service
[pipes-and-filters]: ../patterns/pipes-and-filters.md
[service-fabric-autoscale]: /azure/service-fabric/service-fabric-cluster-scale-up-down
[throttling]: ../patterns/throttling.md
[vm-scale-sets]: /azure/virtual-machine-scale-sets/virtual-machine-scale-sets-overview
[vm-scale-sets-autoscale]: /azure/virtual-machine-scale-sets/virtual-machine-scale-sets-autoscale-overview
