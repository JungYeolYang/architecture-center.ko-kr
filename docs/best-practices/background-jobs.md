---
title: 백그라운드 작업 지침
description: 사용자 인터페이스와 독립적으로 실행되는 백그라운드 작업에 대한 지침.
author: dragon119
ms.date: 05/24/2017
pnp.series.title: Best Practices
ms.openlocfilehash: 57fd7a6cc400b53e51e08fb5a1377dce4ae61327
ms.sourcegitcommit: e9eb2b895037da0633ef3ccebdea2fcce047620f
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/30/2018
ms.locfileid: "50251926"
---
# <a name="background-jobs"></a><span data-ttu-id="53b2b-103">백그라운드 작업</span><span class="sxs-lookup"><span data-stu-id="53b2b-103">Background jobs</span></span>
[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="53b2b-104">다양한 유형의 응용 프로그램을 사용하려면 사용자 인터페이스(UI)와 독립적으로 실행되는 백그라운드 작업이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-104">Many types of applications require background tasks that run independently of the user interface (UI).</span></span> <span data-ttu-id="53b2b-105">이러한 작업의 예로 배치 작업, 집약적인 처리 작업, 워크플로 등의 장기 실행 프로세스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-105">Examples include batch jobs, intensive processing tasks, and long-running processes such as workflows.</span></span> <span data-ttu-id="53b2b-106">백그라운드 작업은 사용자 조작 없이 실행할 수 있으며, 응용 프로그램은 작업을 시작한 다음 사용자의 조작 요청을 계속 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-106">Background jobs can be executed without requiring user interaction--the application can start the job and then continue to process interactive requests from users.</span></span> <span data-ttu-id="53b2b-107">따라서 응용 프로그램 UI에 대한 부담을 최소화하므로 가용성을 개선하고 대화형 응답 시간을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-107">This can help to minimize the load on the application UI, which can improve availability and reduce interactive response times.</span></span>

<span data-ttu-id="53b2b-108">예를 들어 응용 프로그램이 사용자가 업로드한 이미지의 미리 보기를 생성해야 하는 경우, 프로세스가 완료될 때까지 사용자가 기다리게 할 필요 없이 이 작업을 백그라운드 작업으로 수행하고 완료되었을 때 미리 보기를 저장소에 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-108">For example, if an application is required to generate thumbnails of images that are uploaded by users, it can do this as a background job and save the thumbnail to storage when it is complete--without the user needing to wait for the process to be completed.</span></span> <span data-ttu-id="53b2b-109">마찬가지로, 주문을 실행하는 사용자는 주문을 처리하는 백그라운드 워크플로를 시작하고 UI를 사용하여 웹앱을 계속 탐색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-109">In the same way, a user placing an order can initiate a background workflow that processes the order, while the UI allows the user to continue browsing the web app.</span></span> <span data-ttu-id="53b2b-110">백그라운드 작업이 완료되면 저장된 주문 데이터를 업데이트하고 주문을 확인하는 메일을 사용자에 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-110">When the background job is complete, it can update the stored orders data and send an email to the user that confirms the order.</span></span>

<span data-ttu-id="53b2b-111">작업을 백그라운드 작업으로 구현할지 여부를 생각할 때 주된 기준은 작업이 사용자 조작 없이, 그리고 작업이 완료될 때까지 UI가 기다릴 필요 없이 실행할 수 있는지 여부입니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-111">When you consider whether to implement a task as a background job, the main criteria is whether the task can run without user interaction and without the UI needing to wait for the job to be completed.</span></span> <span data-ttu-id="53b2b-112">완료될 때까지 사용자 또는 UI가 기다려야 하는 작업은 백그라운드 작업으로 적절하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-112">Tasks that require the user or the UI to wait while they are completed might not be appropriate as background jobs.</span></span>

## <a name="types-of-background-jobs"></a><span data-ttu-id="53b2b-113">백그라운드 작업의 유형</span><span class="sxs-lookup"><span data-stu-id="53b2b-113">Types of background jobs</span></span>
<span data-ttu-id="53b2b-114">일반적으로 백그라운드 작업에는 다음과 같은 유형의 작업 중 하나 이상이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-114">Background jobs typically include one or more of the following types of jobs:</span></span>

* <span data-ttu-id="53b2b-115">수학 계산, 구조 모델 분석 등 CPU를 많이 사용하는 작업.</span><span class="sxs-lookup"><span data-stu-id="53b2b-115">CPU-intensive jobs, such as mathematical calculations or structural model analysis.</span></span>
* <span data-ttu-id="53b2b-116">일련의 저장소 트랜잭션 실행 또는 파일 인덱싱 등 I/O 사용 작업.</span><span class="sxs-lookup"><span data-stu-id="53b2b-116">I/O-intensive jobs, such as executing a series of storage transactions or indexing files.</span></span>
* <span data-ttu-id="53b2b-117">야간 데이터 업데이트 또는 예약된 처리 같은 Batch 작업.</span><span class="sxs-lookup"><span data-stu-id="53b2b-117">Batch jobs, such as nightly data updates or scheduled processing.</span></span>
* <span data-ttu-id="53b2b-118">주문 처리 또는 서비스 및 시스템 프로비전 등 장기 실행 워크플로.</span><span class="sxs-lookup"><span data-stu-id="53b2b-118">Long-running workflows, such as order fulfillment, or provisioning services and systems.</span></span>
* <span data-ttu-id="53b2b-119">작업이 처리를 위해 더 안전한 위치로 넘겨지는 중요한 데이터 처리.</span><span class="sxs-lookup"><span data-stu-id="53b2b-119">Sensitive-data processing where the task is handed off to a more secure location for processing.</span></span> <span data-ttu-id="53b2b-120">예를 들어 웹앱 내에서 중요한 데이터를 처리하지 않고</span><span class="sxs-lookup"><span data-stu-id="53b2b-120">For example, you might not want to process sensitive data within a web app.</span></span> <span data-ttu-id="53b2b-121">대신 [게이트키퍼](https://msdn.microsoft.com/library/dn589793.aspx)와 같은 패턴을 사용하여 보호된 저장소에 액세스할 수 있는 격리된 백그라운드 프로세스에 데이터를 전송할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-121">Instead, you might use a pattern such as [Gatekeeper](https://msdn.microsoft.com/library/dn589793.aspx) to transfer the data to an isolated background process that has access to protected storage.</span></span>

## <a name="triggers"></a><span data-ttu-id="53b2b-122">트리거</span><span class="sxs-lookup"><span data-stu-id="53b2b-122">Triggers</span></span>
<span data-ttu-id="53b2b-123">백그라운드 작업을 여러 가지 방법으로 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-123">Background jobs can be initiated in several different ways.</span></span> <span data-ttu-id="53b2b-124">이러한 방법은 모두 다음 범주 중 하나에 속합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-124">They fall into one of the following categories:</span></span>

* <span data-ttu-id="53b2b-125">[**이벤트 기반 트리거**](#event-driven-triggers).</span><span class="sxs-lookup"><span data-stu-id="53b2b-125">[**Event-driven triggers**](#event-driven-triggers).</span></span> <span data-ttu-id="53b2b-126">작업은 이벤트, 일반적으로 사용자 또는 워크플로 단계에 의해 실행된 동작에 응답하여 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-126">The task is started in response to an event, typically an action taken by a user or a step in a workflow.</span></span>
* <span data-ttu-id="53b2b-127">[**일정 기반 트리거**](#schedule-driven-triggers).</span><span class="sxs-lookup"><span data-stu-id="53b2b-127">[**Schedule-driven triggers**](#schedule-driven-triggers).</span></span> <span data-ttu-id="53b2b-128">타이머를 기준으로 일정에 따라 작업이 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-128">The task is invoked on a schedule based on a timer.</span></span> <span data-ttu-id="53b2b-129">이는 되풀이 일정 또는 이후 시간에 대해 지정된 일회성 호출일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-129">This might be a recurring schedule or a one-off invocation that is specified for a later time.</span></span>

### <a name="event-driven-triggers"></a><span data-ttu-id="53b2b-130">이벤트 기반 트리거</span><span class="sxs-lookup"><span data-stu-id="53b2b-130">Event-driven triggers</span></span>
<span data-ttu-id="53b2b-131">이벤트 기반 호출은 트리거를 사용하여 백그라운드 작업을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-131">Event-driven invocation uses a trigger to start the background task.</span></span> <span data-ttu-id="53b2b-132">이벤트 기반 트리거의 사용 예는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-132">Examples of using event-driven triggers include:</span></span>

* <span data-ttu-id="53b2b-133">UI 또는 다른 작업이 메시지를 큐에 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-133">The UI or another job places a message in a queue.</span></span> <span data-ttu-id="53b2b-134">메시지는 주문을 실행하는 사용자와 같이 실행된 작업에 관한 데이터를 포함하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-134">The message contains data about an action that has taken place, such as the user placing an order.</span></span> <span data-ttu-id="53b2b-135">백그라운드 작업은 이 큐를 수신 대기하여 새 메시지 도착을 감지합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-135">The background task listens on this queue and detects the arrival of a new message.</span></span> <span data-ttu-id="53b2b-136">메시지를 읽고 메시지 내의 데이터를 백그라운드 작업에 대한 입력으로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-136">It reads the message and uses the data in it as the input to the background job.</span></span>
* <span data-ttu-id="53b2b-137">UI 또는 다른 작업이 값을 저장소에 저장하거나 저장소의 값을 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-137">The UI or another job saves or updates a value in storage.</span></span> <span data-ttu-id="53b2b-138">백그라운드 작업이 저장소를 모니터링하고 변경 내용을 감지합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-138">The background task monitors the storage and detects changes.</span></span> <span data-ttu-id="53b2b-139">데이터를 읽고 해당 데이터를 백그라운드 작업에 대한 입력으로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-139">It reads the data and uses it as the input to the background job.</span></span>
* <span data-ttu-id="53b2b-140">UI 또는 다른 작업이 HTTPS URI 또는 웹 서비스로 표시되는 API와 같은 엔드포인트에 요청을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-140">The UI or another job makes a request to an endpoint, such as an HTTPS URI, or an API that is exposed as a web service.</span></span> <span data-ttu-id="53b2b-141">요청의 일부로 백그라운드 작업을 완료하는 데 필요한 데이터를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-141">It passes the data that is required to complete the background task as part of the request.</span></span> <span data-ttu-id="53b2b-142">엔드포인트 또는 웹 서비스가 데이터를 자체의 입력으로 사용하는 백그라운드 작업을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-142">The endpoint or web service invokes the background task, which uses the data as its input.</span></span>

<span data-ttu-id="53b2b-143">이미지 처리, 워크플로, 원격 서비스에 정보 보내기, 메일 메시지 모내기, 다중 테넌트 응용 프로그램에서 새 사용자 프로비전 등이 이벤트 기반 호출에 적합한 작업의 대표적인 예입니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-143">Typical examples of tasks that are suited to event-driven invocation include image processing, workflows, sending information to remote services, sending email messages, and provisioning new users in multitenant applications.</span></span>

### <a name="schedule-driven-triggers"></a><span data-ttu-id="53b2b-144">일정 기반 트리거</span><span class="sxs-lookup"><span data-stu-id="53b2b-144">Schedule-driven triggers</span></span>
<span data-ttu-id="53b2b-145">일정 기반 호출은 타이머를 사용하여 백그라운드 작업을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-145">Schedule-driven invocation uses a timer to start the background task.</span></span> <span data-ttu-id="53b2b-146">일정 기반 트리거의 사용 예는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-146">Examples of using schedule-driven triggers include:</span></span>

* <span data-ttu-id="53b2b-147">응용 프로그램 내에서 로컬로 또는 응용 프로그램의 운영 체제의 일부로 실행하는 타이머가 정기적으로 백그라운드 작업을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-147">A timer that is running locally within the application or as part of the application’s operating system invokes a background task on a regular basis.</span></span>
* <span data-ttu-id="53b2b-148">다른 응용 프로그램 또는 Azure Scheduler와 같은 타이머 서비스에서 실행되는 타이머가 정기적으로 API 또는 웹 서비스에 요청을 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-148">A timer that is running in a different application, or a timer service such as Azure Scheduler, sends a request to an API or web service on a regular basis.</span></span> <span data-ttu-id="53b2b-149">API 또는 웹 서비스가 백그라운드 작업을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-149">The API or web service invokes the background task.</span></span>
* <span data-ttu-id="53b2b-150">별도 프로세스 또는 응용 프로그램이 지정된 시간 지연 후에 한 번 또는 특정 시간에 백그라운드 작업을 호출하게 하는 타이머를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-150">A separate process or application starts a timer that causes the background task to be invoked once after a specified time delay, or at a specific time.</span></span>

<span data-ttu-id="53b2b-151">일정 기반 호출에 적합한 작업의 일반적인 예로는 배치 처리 루틴(예: 사용자의 최근 행동을 기반으로 사용자에 대한 관련 제품 목록 업데이트), 일상적인 데이터 처리 작업(예: 인덱스 업데이트 또는 누적된 결과 생성), 일일 보고서에 대한 데이터 분석, 데이터 보존 정리, 데이터 일관성 검사 등이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-151">Typical examples of tasks that are suited to schedule-driven invocation include batch-processing routines (such as updating related-products lists for users based on their recent behavior), routine data processing tasks (such as updating indexes or generating accumulated results), data analysis for daily reports, data retention cleanup, and data consistency checks.</span></span>

<span data-ttu-id="53b2b-152">단일 인스턴스로 실행해야 하는 일정 기반 작업을 사용하는 경우, 다음 사항에 유의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-152">If you use a schedule-driven task that must run as a single instance, be aware of the following:</span></span>

* <span data-ttu-id="53b2b-153">스케줄러를 실행하는 계산 인스턴스(Windows 예약된 작업을 사용하는 가상 머신 등)가 확장된 경우, 스케줄러의 여러 인스턴스가 실행되며</span><span class="sxs-lookup"><span data-stu-id="53b2b-153">If the compute instance that is running the scheduler (such as a virtual machine using Windows scheduled tasks) is scaled, you will have multiple instances of the scheduler running.</span></span> <span data-ttu-id="53b2b-154">이 인스턴스가 작업의 복수 인스턴스를 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-154">These could start multiple instances of the task.</span></span>
* <span data-ttu-id="53b2b-155">작업이 스케줄러 이벤트 간의 기간보다 더 오래 실행되는 경우, 스케줄러는 이전 인스턴스가 여전히 실행하는 동안 작업의 다른 인스턴스를 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-155">If tasks run for longer than the period between scheduler events, the scheduler may start another instance of the task while the previous one is still running.</span></span>

## <a name="returning-results"></a><span data-ttu-id="53b2b-156">결과 반환</span><span class="sxs-lookup"><span data-stu-id="53b2b-156">Returning results</span></span>
<span data-ttu-id="53b2b-157">백그라운드 작업이 별도 프로세스 또는 심지어 별도 위치에서, UI 또는 백그라운드 작업을 호출한 프로세스에서 비동기 방식으로 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-157">Background jobs execute asynchronously in a separate process, or even in a separate location, from the UI or the process that invoked the background task.</span></span> <span data-ttu-id="53b2b-158">백그라운드 작업은 "시작 후 잊어 버리는" 작업이 가장 좋으며, 해당 작업의 실행 진행률이 UI 또는 호출 프로세스에 영향을 미치지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-158">Ideally, background tasks are “fire and forget” operations, and their execution progress has no impact on the UI or the calling process.</span></span> <span data-ttu-id="53b2b-159">즉, 호출 프로세스는 작업이 완료될 때까지 기다리지 않으므로</span><span class="sxs-lookup"><span data-stu-id="53b2b-159">This means that the calling process does not wait for completion of the tasks.</span></span> <span data-ttu-id="53b2b-160">작업이 종료되는 시기를 자동으로 감지할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-160">Therefore, it cannot automatically detect when the task ends.</span></span>

<span data-ttu-id="53b2b-161">백그라운드 작업이 진행률 또는 완료를 나타내기 위해 호출 작업과 통신해야 하는 경우에는 이에 대한 메커니즘을 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-161">If you require a background task to communicate with the calling task to indicate progress or completion, you must implement a mechanism for this.</span></span> <span data-ttu-id="53b2b-162">일부 사례:</span><span class="sxs-lookup"><span data-stu-id="53b2b-162">Some examples are:</span></span>

* <span data-ttu-id="53b2b-163">상태 표시기 값을 필요한 경우 해당 값을 모니터링하거나 검사할 수 있는 UI 또는 호출 작업이 액세스할 수 있는 저장소에 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-163">Write a status indicator value to storage that is accessible to the UI or caller task, which can monitor or check this value when required.</span></span> <span data-ttu-id="53b2b-164">백그라운드 작업이 호출자에게 반환해야 하는 다른 데이터는 동일한 저장소에 배치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-164">Other data that the background task must return to the caller can be placed into the same storage.</span></span>
* <span data-ttu-id="53b2b-165">UI 또는 호출자가 수신 대기할 수 있는 회신 큐를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-165">Establish a reply queue that the UI or caller listens on.</span></span> <span data-ttu-id="53b2b-166">백그라운드 작업은 메시지를 큐에 보내서 상태 및 완료를 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-166">The background task can send messages to the queue that indicate status and completion.</span></span> <span data-ttu-id="53b2b-167">백그라운드 작업이 호출자에게 반환해야 하는 데이터는 동일한 메시지에 배치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-167">Data that the background task must return to the caller can be placed into the messages.</span></span> <span data-ttu-id="53b2b-168">Azure Service Bus를 사용하는 경우, **ReplyTo** 및 **CorrelationId** 속성을 사용하여 이 기능을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-168">If you are using Azure Service Bus, you can use the **ReplyTo** and **CorrelationId** properties to implement this capability.</span></span>
* <span data-ttu-id="53b2b-169">UI 또는 호출자가 상태 정보를 가져오기 위해 액세스할 수 있는 백그라운드 작업에서 API 또는 엔드포인트를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-169">Expose an API or endpoint from the background task that the UI or caller can access to obtain status information.</span></span> <span data-ttu-id="53b2b-170">백그라운드 작업이 호출자에게 반환해야 하는 데이터를 응답에 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-170">Data that the background task must return to the caller can be included in the response.</span></span>
* <span data-ttu-id="53b2b-171">백그라운드 작업이 API를 통해 UI 또는 호출자를 콜백하여 미리 정의된 지점 또는 완료 시의 상태를 나타내게 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-171">Have the background task call back to the UI or caller through an API to indicate status at predefined points or on completion.</span></span> <span data-ttu-id="53b2b-172">로컬로 발생한 이벤트 또는 게시 및 구독 메커니즘을 통해 이렇게 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-172">This might be through events raised locally or through a publish-and-subscribe mechanism.</span></span> <span data-ttu-id="53b2b-173">백그라운드 작업이 호출자에게 반환해야 하는 데이터를 요청 또는 이벤트 페이로드에 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-173">Data that the background task must return to the caller can be included in the request or event payload.</span></span>

## <a name="hosting-environment"></a><span data-ttu-id="53b2b-174">호스팅 환경</span><span class="sxs-lookup"><span data-stu-id="53b2b-174">Hosting environment</span></span>
<span data-ttu-id="53b2b-175">다른 Azure 플랫폼 서비스의 범위를 사용하여 백그라운드 작업을 호스트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-175">You can host background tasks by using a range of different Azure platform services:</span></span>

* <span data-ttu-id="53b2b-176">[**Azure Web Apps 및 WebJobs**](#azure-web-apps-and-webjobs).</span><span class="sxs-lookup"><span data-stu-id="53b2b-176">[**Azure Web Apps and WebJobs**](#azure-web-apps-and-webjobs).</span></span> <span data-ttu-id="53b2b-177">WebJobs를 사용하여 웹앱의 컨텍스트 내에서 서로 다른 형식의 스크립트 또는 실행 프로그램의 범위를 기반으로 사용자 지정 작업을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-177">You can use WebJobs to execute custom jobs based on a range of different types of scripts or executable programs within the context of a web app.</span></span>
* <span data-ttu-id="53b2b-178">[**Azure Virtual Machines**](#azure-virtual-machines).</span><span class="sxs-lookup"><span data-stu-id="53b2b-178">[**Azure Virtual Machines**](#azure-virtual-machines).</span></span> <span data-ttu-id="53b2b-179">Windows 서비스를 가지고 있거나 Windows 작업 Scheduler를 사용하려는 경우, 전용 가상 머신 내에서 백그라운드 작업을 호스트하는 것이 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-179">If you have a Windows service or want to use the Windows Task Scheduler, it is common to host your background tasks within a dedicated virtual machine.</span></span>
* <span data-ttu-id="53b2b-180">[**Azure Batch**](#azure-batch).</span><span class="sxs-lookup"><span data-stu-id="53b2b-180">[**Azure Batch**](#azure-batch).</span></span> <span data-ttu-id="53b2b-181">Batch는 계산 집약적 작업이 관리되는 가상 머신 컬렉션에서 실행되도록 예약하는 플랫폼 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-181">Batch is a platform service that schedules compute-intensive work to run on a managed collection of virtual machines.</span></span> <span data-ttu-id="53b2b-182">이 기능은 계산 리소스 크기를 자동으로 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-182">It can automatically scale compute resources.</span></span>
* <span data-ttu-id="53b2b-183">[**Azure Container Service**](#azure-container-service).</span><span class="sxs-lookup"><span data-stu-id="53b2b-183">[**Azure Container Service**](#azure-container-service).</span></span> <span data-ttu-id="53b2b-184">Azure Container Service는 Azure에서 컨테이너 호스팅 환경을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-184">Azure Container Service provides a container hosting environment on Azure.</span></span> 
* <span data-ttu-id="53b2b-185">[**Azure Cloud Services**](#azure-cloud-services).</span><span class="sxs-lookup"><span data-stu-id="53b2b-185">[**Azure Cloud Services**](#azure-cloud-services).</span></span> <span data-ttu-id="53b2b-186">백그라운드 작업으로 실행하는 역할 내에서 코드를 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-186">You can write code within a role that executes as a background task.</span></span>

<span data-ttu-id="53b2b-187">다음 섹션에서는 이러한 각 옵션을 더 자세히 설명하며, 적절한 옵션을 선택하는 데 도움이 되는 고려 사항을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-187">The following sections describe each of these options in more detail, and include considerations to help you choose the appropriate option.</span></span>

### <a name="azure-web-apps-and-webjobs"></a><span data-ttu-id="53b2b-188">Azure Web Apps 및 WebJobs</span><span class="sxs-lookup"><span data-stu-id="53b2b-188">Azure Web Apps and WebJobs</span></span>

<span data-ttu-id="53b2b-189">Azure WebJobs를 사용하여 Azure 웹앱 내에서 사용자 지정 작업을 백그라운드 작업으로 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-189">You can use Azure WebJobs to execute custom jobs as background tasks within an Azure Web App.</span></span> <span data-ttu-id="53b2b-190">WebJobs는 웹앱의 컨텍스트 내에서 연속 프로세스로 실행되거나</span><span class="sxs-lookup"><span data-stu-id="53b2b-190">WebJobs run within the context of your web app as a continuous process.</span></span> <span data-ttu-id="53b2b-191">저장소 Blob 및 메시지 큐의 변경 같은 외부 요소 또는 Azure Scheduler에서 오는 트리거 이벤트에 응답하여 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-191">WebJobs also run in response to a trigger event from Azure Scheduler or external factors, such as changes to storage blobs and message queues.</span></span> <span data-ttu-id="53b2b-192">작업을 요청 시 시작 및 중지하고 정상적으로 종료할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-192">Jobs can be started and stopped on demand, and shut down gracefully.</span></span> <span data-ttu-id="53b2b-193">지속적으로 실행되는 WebJob이 실패하면 자동으로 다시 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-193">If a continuously running WebJob fails, it is automatically restarted.</span></span> <span data-ttu-id="53b2b-194">다시 시도 및 오류 작업을 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-194">Retry and error actions are configurable.</span></span>

<span data-ttu-id="53b2b-195">WebJob을 구성하는 경우</span><span class="sxs-lookup"><span data-stu-id="53b2b-195">When you configure a WebJob:</span></span>

* <span data-ttu-id="53b2b-196">작업이 이벤트 기반 트리거에 응답하게 하려면 해당 작업을 **계속 실행**으로 구성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-196">If you want the job to respond to an event-driven trigger, you should configure it as **Run continuously**.</span></span> <span data-ttu-id="53b2b-197">스크립트 또는 프로그램은 site/wwwroot/app_data/jobs/continuous라는 폴더에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-197">The script or program is stored in the folder named site/wwwroot/app_data/jobs/continuous.</span></span>
* <span data-ttu-id="53b2b-198">작업이 일정 기반 트리거에 응답하게 하려면 해당 작업을 **일정에 따라 실행**으로 구성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-198">If you want the job to respond to a schedule-driven trigger, you should configure it as **Run on a schedule**.</span></span> <span data-ttu-id="53b2b-199">스크립트 또는 프로그램은 site/wwwroot/app_data/jobs/triggered라는 폴더에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-199">The script or program is stored in the folder named site/wwwroot/app_data/jobs/triggered.</span></span>
* <span data-ttu-id="53b2b-200">작업을 구성할 때 **요청 시 실행** 옵션을 선택하면 작업을 시작할 때 **일정에 따라 실행** 옵션과 같은 코드를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-200">If you choose the **Run on demand** option when you configure a job, it will execute the same code as the **Run on a schedule** option when you start it.</span></span>

<span data-ttu-id="53b2b-201">Azure WebJobs는 웹앱의 샌드박스 내에서 실행되며,</span><span class="sxs-lookup"><span data-stu-id="53b2b-201">Azure WebJobs run within the sandbox of the web app.</span></span> <span data-ttu-id="53b2b-202">이는 환경 변수를 액세스하고 연결 문자열 같은 정보를 웹앱과 공유할 수 있음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-202">This means that they can access environment variables and share information, such as connection strings, with the web app.</span></span> <span data-ttu-id="53b2b-203">작업은 작업을 실행하는 컴퓨터의 고유 식별자에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-203">The job has access to the unique identifier of the machine that is running the job.</span></span> <span data-ttu-id="53b2b-204">**AzureWebJobsStorage**라는 연결 문자열은 Azure Storage 큐, Blob 및 응용 프로그램 데이터에 대한 테이블, 그리고 메시징 및 통신을 위한 Service Bus 액세스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-204">The connection string named **AzureWebJobsStorage** provides access to Azure storage queues, blobs, and tables for application data, and access to Service Bus for messaging and communication.</span></span> <span data-ttu-id="53b2b-205">**AzureWebJobsDashboard**라는 연결 문자열은 작업 동작 로그 파일에 대한 액세스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-205">The connection string named **AzureWebJobsDashboard** provides access to the job action log files.</span></span>

<span data-ttu-id="53b2b-206">Azure WebJob은 다음과 같은 특성을 가지고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-206">Azure WebJobs have the following characteristics:</span></span>

* <span data-ttu-id="53b2b-207">**보안**: WebJobs는 웹앱의 배포 자격 증명에 의해 보호됩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-207">**Security**: WebJobs are protected by the deployment credentials of the web app.</span></span>
* <span data-ttu-id="53b2b-208">**지원되는 파일 형식**: 명령 스크립트(.cmd), 배치 파일(.bat), PowerShell 스크립트(.ps1), Bash 셸 스크립트(.sh), PHP 스크립트(.php), Python 스크립트(.py), JavaScript 코드(.js) 및 실행 프로그램(.exe,.jar 등)을 사용하여 WebJobs를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-208">**Supported file types**: You can define WebJobs by using command scripts (.cmd), batch files (.bat), PowerShell scripts (.ps1), bash shell scripts (.sh), PHP scripts (.php), Python scripts (.py), JavaScript code (.js), and executable programs (.exe, .jar, and more).</span></span>
* <span data-ttu-id="53b2b-209">**배포**: [Azure Portal](/azure/app-service-web/web-sites-create-web-jobs)을 사용하거나, [Visual Studio](/azure/app-service-web/websites-dotnet-deploy-webjobs)를 사용하거나, [Azure WebJobs SDK](/azure/app-service/webjobs-sdk-get-started)를 사용하거나, 이들을 다음 위치에 직접 복사하여 스크립트 및 실행 파일을 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-209">**Deployment**: You can deploy scripts and executables by using the [Azure portal](/azure/app-service-web/web-sites-create-web-jobs), by using [Visual Studio](/azure/app-service-web/websites-dotnet-deploy-webjobs), by using the [Azure WebJobs SDK](/azure/app-service/webjobs-sdk-get-started), or by copying them directly to the following locations:</span></span>
  * <span data-ttu-id="53b2b-210">트리거된 실행의 경우: site/wwwroot/app_data/jobs/triggered/{job name}</span><span class="sxs-lookup"><span data-stu-id="53b2b-210">For triggered execution: site/wwwroot/app_data/jobs/triggered/{job name}</span></span>
  * <span data-ttu-id="53b2b-211">연속 실행의 경우: site/wwwroot/app_data/jobs/continuous/{job name}</span><span class="sxs-lookup"><span data-stu-id="53b2b-211">For continuous execution: site/wwwroot/app_data/jobs/continuous/{job name}</span></span>
* <span data-ttu-id="53b2b-212">**로깅**: Console.Out은 INFO로 처리(표시)되며</span><span class="sxs-lookup"><span data-stu-id="53b2b-212">**Logging**: Console.Out is treated (marked) as INFO.</span></span> <span data-ttu-id="53b2b-213">Console.Error는 ERROR로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-213">Console.Error is treated as ERROR.</span></span> <span data-ttu-id="53b2b-214">모니터링 및 진단 정보는 Azure 포털을 사용하여 액세스할 수 있으며</span><span class="sxs-lookup"><span data-stu-id="53b2b-214">You can access monitoring and diagnostics information by using the Azure portal.</span></span> <span data-ttu-id="53b2b-215">로그 파일은 사이트에서 직접 다운로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-215">You can download log files directly from the site.</span></span> <span data-ttu-id="53b2b-216">이들은 다음 위치에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-216">They are saved in the following locations:</span></span>
  * <span data-ttu-id="53b2b-217">트리거된 실행의 경우: Vfs/data/jobs/triggered/jobName</span><span class="sxs-lookup"><span data-stu-id="53b2b-217">For triggered execution: Vfs/data/jobs/triggered/jobName</span></span>
  * <span data-ttu-id="53b2b-218">연속 실행의 경우: Vfs/data/jobs/continuous/jobName</span><span class="sxs-lookup"><span data-stu-id="53b2b-218">For continuous execution: Vfs/data/jobs/continuous/jobName</span></span>
* <span data-ttu-id="53b2b-219">**구성**: 포털, REST API 및 PowerShell을 사용하여 WebJobs를 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-219">**Configuration**: You can configure WebJobs by using the portal, the REST API, and PowerShell.</span></span> <span data-ttu-id="53b2b-220">루트 디렉터리의 settings.job이라는 구성 파일을 작업 스크립트로 사용하여 작업에 대한 구성 정보를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-220">You can use a configuration file named settings.job in the same root directory as the job script to provide configuration information for a job.</span></span> <span data-ttu-id="53b2b-221">예: </span><span class="sxs-lookup"><span data-stu-id="53b2b-221">For example:</span></span>
  * <span data-ttu-id="53b2b-222">{ "stopping_wait_time": 60 }</span><span class="sxs-lookup"><span data-stu-id="53b2b-222">{ "stopping_wait_time": 60 }</span></span>
  * <span data-ttu-id="53b2b-223">{ "is_singleton": true }</span><span class="sxs-lookup"><span data-stu-id="53b2b-223">{ "is_singleton": true }</span></span>

#### <a name="considerations"></a><span data-ttu-id="53b2b-224">고려 사항</span><span class="sxs-lookup"><span data-stu-id="53b2b-224">Considerations</span></span>

* <span data-ttu-id="53b2b-225">기본적으로 WebJobs 웹앱을 통해 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-225">By default, WebJobs scale with the web app.</span></span> <span data-ttu-id="53b2b-226">그러나 **is_singleton** 구성 속성을 **true**로 설정하여 작업을 단일 인스턴스에서 실행되도록 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-226">However, you can configure jobs to run on single instance by setting the **is_singleton** configuration property to **true**.</span></span> <span data-ttu-id="53b2b-227">단일 인스턴스 WebJobs는 확장을 원하지 않거나 인덱싱 다시 수행, 데이터 분석 및 유사한 작업 등 동시에 복수 인스턴스의 실행을 원하지 않는 작업에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-227">Single instance WebJobs are useful for tasks that you do not want to scale or run as simultaneous multiple instances, such as reindexing, data analysis, and similar tasks.</span></span>
* <span data-ttu-id="53b2b-228">작업이 웹앱의 성능에 미치는 영향을 최소화하려면 장기 실행 또는 리소스를 많이 사용할 수 있는 WebJobs를 호스트하기 위해 새 App Service 계획에 빈 Azure Web Apps 인스턴스를 만드는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-228">To minimize the impact of jobs on the performance of the web app, consider creating an empty Azure Web App instance in a new App Service plan to host WebJobs that may be long running or resource intensive.</span></span>

### <a name="more-information"></a><span data-ttu-id="53b2b-229">자세한 정보</span><span class="sxs-lookup"><span data-stu-id="53b2b-229">More information</span></span>
* <span data-ttu-id="53b2b-230">[Azure WebJobs 권장 리소스](/azure/app-service-web/websites-webjobs-resources)는 WebJobs에 유용한 많은 리소스, 다운로드 및 샘플을 나열합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-230">[Azure WebJobs recommended resources](/azure/app-service-web/websites-webjobs-resources) lists the many useful resources, downloads, and samples for WebJobs.</span></span>

### <a name="azure-virtual-machines"></a><span data-ttu-id="53b2b-231">Azure Virtual Machines</span><span class="sxs-lookup"><span data-stu-id="53b2b-231">Azure Virtual Machines</span></span>
<span data-ttu-id="53b2b-232">백그라운드 작업은 Azure Web Apps 또는 Cloud Services에 배포되지 않도록 하는 방법으로 구현할 수 있습니다. 이러한 옵션은 불편할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-232">Background tasks might be implemented in a way that prevents them from being deployed to Azure Web Apps or Cloud Services, or these options might not be convenient.</span></span> <span data-ttu-id="53b2b-233">일반적인 예로 Windows 서비스, 타사 유틸리티 및 실행 프로그램이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-233">Typical examples are Windows services, and third-party utilities and executable programs.</span></span> <span data-ttu-id="53b2b-234">또한 응용 프로그램을 호스트하는 것과 다른 실행 환경을 위해 작성된 프로그램도 이러한 예에 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-234">Another example might be programs written for an execution environment that is different than that hosting the application.</span></span> <span data-ttu-id="53b2b-235">예를 들어, Windows 또는 .NET 응용 프로그램에서 실행하려는 Unix 또는 Linux 프로그램이 그러한 프로그램입니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-235">For example, it might be a Unix or Linux program that you want to execute from a Windows or .NET application.</span></span> <span data-ttu-id="53b2b-236">Azure 가상 머신을 위한 다양한 운영 체제 중에서 선택하고 사용자 서비스 또는 실행 파일을 해당 가상 머신에서 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-236">You can choose from a range of operating systems for an Azure virtual machine, and run your service or executable on that virtual machine.</span></span>

<span data-ttu-id="53b2b-237">Virtual Machines를 사용할 때 선택하는 방법은 [Azure App Services, Cloud Services 및 Virtual Machines 비교](/azure/app-service-web/choose-web-site-cloud-service-vm/)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="53b2b-237">To help you choose when to use Virtual Machines, see [Azure App Services, Cloud Services and Virtual Machines comparison](/azure/app-service-web/choose-web-site-cloud-service-vm/).</span></span> <span data-ttu-id="53b2b-238">[Virtual Machines를 위한 옵션에 대한 자세한 내용은 Azure의 Windows 가상 머신 크기](/azure/virtual-machines/windows/sizes)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="53b2b-238">For information about the options for Virtual Machines, see [Sizes for Windows virtual machines in Azure](/azure/virtual-machines/windows/sizes).</span></span> <span data-ttu-id="53b2b-239">Virtual Machines에 사용할 수 있는 운영 체제 및 미리 작성된 이미지에 대한 자세한 내용은 [Azure Virtual Machines Marketplace](https://azure.microsoft.com/gallery/virtual-machines/)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="53b2b-239">For more information about the operating systems and prebuilt images that are available for Virtual Machines, see [Azure Virtual Machines Marketplace](https://azure.microsoft.com/gallery/virtual-machines/).</span></span>

<span data-ttu-id="53b2b-240">별도 가상 머신에서 백그라운드 작업을 시작하려는 경우 다양한 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-240">To initiate the background task in a separate virtual machine, you have a range of options:</span></span>

* <span data-ttu-id="53b2b-241">작업이 표시하는 엔드포인트로 요청을 보내 사용자 응용 프로그램에서 요청 시 작업을 직접 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-241">You can execute the task on demand directly from your application by sending a request to an endpoint that the task exposes.</span></span> <span data-ttu-id="53b2b-242">이렇게 하면 작업에 필요한 모든 데이터가 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-242">This passes in any data that the task requires.</span></span> <span data-ttu-id="53b2b-243">이 엔드포인트에서 작업을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-243">This endpoint invokes the task.</span></span>
* <span data-ttu-id="53b2b-244">스케줄러 또는 선택한 운영 체제에서 사용할 수 있는 타이머를 사용하여 작업을 일정에 따라 실행하도록 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-244">You can configure the task to run on a schedule by using a scheduler or timer that is available in your chosen operating system.</span></span> <span data-ttu-id="53b2b-245">예를 들어 Windows에서는 Windows 작업 Scheduler를 사용하여 스크립트 및 작업을 실행하거나,</span><span class="sxs-lookup"><span data-stu-id="53b2b-245">For example, on Windows you can use Windows Task Scheduler to execute scripts and tasks.</span></span> <span data-ttu-id="53b2b-246">가상 머신에 SQL Server를 설치한 경우 SQL Server 에이전트를 사용하여 스크립트 및 작업을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-246">Or, if you have SQL Server installed on the virtual machine, you can use the SQL Server Agent to execute scripts and tasks.</span></span>
* <span data-ttu-id="53b2b-247">Azure Scheduler를 사용하여 작업이 수신 대기하는 큐에 메시지를 추가하거나 요청을 작업이 표시하는 API에 보내서 작업을 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-247">You can use Azure Scheduler to initiate the task by adding a message to a queue that the task listens on, or by sending a request to an API that the task exposes.</span></span>

<span data-ttu-id="53b2b-248">백그라운드 작업을 시작할 수 있는 방법은 이전 섹션 [트리거](#triggers)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="53b2b-248">See the earlier section [Triggers](#triggers) for more information about how you can initiate background tasks.</span></span>  

#### <a name="considerations"></a><span data-ttu-id="53b2b-249">고려 사항</span><span class="sxs-lookup"><span data-stu-id="53b2b-249">Considerations</span></span>
<span data-ttu-id="53b2b-250">Azure 가상 머신에서 백그라운드 작업을 배포할지 여부를 결정할 때 다음 사항을 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="53b2b-250">Consider the following points when you are deciding whether to deploy background tasks in an Azure virtual machine:</span></span>

* <span data-ttu-id="53b2b-251">별도 Azure 가상 머신에서 백그라운드 작업을 호스트하면 유연성을 제공하며 시작, 실행, 예약 및 리소스 할당을 정확하게 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-251">Hosting background tasks in a separate Azure virtual machine provides flexibility and allows precise control over initiation, execution, scheduling, and resource allocation.</span></span> <span data-ttu-id="53b2b-252">그러나 단지 백그라운드 작업을 실행하기 위해 가상 머신을 배포해야 한다면 런타임 비용이 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-252">However, it will increase runtime cost if a virtual machine must be deployed just to run background tasks.</span></span>
* <span data-ttu-id="53b2b-253">Azure Portal에서 작업을 모니터링하는 기능은 없고 실패한 작업을 자동으로 다시 시작하는 기능도 없지만, [Azure Resource Manager Cmdlet](https://msdn.microsoft.com/library/mt125356.aspx)을 사용하여 가상 머신의 기본 상태를 모니터링하고 이를 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-253">There is no facility to monitor the tasks in the Azure portal and no automated restart capability for failed tasks--although you can monitor the basic status of the virtual machine and manage it by using the  [Azure Resource Manager Cmdlets](https://msdn.microsoft.com/library/mt125356.aspx).</span></span> <span data-ttu-id="53b2b-254">그러나 계산 노드의 프로세스 및 스레드를 제어하는 기능은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-254">However, there are no facilities to control processes and threads in compute nodes.</span></span> <span data-ttu-id="53b2b-255">일반적으로 가상 컴퓨터를 사용하려면 작업의 구현 및 가상 컴퓨터의 운영 체제에서 데이터를 수집하는 메커니즘을 구현하기 위해 추가적인 노력이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-255">Typically, using a virtual machine will require additional effort to implement a mechanism that collects data from instrumentation in the task, and from the operating system in the virtual machine.</span></span> <span data-ttu-id="53b2b-256">적절할 수 있는 한 가지 해결책은 [System Center Management Pack for Azure](https://www.microsoft.com/download/details.aspx?id=50013)를 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-256">One solution that might be appropriate is to use the [System Center Management Pack for Azure](https://www.microsoft.com/download/details.aspx?id=50013).</span></span>
* <span data-ttu-id="53b2b-257">HTTP 엔드포인트를 통해 표시되는 모니터링 프로브를 만드는 것을 고려할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-257">You might consider creating monitoring probes that are exposed through HTTP endpoints.</span></span> <span data-ttu-id="53b2b-258">이 프로브에 대한 코드는 상태 확인, 작업 정보 및 통계 수집 또는 오류 정보 정렬 및 관리 응용 프로그램에 해당 정보 반환을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-258">The code for these probes could perform health checks, collect operational information and statistics--or collate error information and return it to a management application.</span></span> <span data-ttu-id="53b2b-259">자세한 내용은 [상태 엔드포인트 모니터링 패턴](../patterns/health-endpoint-monitoring.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="53b2b-259">For more information, see [Health Endpoint Monitoring Pattern](../patterns/health-endpoint-monitoring.md).</span></span>

#### <a name="more-information"></a><span data-ttu-id="53b2b-260">자세한 정보</span><span class="sxs-lookup"><span data-stu-id="53b2b-260">More information</span></span>
* <span data-ttu-id="53b2b-261">[Virtual Machines](https://azure.microsoft.com/services/virtual-machines/)</span><span class="sxs-lookup"><span data-stu-id="53b2b-261">[Virtual Machines](https://azure.microsoft.com/services/virtual-machines/) on Azure</span></span>
* [<span data-ttu-id="53b2b-262">Azure Virtual Machines FAQ</span><span class="sxs-lookup"><span data-stu-id="53b2b-262">Azure Virtual Machines FAQ</span></span>](/azure/virtual-machines/virtual-machines-linux-classic-faq?toc=%2fazure%2fvirtual-machines%2flinux%2fclassic%2ftoc.json)

### <a name="azure-batch"></a><span data-ttu-id="53b2b-263">Azure Batch</span><span class="sxs-lookup"><span data-stu-id="53b2b-263">Azure Batch</span></span> 

<span data-ttu-id="53b2b-264">수십, 수백 또는 수천 개의 VM에서 대규모 병렬 HPC(고성능 컴퓨팅) 작업을 실행해야 하는 경우에는 [Azure Batch](/azure/batch/)를 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="53b2b-264">Consider [Azure Batch](/azure/batch/) if you need to run large, parallel high-performance computing (HPC) workloads across tens, hundreds, or thousands of VMs.</span></span>  

<span data-ttu-id="53b2b-265">Batch 서비스는 VM을 프로비전하고, VM에 작업을 할당하고, 작업을 실행하고, 진행 상황을 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-265">The Batch service provisions the VMs, assign tasks to the VMs, runs the tasks, and monitors the progress.</span></span> <span data-ttu-id="53b2b-266">Batch는 워크로드에 따라 VM을 자동으로 스케일 아웃할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-266">Batch can automatically scale out the VMs in response to the workload.</span></span> <span data-ttu-id="53b2b-267">Batch는 또한 작업 일정 예약을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-267">Batch also provides job scheduling.</span></span> <span data-ttu-id="53b2b-268">Azure Batch는 Linux 및 Windows VM을 둘 다 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-268">Azure Batch supports both Linux and Windows VMs.</span></span>

#### <a name="considerations"></a><span data-ttu-id="53b2b-269">고려 사항</span><span class="sxs-lookup"><span data-stu-id="53b2b-269">Considerations</span></span> 

<span data-ttu-id="53b2b-270">Batch는 본질적인 병렬 워크로드에 잘 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-270">Batch works well with intrinsically parallel workloads.</span></span> <span data-ttu-id="53b2b-271">또한 마지막에 감소 단계를 사용해서 병렬 계산을 수행하거나, 노드 간에 메시지 전달이 필요한 병렬 작업을 위해 [MPI(메시지 전달 인터페이스) 응용 프로그램](/azure/batch/batch-mpi)을 실행할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-271">It can also perform parallel calculations with a reduce step at the end, or run [Message Passing Interface (MPI) applications](/azure/batch/batch-mpi) for parallel tasks that require message passing between nodes.</span></span> 

<span data-ttu-id="53b2b-272">Azure Batch 작업은 노드(VM) 풀에서 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-272">An Azure Batch job runs on a pool of nodes (VMs).</span></span> <span data-ttu-id="53b2b-273">한 가지 방법은 필요할 때만 풀을 할당한 후 작업이 완료되면 삭제하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-273">One approach is to allocate a pool only when needed and then delete it after the job completes.</span></span> <span data-ttu-id="53b2b-274">이렇게 하면 노드가 유휴 상태가 되지 않으므로 활용률은 최대화되지만 작업은 노드가 할당될 때까지 대기해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-274">This maximizes utilization, because nodes are not idle, but the job must wait for nodes to be allocated.</span></span> <span data-ttu-id="53b2b-275">또는 미리 풀을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-275">Alternatively, you can create a pool ahead of time.</span></span> <span data-ttu-id="53b2b-276">이 방법은 작업 시작에 소요되는 시간을 최소화하지만, 결과적으로 노드가 유휴 상태가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-276">That approach minimizes the time that it takes for a job to start, but can result in having nodes that sit idle.</span></span> <span data-ttu-id="53b2b-277">자세한 내용은 [풀 및 계산 노드 수명](/azure/batch/batch-api-basics#pool-and-compute-node-lifetime)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="53b2b-277">For more information, see [Pool and compute node lifetime](/azure/batch/batch-api-basics#pool-and-compute-node-lifetime).</span></span>

#### <a name="more-information"></a><span data-ttu-id="53b2b-278">자세한 정보</span><span class="sxs-lookup"><span data-stu-id="53b2b-278">More information</span></span> 

* [<span data-ttu-id="53b2b-279">Batch를 사용하여 본질적인 병렬 워크로드 실행</span><span class="sxs-lookup"><span data-stu-id="53b2b-279">Run intrinsically parallel workloads with Batch</span></span>](/azure/batch/batch-technical-overview) 
* [<span data-ttu-id="53b2b-280">Batch를 사용하여 대규모 병렬 계산 솔루션 개발</span><span class="sxs-lookup"><span data-stu-id="53b2b-280">Develop large-scale parallel compute solutions with Batch</span></span>](/azure/batch/batch-api-basics) 
* [<span data-ttu-id="53b2b-281">대규모 컴퓨팅 워크로드를 위한 Batch 및 HPC 솔루션</span><span class="sxs-lookup"><span data-stu-id="53b2b-281">Batch and HPC solutions for large-scale computing workloads</span></span>](/azure/batch/batch-hpc-solutions)

### <a name="azure-container-service"></a><span data-ttu-id="53b2b-282">Azure Container Service</span><span class="sxs-lookup"><span data-stu-id="53b2b-282">Azure Container Service</span></span> 

<span data-ttu-id="53b2b-283">Azure Container Service를 사용하여 컨테이너화된 응용 프로그램을 실행하도록 VM 클러스터를 구성하고 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-283">Azure Container Service lets you configure and manage a cluster of VMs in Azure to run containerized applications.</span></span> <span data-ttu-id="53b2b-284">이 서비스는 오케스트레이션을 위해 Docker Swarm, DC/OS 또는 Kubernetes 옵션을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-284">It provides a choice of Docker Swarm, DC/OS, or Kubernetes for orchestration.</span></span> 

<span data-ttu-id="53b2b-285">컨테이너는 백그라운드 작업을 실행하는 데 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-285">Containers can be useful for running background jobs.</span></span> <span data-ttu-id="53b2b-286">몇 가지 이점은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-286">Some of the benefits include:</span></span> 

- <span data-ttu-id="53b2b-287">컨테이너는 고밀도 호스팅을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-287">Containers support high-density hosting.</span></span> <span data-ttu-id="53b2b-288">각 VM에 여러 컨테이너를 배치하면서, 백그라운드 작업을 하나의 컨테이너에 격리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-288">You can isolate a background task in a container, while placing multiple containers in each VM.</span></span>
- <span data-ttu-id="53b2b-289">컨테이너 오케스트레이터는 내부 부하 분산을 처리하고, 내부 네트워크 및 기타 구성 작업을 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-289">The container orchestrator handles internal load balancing, configuring the internal network, and other configuration tasks.</span></span>
- <span data-ttu-id="53b2b-290">컨테이너는 필요에 따라 시작 및 중지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-290">Containers can be started and stopped as needed.</span></span> 
- <span data-ttu-id="53b2b-291">Azure Container Registry를 사용하여 Azure 경계 내에서 컨테이너를 등록할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-291">Azure Container Registry allows you to register your containers inside Azure boundaries.</span></span> <span data-ttu-id="53b2b-292">이를 통해 보안, 개인 정보 보호 및 근접성 이점을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-292">This comes with security, privacy, and proximity benefits.</span></span> 

#### <a name="considerations"></a><span data-ttu-id="53b2b-293">고려 사항</span><span class="sxs-lookup"><span data-stu-id="53b2b-293">Considerations</span></span>

- <span data-ttu-id="53b2b-294">컨테이너 오케스트레이터를 사용하는 방법을 이해해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-294">Requires an understanding of how to use a container orchestrator.</span></span> <span data-ttu-id="53b2b-295">DevOps 팀의 기술에 따라, 문제가 될 수도 있고 그렇지 않을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-295">Depending on the skillset of your DevOps team, this may or may not be an issue.</span></span>  
- <span data-ttu-id="53b2b-296">컨테이너 서비스는 IaaS 환경에서 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-296">Container Service runs in an IaaS environment.</span></span> <span data-ttu-id="53b2b-297">전용 VNet 내에 VM 클러스터를 프로비전합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-297">It provisions a cluster of VMs inside a dedicated VNet.</span></span> 

#### <a name="more-information"></a><span data-ttu-id="53b2b-298">자세한 정보</span><span class="sxs-lookup"><span data-stu-id="53b2b-298">More information</span></span> 

* [<span data-ttu-id="53b2b-299">Azure Container Service를 사용한 Docker 컨테이너 호스팅 소개</span><span class="sxs-lookup"><span data-stu-id="53b2b-299">Introduction to Docker container hosting solutions with Azure Container Service</span></span>](/azure/container-service/container-service-intro) 
* [<span data-ttu-id="53b2b-300">개인 Docker 컨테이너 레지스트리 소개</span><span class="sxs-lookup"><span data-stu-id="53b2b-300">Introduction to private Docker container registries</span></span>](/azure/container-registry/container-registry-intro) 

### <a name="azure-cloud-services"></a><span data-ttu-id="53b2b-301">Azure Cloud Services</span><span class="sxs-lookup"><span data-stu-id="53b2b-301">Azure Cloud Services</span></span> 
<span data-ttu-id="53b2b-302">웹 역할 내에서 또는 별도 작업자 역할에서 백그라운드 작업을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-302">You can execute background tasks within a web role or in a separate worker role.</span></span> <span data-ttu-id="53b2b-303">작업자 역할을 사용할지 여부는 확장성과 탄력성, 작업 수명, 릴리스 주기, 보안, 내결함성, 경합, 복잡성 및 논리적 아키텍처를 고려하여 결정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-303">When you are deciding whether to use a worker role, consider scalability and elasticity requirements, task lifetime, release cadence, security, fault tolerance, contention, complexity, and the logical architecture.</span></span> <span data-ttu-id="53b2b-304">자세한 내용은 [Compute 리소스 통합 패턴](../patterns/compute-resource-consolidation.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="53b2b-304">For more information, see [Compute Resource Consolidation Pattern](../patterns/compute-resource-consolidation.md).</span></span>

<span data-ttu-id="53b2b-305">Cloud Services 역할 내에서 백그라운드 작업을 구현하는 여러 가지 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-305">There are several ways to implement background tasks within a Cloud Services role:</span></span>

* <span data-ttu-id="53b2b-306">역할에 **RoleEntryPoint** 클래스의 구현을 만들고 해당 메서드를 사용하여 백그라운드 작업을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-306">Create an implementation of the **RoleEntryPoint** class in the role and use its methods to execute background tasks.</span></span> <span data-ttu-id="53b2b-307">작업은 WaIISHost.exe의 컨텍스트에서 실행되며,</span><span class="sxs-lookup"><span data-stu-id="53b2b-307">The tasks run in the context of WaIISHost.exe.</span></span> <span data-ttu-id="53b2b-308">**CloudConfigurationManager** 클래스의 **GetSetting** 메서드를 사용하여 구성 설정을 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-308">They can use the **GetSetting** method of the **CloudConfigurationManager** class to load configuration settings.</span></span> <span data-ttu-id="53b2b-309">자세한 내용은 [수명 주기](#lifecycle)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="53b2b-309">For more information, see [Lifecycle](#lifecycle).</span></span>
* <span data-ttu-id="53b2b-310">시작 작업을 사용하여 응용 프로그램이 시작될 때 백그라운드 작업을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-310">Use startup tasks to execute background tasks when the application starts.</span></span> <span data-ttu-id="53b2b-311">작업을 백그라운드에서 계속 실행하게 하려면 **taskType** 속성을 **배경**으로 설정합니다. 이렇게 하지 않으면 응용 프로그램 시작 프로세스가 중단되며 작업이 완료되기를 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-311">To force the tasks to continue to run in the background, set the **taskType** property to **background** (if you do not do this, the application startup process will halt and wait for the task to finish).</span></span> <span data-ttu-id="53b2b-312">자세한 내용은 [Azure에서 시작 작업 실행](/azure/cloud-services/cloud-services-startup-tasks)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="53b2b-312">For more information, see [Run startup tasks in Azure](/azure/cloud-services/cloud-services-startup-tasks).</span></span>
* <span data-ttu-id="53b2b-313">WebJobs SDK를 사용하여 백그라운드 작업을 시작 작업으로 시작되는 WebJobs로 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-313">Use the WebJobs SDK to implement background tasks such as WebJobs that are initiated as a startup task.</span></span> <span data-ttu-id="53b2b-314">자세한 내용은 [Azure App Service에서 .NET WebJob 만들기](/azure/app-service-web/websites-dotnet-webjobs-sdk-get-started)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="53b2b-314">For more information, see [Create a .NET WebJob in Azure App Service](/azure/app-service-web/websites-dotnet-webjobs-sdk-get-started).</span></span>
* <span data-ttu-id="53b2b-315">시작 작업을 사용하여 하나 이상의 백그라운드 작업을 실행하는 Windows 서비스를 설치합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-315">Use a startup task to install a Windows service that executes one or more background tasks.</span></span> <span data-ttu-id="53b2b-316">서비스가 백그라운드에서 실행하도록 **taskType** 속성을 **배경**으로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-316">You must set the **taskType** property to **background** so that the service executes in the background.</span></span> <span data-ttu-id="53b2b-317">자세한 내용은 [Azure에서 시작 작업 실행](/azure/cloud-services/cloud-services-startup-tasks)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="53b2b-317">For more information, see [Run startup tasks in Azure](/azure/cloud-services/cloud-services-startup-tasks).</span></span>

<span data-ttu-id="53b2b-318">웹 역할에서 백그라운드 작업을 실행하는 방법의 주된 장점은 추가 역할을 배포하라는 요구 사항이 없기 때문에 호스팅 비용이 절감된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-318">The main advantage of running background tasks in the web role is the saving in hosting costs because there is no requirement to deploy additional roles.</span></span>

<span data-ttu-id="53b2b-319">작업자 역할에서 백그라운드 작업을 실행하는 방법은 여러 가지 장점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-319">Running background tasks in a worker role has several advantages:</span></span>

* <span data-ttu-id="53b2b-320">각 유형의 역할에 대해 별도로 확장을 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-320">It allows you to manage scaling separately for each type of role.</span></span> <span data-ttu-id="53b2b-321">예를 들어 현재 부하를 지원하려면 웹 역할의 더 많은 인스턴스가 필요할 수 있지만, 백그라운드 작업을 실행하는 작업자 역할의 인스턴스는 감소합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-321">For example, you might need more instances of a web role to support the current load, but fewer instances of the worker role that executes background tasks.</span></span> <span data-ttu-id="53b2b-322">UI 역할에서 별도로 백그라운드 작업 계산 인스턴스를 확장하면 허용 가능한 성능을 유지하면서도 호스팅 비용을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-322">By scaling background task compute instances separately from the UI roles, you can reduce hosting costs, while maintaining acceptable performance.</span></span>
* <span data-ttu-id="53b2b-323">즉, 웹 역할에서 백그라운드 작업에 대한 처리 오버헤드가 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-323">It offloads the processing overhead for background tasks from the web role.</span></span> <span data-ttu-id="53b2b-324">UI를 제공하는 웹 역할은 응답성을 유지할 수 있으며, 따라서 지정된 양의 사용자 요청을 지원하는 데 필요한 인스턴스 수가 감소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-324">The web role that provides the UI can remain responsive, and it may mean fewer instances are required to support a given volume of requests from users.</span></span>
* <span data-ttu-id="53b2b-325">중요한 부분의 분리를 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-325">It allows you to implement separation of concerns.</span></span> <span data-ttu-id="53b2b-326">각 역할 유형은 명확하게 정의되고 관련된 작업의 특정 집합을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-326">Each role type can implement a specific set of clearly defined and related tasks.</span></span> <span data-ttu-id="53b2b-327">따라서 각 역할 간에 코드 및 기능의 독립성이 감소하므로 코드를 더 쉽게 디자인 및 유지 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-327">This makes designing and maintaining the code easier because there is less interdependence of code and functionality between each role.</span></span>
* <span data-ttu-id="53b2b-328">중요한 프로세스 및 데이터를 격리하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-328">It can help to isolate sensitive processes and data.</span></span> <span data-ttu-id="53b2b-329">예를 들어 UI를 구현하는 웹 역할은 작업자 역할에서 관리 및 제어하는 데이터에 액세스할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-329">For example, web roles that implement the UI do not need to have access to data that is managed and controlled by a worker role.</span></span> <span data-ttu-id="53b2b-330">특히 [게이트키퍼 패턴](../patterns/gatekeeper.md) 같은 패턴을 사용하는 경우 보안 강화에 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-330">This can be useful in strengthening security, especially when you use a pattern such as the [Gatekeeper Pattern](../patterns/gatekeeper.md).</span></span>  

#### <a name="considerations"></a><span data-ttu-id="53b2b-331">고려 사항</span><span class="sxs-lookup"><span data-stu-id="53b2b-331">Considerations</span></span>
<span data-ttu-id="53b2b-332">Cloud Services 웹 및 작업자 역할을 허용하는 경우 백그라운드 작업을 배포할 방법 및 위치를 선택할 때 다음 사항을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-332">Consider the following points when choosing how and where to deploy background tasks when using Cloud Services web and worker roles:</span></span>

* <span data-ttu-id="53b2b-333">백그라운드 작업을 기존 웹 역할에서 호스트하면 단순히 이 작업에 대한 별도의 작업자 역할을 실행하는 비용을 절감할 수 있지만,</span><span class="sxs-lookup"><span data-stu-id="53b2b-333">Hosting background tasks in an existing web role can save the cost of running a separate worker role just for these tasks.</span></span> <span data-ttu-id="53b2b-334">처리 및 다른 리소스에 대한 경합이 있는 경우 응용 프로그램의 성능과 가용성에 영향을 미칠 가능성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-334">However, it is likely to affect the performance and availability of the application if there is contention for processing and other resources.</span></span> <span data-ttu-id="53b2b-335">별도 작업자 역할을 사용하면 장기 실행 또는 리소스를 많이 사용하는 백그라운드 작업의 영향으로부터 웹 역할이 보호됩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-335">Using a separate worker role protects the web role from the impact of long-running or resource-intensive background tasks.</span></span>
* <span data-ttu-id="53b2b-336">**RoleEntryPoint** 클래스를 사용하여 백그라운드 작업을 호스트하면 이 작업을 쉽게 다른 역할로 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-336">If you host background tasks by using the **RoleEntryPoint** class, you can easily move this to another role.</span></span> <span data-ttu-id="53b2b-337">예를 들어 웹 역할에서 클래스를 만들고 나중에 작업자 역할에서 작업을 실행해야 할 필요가 있는 경우, **RoleEntryPoint** 클래스 구현을 작업자 역할로 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-337">For example, if you create the class in a web role and later decide that you need to run the tasks in a worker role, you can move the **RoleEntryPoint** class implementation into the worker role.</span></span>
* <span data-ttu-id="53b2b-338">시작 작업은 프로그램 또는 스크립트를 실행하도록 디자인됩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-338">Startup tasks are designed to execute a program or a script.</span></span> <span data-ttu-id="53b2b-339">백그라운드 작업을 실행 프로그램으로 배포하는 것은 특히 종속 어셈블리의 배포도 필요한 경우 더 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-339">Deploying a background job as an executable program might be more difficult, especially if it also requires deployment of dependent assemblies.</span></span> <span data-ttu-id="53b2b-340">시작 작업을 사용할 때 백그라운드 작업을 정의하는 스크립트를 배포하고 사용하는 것이 더 쉬울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-340">It might be easier to deploy and use a script to define a background job when you use startup tasks.</span></span>
* <span data-ttu-id="53b2b-341">백그라운드 작업을 실패하게 만드는 예외는 호스트되는 방법에 따라 서로 다른 영향을 미칩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-341">Exceptions that cause a background task to fail have a different impact, depending on the way that they are hosted:</span></span>
  * <span data-ttu-id="53b2b-342">**RoleEntryPoint** 클래스 접근 방식을 사용하는 경우, 실패한 작업은 역할을 다시 시작하게 만들어 작업이 자동으로 다시 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-342">If you use the **RoleEntryPoint** class approach, a failed task will cause the role to restart so that the task automatically restarts.</span></span> <span data-ttu-id="53b2b-343">이 상황은 응용 프로그램의 가용성에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-343">This can affect availability of the application.</span></span> <span data-ttu-id="53b2b-344">이 문제를 방지하려면 **RoleEntryPoint** 클래스 및 모든 백그라운드 작업 내에 강력한 예외 처리를 포함시킵니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-344">To prevent this, ensure that you include robust exception handling within the **RoleEntryPoint** class and all the background tasks.</span></span> <span data-ttu-id="53b2b-345">코드를 사용하여 실패하는 작업을 다시 시작하고(적절한 경우) 사용자 코드 내에서 실패로부터 정상적으로 복구할 수 없는 경우에만 예외를 발생시켜 역할을 다시 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-345">Use code to restart tasks that fail where this is appropriate, and throw the exception to restart the role only if you cannot gracefully recover from the failure within your code.</span></span>
  * <span data-ttu-id="53b2b-346">시작 작업을 사용하면 사용자가 작업 실행 관리 및 실패 여부 검사를 책임져야 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-346">If you use startup tasks, you are responsible for managing the task execution and checking if it fails.</span></span>
* <span data-ttu-id="53b2b-347">시작 작업의 관리 및 모니터링은 **RoleEntryPoint** 클래스 접근 방식을 사용하는 것보다 더 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-347">Managing and monitoring startup tasks is more difficult than using the **RoleEntryPoint** class approach.</span></span> <span data-ttu-id="53b2b-348">그러나 Azure WebJobs SDK에는 시작 작업을 통해 시작하는 WebJobs 관리를 쉽게 수행할 수 있는 대시보드가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-348">However, the Azure WebJobs SDK includes a dashboard to make it easier to manage WebJobs that you initiate through startup tasks.</span></span>

#### <a name="lifecycle"></a><span data-ttu-id="53b2b-349">수명 주기</span><span class="sxs-lookup"><span data-stu-id="53b2b-349">Lifecycle</span></span> 
 <span data-ttu-id="53b2b-350">**RoleEntryPoint** 클래스를 사용하여 웹 및 작업자 역할을 사용하는 Cloud Services 응용 프로그램에 대한 백그라운드 작업을 구현하기로 결정한 경우, 해당 작업을 올바르게 사용하려면 이 클래스의 수명 주기를 이해해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-350">If you decide to implement background jobs for Cloud Services applications that use web and worker roles by using the **RoleEntryPoint** class, it is important to understand the lifecycle of this class in order to use it correctly.</span></span>

<span data-ttu-id="53b2b-351">웹 및 작업자 역할은 시작, 실행 및 중지함에 따라 개별 단계의 집합을 거치게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-351">Web and worker roles go through a set of distinct phases as they start, run, and stop.</span></span> <span data-ttu-id="53b2b-352">**RoleEntryPoint** 클래스는 이러한 단계가 실행되는 시기를 나타내는 일련의 이벤트를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-352">The **RoleEntryPoint** class exposes a series of events that indicate when these stages are occurring.</span></span> <span data-ttu-id="53b2b-353">이러한 이벤트를 사용하여 사용자 지정 백그라운드 작업을 초기화, 실행 및 중지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-353">You use these to initialize, run, and stop your custom background tasks.</span></span> <span data-ttu-id="53b2b-354">전체 주기는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-354">The complete cycle is:</span></span>

* <span data-ttu-id="53b2b-355">Azure는 역할 어셈블리를 로드하고 **RoleEntryPoint**에서 파생된 클래스를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-355">Azure loads the role assembly and searches it for a class that derives from **RoleEntryPoint**.</span></span>
* <span data-ttu-id="53b2b-356">이 클래스를 발견하면 **RoleEntryPoint.OnStart()** 를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-356">If it finds this class, it calls **RoleEntryPoint.OnStart()**.</span></span> <span data-ttu-id="53b2b-357">사용자의 백그라운드 작업을 초기화하려면 이 메서드를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-357">You override this method to initialize your background tasks.</span></span>
* <span data-ttu-id="53b2b-358">**OnStart** 메서드가 완료된 후 Azure는 응용 프로그램의 전역 파일(있는 경우, 예: ASP.NET을 실행하는 웹 역할의 Global.asax)에서 **Application_start()** 를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-358">After the **OnStart** method has completed, Azure calls **Application_Start()** in the application’s Global file if this is present (for example, Global.asax in a web role running ASP.NET).</span></span>
* <span data-ttu-id="53b2b-359">Azure는 **OnStart()** 와 병렬로 실행하는 새 포그라운드에 대해 **RoleEntryPoint.Run()** 을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-359">Azure calls **RoleEntryPoint.Run()** on a new foreground thread that executes in parallel with **OnStart()**.</span></span> <span data-ttu-id="53b2b-360">사용자의 백그라운드 작업을 시작하려면 이 메서드를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-360">You override this method to start your background tasks.</span></span>
* <span data-ttu-id="53b2b-361">Run 메서드가 종료되면 Azure는 먼저 응용 프로그램의 전역 파일(있는 경우)에서 **Application_End()** 를 호출한 다음 **RoleEntryPoint.OnStop()** 을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-361">When the Run method ends, Azure first calls **Application_End()** in the application’s Global file if this is present, and then calls **RoleEntryPoint.OnStop()**.</span></span> <span data-ttu-id="53b2b-362">사용자의 백그라운드 작업 중지, 리소스 정리, 개체 삭제 및 작업이 사용했을 수 있는 연결 닫기를 수행하려면 **OnStop**을 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-362">You override the **OnStop** method to stop your background tasks, clean up resources, dispose of objects, and close connections that the tasks may have used.</span></span>
* <span data-ttu-id="53b2b-363">Azure 작업자 역할 호스트 프로세스는 중지됩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-363">The Azure worker role host process is stopped.</span></span> <span data-ttu-id="53b2b-364">이 시점에 역할이 재활용되고 다시 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-364">At this point, the role will be recycled and will restart.</span></span>

<span data-ttu-id="53b2b-365">**RoleEntryPoint** 클래스의 메서드 사용에 대한 더 자세한 내용 및 예제는 [Compute 리소스 통합 패턴](../patterns/compute-resource-consolidation.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="53b2b-365">For more details and an example of using the methods of the **RoleEntryPoint** class, see [Compute Resource Consolidation Pattern](../patterns/compute-resource-consolidation.md).</span></span>

#### <a name="implementation-considerations"></a><span data-ttu-id="53b2b-366">구현 고려 사항</span><span class="sxs-lookup"><span data-stu-id="53b2b-366">Implementation considerations</span></span>

<span data-ttu-id="53b2b-367">웹 또는 작업자 역할에서 백그라운드 작업을 구현하는 경우 다음 사항을 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="53b2b-367">Consider the following points if you are implementing background tasks in a web or worker role:</span></span>

* <span data-ttu-id="53b2b-368">**RoleEntryPoint** 클래스의 기본 **Run** 메서드 구현에는 역할을 무기한 유지하는 **Thread.Sleep(Timeout.Infinite)** 호출이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-368">The default **Run** method implementation in the **RoleEntryPoint** class contains a call to **Thread.Sleep(Timeout.Infinite)** that keeps the role alive indefinitely.</span></span> <span data-ttu-id="53b2b-369">**Run** 메서드(일반적으로 백그라운드 작업을 실행하기 위해 필요함)를 재정의할 경우에는 역할 인스턴스를 재활용하기를 원하지 않는 한 사용자의 코드가 메서드에서 종료하는 것을 허용해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-369">If you override the **Run** method (which is typically necessary to execute background tasks), you must not allow your code to exit from the method unless you want to recycle the role instance.</span></span>
* <span data-ttu-id="53b2b-370">**Run** 메서드의 일반적인 구현은 각 백그라운드 작업을 시작하는 코드 및 모든 백그라운드 작업의 상태를 주기적으로 확인하는 루프 구문을 포함하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-370">A typical implementation of the **Run** method includes code to start each of the background tasks and a loop construct that periodically checks the state of all the background tasks.</span></span> <span data-ttu-id="53b2b-371">이러한 구현은 실패한 단계를 다시 시작하거나 작업이 완료되었음을 나타내는 취소 토큰을 모니터링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-371">It can restart any that fail or monitor for cancellation tokens that indicate that jobs have completed.</span></span>
* <span data-ttu-id="53b2b-372">백그라운드 작업이 처리되지 않은 예외를 발생시킨 경우, 역할의 다른 백그라운드 작업이 계속 실행될 수 있도록 하면서 해당 작업을 재활용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-372">If a background task throws an unhandled exception, that task should be recycled while allowing any other background tasks in the role to continue running.</span></span> <span data-ttu-id="53b2b-373">그러나 예외가 공유 저장소와 같은 작업 외부의 개체 손상으로 야기된 경우, 사용자의 **RoleEntryPoint** 클래스에 의해 예외를 처리하고, 모든 작업을 취소하고, **Run** 메서드의 종료를 허용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-373">However, if the exception is caused by corruption of objects outside the task, such as shared storage, the exception should be handled by your **RoleEntryPoint** class, all tasks should be cancelled, and the **Run** method should be allowed to end.</span></span> <span data-ttu-id="53b2b-374">이때 Azure는 역할을 다시 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-374">Azure will then restart the role.</span></span>
* <span data-ttu-id="53b2b-375">백그라운드 작업을 일시 중지 또는 중단하려면 **OnStop** 메서드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-375">Use the **OnStop** method to pause or kill background tasks and clean up resources.</span></span> <span data-ttu-id="53b2b-376">이를 위해 장기 실행 또는 다단계 작업을 중지해야 할 수 있으며,</span><span class="sxs-lookup"><span data-stu-id="53b2b-376">This might involve stopping long-running or multistep tasks.</span></span> <span data-ttu-id="53b2b-377">이 작업을 데이터 불일치가 발생하지 않도록 수행할 수 있는 방법을 고려해야 합니다</span><span class="sxs-lookup"><span data-stu-id="53b2b-377">It is vital to consider how this can be done to avoid data inconsistencies.</span></span> <span data-ttu-id="53b2b-378">역할 인스턴스가 사용자가 시작한 종료 이외의 이유로 중지된 경우, **OnStop** 메서드에서 실행되는 코드는 5분 이내에 완료되어야 하며, 5분이 지나면 강제 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-378">If a role instance stops for any reason other than a user-initiated shutdown, the code running in the **OnStop** method must be completed within five minutes before it is forcibly terminated.</span></span> <span data-ttu-id="53b2b-379">사용자의 코드가 이 시간 이내에 완료될 수 있는지 또는 완료될 때까지 실행하지 않고 견딜 수 있는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-379">Ensure that your code can be completed in that time or can tolerate not running to completion.</span></span>  
* <span data-ttu-id="53b2b-380">Azure Load Balancer는 **RoleEntryPoint.OnStart** 메서드가**true** 값을 반환하면 트래픽을 해당 역할 인스턴스로 전달하기 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-380">The Azure load balancer starts directing traffic to the role instance when the **RoleEntryPoint.OnStart** method returns the value **true**.</span></span> <span data-ttu-id="53b2b-381">따라서 **OnStart** 메서드의 모든 초기화 코드를 성공적으로 초기화되지 않은 역할 인스턴스가 트래픽을 수신하지 않도록 하는 것을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-381">Therefore, consider putting all your initialization code in the **OnStart** method so that role instances that do not successfully initialize will not receive any traffic.</span></span>
* <span data-ttu-id="53b2b-382">**RoleEntryPoint** 클래스의 메서드에 더하여 시작 작업을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-382">You can use startup tasks in addition to the methods of the **RoleEntryPoint** class.</span></span> <span data-ttu-id="53b2b-383">시작 작업은 역할이 요청을 수신하기 전에 수행되므로 이러한 시작 작업을 사용하여 Azure 부하 분산 장치에서 변경해야 하는 설정을 초기화해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-383">You should use startup tasks to initialize any settings that you need to change in the Azure load balancer because these tasks will execute before the role receives any requests.</span></span> <span data-ttu-id="53b2b-384">자세한 내용은 [Azure에서 시작 작업 실행](/azure/cloud-services/cloud-services-startup-tasks/)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="53b2b-384">For more information, see [Run startup tasks in Azure](/azure/cloud-services/cloud-services-startup-tasks/).</span></span>
* <span data-ttu-id="53b2b-385">시작 작업에 오류가 있으면 역할을 계속 다시 시작하도록 강요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-385">If there is an error in a startup task, it might force the role to continually restart.</span></span> <span data-ttu-id="53b2b-386">이로 인해 이전 단계의 버전으로 다시 VIP(가상 IP) 주소 교환을 수행하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-386">This can prevent you from performing a virtual IP (VIP) address swap back to a previously staged version because the swap requires exclusive access to the role.</span></span> <span data-ttu-id="53b2b-387">교환을 위해서는 역할에 단독 액세스해야 하는데, 역할이 다시 시작되는 동안에는 액세스가 불가능하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-387">This cannot be obtained while the role is restarting.</span></span> <span data-ttu-id="53b2b-388">해결 방법:</span><span class="sxs-lookup"><span data-stu-id="53b2b-388">To resolve this:</span></span>
  
  * <span data-ttu-id="53b2b-389">사용자 역할의 **OnStart** 및 **Run** 메서드 시작 부분에 다음 코드를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-389">Add the following code to the beginning of the **OnStart** and **Run** methods in your role:</span></span>
    
    ```C#
    var freeze = CloudConfigurationManager.GetSetting("Freeze");
    if (freeze != null)
    {
      if (Boolean.Parse(freeze))
      {
        Thread.Sleep(System.Threading.Timeout.Infinite);
      }
    }
    ```
    
  * <span data-ttu-id="53b2b-390">역할에 대한 ServiceDefinition.csdef 및 ServiceConfiguration.\*.cscfg 파일에 부울 값 **동결** 설정의 정의를 추가하고 해당 값을 **false**로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-390">Add the definition of the **Freeze** setting as a Boolean value to the ServiceDefinition.csdef and ServiceConfiguration.\*.cscfg files for the role and set it to **false**.</span></span> <span data-ttu-id="53b2b-391">역할이 반복된 다시 시작 모드로 전환된 경우에는 이 설정을 **true**로 변경하여 역할 실행을 중지하고 이전 버전으로 교환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-391">If the role goes into a repeated restart mode, you can change the setting to **true** to freeze role execution and allow it to be swapped with a previous version.</span></span>

#### <a name="more-information"></a><span data-ttu-id="53b2b-392">자세한 정보</span><span class="sxs-lookup"><span data-stu-id="53b2b-392">More information</span></span>
* [<span data-ttu-id="53b2b-393">Compute 리소스 통합 패턴</span><span class="sxs-lookup"><span data-stu-id="53b2b-393">Compute Resource Consolidation Pattern</span></span>](../patterns/compute-resource-consolidation.md)
* [<span data-ttu-id="53b2b-394">Azure WebJobs SDK 시작</span><span class="sxs-lookup"><span data-stu-id="53b2b-394">Get started with the Azure WebJobs SDK</span></span>](/azure/app-service-web/websites-dotnet-webjobs-sdk-get-started/)


## <a name="partitioning"></a><span data-ttu-id="53b2b-395">분할</span><span class="sxs-lookup"><span data-stu-id="53b2b-395">Partitioning</span></span>
<span data-ttu-id="53b2b-396">기존 계산 인스턴스(예: 웹앱, 웹 역할, 기존 작업자 역할 또는 가상 머신) 내에 백그라운드 작업을 포함하기로 결정한 경우, 이 결정이 계산 인스턴스 및 백그라운드 작업 자체의 품질 특성에 미치는 영향을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-396">If you decide to include background tasks within an existing compute instance (such as a web app, web role, existing worker role, or virtual machine), you must consider how this will affect the quality attributes of the compute instance and the background task itself.</span></span> <span data-ttu-id="53b2b-397">이러한 요소는 작업을 기존 계산 인스턴스와 공동 배치할지 아니면 별도 계산 인스턴스로 분리할지 결정하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-397">These factors will help you to decide whether to colocate the tasks with the existing compute instance or separate them out into a separate compute instance:</span></span>

* <span data-ttu-id="53b2b-398">**가용성**: 백그라운드 작업이 응용 프로그램의 다른 부분, 특히 UI 및 사용자 조작에 직접 관련된 다른 부분과 같은 수준의 가용성을 가질 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-398">**Availability**: Background tasks might not need to have the same level of availability as other parts of the application, in particular the UI and other parts that are directly involved in user interaction.</span></span> <span data-ttu-id="53b2b-399">백그라운드 작업은 작업이 큐에 대기 중이기 때문에 대기 시간, 연결 실패 시 다시 시도 및 가용성에 영향을 미치는 다른 요소에 대해 더 잘 견딜 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-399">Background tasks might be more tolerant of latency, retried connection failures, and other factors that affect availability because the operations can be queued.</span></span> <span data-ttu-id="53b2b-400">그러나 큐를 차단하고 전체적으로 응용 프로그램에 영향을 미칠 수 있는 요청 백업을 방지하기에 충분한 용량이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-400">However, there must be sufficient capacity to prevent the backup of requests that could block queues and affect the application as a whole.</span></span>
* <span data-ttu-id="53b2b-401">**확장성**: 백그라운드 작업의 확장성 요구 사항은 UI 및 응용 프로그램의 대화형 부분과는 다를 가능성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-401">**Scalability**: Background tasks are likely to have a different scalability requirement than the UI and the interactive parts of the application.</span></span> <span data-ttu-id="53b2b-402">UI 확장은 최고 수요를 만족하기 위해 필요할 수 있지만, 미해결 백그라운드 작업을 계산 인스턴스 수가 적어 사용량이 적은 시간 동안 완료할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-402">Scaling the UI might be necessary to meet peaks in demand, while outstanding background tasks might be completed during less busy times by a fewer number of compute instances.</span></span>
* <span data-ttu-id="53b2b-403">**복원력**: 백그라운드 작업만 호스트하는 계산 인스턴스의 실패는 이러한 작업 요청이 큐에 대기 중이거나 작업이 다시 사용할 수 있게 될 때까지 연기된 경우 전체적으로 응용 프로그램에 그다지 영향을 미치지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-403">**Resiliency**: Failure of a compute instance that just hosts background tasks might not fatally affect the application as a whole if the requests for these tasks can be queued or postponed until the task is available again.</span></span> <span data-ttu-id="53b2b-404">계산 인스턴스 및/또는 작업을 적절한 간격 내에 다시 시작할 수 있다면 응용 프로그램의 사용자는 영향을 받지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-404">If the compute instance and/or tasks can be restarted within an appropriate interval, users of the application might not be affected.</span></span>
* <span data-ttu-id="53b2b-405">**보안**: 백그라운드 작업의 보안 요구 사항 또는 제한은 UI 또는 응용 프로그램의 다른 부분과는 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-405">**Security**: Background tasks might have different security requirements or restrictions than the UI or other parts of the application.</span></span> <span data-ttu-id="53b2b-406">별도 계산 인스턴스를 사용하면 작업에 대해 다른 보안 환경을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-406">By using a separate compute instance, you can specify a different security environment for the tasks.</span></span> <span data-ttu-id="53b2b-407">또한 보안 및 분리를 최대화하기 위해 게이트키퍼 같은 패턴을 사용하여 백그라운드 계산 인스턴스를 UI와 격리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-407">You can also use patterns such as Gatekeeper to isolate the background compute instances from the UI in order to maximize security and separation.</span></span>
* <span data-ttu-id="53b2b-408">**성능**: 작업의 성능 요구 사항을 구체적으로 일치시키기 위해 백그라운드 작업에 대한 계산 인스턴스 유형을 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-408">**Performance**: You can choose the type of compute instance for background tasks to specifically match the performance requirements of the tasks.</span></span> <span data-ttu-id="53b2b-409">즉, 작업에 UI와 같은 처리 용량이 필요하지 않은 경우 비용이 적은 계산 옵션을 사용하거나, 또는 추가 용량 및 리소스가 필요한 경우 더 큰 인스턴스를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-409">This might mean using a less expensive compute option if the tasks do not require the same processing capabilities as the UI, or a larger instance if they require additional capacity and resources.</span></span>
* <span data-ttu-id="53b2b-410">**관리 효율성**: 백그라운드 작업의 개발 및 배포 리듬은 주 응용 프로그램 코드 또는 UI와는 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-410">**Manageability**: Background tasks might have a different development and deployment rhythm from the main application code or the UI.</span></span> <span data-ttu-id="53b2b-411">이러한 작업을 별도 계산 인스턴스에 배포하면 업데이트 및 버전 관리를 간소화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-411">Deploying them to a separate compute instance can simplify updates and versioning.</span></span>
* <span data-ttu-id="53b2b-412">**비용**: 백그라운드 작업을 실행하기 위해 계산 인스턴스를 추가하면 호스팅 비용이 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-412">**Cost**: Adding compute instances to execute background tasks increases hosting costs.</span></span> <span data-ttu-id="53b2b-413">추가 용량과 이러한 추가 비용 간의 절충을 신중하게 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-413">You should carefully consider the trade-off between additional capacity and these extra costs.</span></span>

<span data-ttu-id="53b2b-414">자세한 내용은 [리더 선택 패턴](../patterns/leader-election.md) 및 [경쟁 소비자 패턴](../patterns/competing-consumers.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="53b2b-414">For more information, see [Leader Election Pattern](../patterns/leader-election.md) and [Competing Consumers Pattern](../patterns/competing-consumers.md).</span></span>

## <a name="conflicts"></a><span data-ttu-id="53b2b-415">충돌</span><span class="sxs-lookup"><span data-stu-id="53b2b-415">Conflicts</span></span>
<span data-ttu-id="53b2b-416">백그라운드 작업의 여러 인스턴스가 있는 경우, 데이터베이스 및 저장소 같은 서비스와 리소스의 액세스에 대해 계산할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-416">If you have multiple instances of a background job, it is possible that they will compete for access to resources and services, such as databases and storage.</span></span> <span data-ttu-id="53b2b-417">이 동시 액세스로 인해 리소스 경합을 초래하여 서비스 가용성 및 저장소의 데이터 무결성에 충돌이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-417">This concurrent access can result in resource contention, which might cause conflicts in availability of the services and in the integrity of data in storage.</span></span> <span data-ttu-id="53b2b-418">리소스 경합은 비관적 잠금 접근 방식을 사용하여 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-418">You can resolve resource contention by using a pessimistic locking approach.</span></span> <span data-ttu-id="53b2b-419">이는 작업의 경합 인스턴스가 동시에 서비스에 액세스하거나 데이터를 손상시키지 못하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-419">This prevents competing instances of a task from concurrently accessing a service or corrupting data.</span></span>

<span data-ttu-id="53b2b-420">충돌을 해결 하는 다른 방법은 언제나 하나의 인스턴스만 실행되도록 백그라운드 작업을 단일 항목으로 정의하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-420">Another approach to resolve conflicts is to define background tasks as a singleton, so that there is only ever one instance running.</span></span> <span data-ttu-id="53b2b-421">그러나 이렇게 하면 특히 UI가 둘 이상의 백그라운드 작업을 사용하도록 유지할 만큼 충분한 작업을 제공할 수 있는 경우</span><span class="sxs-lookup"><span data-stu-id="53b2b-421">However, this eliminates the reliability and performance benefits that a multiple-instance configuration can provide.</span></span> <span data-ttu-id="53b2b-422">복수 인스턴스 구성이 제공할 수 있는 안정성 및 성능 이점이 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-422">This is especially true if the UI can supply sufficient work to keep more than one background task busy.</span></span>

<span data-ttu-id="53b2b-423">백그라운드 작업이 자동으로 다시 시작되고 최고 수요를 극복하기에 충분한 용량을 갖도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-423">It is vital to ensure that the background task can automatically restart and that it has sufficient capacity to cope with peaks in demand.</span></span> <span data-ttu-id="53b2b-424">계산 인스턴스에 충분한 리소스 할당, 수요가 감소할 때 요청을 나중에 실행하도록 저장할 수 있는 큐 메커니즘 또는 두 기법의 조합에 의해 이를 실현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-424">You can achieve this by allocating a compute instance with sufficient resources, by implementing a queueing mechanism that can store requests for later execution when demand decreases, or by using a combination of these techniques.</span></span>

## <a name="coordination"></a><span data-ttu-id="53b2b-425">조정</span><span class="sxs-lookup"><span data-stu-id="53b2b-425">Coordination</span></span>
<span data-ttu-id="53b2b-426">백그라운드 작업은 복잡하여 결과를 생성하거나 모든 요구 사항을 충족하기 위해 복수의 개별 작업을 실행해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-426">The background tasks might be complex and might require multiple individual tasks to execute to produce a result or to fulfil all the requirements.</span></span> <span data-ttu-id="53b2b-427">일반적으로 이러한 시나리오에서는 작업을 복수의 소비자가 실행할 수 있는 더 작은 개별 단계 또는 하위 작업으로 분할합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-427">It is common in these scenarios to divide the task into smaller discreet steps or subtasks that can be executed by multiple consumers.</span></span> <span data-ttu-id="53b2b-428">개별 단계는 복수 작업에 다시 사용할 수 있기 때문에, 다단계 작업은 효율적이고 더 유연할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-428">Multistep jobs can be more efficient and more flexible because individual steps might be reusable in multiple jobs.</span></span> <span data-ttu-id="53b2b-429">또한 단계를 추가, 제거하거나 순서를 수정하기 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-429">It is also easy to add, remove, or modify the order of the steps.</span></span>

<span data-ttu-id="53b2b-430">복수의 작업과 단계를 조정하는 것은 쉽지 않을 수 있지만, 해결책 구현을 안내하기 위해 사용할 수 있는 일반적인 패턴 세 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-430">Coordinating multiple tasks and steps can be challenging, but there are three common patterns that you can use to guide your implementation of a solution:</span></span>

* <span data-ttu-id="53b2b-431">**작업을 다시 사용할 수 있는 여러 단계로 분해**.</span><span class="sxs-lookup"><span data-stu-id="53b2b-431">**Decomposing a task into multiple reusable steps**.</span></span> <span data-ttu-id="53b2b-432">응용 프로그램은 처리하는 정보에 대한 복잡성이 서로 다른 다양한 작업을 수행해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-432">An application might be required to perform a variety of tasks of varying complexity on the information that it processes.</span></span> <span data-ttu-id="53b2b-433">이 응용 프로그램의 구현에 대한 간단하지만 유연하지 않은 접근 방식은 이 처리를 모놀리식 모듈로 수행하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-433">A straightforward but inflexible approach to implementing this application might be to perform this processing as a monolithic module.</span></span> <span data-ttu-id="53b2b-434">그러나 이 접근 방식은 코드를 리팩터링, 최적화 또는 응용 프로그램 내의 다른 곳에 같은 처리의 일부가 필요한 경우 다시 사용할 기회를 감소시킬 가능성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-434">However, this approach is likely to reduce the opportunities for refactoring the code, optimizing it, or reusing it if parts of the same processing are required elsewhere within the application.</span></span> <span data-ttu-id="53b2b-435">자세한 내용은 [파이프 및 필터 패턴](../patterns/pipes-and-filters.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="53b2b-435">For more information, see [Pipes and Filters Pattern](../patterns/pipes-and-filters.md).</span></span>
* <span data-ttu-id="53b2b-436">**작업 단계의 실행 관리**.</span><span class="sxs-lookup"><span data-stu-id="53b2b-436">**Managing execution of the steps for a task**.</span></span> <span data-ttu-id="53b2b-437">응용 프로그램에서 여러 단계로 구성되고 단계 중 일부가 원격 서비스를 호출하거나 원격 리소스에 액세스할 수 있는 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-437">An application might perform tasks that comprise a number of steps (some of which might invoke remote services or access remote resources).</span></span> <span data-ttu-id="53b2b-438">개별 단계는 서로 독립적일 수 있지만, 작업을 구현하는 응용 프로그램 논리에 의해 조정됩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-438">The individual steps might be independent of each other, but they are orchestrated by the application logic that implements the task.</span></span> <span data-ttu-id="53b2b-439">자세한 내용은 참조 [Scheduler 에이전트 감독자 패턴](../patterns/scheduler-agent-supervisor.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="53b2b-439">For more information, see [Scheduler Agent Supervisor Pattern](../patterns/scheduler-agent-supervisor.md).</span></span>
* <span data-ttu-id="53b2b-440">**실패한 작업 단계에 대한 복구 관리**.</span><span class="sxs-lookup"><span data-stu-id="53b2b-440">**Managing recovery for task steps that fail**.</span></span> <span data-ttu-id="53b2b-441">응용 프로그램은 결국 함께 모여서 일관된 작업을 정의하는 일련의 단계에 의해 수행되는 작업을 하나 이상의 단계가 실패하면 취소해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-441">An application might need to undo the work that is performed by a series of steps (which together define an eventually consistent operation) if one or more of the steps fail.</span></span> <span data-ttu-id="53b2b-442">자세한 내용은 [트랜잭션 패턴 보상](../patterns/compensating-transaction.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="53b2b-442">For more information, see [Compensating Transaction Pattern](../patterns/compensating-transaction.md).</span></span>


## <a name="resiliency-considerations"></a><span data-ttu-id="53b2b-443">복원력 고려 사항</span><span class="sxs-lookup"><span data-stu-id="53b2b-443">Resiliency considerations</span></span>
<span data-ttu-id="53b2b-444">백그라운드 작업은 응용 프로그램에 신뢰할 수 있는 서비스를 제공하기 위해 복원력이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-444">Background tasks must be resilient in order to provide reliable services to the application.</span></span> <span data-ttu-id="53b2b-445">백그라운드 작업을 계획 및 디자인할 때는 다음 사항을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-445">When you are planning and designing background tasks, consider the following points:</span></span>

* <span data-ttu-id="53b2b-446">백그라운드 작업은 데이터를 손상하거나 응용 프로그램에 불일치를 발생시키지 않고 역할 또는 서비스 다시 시작을 정상적으로 처리할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-446">Background tasks must be able to gracefully handle role or service restarts without corrupting data or introducing inconsistency into the application.</span></span> <span data-ttu-id="53b2b-447">장기 실행 또는 다단계 작업의 경우, 작업의 상태를 영구적 저장소에 저장하거나, 또는 적절한 경우 메시지를 큐에 저장하여 *검사점 설정*을 사용하는 것을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-447">For long-running or multistep tasks, consider using *check pointing* by saving the state of jobs in persistent storage, or as messages in a queue if this is appropriate.</span></span> <span data-ttu-id="53b2b-448">예를 들어 메시지의 상태 정보를 큐에 영구적으로 저장하고 작업 진행에 따라 이 상태 정보를 증분 방식으로 업데이트하여 작업이 처음부터 다시 시작하는 대신에 마지막 알려진 양호한 검사점부터 처리되도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-448">For example, you can persist state information in a message in a queue and incrementally update this state information with the task progress so that the task can be processed from the last known good checkpoint--instead of restarting from the beginning.</span></span> <span data-ttu-id="53b2b-449">Azure Service Bus 큐를 사용하는 경우, 메시지 세션을 사용하여 같은 시나리오를 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-449">When using Azure Service Bus queues, you can use message sessions to enable the same scenario.</span></span> <span data-ttu-id="53b2b-450">세션을 통해 [SetState](https://docs.microsoft.com/dotnet/api/microsoft.servicebus.messaging.messagesession.setstate?view=azureservicebus-4.0.0) 및 [GetState](https://docs.microsoft.com/dotnet/api/microsoft.servicebus.messaging.messagesession.getstate?view=azureservicebus-4.0.0) 메서드를 사용하여 응용 프로그램 처리 상태를 저장하고 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-450">Sessions allow you to save and retrieve the application processing state by using the [SetState](https://docs.microsoft.com/dotnet/api/microsoft.servicebus.messaging.messagesession.setstate?view=azureservicebus-4.0.0) and [GetState](https://docs.microsoft.com/dotnet/api/microsoft.servicebus.messaging.messagesession.getstate?view=azureservicebus-4.0.0) methods.</span></span> <span data-ttu-id="53b2b-451">신뢰할 수 있는 다단계 프로세스와 워크플로를 디자인하는 방법에 대 한 자세한 내용은 [Scheduler 에이전트 감독자 패턴](../patterns/scheduler-agent-supervisor.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="53b2b-451">For more information about designing reliable multistep processes and workflows, see [Scheduler Agent Supervisor Pattern](../patterns/scheduler-agent-supervisor.md).</span></span>
* <span data-ttu-id="53b2b-452">웹 또는 작업자 역할을 사용하여 복수의 백그라운드 작업을 호스트하는 경우, 사용자의 **실행** 메서드 재정의를 실패했거나 중단된 작업을 모니터링하도록 디자인하고 해당 작업을 다시 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-452">When you use web or worker roles to host multiple background tasks, design your override of the **Run** method to monitor for failed or stalled tasks, and restart them.</span></span> <span data-ttu-id="53b2b-453">이 방법이 사실상 불가능하고 작업자 역할을 하용 중인 경우, **Run** 메서드에서 종료하여 작업자 역할을 강제로 다시 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-453">Where this is not practical, and you are using a worker role, force the worker role to restart by exiting from the **Run** method.</span></span>
* <span data-ttu-id="53b2b-454">큐를 사용하여 백그라운드 작업과 통신하는 경우, 큐는 응용 프로그램이 평시 부하보다 더 높은 상태에 있는 동안 작업에 보내진 요청을 저장하는 버퍼 역할을 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-454">When you use queues to communicate with background tasks, the queues can act as a buffer to store requests that are sent to the tasks while the application is under higher than usual load.</span></span> <span data-ttu-id="53b2b-455">이 방법으로 사용량이 적은 기간 동안 작업이 UI를 불러오게 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-455">This allows the tasks to catch up with the UI during less busy periods.</span></span> <span data-ttu-id="53b2b-456">또한 이렇게 하면 역할을 재활용해도 UI가 차단되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-456">It also means that recycling the role will not block the UI.</span></span> <span data-ttu-id="53b2b-457">자세한 내용은 [큐 기반 부하 평준화 패턴](../patterns/queue-based-load-leveling.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="53b2b-457">For more information, see [Queue-Based Load Leveling Pattern](../patterns/queue-based-load-leveling.md).</span></span> <span data-ttu-id="53b2b-458">일부 작업이 다른 작업보다 더 중요 한 경우, 이러한 작업이 덜 중요한 작업보다 먼저 실행되도록 [우선순위 큐 패턴](../patterns/priority-queue.md)의 구현을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-458">If some tasks are more important than others, consider implementing the [Priority Queue Pattern](../patterns/priority-queue.md) to ensure that these tasks run before less important ones.</span></span>
* <span data-ttu-id="53b2b-459">메시지 또는 프로세스 메시지에 의해 시작되는 백그라운드 작업은 순서에서 벗어난 메시지 도착, 반복적으로 오류를 발생시키는 메시지(흔히 *포이즌 메시지*라 함) 및 두 번 이상 전달된 메시지 등과 같은 불일치를 처리하도록 설계해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-459">Background tasks that are initiated by messages or process messages must be designed to handle inconsistencies, such as messages arriving out of order, messages that repeatedly cause an error (often referred to as *poison messages*), and messages that are delivered more than once.</span></span> <span data-ttu-id="53b2b-460">다음을 고려해 보세요.</span><span class="sxs-lookup"><span data-stu-id="53b2b-460">Consider the following:</span></span>
  * <span data-ttu-id="53b2b-461">기존 데이터 값을 기반으로 데이터를 변경하는(예를 들어 기존 값에 값을 더함) 메시지 같은 특정 순서에 따라 처리해야 하는 메시지는 원래 보낸 순서대로 도착하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-461">Messages that must be processed in a specific order, such as those that change data based on the existing data value (for example, adding a value to an existing value), might not arrive in the original order in which they were sent.</span></span> <span data-ttu-id="53b2b-462">또는 이러한 메시지는 각 인스턴스에 대한 변화하는 부하로 인해 다른 순서로 백그라운드 작업의 다른 인스턴스에 의해 처리될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-462">Alternatively, they might be handled by different instances of a background task in a different order due to varying loads on each instance.</span></span> <span data-ttu-id="53b2b-463">특정 순서에 따라 처리해야 하는 메시지는 시퀀스 번호, 키 또는 백그라운드 작업이 올바른 순서로 처리되도록 하기 위해 사용할 수 있는 일부 다른 표시기를 포함해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-463">Messages that must be processed in a specific order should include a sequence number, key, or some other indicator that background tasks can use to ensure that they are processed in the correct order.</span></span> <span data-ttu-id="53b2b-464">Azure Service Bus를 사용하는 경우, 전달 순서를 보장하기 위해 메시지 세션을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-464">If you are using Azure Service Bus, you can use message sessions to guarantee the order of delivery.</span></span> <span data-ttu-id="53b2b-465">그러나 가능하면 프로세스를 이 메시지 순서가 중요하지 않도록 디자인하는 것이 일반적으로 더 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-465">However, it is usually more efficient, where possible, to design the process so that the message order is not important.</span></span>
  * <span data-ttu-id="53b2b-466">일반적으로 백그라운드 작업은 큐의 메시지를 엿보고 메시지를 다른 메시지 소비자로부터 일시적으로 숨긴 다음,</span><span class="sxs-lookup"><span data-stu-id="53b2b-466">Typically, a background task will peek at messages in the queue, which temporarily hides them from other message consumers.</span></span> <span data-ttu-id="53b2b-467">해당 메시지가 성공적으로 처리된 후에 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-467">Then it deletes the messages after they have been successfully processed.</span></span> <span data-ttu-id="53b2b-468">메시지를 처리할 때 백그라운드 작업이 실패한 경우, 해당 메시지는 엿보기 시간 제한이 만료된 후 큐에 다시 나타나며,</span><span class="sxs-lookup"><span data-stu-id="53b2b-468">If a background task fails when processing a message, that message will reappear on the queue after the peek time-out expires.</span></span> <span data-ttu-id="53b2b-469">작업의 다른 인스턴스에 의해 또는 이 인스턴스의 다음 처리 주기 동안 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-469">It will be processed by another instance of the task or during the next processing cycle of this instance.</span></span> <span data-ttu-id="53b2b-470">메시지가 소비자에서 일관되게 오류를 발생시키면 해당 메시지 때문에 작업, 큐 및 큐가 꽉 찬 경우 결국 응용 프로그램 자체가 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-470">If the message consistently causes an error in the consumer, it will block the task, the queue, and eventually the application itself when the queue becomes full.</span></span> <span data-ttu-id="53b2b-471">그러므로 큐에서 포이즌 메시지를 감지하여 제거해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-471">Therefore, it is vital to detect and remove poison messages from the queue.</span></span> <span data-ttu-id="53b2b-472">Azure Service Bus를 사용하는 경우, 오류를 야기하는 메시지를 연결된 배달 못한 메시지 큐로 자동 또는 수동으로 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-472">If you are using Azure Service Bus, messages that cause an error can be moved automatically or manually to an associated dead letter queue.</span></span>
  * <span data-ttu-id="53b2b-473">큐는 *최소한 한 번* 전달 메커니즘을 보장 받지만 동일한 메시지를 두 번 이상 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-473">Queues are guaranteed at *least once* delivery mechanisms, but they might deliver the same message more than once.</span></span> <span data-ttu-id="53b2b-474">또한 메시지를 처리한 후 큐에서 삭제하기 전에 백그라운드 작업이 실패하면 해당 메시지는 처리를 위해 다시 사용할 수 있게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-474">In addition, if a background task fails after processing a message but before deleting it from the queue, the message will become available for processing again.</span></span> <span data-ttu-id="53b2b-475">백그라운드 작업은 멱등원이어야 합니다. 즉, 같은 메시지를 두 번 이상 처리해도 오류 또는 응용 프로그램의 데이터의 불일치를 야기하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-475">Background tasks should be idempotent, which means that processing the same message more than once does not cause an error or inconsistency in the application’s data.</span></span> <span data-ttu-id="53b2b-476">저장된 값을 특정 새 값으로 설정하는 작업 등 일부 작업은 당연히 멱등원입니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-476">Some operations are naturally idempotent, such as setting a stored value to a specific new value.</span></span> <span data-ttu-id="53b2b-477">그러나 저장된 값이 메시지를 원래 보냈을 때와 여전히 같은지 검사하지 않고 기존 저장된 값에 값을 더하는 것과 같은 작업은 불일치를 야기합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-477">However, operations such as adding a value to an existing stored value without checking that the stored value is still the same as when the message was originally sent will cause inconsistencies.</span></span> <span data-ttu-id="53b2b-478">Azure Service Bus 큐를 중복된 메시지를 자동으로 제거하도록 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-478">Azure Service Bus queues can be configured to automatically remove duplicated messages.</span></span>
  * <span data-ttu-id="53b2b-479">Azure 저장소 큐 및 Azure Service Bus 큐와 같은 일부 메시징 시스템은 메시지를 큐에서 읽은 횟수를 나타내는 큐에서 제거 횟수 속성을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-479">Some messaging systems, such as Azure storage queues and Azure Service Bus queues, support a de-queue count property that indicates the number of times a message has been read from the queue.</span></span> <span data-ttu-id="53b2b-480">이 속성은 반복 및 포이즌 메시지 처리에 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-480">This can be useful in handling repeated and poison messages.</span></span> <span data-ttu-id="53b2b-481">자세한 내용은 [비동기 메시징 입문서](https://msdn.microsoft.com/library/dn589781.aspx) 및 [멱등성 패턴](https://blog.jonathanoliver.com/idempotency-patterns/)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="53b2b-481">For more information, see [Asynchronous Messaging Primer](https://msdn.microsoft.com/library/dn589781.aspx) and [Idempotency Patterns](https://blog.jonathanoliver.com/idempotency-patterns/).</span></span>

## <a name="scaling-and-performance-considerations"></a><span data-ttu-id="53b2b-482">확장 및 성능 고려 사항</span><span class="sxs-lookup"><span data-stu-id="53b2b-482">Scaling and performance considerations</span></span>
<span data-ttu-id="53b2b-483">백그라운드 작업은 시스템이 부하를 받고 있을 때 지연된 작업으로 인해 응용 프로그램을 차단하거나 불일치를 야기하지 않을 만큼 충분한 성능을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-483">Background tasks must offer sufficient performance to ensure they do not block the application, or cause inconsistencies due to delayed operation when the system is under load.</span></span> <span data-ttu-id="53b2b-484">일반적으로 백그라운드 작업을 호스트하는 계산 인스턴스를 확장하면 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-484">Typically, performance is improved by scaling the compute instances that host the background tasks.</span></span> <span data-ttu-id="53b2b-485">백그라운드 작업을 계획 및 디자인할 때는 확장성 및 성능에 관하여 다음 사항을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-485">When you are planning and designing background tasks, consider the following points around scalability and performance:</span></span>

* <span data-ttu-id="53b2b-486">Azure는 현재 수요와 부하 또는 Web Apps, Cloud Services 웹 및 작업자 역할, 그리고 Virtual Machines에서 호스트하는 배치의 경우 미리 정의된 일정을 기반으로 하는 자동 크기 조정을 지원합니다(확장 및 다시 축소 모두).</span><span class="sxs-lookup"><span data-stu-id="53b2b-486">Azure supports autoscaling (both scaling out and scaling back in) based on current demand and load--or on a predefined schedule, for Web Apps, Cloud Services web and worker roles, and Virtual Machines hosted deployments.</span></span> <span data-ttu-id="53b2b-487">런타임 비용을 최소화하면서 응용 프로그램이 전체적으로 충분한 성능을 갖게 하려면 이 기능을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-487">Use this feature to ensure that the application as a whole has sufficient performance capabilities while minimizing runtime costs.</span></span>
* <span data-ttu-id="53b2b-488">백그라운드 작업이 Cloud Services 응용 프로그램(예: UI 또는 데이터 액세스 계층 같은 구성 요소)의 다른 부분에서 다른 성능 용량을 가지는 경우, 백그라운드 작업을 별도 작업자 역할에서 함께 호스트하면 UI 및 백그라운드 작업이 부하를 독립적으로 관리하도록 크기 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-488">Where background tasks have a different performance capability from the other parts of a Cloud Services application (for example, the UI or components such as the data access layer), hosting the background tasks together in a separate worker role allows the UI and background task roles to scale independently to manage the load.</span></span> <span data-ttu-id="53b2b-489">여러 백그라운드 작업이 서로 크게 다른 성능 기능을 가지는 경우, 작업을 별도 작업자 역할로 분할하고 각 역할 유형을 독립적으로 크기 조정하는 것을 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="53b2b-489">If multiple background tasks have significantly different performance capabilities from each other, consider dividing them into separate worker roles and scaling each role type independently.</span></span> <span data-ttu-id="53b2b-490">단, 참고로 이렇게 하면 모든 작업을 더 적은 수의 역할로 결합하는 방법에 비해 런타임 비용이 증가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-490">However, note that this might increase runtime costs compared to combining all the tasks into fewer roles.</span></span>
* <span data-ttu-id="53b2b-491">단순히 역할의 크기만 조정하면 부하를 받을 때 성능 손실을 방지하기에 부족할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-491">Simply scaling the roles might not be sufficient to prevent loss of performance under load.</span></span> <span data-ttu-id="53b2b-492">또한 전체 처리 체인의 단일 지점이 병목 상태가 되는 것을 방지하기 위해 저장소 큐 및 다른 리소스를 크기 조정해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-492">You might also need to scale storage queues and other resources to prevent a single point of the overall processing chain from becoming a bottleneck.</span></span> <span data-ttu-id="53b2b-493">또한 저장소의 최대 처리량 및 응용 프로그램과 백그라운드 작업이 의존하는 다른 서비스 등 다른 제한도 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-493">Also, consider other limitations, such as the maximum throughput of storage and other services that the application and the background tasks rely on.</span></span>
* <span data-ttu-id="53b2b-494">백그라운드 작업은 크기 조정을 고려하여 디자인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-494">Background tasks must be designed for scaling.</span></span> <span data-ttu-id="53b2b-495">예를 들어 이러한 작업은 저장소 큐에서 수신 대기하거나 메시지를 해당 큐에 보내기 위해 사용 중인 저장소 큐 수를 동적으로 감지할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-495">For example, they must be able to dynamically detect the number of storage queues in use in order to listen on or send messages to the appropriate queue.</span></span>
* <span data-ttu-id="53b2b-496">기본적으로 WebJobs는 자체의 연결된 Azure Web Apps 인스턴스를 통해 크기를 조정합니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-496">By default, WebJobs scale with their associated Azure Web Apps instance.</span></span> <span data-ttu-id="53b2b-497">그러나 WebJob을 단일 인스턴스로 실행하려면 JSON 데이터 **{"is_singleton": true}** 가 포함된 Settings.job 파일을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-497">However, if you want a WebJob to run as only a single instance, you can create a Settings.job file that contains the JSON data **{ "is_singleton": true }**.</span></span> <span data-ttu-id="53b2b-498">이렇게 하면 연결된 웹앱의 여러 인스턴스가 있더라도 Azure가 WebJob의 인스턴스를 한 개만 실행하게 되며,</span><span class="sxs-lookup"><span data-stu-id="53b2b-498">This forces Azure to only run one instance of the WebJob, even if there are multiple instances of the associated web app.</span></span> <span data-ttu-id="53b2b-499">이는 단일 인스턴스로만 실행해야 하는 예약된 작업에 유용한 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="53b2b-499">This can be a useful technique for scheduled jobs that must run as only a single instance.</span></span>

## <a name="related-patterns"></a><span data-ttu-id="53b2b-500">관련된 패턴</span><span class="sxs-lookup"><span data-stu-id="53b2b-500">Related patterns</span></span>
* [<span data-ttu-id="53b2b-501">비동기 메시징 입문</span><span class="sxs-lookup"><span data-stu-id="53b2b-501">Asynchronous Messaging Primer</span></span>](https://msdn.microsoft.com/library/dn589781.aspx)
* [<span data-ttu-id="53b2b-502">자동 크기 조정 지침</span><span class="sxs-lookup"><span data-stu-id="53b2b-502">Autoscaling Guidance</span></span>](https://msdn.microsoft.com/library/dn589774.aspx)
* [<span data-ttu-id="53b2b-503">트랜잭션 패턴 보상</span><span class="sxs-lookup"><span data-stu-id="53b2b-503">Compensating Transaction Pattern</span></span>](../patterns/compensating-transaction.md)
* [<span data-ttu-id="53b2b-504">경쟁 소비자 패턴</span><span class="sxs-lookup"><span data-stu-id="53b2b-504">Competing Consumers Pattern</span></span>](../patterns/competing-consumers.md)
* [<span data-ttu-id="53b2b-505">Compute 분할 지침</span><span class="sxs-lookup"><span data-stu-id="53b2b-505">Compute Partitioning Guidance</span></span>](https://msdn.microsoft.com/library/dn589773.aspx)
* [<span data-ttu-id="53b2b-506">Compute 리소스 통합 패턴</span><span class="sxs-lookup"><span data-stu-id="53b2b-506">Compute Resource Consolidation Pattern</span></span>](https://msdn.microsoft.com/library/dn589778.aspx)
* [<span data-ttu-id="53b2b-507">게이트키퍼 패턴</span><span class="sxs-lookup"><span data-stu-id="53b2b-507">Gatekeeper Pattern</span></span>](../patterns/gatekeeper.md)
* [<span data-ttu-id="53b2b-508">리더 선택 패턴</span><span class="sxs-lookup"><span data-stu-id="53b2b-508">Leader Election Pattern</span></span>](../patterns/leader-election.md)
* [<span data-ttu-id="53b2b-509">파이프 및 필터 패턴</span><span class="sxs-lookup"><span data-stu-id="53b2b-509">Pipes and Filters Pattern</span></span>](../patterns/pipes-and-filters.md)
* [<span data-ttu-id="53b2b-510">우선순위 큐 패턴</span><span class="sxs-lookup"><span data-stu-id="53b2b-510">Priority Queue Pattern</span></span>](../patterns/priority-queue.md)
* [<span data-ttu-id="53b2b-511">큐 기반 부하 평준화 패턴</span><span class="sxs-lookup"><span data-stu-id="53b2b-511">Queue-based Load Leveling Pattern</span></span>](../patterns/queue-based-load-leveling.md)
* [<span data-ttu-id="53b2b-512">Scheduler 에이전트 감독자 패턴</span><span class="sxs-lookup"><span data-stu-id="53b2b-512">Scheduler Agent Supervisor Pattern</span></span>](../patterns/scheduler-agent-supervisor.md)

## <a name="more-information"></a><span data-ttu-id="53b2b-513">자세한 정보</span><span class="sxs-lookup"><span data-stu-id="53b2b-513">More information</span></span>
* [<span data-ttu-id="53b2b-514">백그라운드 작업 실행</span><span class="sxs-lookup"><span data-stu-id="53b2b-514">Executing Background Tasks</span></span>](https://msdn.microsoft.com/library/ff803365.aspx)
* <span data-ttu-id="53b2b-515">[Azure Cloud Services 역할 수명 주기](https://channel9.msdn.com/Series/Windows-Azure-Cloud-Services-Tutorials/Windows-Azure-Cloud-Services-Role-Lifecycle) (비디오)</span><span class="sxs-lookup"><span data-stu-id="53b2b-515">[Azure Cloud Services Role Lifecycle](https://channel9.msdn.com/Series/Windows-Azure-Cloud-Services-Tutorials/Windows-Azure-Cloud-Services-Role-Lifecycle) (video)</span></span>
* [<span data-ttu-id="53b2b-516">Azure WebJobs SDK 정의</span><span class="sxs-lookup"><span data-stu-id="53b2b-516">What is the Azure WebJobs SDK</span></span>](https://docs.microsoft.com/azure/app-service-web/websites-dotnet-webjobs-sdk)
* [<span data-ttu-id="53b2b-517">WebJob으로 백그라운드 작업 실행</span><span class="sxs-lookup"><span data-stu-id="53b2b-517">Run Background tasks with WebJobs</span></span>](https://docs.microsoft.com/azure/app-service-web/web-sites-create-web-jobs)
* [<span data-ttu-id="53b2b-518">Azure 큐 및 Service Bus 큐 - 비교 및 대조</span><span class="sxs-lookup"><span data-stu-id="53b2b-518">Azure Queues and Service Bus Queues - Compared and Contrasted</span></span>](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-azure-and-service-bus-queues-compared-contrasted)
* [<span data-ttu-id="53b2b-519">클라우드 서비스에서 진단 기능을 사용하는 방법</span><span class="sxs-lookup"><span data-stu-id="53b2b-519">How to Enable Diagnostics in a Cloud Service</span></span>](https://docs.microsoft.com/azure/cloud-services/cloud-services-dotnet-diagnostics)

