---
title: Data partitioning guidance
description: Guidance for how to separate partitions to be managed and accessed separately.
author: dragon119
ms.service: guidance
ms.topic: article
ms.date: 07/13/2016
ms.author: pnp

pnp.series.title: Best Practices
---
# 데이터 분할
[!INCLUDE [header](../_includes/header.md)]

많은 대규모 솔루션에서 데이터는 별도로 관리 및 액세스할 수 있는 별도의 파티션으로 나뉩니다. 분할 전략을 주의 깊게 선택하여 장점을 극대화하고 부작용을 최소화해야 합니다. 분할은 확장성을 개선하고, 경합을 줄이며, 성능을 최적화합니다. 분할의 다른 이점으로는 사용 패턴에 따라 데이터를 나누는 메커니즘을 지원할 수 있다는 점입니다. 예를 들어, 저렴한 데이터 저장소에 오래된 비활성(콜드) 데이터를 보관할 수 있습니다. 

## 왜 파티션 데이터인가?
대다수 클라우드 응용 프로그램과 서비스는 데이터 저장과 검색 기능을 갖추고 있습니다. 응용 프로그램이 사용하는 데이터 저장소 설계는 시스템의 성능, 처리량 및 확장성과 밀접한 관련이 있습니다. 대규모 시스템에서 일반적으로 적용되는 한 가지 기법은 데이터를 별도의 파티션으로 나누는 것입니다. 

> 이 지침에서 사용되는 *분할*이라는 용어는 데이터를 별도의 데이터 저장소로 물리적으로 나누는 프로세스를 말합니다. 여기서 분할은 SQL Server 테이블의 분할과는 다른 개념입니다.
>
>

데이터를 분할하면 다양한 이점이 있습니다. 예를 들면, 다음과 같은 이점을 위해 데이터 분할을 적용할 수 있습니다. 

* **확장성 향상**. 단일 데이터베이스 시스템을 강화하다 보면 결국 물리적 하드웨어의 한계에 도달하게 됩니다. 각기 별도의 서버에서 호스팅되는 파티션 여러 개에서 데이터를 나눌 경우, 시스템은 거의 무제한적으로 규모가 확장됩니다.
* **성능 개선**. 각 파티션에서 데이터 액세스 작업은 적은 양의 데이터에서 진행됩니다. 데이터가 적절한 방식으로 분할되기만 하면, 분할은 시스템의 효율성을 높여 줄 수 있습니다. 2개 이상의 파티션에 영향을 주는 작업은 동시에 실행될 수 있습니다. 각 파티션은 해당 파티션을 사용하는 응용 프로그램 근처에 위치하여 네트워크 대기 시간을 최소화할 수 있습니다.
* **가용성 개선**. 여러 서버에서 데이터를 분리하면 단일 장애 지점을 차단해 줍니다. 서버에 장애가 발생하거나 예정된 유지 관리 작업이 실행중인 경우, 해당 파티션의 데이터만 사용할 수 없는 상태가 됩니다. 다른 파티션에서는 작업을 계속할 수 있습니다. 파티션 수가 늘어나면 사용할 수 없는 데이터의 비율이 줄어 단일 서버 장애와 관련된 영향이 감소합니다. 각 파티션을 복제하면 작업에 영향을 주는 단일 파티션 장애 발생 가능성이 더 줄어들 수 있습니다. 또한 가용성 요구사항이 낮은 저가치 데이터에서 계속 많이 사용해야 하는 중요 데이터를 분리할 수도 있습니다.
* **보안 강화**. 데이터와 분할 방식 특성에 따라 중요한 데이터와 중요하지 않은 데이터를 다른 파티션으로 분리한 다음, 다른 서버나 데이터 저장소로 분리할 수도 있습니다. 그리고 나면 특히 보안이 중요한 데이터에 맞게 최적화될 수 있습니다.
* **운영 유연성 지원**. 분할은 그 자체로 작업을 미세 조정할 수 있는 다양한 가능성을 열어 주므로, 관리 효율을 극대화하고 비용을 최소화할 수 있습니다. 예를 들어, 관리, 모니터링, 백업, 복원 등 각 파티션의 데이터 중요도에 따라 관리 작업별 전략을 정의할 수 있습니다.
* **데이터 저장소와 사용 패턴 일치**. 분할을 통해 데이터 저장소가 지원하는 기본 제공 기능과 비용에 따라 각 파티션을 다양한 유형의 데이터 저장소에서 배포할 수 있습니다. 예를 들어, 대형 이진 데이터를 blob 데이터 저장소에 저장하면서도, 더 많은 구조적 데이터를 문서 데이터베이스에 보관할 수 있습니다. 자세한 내용은 패턴 및 사례 가이드의 [Polyglot 솔루션 빌드]와 Microsoft 웹사이트의 [확장성이 우수한 솔루션의 데이터 액세스:. SQL, NoSQL 및 Polyglot 지속성]을 참조하십시오.

일부 시스템은 이점 이외에 비용을 감안하여 분할을 구현하지 않습니다. 이에 대한 일반적인 이유는 다음과 같습니다. 

•	많은 데이터 저장소 시스템이 여러 파티션에서 조인을 지원하지 않아 분할된 시스템에서 참조 무결성을 유지하기 어려울 수 있습니다. 흔히 응용 프로그램 코드(분할 계층)에서 조인과 무결성 검사를 구현해야 하기 때문에 추가 입출력이 필요하고 응용 프로그램 복잡성이 발생할 수 있습니다.

•	파티션 유지는 언제나 사소한 작업이 아닙니다. 데이터가 변동이 심한 시스템에서는 정기적으로 파티션 균형을 다시 맞춰 경합과 핫스폿을 줄여야 합니다.

•	일반적인 도구는 자연히 분할된 데이터에서 작동하지 않습니다.


## 파티션 설계
데이터 분할 방식으로는 수평, 수직 및 기능이 있습니다. 선택하는 전략은 데이터 분할 이유와 데이터를 사용하는 응용 프로그램 및 서비스 요구사항에 따라 달라집니다. 

> [!참고]
> 이 지침에 설명된 분할 체계 방식은 기본 데이터 저장소 기술과 무관합니다. 또한 그 근거와 NoSQL 데이터베이스를 포함한 많은 유형의 데이터 저장소에 적용될 수 있습니다. 
>
>

### 분할 전략
일반적인 데이터 분할 전략 세 가지는 다음과 같습니다. 

* **수평 분할**(흔히 샤딩*sharding*이라고 함). 이 전략에서는 각 파티션이 그 자체로 데이터 저장소이지만, 모든 파티션의 체계가 동일합니다. 각 파티션은 *샤드(shard)*  알려져 있고 전자 상거래 응용 프로그램에서 특정 고객 집합의 모든 주문과 같은 특정 데이터 하위 집합을 보관합니다.
* **수직 분할**. 이 전략에서 각 파티션은 데이터 저장소의 여러 항목 필드의 하위 집합을 저장합니다. 이 필드는 사용 패턴에 따라 나뉩니다. 예를 들어, 자주 액세스하는 필드를 하나의 수직 파티션에 배치하고 자주 액세스하지 않는 필드는 다른 파티션에 배치할 수 있습니다.
* **기능 분할**. 이 전략에서는 시스템에서 바인딩된 각 컨텍스트가 데이터를 사용하는 방법에 따라 데이터를 집계합니다. 예를 들어, 청구 및 제품 재고 관리를 위해 별도의 비즈니스 기능을 구현한 전자 상거래 시스템은 송장 데이터와 제품 재고 데이터를 각기 다른 파티션에 저장할 수 있습니다.

여기에 나와 있는 이 세 가지 전략을 조합하여 사용할 수 있다는 점을 잘 알고 있어야 합니다. 이들 전략은 서로 배타적이지 않으므로, 분할 체계를 설계할 때 모든 전략을 고려하는 것이 좋습니다. 예를 들어, 데이터를 샤드로 나눈 후 수직 분할을 사용해 각 샤드에서 데이터를 추가로 세분화할 수 있습니다. 마찬가지로, 기능 파티션의 데이터를 샤드로 분할할 수 있습니다(수직으로도 분할 가능). 

그렇지만, 각 전략의 요구사양이 다양하여 많은 충돌 문제가 발생할 수 있습니다. 전체 데이터 처리 성능 목표에 부합하는 분할 체계를 설계할 때에는 이 모든 사항을 평가하고 균형을 맞춰야 합니다. 다음 섹션에서는 각 전략에 대해 자세히 알아봅니다. 

### 수평 분할(샤딩)
그림 1은 수평 분할 또는 샤딩에 대한 개요를 나타냅니다. 이 예에서 제품 재고 데이터는 제품 키를 기준으로 샤드(shard)로 나뉩니다. 각 샤드에는 알파벳 순으로 정렬된 연속 범위의 샤드 키((A-G 및 H-Z) 데이터가 저장되어 있습니다. 

![Horizontally partitioning (sharding) data based on a partition key](./images/data-partitioning/DataPartitioning01.png)

*그림 1. 파티션 키 기준의 수평 분할(샤딩) 데이터*

샤딩(Sharding)을 통해 더 많은 컴퓨터에서 부하를 분산시켜 경합을 줄이고 성능을 개선할 수 있습니다. 시스템을 확장하려면 추가 서버에서 실행되는 샤드를 추가합니다. 

이 분할 전략을 구현할 때 가장 중요한 요소는 샤딩 키를 선택하는 것입니다. 시스템을 작동한 후에는 키를 변경하기 어려울 수 있습니다. 키는 데이터가 분할되어 워크로드가 샤드에서 가능한 한 균등하도록 보장해야 합니다. 

다른 샤드에는 유사한 분량의 데이터가 포함되어 있어서는 안 됩니다. 그 보다 더 중요한 고려 사항은 요청 개수의 균형을 유지하는 것입니다. 일부 샤드는 매우 클 수 있지만, 각 항목은 적은 수의 액세스 작업의 제목입니다. 물론, 작은 샤드가 있을 수 있고, 각 항목은 훨씬 더 자주 액세스됩니다. 단일 샤드는 샤드를 호스팅하는 데 사용되고 있는 데이터 저장소의 규모 제한(용량 및 리소스 처리 측면)을 초과해서는 안 됩니다. 

샤딩 체계를 사용할 경우, 성능과 가용성에 영향을 줄 수 있는 핫스폿(또는 핫 파티션)을 만들지 말아야 합니다. 예를 들어, 고객 이름의 첫 번째 문자가 아닌 고객 식별자의 해시를 사용할 경우, 일반적인 머리글자와 일반적이지 않은 머리글자로 인한 배포 불균형을 방지해 줍니다. 이것은 여러 파티션에서 더 고르게 데이터를 배포하도록 해주는 일반적인 기법입니다. 

샤딩 키를 선택할 때에는 대규모 샤드를 작은 조각으로 분할하거나, 작은 샤드를 큰 파티션으로 합치거나, 파티션 집합에 저장된 데이터를 설명하는 체계를 변경하는 데 따른 향후 요구사항을 최소화해야 합니다. 이 작업은 매우 시간 소모적일 수 있고, 이 작업을 실행하는 동안 하나 이상의 샤드를 오프라인으로 전환해야 할 수도 있습니다. 

샤드를 복제하는 경우, 온라인 상태를 유지해야 하는 복제본도 있고 분할, 병합 또는 재구성해야 하는 복제본도 있습니다. 그렇지만, 이 시스템은 재구성을 실행하는 동안 이 샤드에서 실행할 수 있는 작업을 제한해야 합니다. 예를 들어, 복제본의 데이터는 읽기 전용으로 표시되어 샤드가 재구성되는 동안 발생할 수 있는 불일치 범위를 제한할 수 있습니다. 

>이 많은 고려 사항들을 비롯해, 수평 분할을 구현하는 데이터 저장소를 설계할 때의 모범 사례 기법에 대한 자세한 정보와 지침은 [샤딩 패턴]을 참조하십시오. 
>
>

### 수직 분할
수직 분할의 가장 일반적인 용도는 가장 자주 액세스하는 항목 가져오기와 관련된 I/O 및 성능 비용을 절감하는 데 있습니다. 그림 2에는 수직 분할의 예가 나와 있습니다. 이 예에서 각 데이터 항목별 속성은 파티션별로 다릅니다. 제품 이름, 설명, 가격 정보 등 자주 액세스되는 데이터를 저장한 파티션도 있고, 재고 수량과 마지막 주문 날짜를 저장한 파티션도 있습니다. 

![Vertically partitioning data by its pattern of use](./images/data-partitioning/DataPartitioning02.png)

*그림 2. 사용 패턴별 수직 분할 데이터*

이 예에서 제품 세부 정보를 고객에게 표시할 때 응용 프로그램은 제품 이름, 설명, 가격에 대해 정기적으로 쿼리합니다. 제조업체에서 제품을 마지막으로 주문했을 당시 재고 수준과 날짜는 보통 함께 사용되기 때문에 별도의 파티션에 보관됩니다. 

이 분할 체계는 비교적 유동성이 낮은 데이터(제품 이름, 설명, 가격)가 보다 동적인 데이터(재고 수준과 마지막 주문 날짜)와 분리되는 추가적인 이점이 있습니다. 응용 프로그램은 자주 액세스되는 유동성이 낮은 데이터를 메모리에 캐시하는 것이 유용할 수 있습니다. 

이 분할 전략의 또 다른 시나리오로는 중요한 데이터의 보안을 극대화하는 것입니다. 예를 들어, 신용카드 번호와 해당 카드의 보안 확인 번호를 분리된 파티션에 저장함으로써 보안을 극대화할 수 있습니다. 

또한 수직 분할은 데이터에 필요한 동시 액세스 분량을 줄여줄 수도 있습니다. 

> 수직 분할은 데이터 저장소 내에서 엔터티 수준에서 작동하면서 엔터티를 일부 정규화하여 *넓은* 항목에서 *좁은* 항목 집합으로 분해합니다. 이 분할 방식은 HBase 및 Cassandra와 같은 열 기반 데이터 저장소에 적합합니다. 열 컬렉션의 데이터가 변경될 가능성이 적으면, SQL Server에서 열 저장소를 사용하는 것을 고려해 볼 수도 있습니다. 
>
>

### 기능 분할
시스템이 응용 프로그램에서 고유한 각 비즈니스 영역이나 서비스별로 바인딩된 컨텍스트를 식별할 수 있는 경우, 기능 분할 기법은 분리 및 데이터 액세스 성능을 높여 줍니다. 기능 분할의 또 다른 일반적인 용도는 보고 목적으로 사용되는 읽기 전용 데이터에서 읽기-쓰기 데이터를 분리하는 것입니다. 그림 3은 재고 데이터가 고객 데이터와 분리되는 기능 분할에 대한 개요를 나타냅니다. 

![Functionally partitioning data by bounded context or subdomain](./images/data-partitioning/DataPartitioning03.png)

*그림 3. 바운딩된 컨텍스트 또는 하위 도메인별 기능 분할 데이터*

이 분할 전략은 시스템의 여러 부분에서 데이터 액세스 경합을 줄이는 데 도움이 될 수 있습니다. 

## 확장성을 고려한 파티션 설계
확장성을 극대화하는 방향으로 데이터를 배포하기 위해서는 각 파티션별로 크기와 워크로드를 고려하고 균형을 맞추는 것이 필수적입니다. 그렇지만, 단일 파티션 저장소의 크기 조정 한도를 초과하지 않으면서 데이터를 분할해야 합니다. 

확장성을 고려하면서 파티션을 설계할 때에는 다음 단계를 따릅니다. 

1.	응용 프로그램을 분석하여 각 쿼리에서 반환한 결과 집합 크기, 액세스 빈도, 내재된 대기 시간, 서버 측 계산 처리 요구사항과 같은 데이터 액세스 패턴을 파악합니다. 많은 경우 일부 주요 엔터티가 처리 리소스의 대부분을 요구하게 됩니다.
2.	이 분석을 사용하여 데이터의 크기 및 워크로드와 같은 현재 및 향후 확장성 목표를 결정합니다. 그런 다음, 여러 파티션에서 데이터를 배포하여 확장성 목표를 충족합니다. 균등한 배포를 위해서는 반드시 수평 분할 전략에서 적절한 샤드 키를 선택해야 합니다. 자세한 내용은 [샤딩 패턴]을 참조하십시오.
3.	각 파티션에서 사용할 수 있는 리소스는 데이터 크기와 처리량 측면에서 확장성 요구사항을 처리하기에 충분해야 합니다. 예를 들어, 파티션을 호스팅하고 있는 노드로 인해 저장소 공간의 용량, 처리 능력, 지원되는 네트워크 대역폭에 엄격한 제한이 걸릴 수도 있습니다. 데이터 저장소와 처리 요구사항이 이 제한을 초과할 경우, 분할 전략을 정비하거나 데이터를 추가로 분할할 수도 있습니다. 예를 들어, 한 가지 확장성 접근 방식은 로깅 데이터를 핵심 응용 프로그램 기능과 분리하는 것입니다. 이 작업을 하려면 별도의 데이터 저장소를 사용하여 전체 데이터 저장소 요구사항이 노드의 확장 제한을 초과하지 않도록 해야 합니다. 데이터 저장소의 전체 개수가 노드 제한을 초과할 경우, 별도의 저장소 노드를 사용해야 할 수도 있습니다.
4.	데이터가 예상대로 배포되고 파티션이 자체 부하를 처리할 수 있는지 확인하기 위해 용도에 따라 시스템을 모니터링합니다. 사용 현황은 분석에 따라 예상되는 사용 현황과 일치하지 않을 수도 있습니다. 이 경우에 파티션 균형을 재조정할 수도 있습니다. 이 작업에 실패하면, 시스템의 일부 부분을 재설계하여 필요한 균형을 확보할 수도 있습니다.

일부 클라우드 환경은 인프라 경계 관점에서 리소스를 할당합니다. 선택한 경계 한도는 데이터 저장소, 처리 능력 및 대역폭 측면에서 데이터 볼륨을 예상대로 증가시킬 수 있는 여지가 있어야 합니다. 

예를 들어 Azure 테이블 저장소를 사용하는 경우, 사용 중인 샤드는 요청을 처리하기 위해 단일 파티션에서 사용할 수 있는 것보다 더 많은 리소스가 필요할 수 있습니다. (특정 기간 동안 단일 파티션에서 처리 가능한 요청 볼륨에는 제한이 있습니다. 자세한 내용은 Microsoft 웹사이트에서 [Azure 저장소 확장성 및 성능 목표] 페이지를 참조하십시오.

 이 경우에 샤드를 다시 분할하여 부하를 분산시켜야 할 수도 있습니다. 이 테이블의 전체 크기나 처리량이 저장소 계정의 용량을 초과하는 경우, 추가 저장소 계정을 만들고 이 계정에서 테이블을 분산시켜야 합니다. 저장소 계정 개수가 1회 구독 시 사용 가능한 계정 개수를 초과하는 경우, 여러 번 구독해야 합니다. 

## 쿼리 성능을 고려한 파티션 설계
쿼리 성능은 흔히 소량 데이터 집합을 사용하고 병렬 쿼리를 실행하여 강화할 수 있습니다. 각 파티션은 전체 데이터 집합 중 적은 비율을 포함해야 합니다. 볼륨을 줄이면 쿼리 성능이 개선됩니다. 그렇지만, 분할은 데이터베이스를 설계하고 구성할 수 있는 대체 방안이 아닙니다. 예를 들어, 관계형 데이터베이스를 사용하고 있는 경우 필요한 인덱스를 지정해야 합니다. 

쿼리 성능을 고려하면서 파티션을 설계할 때에는 다음 단계를 따릅니다. 

1.	다음과 같이 응용 프로그램 요구사항과 성능을 점검합니다.
•	비즈니스 요구사항을 사용하여 항상 빠르게 실행해야 하는 필수 쿼리를 결정합니다.

•	시스템을 모니터링하여 천천히 실행되는 모든 쿼리를 식별합니다.

•	가장 자주 실행되는 쿼리를 설정합니다. 각 쿼리의 단일 인스턴스는 비용을 최소화하면서도 리소스의 누적 사용량은 클 수 있습니다. 이들 쿼리에 의해 검색된 별도의 파티션이나 캐시 안에 따로 분리시키는 것이 유용합니다.

2.	다음과 같이 성능을 저하시키는 데이터를 분할합니다.
•	쿼리 응답 시간이 목표 내에 들어오도록 각 파티션 크기를 제한합니다.

•	수평 분할을 구현하는 경우 응용 프로그램이 파티션을 쉽게 찾을 수 있도록 샤드 키를 설계합니다. 그러면 쿼리가 모든 파티션을 스캔할 필요가 없습니다.

•	파티션의 위치를 고려합니다. 가능한 한 응용 프로그램과 이 응용 프로그램에  액세스하는 사용자와 지리적으로 가까운 곳에 있는 파티션에 데이터를 보관해야 합니다.

3.	엔터티에 처리량 및 쿼리 성능 요구사항이 있으면, 해당 엔터티 기반의 기능 분할을 사용합니다. 하지만 그래도 이 요구사항에 계속 부합하지 않으면, 수평 분할도 적용합니다. 대다수의 경우 단일 분할 전략으로 충분하지만, 경우에 따라서는 두 가지 전략을 조합하는 것이 더 효율적입니다.
4.	성능을 개선하려면 여러 파티션에서 동시에 실행되는 비동기 쿼리를 사용하는 것이 좋습니다.

## 가용성을 고려한 파티션 설계
분할 데이터를 통해 응용 프로그램의 가용성을 개선하려면 전체 데이터 집합에 단일 장애 지점이 포함되지 않고 데이터 집합의 개별 하위 집합이 독립적으로 관리될 수 있도록 보장해야 합니다. 필수 데이터를 포함하는 파티션 복제도 가용성을 개선할 수 있습니다. 

파티션을 설계하고 구현할 때에는 가용성에 영향을 주는 다음 요소를 고려해야 합니다. 

* **비즈니스 작업에서 데이터의 중요도**. 일부 데이터에는 송장 세부 정보 및 은행 거래 내역과 같은 중요한 비즈니스 정보가 포함되기도 하고, 로그 파일, 성능 추적 등 중요도가 낮은 운영 데이터가 포함되기도 합니다. 각 데이터 형식을 확인한 후 다음 사항을 고려해야 합니다.
o	적절한 백업 계획이 지원되는 고가용성 파티션에 중요 데이터 저장.

o	각 데이터 집합의 서로 다른  중요도에 맞게 별도의 관리 및 모니터링 메커니즘이나 절차 수립. 적절한 빈도로 함께 백업할 수 있도록 동일한 파티션에 중요도가 동일한 데이터 배치. 예를 들어, 은행 거래용 데이터를 저장한 파티션은 로깅이나 추적 정보를 저장한 파티션보다 더 자주 백업해야 합니다.

* **개별 파티션을 관리하는 방법**. 독립적인 관리와 유지 관리를 지원하는 파티션을 설계하면 여러 장점이 있습니다. 예:
o	파티션에 오류가 발생하면, 다른 파티션의 데이터에 액세스하는 응용 프로그램의 인스턴스에 영향을 주지 않고 독립적으로 복구할 수 있습니다.

o	지리적 영역별로 데이터를 분할하면 예정된 유지 관리 작업이 각 위치별로 사용량이 적은 시간에 진행됩니다. 이 기간 중에 예정된 유지 관리를 완료하지 못할 정도로 파티션이 너무 커서는 안 됩니다.

* **여러 파티션에서 중요 데이터의 복제 여부**. 이 전략은 일관성 문제를 발생시킬 수 있지만 가용성과 성능을 높여 줍니다. 파티션의 데이터에 적용된 변경 내용이 모든 복제본과 동기화되기까지는 다소 시간이 걸립니다. 이 기간 중에 다른 파티션은 다른 데이터 값을 포함합니다.

## 분할이 설계와 개발에 미치는 영향 파악
분할을 사용하면 시스템 설계와 개발에 따른 복잡성이 커집니다. 시스템이 처음에 단일 파티션만을 포함하더라도 시스템 설계의 기본 부분으로서 분할을 고려해야 합니다. 분할을 나중에 추가하게 된 경우, 시스템에 성능 및 확장성 문제가 발생하면 이미 실행간 시스템을 유지해야 하기 때문에 복잡성이 커집니다.

시스템이 이 환경에서 분할을 포함하도록 업데이트하는 경우, 데이터 액세스 논리를 수정해야 합니다. 또한 대량의 기존 데이터를 마이그레이션하여 여러 파티션에서 배포할 수도 있고, 이와 동시에 사용자는 흔히 시스템을 계속 사용할 수 있을 것으로 예상합니다. 

경우에 따라서는 초기 데이터 집합이 작으며 단일 서버로 쉽게 처리할 수 있기 때문에 분할이 중요하게 고려되지 않습니다. 이것은 초기의 크기 이상으로 확장할 것으로 예상되지 않는 시스템의 경우에 적용되지만, 많은 상업용 시스템은 사용자 수 증가에 따라 확장해야 합니다. 이러한 확장에는 보통 데이터 볼륨 증가가 동반됩니다. 

또한 분할이 항상 대형 데이터 저장소의 기능이 아님을 이해해야 합니다. 예를 들어, 작은 데이터 저장소를 수백 개의 동시 클라이언트가 과도하게 액세스할 수도 있습니다. 이 상황에서 데이터를 분할하면 경합을 줄이고 처리량을 개선할 수 있습니다.

데이터 분할 체계를 설계할 때에는 다음 사항에 유의해야 합니다. 

* **가능한 경우, 각 파티션에 가장 많이 사용되는 데이터베이스 작업용 데이터를 보관하여 교차 파티션 액세스 작업을 최소화합니다**. 여러 파티션에서 쿼리를 진행하면 단일 파티션의 쿼리보다 시간이 더 소요될 수 있지만, 하나의 쿼리 집합에서 파티션을 최적화하면 다른 쿼리 집합에 부정적인 영향을 줄 수 있습니다. 어쩔 수 없이 여러 파티션에서 쿼리해야 하는 경우 응용 프로그램 내에서 병렬 쿼리를 실행하고 결과를 집계하여 쿼리 시간을 최소화합니다. 이 접근 방식은 하나의 쿼리에서 결과를 가져와 다음 쿼리에서 사용하는 경우 등 경우에 따라 불가능할 수 있습니다.
* **쿼리가 우편 번호 테이블이나 제품 목록과 같은 비교적 정적 참조 데이터를 사용하는 경우, 모든 파디션에서 이 데이터를 복제하여 다른 파티션에서 별도의 조회 작업 요구사항을 줄여야 합니다**. 또한, 이 접근 방식은 참조 데이터가 전체 시스템에서 많은 트래픽을 발생시킬 수 있는 "핫" 데이터 집합이 될 가능성을 낮출 수 있습니다.  그렇지만, 발생 가능한 모든 변경 내용을 이 참조 데이터와 동기화할 때 관련 비용이 추가됩니다.
* **가능한 경우, 수직 및 기능 파티션에서 참조 무결성의 요구사항을 최소화합니다**. 이 체계에서 응용 프로그램은 데이터가 업데이트 및 소비되면 전체 파티션에서 직접 참조 무결성을 유지해야 합니다. 여러 파티션에서 데이터를 조인해야 하는 쿼리는 동일한 파티션 내에서만 데이터를 조인하는 쿼리보다 더 느리게 실행됩니다. 왜냐하면, 일반적으로 응용 프로그램은 키와 외래 키 순서로 연속 쿼리를 실행하기 때문입니다. 그 대신, 관련 데이터의 복제나 비정규화를 고려해야 합니다. 교차 파티션 조인이 필요한 쿼리 시간을 최소화하려면, 파티션에서 쿼리를 실행하고 응용 프로그램 내에서 데이터를 조인해야 합니다.
* **분할 체계가 파티션 전체의 데이터 일관성에 미칠 수 있는 영향을 고려합니다.** 철저한 일관성이 실제로 꼭 필요한지 여부를 평가합니다. 그 대신, 클라우드에서 일반적인 접근 방식은 최종 일관성을 구현하는 것입니다. 각 파티션에서 데이터는 개별적으로 업데이트되고, 응용 프로그램 논리는 업데이트를 모두 완료하도록 보장합니다. 또한, 결국 일관된 작업을 실행하는 동안 데이터를 쿼리하면서 발생할 수 있는 불일치를 처리합니다. 최종 일관성에 대한 자세한 내용은 [데이터 일관성 프라이머]를 참조하십시오.
* **쿼리가 올바른 파티션을 찾는 방법을 고려합니다**. 쿼리가 모든 파티션을 스캔하여 필요한 데이터를 찾아야 하면, 여러 병렬 쿼리를 실행하고 있더라도 성능에 상당한 영향을 주게 됩니다. 수직 및 기능 분할 전략에서 사용되는 쿼리는 당연히 파티션을 지정할 수 있습니다. 그렇지만, 수평 분할(샤딩)은 모든 샤드의 체계가 동일하기 때문에 항목을 찾기 어렵게 만들기도 합니다. 샤딩에서 일반적인 해결책은 데이터의 특정 항목에서 샤드 위치를 찾는 데 사용할 수 있는 맵을 유지하는 것입니다. 이 맵은 응용 프로그램의 샤딩 논리에서 구현되거나 데이터 저장소가 투명한 샤딩을 지원하는 경우 이 데이터 저장소를 통해 유지됩니다.
* **수평 분할 전략을 사용할 때에는 정기적으로 샤드 균형을 다시 맞춰야 합니다**. 이 작업을 통해 크기 및 워크로드별로 데이터를 균일하게 배포하여 핫스폿을 최소화하고, 쿼리 성능을 극대화하고, 물리적 저장소 제한을 잘 처리할 수 있습니다. 그렇지만, 이 작업은 흔히 사용자 지정 도구나 프로세스를 사용해야 하기 때문에 복잡합니다.
* **각 파티션을 복제하는 경우, 오류 발생을 차단해 주는 추가 보호 장치가 마련됩니다**. 단일 복제본에 오류가 발생하면, 쿼리가 실행 중인 복사본으로 전달될 수 있습니다.
* **분할 전략의 물리적 제한에 도달하면, 확장성을 다양한 수준으로 넓혀야 할 수도 있습니다**. 예를 들어, 분할이 데이터베이스 수준인 경우 여러 데이터베이스에서 파티션을 찾거나 복제해야 합니다. 분할이 이미 데이터베이스 수준이고 물리적 제한에 대한 문제가 생기면 여러 호스팅 계정에서 파티션을 찾거나 복제해야 합니다.
* **여러 파티션에서 데이터에 액세스하는 트랜잭션을 차단합니다**. 일부 데이터 저장소는 단일 파티션에서 데이터를 찾을 때에만 데이터를 수정하는 작업에서 트랜잭션 일관성과 무결성을 구현합니다. 여러 파티션에서 트랜잭션 지원이 필요한 경우, 대다수 분할 시스템은 기본 지원을 제공하지 않기 때문에 응용 프로그램 논리의 일부로서 이것을 구현해야 합니다.

모든 데이터 저장소는 운영 관리 및 모니터링 활동을 필요로 합니다. 이 작업은 데이터 로드에서부터 데이터 백업 및 복원, 데이터 재구성, 시스템의 올바르고 효율적인 실행 보장에 이르기까지 포괄적입니다. 

운영 관리에 영향을 주는 다음 요소를 고려해야 합니다. 

* **데이터를 분할할 때 적절한 관리와 운영 작업을 구현하는 방법**. 이 작업에는 백업과 복원, 데이터 보관, 시스템 모니터링 등 여타 관리 작업이 포함됩니다. 예를 들어, 백업과 복원 작업 중에 논리 일관성을 유지하는 일이 문제가 될 수 있습니다.
* **데이터를 여러 파티션에 로드하고 다른 소스에서 오는 새 데이터를 추가하는 방법**. 일부 도구와 유틸리티는 데이터를 올바른 파티션에 로드하는 작업 등 샤딩된 데이터 작업을 지원하지 않을 수도 있습니다. 즉, 새 도구와 유틸리티를 만들거나 가져와야 할 수도 있습니다.
* **정기적으로 데이터를 보관하고 삭제하는 방법**. 과도한 파티션 증가를 방지하려면, 정기적으로(보통월 단위로) 데이터를 보관하고 삭제해야 합니다. 각기 다른 보관 체계에 맞게 데이터를 변환해야 할 수도 있습니다.
* **데이터 무결성 문제를 찾는 방법**. 한 파티션의 데이터가 다른 파티션의 누락된 정보를 참조하는 경우 등 데이터 무결성 문제를 찾는 정기적인 프로세스를 실행하는 것을 고려해 보십시오. 이 프로세스에서 이 문제를 자동으로 수정하거나 작업자에게 경고를 보내 문제를 직접 수정하도록 할 수 있습니다. 예를 들어, 전자 상거래 응용 프로그램에서 주문 정보는 하나의 파티션에 저장될 수 있지만 각 주문을 구성하는 품목은 다른 파티션에 저장될 수 있습니다. 주문 프로세스는 데이터를 다른 파티션에 추가해야 합니다. 이 프로세스가 실패하면, 해당 주문이 없는 줄 항목에 저장될 수 있습니다.

다른 데이터 저장소 기술은 일반적으로 분할을 지원하는 자체 기능을 내장하고 있습니다. 다음 섹션에서는 Azure 응용 프로그램에서 많이 사용되는 데이터 저장소의 실행 옵션에 대해 간략하게 알아봅니다. 또한, 이 기능을 최대한 활용할 수 있는 응용 프로그램 설계 시 고려 사항에 대해서도 설명합니다. 

## Azure SQL Database에 적합한 분할 전략
Azure SQL Database는 클라우드에서 실행되는 관계형 DaaS(database-as-a-service) 데이터베이스로서 Microsoft SQL Server를 기반으로 합니다. 관계형 데이터베이스는 정보를 테이블로 나누고, 각 테이블에 엔터티에 대한 정보를 일련의 행으로 보관합니다. 각 행에는 개별 엔터티 필드에 대한 데이터가 있는 열이 포함되어 있습니다. Microsoft 웹사이트의 [Azure SQL Database란?] 페이지에는 SQL 데이터베이스 만들기와 사용에 대한 세부 설명서가 나와 있습니다. 

## Elastic Database를 사용한 수평 분할
단일 SQL 데이터베이스는 저장할 수 있는 데이터의 용량에 제한이 있습니다. 처리량은 구조적인 요소와 지원되는 많은 수의 동시 연결로 인해 제약을 받습니다. SQL Database의 Elastic Database 기능은 SQL 데이터베이스의 수평 크기 조정을 지원합니다. Elastic Database를 사용하면, 데이터를 샤드로 분할하여 여러 SQL 데이터베이스에 분산시킬 수 있습니다. 또한 증가와 감소를 처리해야 하는 데이터 볼륨으로서 샤드를 추가 또는 제거할 수도 있습니다. Elastic Database를 사용하면 데이터베이스에서 부하를 분산시켜 경합을 줄이는 데도 도움이 됩니다. 

> [!참고]
Elastic Database는 Azure SQL Database의 Federations 기능을 대체할 수 있는 기능입니다. 기존 SQL Database Federation 설치는 Federations 마이그레이션 유틸리티를 사용하여 Elastic Database로 마이그레이션할 수 있습니다. 그렇지 않고, 시나리오가 Elastic Database가 제공하는 기능에 잘 부합하지 않는 경우 자체 샤딩 메커니즘을 구현하는 방법도 있습니다. 
>
>

각 샤드는 SQL 데이터베이스로서 구현됩니다. 샤드는 2개 이상의 데이터 집합 (*샤들렛[shardlet]*이라고 함)을 가질 수 있습니다. 각 데이터베이스는 각각 갖고 있는 샤들렛에 대해 설명된 메타데이터를 유지합니다. 샤들렛은 단일 데이터 항목이거나 동일한 샤들렛 키를 공유하는 항목 그룹입니다. 예를 들어, 다중 테넌트 응용 프로그램의 데이터를 샤딩하는 경우, 샤들렛 키는 테넌트 ID일 수 있고, 지정된 테넌트의 모든 데이터는 동일한 샤들렛의 일부로 저장될 수 있습니다. 다른 테넌트의 데이터는 각기 다른 샤들렛에 저장됩니다. 

데이터 집합을 샤들렛 키와 연결하는 것은 프로그래머의 책임입니다. 별도의 SQL 데이터베이스는 전역 샤드 맵 관리자 역할을 합니다. 이 데이터베이스에는 시스템에 있는 모든 샤드와 샤들렛 목록이 들어 있습니다. 데이터에 액세스하는 클라이언트 응용 프로그램은 먼저 전역 샤드 맵 관리자 데이터베이스에 연결되어 샤드 맵(샤드와 샤들렛 열거) 복사본을 가져온 후 로컬에서 캐시합니다. 

그런 다음 이 응용 프로그램은 이 정보를 사용해 데이터 요청을 적절한 샤드에 전달합니다. 이 기능은 NuGet 패키지로 출시된 Azure SQL Database Elastic Database Client Library에 포함된 일련의 API 뒤에 숨겨져 있습니다. Microsoft 웹사이트의 [Elastic Database 기능 개요] 페이지에는 Elastic Database에 대한 보다 포괄적인 소개가 나와 있습니다.

> [!참고]
> 전역 샤드 맵 관리자 데이터베이스를 복제하여 대기 시간을 줄이고 가용성을 개선할 수 있습니다. Premium 가격대를 사용해 데이터베이스를 구현할 경우 활성 지리적 복제를 구성하여 데이터를 다른 지역의 데이터베이스로 연속 복사할 수 있습니다. 사용자 기반의 각 영역에 데이터베이스 복사본을 만듭니다. 그런 다음 응용 프로그램을 구성하여 이 복사본에 연결하여 샤드 맵을 가져옵니다. 
>
> 대안은 Azure SQL Data Sync 또는 Azure Data Factory 파이프라인을 사용하여 전 영역에서 샤드 맵 관리자 데이터베이스를 복제하는 것입니다. 이 복제 양식은 정기적으로 실행되고 샤드 맵이 드물게 바뀌는 경우에 더 적합합니다. 물론, 샤드 맵 관리자 데이터베이스는 Premium 가격대를 사용해 만들지 않아도 됩니다. 
>
>

Elastic Database는 데이터를 샤들렛에 매핑하고 이 데이터를 샤드에 저장하는 두 가지 체계를 갖추고 있습니다. 

* **목록 샤드 맵**은 단일 키와 샤들렛 사이의 연관성을 잘 보여줍니다. 예를 들어, 다중 테넌트 시스템에서 각 테넌트별 데이터는 고유 키와 연결되어 자체 샤들렛에 저장되어 있을 수 있습니다. 개인 정보와 격리(즉, 하나의 테넌트가 다른 테넌트가 사용 가능한 데이터 저장소 리소스를 소모하지 못하도록 함)를 보장하기 위해 각 샤들렛은 자체 샤드에 저장될 수 있습니다.

![Using a list shard map to store tenant data in separate shards](./images/data-partitioning/PointShardlet.png)

*그림 4. 목록 샤드 맵을 사용하여 별도의 샤드에 테넌트 데이터 저장*

* **범위 샤드 맵**은 단일 키와 샤들렛 사이의 연관성을 잘 보여줍니다. 앞서 설명한 다중 테넌트 예에서 전용 샤들렛을 구현하는 대안으로서 동일한 샤들렛 내에서 테넌트 집합(각각 자체 키가 있음)의 데이터를 그룹화할 수 있습니다. 이 체계는 첫 번째보다 비용이 저렴하지만(테넌트가 데이터 저장소 리소스를 공유하기 때문), 데이터 개인정보와 격리 기능을 감소시킬 위험이 있습니다.

![Using a range shard map to store data for a range of tenants in a shard](./images/data-partitioning/RangeShardlet.png)

*그림 5. 범위 샤드 맵을 사용하여 샤드에 다양한 테넌트용 데이터 저장*

단일 샤드는 여러 샤들렛의 데이터를 포함한다는 것을 기억하십시오. 예를 들어, 목록 샤들렛을 사용하여 동일한 샤드에서 다른 비인접 테넌트를 저장할 수 있습니다. 또한 동일한 샤드에서 범위 샤들렛과 목록 샤들렛을 혼합할 수 있지만, 이것은 전역 샤드 맵 관리자 데이터베이스에서 다른 맵을 통해 처리됩니다. (전역 샤드 맵 관리자 데이터베이스에는 다중 샤드 맵이 포함될 수 있습니다.) 그림 6은 이 접근 방식을 나타냅니다. 

![Implementing multiple shard maps](./images/data-partitioning/MultipleShardMaps.png)

*그림 6. 다중 샤드 맵 구현*

구현한 분할 체계는 시스템 성능과 상당한 관련이 있을 수 있습니다. 또한 샤드를 추가 또는 제거해야 하는 속도나 샤드에서 데이터가 다시 분할되어야 하는 속도에 영향을 줄 수도 있습니다. Elastic Database를 사용하여 데이터를 분할할 때에는 다음 사항을 고려해야 합니다.

•	동일한 샤드에서 함께 사용되는 데이터를 그룹화하고 여러 샤드에 저장된 데이터에 액세스해야 하는 작업을 하지 않아야 합니다. Elastic Database를 사용할 때 샤드는 자체 SQL 데이터베이스이고, Azure SQL Database는 교차 데이터베이스 조인(클라이언트 측에서 실행해야 함)을 지원하지 않습니다. 또한 Azure SQL Database에서는 하나의 데이터베이스의 참조 무결성 제약, 트리거, 저장된 절차는 다른 데이터베이스의 개체를 참조할 수 없다는 것을 기억하십시오. 그러므로, 샤드 간 종속성이 있는 시스템을 설계해서는 안 됩니다. 그렇지만, SQL 데이터베이스는 쿼리와 다른 작업에 자주 사용되는 참조 데이터 복사본을 저장한 테이블을 포함합니다. 이 테이블은 특정 샤들렛에 속하지 않습니다. 샤드에서 이 데이터를 복제하면 여러 데이터베이스에 걸쳐 있는 데이터를 조인하지 않아도 됩니다. 사실상 이러한 데이터는 정적이거나 유동성이 낮아서 복제 작업을 최소화하고 이 데이터가 부실하게 될 가능성을 낮추게 됩니다.

  > [!참고]
  > SQL Database는 교차 데이터베이스 조인을 지원하지 않지만, Elastic Database API를 통해 교차 사드 쿼리를 실행할 수 있습니다. 이 쿼리는 샤드 맵이 참조하는 모든 샤들렛에 저장된 데이터를 통해 투명하게 반복될 수 있습니다. Elastic Database API는 교차 샤드 쿼리를 일련의 개별 쿼리(각 데이터베이스별로 하나씩)로 나눈 후 그 결과를 병합합니다. 자세한 내용은 Microsoft 웹사이트의 [다중 샤드 질의]페이지를 참조하십시오.
  >
•	동일한 샤드 맵에 속한 샤들렛에 저장된 데이터는 그 체계가 동일해야 합니다. 예를 들어, 테넌트 데이터를 포함하는 일부 샤들렛을 가리키는 목록 샤드 맵과 제품 정보를 포함하는 다른 샤들렛을 만들어서는 안 됩니다. Elastic Database이 이 규칙을 강제적으로 실행하지는 않지만, 각 샤들렛의 체계가 다를 경우 데이터 관리 및 질의가 매우 복잡해집니다. 바로 앞서 언급한 예에서 한 가지 좋은 해결책은 목록 샤드 맵 2개를 만드는 것입니다. 즉, 하나는 테넌트 데이터를 참조하고 다른 하나는 제품 정보를 가리키는 것입니다. 다른 샤들렛에 속하는 데이터는 동일한 샤드에 저장할 수 있다는 점을 명심해야 합니다.

  > [!참고]
  > Elastic Database API의 교차 샤드 쿼리 기능은 동일한 체계를 포함하는 샤드 맵의 각 샤들렛에 따라 달라집니다.
  >
  >
•	동일한 샤드 내에 저장된 데이터의 경우에 트랜잭션 작업이 지원되고, 전체 샤드에서는 지원되지 않습니다. 트랜잭션은 샤들렛이 동일한 샤드의 일부인 경우에 한해 샤들렛을 포함할 수 있습니다. 그러므로, 비즈니스 논리가 트랜잭션을 실행해야 하는 경우, 동일한 샤드에 해당 데이터를 저장하거나 최종 일관성을 구현해야 합니다. 자세한 내용은 [데이터 일관성 프라이머턴]을 참조하십시오.

•	해당 샤드의 데이터에 액세스하는 사용자와 가까운 곳에 샤드를 배치합니다(샤드의 지리적 배치). 이 전략은 대기 시간을 줄이는 데 유용합니다.

•	자주 사용되는 샤드(핫스폿)와 비교적 잘 사용되지 않는 샤드를 혼합하여 사용해서는 안 됩니다. 전체 샤드에서 부하를 균등하게 분산시켜야 합니다. 그러기 위해서는 샤들렛 키를 해싱해야 합니다.

•	샤드를 지리적으로 배치할 경우 해싱된 키는 해당 데이터에 액세스하는 사용자와 가까이에 저장된 샤드에 있는 샤들렛에 매핑되어야 합니다.

•	현재 제한적인 SQL 데이터 형식 집합 *(int, bigint, varbinary,uniqueidentifier)*만이 샤들렛 키로서 지원됩니다. SQL *int* 및 *bigint* 유형은 C#에서 *int* 및 *long* 데이터 형식에 해당되고, 범위가 동일합니다. SQL *varbinary* 유형은 C#의 *Byte* 배열을 사용해 처리할 수 있고, SQL *uniqueidentier* 유형은 .NET Framework의 *Guid* 클래스에 해당됩니다.

이름에서 알 수 있듯이 Elastic Database는 데이터 볼륨 감소와 증가에 따라 시스템이 샤드를 추가하고 제거할 수 있도록 해줍니다. Azure SQL Database Elastic Database 클라이언트 라이브러리의 API를 통해 응용 프로그램은 샤드를 동적으로 만들고 삭제할 수 있습니다(그리고 샤드 맵 관리자를 투명하게 업데이트함). 그렇지만, 샤드를 제거하는 일은 해당 샤드의 모든 데이터를 삭제해야 하는 상당한 손해를 유발하는 작업입니다. 

응용 프로그램이 샤드를 개별 샤드 2개로 분할하거나 샤드를 결합해야 하는 경우, Elastic Database는 별도의 분할-병합 서비스를 제공합니다. 이 서비스는 클라우드 호스팅 서비스에서 실행되고(개발자가 만들어야 함) 샤드 간 데이터를 안전하게 마이그레이션합니다.자세한 내용은 Microsoft 웹사이트에서[Elastic Database 분할-병합 도구를 사용한 크기 조정] 항목을 참조하십시오. 

## Azure 저장소에 적합한 분할 전략
Azure 저장소는 데이터 관리를 위한 추상화 세 가지를 지원합니다. 

•	하나는 테이블 저장소로서 확장 가능한 구조 저장소를 구현합니다. 테이블에는 엔터티 컬렉션이 포함되어 있고, 각 엔터티는 속성과 값 집합을 포함할 수 있습니다.

•	다른 하나는 Blob 저장소로서, 대규모 개체와 파일을 위한 저장소입니다.

•	또 다른 하나는 저장소 큐로서, 응용 프로그램 간에 안정적인 비동기식 메시징을 지원합니다.
 

테이블 저장소와 blob 저장소는 본래 키-값 저장소이며, 이것은 구조적인 데이터와 비구조적인 데이터를 각각 저장하도록 최적화되어 있습니다. 저장소 큐는 느슨하게 결합되어 있는 확장 가능 응용 프로그램을 구축하는 메커니즘을 지원합니다. 테이블 저장소, blob 저장소, 저장소 큐는 Azure 저장소 계정의 컨텍스트 내에서 만들어집니다. 저장소 계정은 다음 세 가지 형태의 중복을 지원합니다. 

* **로컬 중복 저장소**, 단일 데이터 센터에서 데이터 복사본 3개를 유지합니다. 이 중복 형태는 하드웨어 오류가 발생해도 보호되지만 전체 데이터 센터까지 영향을 주는 재해에는 보호되지 않습니다.
* **영역 중복 저장소**, 동일한 지역(또는 지역적으로 가까운 두 개의 지역)에 있는 여러 데이터 센터에 분포된 데이터 복사본 3개를 유지합니다. 이 중복 형태는 단일 데이터 센터에서 발생하는 재해로부터 보호되지만, 전체 지역에 영향을 주는 대규모 네트워크 연결이 끊길 경우에는 보호될 수 없습니다. 영역 중복 저장소는 현재 블록 blob에서만 사용할 수 있습니다.
* **지역 중복 저장소**, 데이터 복사본 6개를 유지하며, 이 중 복사본 3개는 하나의 지역(사용자의 로컬 지역)에, 다른 3개는 먼 지역에 유지합니다. 이 중복 형태는 재해 보호 수준이 가장 높습니다.

Microsoft는 Azure 저장소의 확장성 목표를 공개했습니다. 자세한 내용은 Microsoft 웹사이트의 [Azure 저장소 확장성 및 성능 목표]를 참조하십시오. 현재 저장소의 계정 총 용량은 500TB를 초과할 수 없습니다. (여기에는 테이블 저장소와 blob 저장소에 저장된 데이터 크기뿐 아니라 저장소 큐에 저장된 해결되지 않은 메시지도 포함됩니다). 

최대 요청 속도(1-KB 엔터티, blob 또는 메시지 크기 가정)는 20KBps입니다. 시스템이 이 한계를 초과할 가능성이 있으면, 여러 저장소 계정에서 부하를 분할하는 것이 좋습니다. 단일 Azure 구독은 최대 100개의 저장소 계정을 만들 수 있습니다. 그렇지만, 이 한계는 시간의 경과에 따라 바뀔 수 있습니다. 

## 분할 Azure 테이블 저장소
Azure 테이블 저장소는 분할을 중심으로 설계된 키-값 저장소입니다. 모든 엔터티는 파티션에 저장되고, 파티션은 Azure 테이블 저장소를 통해 내부적으로 관리됩니다. 테이블에 저장되는 각 엔터티는 다음을 포함하는 2파트 키를 제공해야 합니다. 

* **파티션 키**. 이것은 파티션 Azure 테이블 저장소가 엔터티를 배치하는 위치를 결정하는 문자열 값입니다. 파티션 키가 동일한 모든 엔터티는 동일한 파티션에 저장됩니다.
* **행 키**. 파티션 내에서 엔터티를 식별하는 다른 문자열 값입니다. 파티션에 있는 모든 엔터티가 이 키별로 오름차순으로 사전식으로 정렬됩니다. 이 파티션 키/행 키 조합은 각 엔터티별로 고유해야 하고 그 길이는 1KB를 초과해서는 안 됩니다.

엔터티의 나머지 데이터는 응용 프로그램 정의 필드로 구성되어 있습니다. 어느 특정 체계를 실행할 수 없고, 각 행에는 다양한 응용 프로그램 정의 필드 집합을 포함할 수 있습니다. 유일한 제한은 엔터티의 최대 크기(파티션 및 행 키 포함)가 현재 1MB라는 점입니다. 테이블의 최대 크기는 200TB이며, 이 수치는 향후 변경될 수 있습니다. (이 제한에 대한 최신 정보는 Microsoft 웹사이트에서 [Azure 저장소 확장성 및 성능 목표] 페이지를 확인하십시오.) 

이 용량을 초과하는 엔터티를 저장할 경우, 엔터티를 여러 테이블로 분할하는 것이 좋습니다. 수직 분할을 사용해 함께 액세스할 가능성이 높은 여러 그룹으로 필드를 나눕니다.

그림 7은 가상 전자 상거래 응용 프로그램에서 저장소 계정(Contoso Data)의 논리 구조의 예를 보여줍니다. 저장소 계정에는 고객 정보, 제품 정보 및 주문 정보의 3가지 테이블이 포함되어 있습니다. 각 테이블에는 여러 파티션이 있습니다. 

고객 정보 테이블에서 데이터는 고객이 거주하는 도시에 따라 분할되고, 행 키는 고객 ID를 포함합니다. 제품 정보 테이블에서 제품은 제품 카테고리별로 분할되고, 행 키는 제품 번호를 포함합니다. 주문 정보 테이블에서 주문은 주문 날짜별로 분할되고, 행 키는 주문을 받은 시간을 명시합니다. 모든 데이터는 각 파티션에서 행 키별로 정렬됩니다.

![The tables and partitions in an example storage account](./images/data-partitioning/TableStorage.png)

*그림 7. 저장소 계정 예의 테이블과 파티션*

> [!참고]
> Azure 테이블 저장소는 각 엔터티에 타임스탬프 필드를 추가합니다. 타임스탬프 필드는 테이블 저장소를 통해 유지되고 엔터티를 수정하고 파티션에 다시 작성할 때마다 업데이트됩니다. 테이블 저장소 서비스는 이 필드를 사용해 낙관적 동시성을 구현합니다. (응용 프로그램이 엔터티를 테이블 저장소에 다시 작성할 때마다 테이블 저장소 서비스는 작성 중인 엔터티에서 타임스탬프의 값을 테이블 저장소에 저장된 값과 비교합니다. 이들 값이 다르면 마지막 검색 이후로 다른 응용 프로그램이 이 엔터티를 수정했고 쓰기 작업에 실패했다는 것입니다. 자체 코드로 이 필드를 수정하지 말고, 새 엔터티를 만들 때 이 필드의 값을 지정하지 마십시오. 
>
>

Azure 테이블 저장소는 파티션 키를 사용해 데이터 저장 방법을 결정합니다. 이전에 사용하지 않은 파티션 키로 엔터티를 테이블에 추가하면, Azure 테이블 저장소는 이 엔터티를 위한 새 파티션을 만듭니다. 파티션 키가 동일한 다른 엔터티는 동일한 파티션에 저장됩니다. 

이 메커니즘은 자동 확장 전략을 효과적으로 구현합니다. Azure 데이터 센터의 단일 서버에 각 파티션이 저장되므로 단일 파티션에서 데이터를 검색하는 쿼리가 빠르게 실행됩니다. 그렇지만, 다양한 파티션이 여러 서버에서 배포될 수 있습니다. 또한, 단일 서버는 파티션 크기가 제한적인 경우에 이 여러 파티션을 호스팅할 수 있습니다. 

Azure 테이블 저장소에 적합한 엔터티를 설계할 때에는 다음 사항을 고려해야 합니다. 

•	파티션 키와 행 키 값 선택은 데이터가 액세스하는 방식으로 진행되어야 합니다. 대다수 쿼리를 지원하는 파티션 키/행 키 조합을 선택합니다. 가장 효율적인 쿼리는 파티션 키와 행 키를 지정하여 데이터를 검색하는 것입니다. 파티션 키와 행 키 범위를 지정하는 쿼리는 단일 파티션을 스캔하여 완료할 수 있습니다. 데이터가 행 키 순서로 저장되어 있기 때문에 이 작업은 비교적 신속하게 끝납니다. 쿼리가 스캔할 파티션을 지정하지 않은 경우, 파티션 키는 Azure 테이블 저장소가 데이터에 적합한 모든 파티션을 스캔하도록 해야 할 수도 있습니다.

  > [!팁]
  > 엔터티에 자연 키가 있으면, 이것을 파티션 키로 사용하고 빈 문자열을 행 키로 지정합니다. 엔터티에 2개 속성을 구성하는 복합 키가 있으면, 가장 느리게 변하는 속성을 파티션 키로 선택하고 다른 키를 행 키로 선택합니다. 엔터티에 키 속성이 3개 이상 있으면, 연속 속성을 사용해 파티션과 행 키를 제공합니다.
  >
  >
•	파티션과 행 키 이외에 필드를 사용하여 데이터를 검색하는 쿼리를 정기적으로 실행할 경우 [인덱스 테이블 패턴]을 구현하는 것이 좋습니다.

•	단조로운 증가 또는 감소 순서("0001", "0002", "0003" 등)를 사용해 파티션 키를 생성하고 각 파티션이 제한적인 양의 데이터만을 포함하는 경우, Azure 테이블 저장소는 동일한 서버에서 이 파티션을 함께 물리적으로 그룹화할 수 있습니다. 이 메커니즘은 응용 프로그램이 연속 범위의 파티션(범위 쿼리)에서 쿼리를 실행할 가능성이 가장 높고 이 경우에 최적화되어 있다는 점을 가정합니다. 그렇지만, 이 접근 방식으로 인해 핫스폿이 단일 서버에 초점을 맞출 수도 있습니다. 왜냐하면 새 엔터티의 모든 삽입은 연속 범위의 한쪽 끝과 다른 쪽 끝에 집중될 가능성이 있기 때문입니다. 또한 이것은 확장성을 낮출 수도 있습니다. 서버 전체에서 부하를 더욱 균등하게 분산시키려면, 파티션 키를 해싱하여 순서를 임의로 지정하는 것이 좋습니다.

•	Azure 테이블 저장소는 동일한 파티션에 속하는 엔터티에서 트랜잭션 작업을 지원합니다. 즉, 응용 프로그램은 삽입, 업데이트, 삭제, 바꾸기, 병합 작업을 원자 단위로 여러 번 실행할 수 있습니다(트랙잭션에 엔터티가 100개를 초과하지 않고 요청의 페이로드가 4MB를 초과하지 않은 경우에 한함). 여러 파티션을 포함하는 작업은 트랜잭션이 아니므로, [데이터 일관성 프라이머]의 설명대로 최종 일관성을 구현해야 할 수도 있습니다. 테이블 저장소와 트랜잭션에 대한 자세한 내용은 Microsoft 웹사이트에서 [엔터티 그룹 트랙잭션 실행]을 참조하십시오.

•	다음 이유로 파티션 키의 세분성에 각별히 주의해야 합니다.
 o	모든 엔터티에서 동일한 파티션 키를 사용하면 테이블 저장소 서비스가 하나의 서버에 저장되는 대형 파티션 하나를 만들게 됩니다. 이렇게 되면 규모 확장이 불가능하고 대신 단일 서버의 부하에 집중하게 됩니다. 그 결과, 이 접근 방식은 소량의 엔터티를 관리하는 시스템에만 적합하게 됩니다. 하지만, 이 접근 방식은 모든 엔터티가 엔터티 그룹 트랜잭션에 참여할 수 있도록 보장해 줍니다.
 
  o	모든 엔터티에서 고유한 파티션 키를 사용하면 테이블 저장소 서비스가 각 엔터티의 개별 파티션을 만들어 많은 소형 파티션(엔터티 크기에 따라 다름)을 만들 수 있습니다. 이 접근 방식은 단일 파티션 키를 사용하는 것보다 확장성이 높지만, 엔터티 그룹 트랜잭션이 불가능합니다. 또한, 엔터티를 2개 이상 가져오는 쿼리는 2대 이상의 서버에서 판독할 수 있습니다. 그렇지만, 응용 프로그램이 범위 쿼리를 실행할 경우 단조로운 순서를 사용해 파티션 키를 생성하면 이 쿼리를 최적화할 수 있습니다.
  
 o	엔터티 하위 집합에서 파티션 키를 공유하면 동일한 파티션에서 관련 엔터티를 그룹화할 수 있습니다. 관련 엔터티를 포함하는 작업은 엔터티 그룹 트랜잭션을 사용하여 실행할 수 있고, 관련 엔터티 집합을 가져오는 쿼리는 단일 서버를 액세스하여 충족할 수 있습니다.
 
Azure 테이블 저장소에서 분할 데이터에 대한 추가 정보는 Microsoft 웹사이트에 있는 [Azure 저장소 테이블 설계 가이드] 항목을 참조하십시오. 

## 분할 Azure blob 저장소
Azure blob 저장소는 대형 이진 개체를 저장할 수 있습니다. 즉, 현재 블록 blob에서는 최대 200GB, 페이지 blob에서는 1TB 크기가 지원됩니다. (자세한 내용은 Microsoft 웹사이트의 [Azure 저장소 확장성 및 성능 목표]를 참조하십시오.) 대용량 데이터를 빠르게 업로드하거나 다운로드해야 하는 스트리밍과 같은 시나리오에서 블록 blob을 사용합니다. 데이터의 여러 부분에 연속으로 액세스하기 보다는 임의로 액세스해야 하는 응용 프로그램에서는 페이지 blob을 사용합니다.

각 blob(블록 또는 페이지)은 Azure 저장소 계정의 컨테이너에 저장됩니다. 컨테이너를 사용해 보안 요구사항이 동일한 관련 blob을 그룹화할 수 있지만, 이 그룹화는 물리적이기 보다는 논리적입니다. 컨테이너 내부에 있는 각 blob에는 고유한 이름이 있습니다.

Blob 저장소는 blob 이름에 따라 자동으로 분할됩니다. 각 blob은 자체 파티션에 저장됩니다. 동일한 컨테이너에 있는 blob은 파티션을 공유하지 않습니다. 동일한 컨테이너에 있는 다양한 blob은 여러 서버에서 분산될 수 있기 때문에 이 아키텍처는 서버 전체에서 Azure blob 저장소가 부하 균형을 투명하게 유지하는 데 도움이 됩니다. 

단일 블록(블록 blob) 또는 페이지(페이지 blob)를 쓰는 작업은 원자성이지만, 블록, 페이지 또는 blob을 포함하는 작업은 원자성이 아닙니다. 여러 블록, 페이지, blob에서 쓰기 작업을 실행할 때 일관성을 보장해야 하는 경우, blob 임대를 사용해 쓰기 잠금을 해제합니다. 

Azure blob 저장소의 전송 속도는 각 blob별로 초당 최대 60MB 또는 초당 500개 요청입니다. 이 한도를 넘을 것으로 예상되고 blob 데이터가 비교적 정적이면, Azure Content Delivery Network를 사용하여 blob를 복제하는 것이 좋습니다. 자세한 내용은 Microsoft 웹사이트의 [Azure용 Delivery Content Network 사용]을 참조하십시오. 추가 지침과 고려 사항은 [Azure용 Content Delivery Network 사용]을 참조하십시오.

## Azure 저장소 큐 분할
Azure 저장소 큐를 통해 프로세스 간 비동기식 메시징을 구현할 수 있습니다. Azure 저장소 계정은 큐를 얼마든지 포함할 수 있고, 각 큐는 메시지를 얼마든지 포함할 수 있습니다. 유일한 제한은 저장소 계정에서 사용할 수 있는 공간입니다. 개별 메시지의 최대 크기는 64KB입니다. 메시지가 이보다 클 경우, 대신 Azure Service Bus 큐를 사용하는 것이 좋습니다. 

각 저장소 큐에는 저장소 계정 내에 고유한 이름이 있습니다. Azure 파티션 큐는 이 이름을 기준으로 합니다. 동일한 큐의 모든 메시지는 동일한 파티션에 저장되고, 이것은 단일 서버를 통해 제어됩니다. 큐는 서버별로 관리되어 부하 균형을 조정할 수 있습니다. 큐를 서버에 할당할 때 응용 프로그램과 사용자에게 투명합니다. 

대규모 응용 프로그램에서는 모든 응용 프로그램 인스턴스에서 동일한 저장소 큐를 사용해서는 안 됩니다. 왜냐하면, 이 접근 방식은 큐를 호스팅하는 서버를 핫스폿으로 만들 수 있기 때문입니다. 그 대신, 응용 프로그램의 기능 영역별로 다른 큐를 사용합니다. Azure 저장소 큐는 트랜잭션을 지원하지 않으므로, 메시지를 다른 큐에 전달해도 메시징 일관성에는 거의 영향을 주지 않아야 합니다. 

Azure 저장소 큐는 초당 최대 2,000개 메시지를 처리할 수 있습니다. 이보다 높은 속도로 메시지를 처리해야 하는 경우, 여러 큐를 만드는 것이 좋습니다. 예를 들어, 전역 응용 프로그램에서 별도의 저장소 계정에 별도의 저장소 큐를 만들어 각 영역에서 실행되고 있는 응용 프로그램 인스턴스를 처리합니다. 

## Azure Service Bus에 적합한 분할 전략
Azure Service Bus는 메시지 브로커를 사용하여 Service Bus 큐 또는 항목에 보내는 메시지를 처리합니다. 기본적으로 큐 또는 항목에 보낸 모든 메시지는 동일한 메시지 브로커 프로세스를 통해 처리됩니다. 이 아키텍처는 메시지 큐의 전체 처리량을 제한할 수 있습니다. 그렇지만, 큐 또는 항목을 만들 때 이것을 분할할 수도 있습니다. 이 작업을 하려면 큐 또는 항목 설명의 *EnablePartitioning* 속성을 *true*로 설정합니다.

분할된 큐 또는 항목을 여러 조각으로 나누고, 이 각 조각을 별도의 메시지 저장소와 메시지 브로커를 통해 지원합니다. Service Bus는 이 조각을 만들고 관리할 책임이 있습니다. 응용 프로그램이 분할된 큐 또는 항목에 메시지를 게시하면, Service Bus는 이 메시지를 이 큐 또는 항목에 적합한 조각에 할당합니다. 응용 프로그램이 큐 또는 가입에서 메시지를 받으면, Service Bus는 각 조각에서 다음 사용 가능한 메시지가 있는지 확인하고 처리할 수 있도록 응용 프로그램에 전달합니다. 

이 구조를 통해 전체 메시지 브로커와 메시지 저장소에서 부하를 분산시켜 확장성과 가용성을 높일 수 있습니다. 한 조각의 메시지 브로커나 메시지 저장소를 일시적으로 사용할 수 없는 경우, Service Bus는 나머지 가용 조각 중 하나에서 메시지를 검색할 수 있습니다. 

Service Bus는 다음과 같이 조각에 메시지를 할당합니다. 

•	메시지가 세션에 속한 경우, * SessionId* 속성에서 동일한 값을 갖는 모든 메시지는 동일한 조각으로 보내집니다.
•	메시지가 세션에 속하지 않지만 보낸 사람이 *PartitionKey* 속성의 값을 지정한 경우, 동일한 *PartitionKey* 값을 갖는 모든 메시지는 동일한 조각으로 보내집니다.

  > [!참고]
  > *SessionId* 및 *PartitionKey* 속성이 모두 지정된 경우에는 동일한 값으로 설정되거나 메시지가 거부됩니다.
  >
  >
•	메시지의 *SessionId* 및 *PartitionKey* 속성이 지정되지 않았지만 중복 감지가 활성화된 경우, *MessageId* 속성이 사용됩니다. 동일한 *MessageId* 를 갖는 모든 메시지는 동일한 조각으로 전송됩니다.

•	메시지에 *SessionId, PartitionKey,* 또는 *MessageId* 속성이 포함되지 않은 경우, Service Bus는 조각에 순서대로 메시지를  할당합니다. 조각을 사용할 수 없는 경우, Service Bus는 다음 조각으로 넘어갑니다. 이것은 메시징 인프라의 일시적인 오류때문에 메시지 전송 작업이 실패하지는 않는다는 것을 의미합니다.

Service Bus 메시지 큐 또는 항목을 분할하지 여부나 분할 방법을 결정할 때에는 다음 사항을 고려해야 합니다. 

•	Service Bus 큐와 항목은 Service Bus 네임스페이스 범위에서 만들어집니다. Service Bus는 현재 네임스페이스당 최대 100개의 분할된 큐 또는 항목을 허용합니다.

•	각 Service Bus 네임스페이스는 항목당 가입 횟수, 초당 동시 전송 및 수신 요청 개수, 설정 가능한 동시 연결의 최대 개수 등 가용 리소스에 할당량을 부과합니다.  이 할당량은 Microsoft 웹사이트의 [Service Bus 할당량] 페이지에 기록됩니다. 이 값을 초과하는 경우, 자체 큐와 항목을 사용한 추가 네임스페이스를 만들고 이 네임스페이스에서 작업을 분산시킵니다. 예를 들어, 전역 응용 프로그램에서 각 영역에 별도의 네임스페이스를 만들고 응용 프로그램 인스턴스를 구성하여 가장 가까운 네임스페이스에서 큐와 항목을 사용합니다.

•	트랜잭션의 일부로서 보낸 메시지는 파티션 키를 지정해야 합니다. 이것은 *SessionId*, *PartitionKey*, or *MessageId* 속성 중 하나입니다. 동일한 트랜잭션의 일부로서 보낸 모든 메시지는 동일한 메시지 브로커 프로세스를 통해 처리되어야 하기 때문에 동일한 파티션 키를 지정해야 합니다. 동일한 트랜잭션 내에서 다른 큐 또는 항목으로 메시지를 보낼 수 없습니다.

•	할당된 큐와 항목은 유휴 상태가 될 때 자동으로 삭제되도록 구성할 수 없습니다.

•	교차 플랫폼이나 하이브리드 솔루션을 빌드하는 경우 분할된 큐와 항목은 현재 AMQP(Advanced Message Queuing Protocol)에서 사용할 수 없습니다.

## Azure DocumentDB 데이터베이스에 적합한 분할 전략
Azure DocumentDB는 문서를 저장할 수 있는 NoSQL 데이터베이스입니다. DocumentDB 데이터베이스의 문서는 개체나 다른 데이터 조각의 JSON 직렬화된 표현입니다. 모든 문서가 고유 ID를 포함해야 하는 점을 제외하고 어떠한 고정 스키마도 실행되지 않습니다. 

문서는 컬렉션으로 구성됩니다. 컬렉션에서 관련 문서를 모두 그룹화할 수 있습니다. 예를 들어, 블로그 게시물을 유지하는 시스템에서 각 블로그 게시물의 콘텐츠를 컬렉션의 문서로 저장할 수 있습니다. 또한 제목 유형별로 컬렉션을 만들 수도 있습니다. 그렇지 않으면, 다른 작성자가 자체 블로그 게시물을 제어하고 관리하는 시스템과 같은 다중 테넌트 응용 프로그램에서 작성자별로 블로그를 분할하고 각 작성자별로 별도의 컬렉션을 만들 수 있습니다. 컬렉션에 할당된 저장소 공간은 탄력적이어서 필요에 따라 줄이거나 늘릴 수 있습니다. 

문서 컬렉션은 단일 데이터베이스 내에서 데이터를 분할하는 자연스러운 메커니즘을 지원합니다. 내부적으로 DocumentDB 데이터베이스는 여러 서버를 포함하고 전체 서버에서 컬렉션을 배포하여 부하를 분산시킬 수 있습니다. 샤딩을 구현하는 가장 간단한 방법은 각 샤드별로 컬렉션을 만드는 것입니다. 

> [!참고]
> 각 DocumentDB 데이터베이스에는 가져오는 리소스 양을 결정하는 성능 수준이 있습니다. 성능 수준은 요청 단위(RU) 속도 제한과 관련되어 있습니다. RU 속도 제한은 예약되어 해당 컬렉션에서 독점적으로 사용할 수 있는 리소스 볼륨을 제한합니다. 컬렉션 비용은 해당 컬렉션에서 선택한 성능 수준에 따라 달라집니다. 성능 수준(및 RU 속도 한계)이 높아질수록 요금이 높아집니다. Azure포털을 사용하여 컬렉션의 성능 수준을 조정할 수 있습니다. 자세한 내용은 Microsoft 웹사이트의 [DocumentDB에서 성능 수준] 페이지를 참조하십시오. 
>
>

모든 데이터베이스는 DocumentDB 계정의 컨텍스트에서 만들어집니다. 단일 DocumentDB 계정에는 여러 데이터베이스가 포함될 수 있고, 이것은 데이터베이스를 만들 영역을 지정합니다. 각 DocumentDB 계정은 자체 액세스 제어를 실행합니다. DocumentDB 계정을 사용하여 액세스해야 하는 사용자와 가까이에 있는 샤드(데이터베이스에 있는 컬렉션)를 지리적으로 찾고 이 사용자만이 해당 샤드에 연결할 수 있도록 제한을 실행할 수 있습니다. 

각 DocumentDB 계정에는 포함하는 데이터베이스와 컬렉션의 개수와 사용 가능한 문서 저장소 양을 제한하는 할당량이 있습니다. 이 제한은 변경 가능하고, Microsoft 웹사이트의 [DocumentDB 제한 및 할당량] 페이지에 설명되어 있습니다. 이론상으로는 모든 샤드가 동일한 데이터베이스에 속한 시스템을 구현할 경우 계정의 저장소 용량 제한에 도달할 수 있습니다. 

이 경우에 추가 DocumentDB 계정 및 데이터베이스를 만들고 이 데이터베이스에서 샤드를 배포해야 합니다. 그렇지만, 데이터베이스의 저장소 용량에 도달할 가능성이 없더라도 여러 데이터베이스를 사용하는 것이 좋습니다. 왜냐하면 각 데이터베이스에는 자체 사용자 및 권한 집합이 있고 이 메커니즘을 사용하여 데이터베이스별 컬렉션에 대한 액세스 권한을 분리할 수 있기 때문입니다. 

그림 8은 DocumentDB 아키텍처의 높은 수준의 구조를 나타냅니다. 

![The structure of DocumentDB](./images/data-partitioning/DocumentDBStructure.png)

*그림 8. DocumentDB 아키텍처의 구조*

적절한 샤드에 요청을 전달하는 것은 클라이언트 응용 프로그램의 작업이며, 이것은 보통 샤드 키를 정의하는 일부 데이터 특성을 기반으로 하는 자체 매핑 메커니즘을 구현하여 실행됩니다. 그림 9는 각기 샤드 역할을 하고 있는 컬렉션 2개를 포함하는 DocumentDB 데이터베이스 2개를 나타냅니다. 데이터는 테넌트 ID별로 샤딩되고 특정 테넌트의 데이터를 포함합니다. 이 데이터베이스는 별도의 DocumentDB 계정에서 만들어집니다. 이 계정은 계정이 데이터를 포함하는 테넌트와 동일한 영역에 있습니다. 클라이언트 응용 프로그램의 라우팅 논리는 테넌트 ID를 샤드 키로 사용합니다. 

![Implementing sharding using Azure DocumentDB](./images/data-partitioning/DocumentDBPartitions.png)

*그림 9. Azure DocumentDB 데이터베이스를 사용한 샤딩 구현*

DocumentDB 데이터베이스를 사용하여 데이터를 분할하는 방법을 결정할 때 고려할 사항은 다음과 같습니다. 

* **DocumentDB 데이터베이스에서 사용 가능한 리소스는 DocumentDB 계정의 할당량 제한에 따라 달라집니다**. 각 데이터베이스에는 많은 컬렉션(다시 말해 제한이 있음)을 저장할 수 있고, 각 컬렉션은 해당 컬렉션에서 RU 속도 제한(예약 처리량)을 통제하는 성능 수준과 관련되어 있습니다. 자세한 내용은 Microsoft 웹사이트의 [DocumentDB 제한 및 할당량] 페이지를 참조하십시오.
* **각 문서에는 컬렉션에 있는 해당 문서를 고유하게 식별하는 데 사용할 수 있는 특성이 있어야 합니다**. 이 특성은 샤드 키와 다르고, 이것은 문서를 저장하는 컬렉션을 정의합니다. 컬렉션은 많은 문서를 포함할 수 하지만 원칙적으로 문서 ID의 최대 길이에 의해서만 제한받습니다. 문서 ID 길이는 최대 255자입니다.
* **문서와 관련된 모든 작업은 트랜잭션의 컨텍스트 내에서 실행됩니다. DocumentDB 데이터베이스의 트랜잭션은 문서를 포함하는 컬렉션의 범위로 지정됩니다.** 작업이 실패하면, 실행한 작업은 롤백됩니다. 문서가 실행되는 동안 적용된 모든 변경 내용은 스냅샷 수준으로 분리됩니다. 이 메커니즘은 예를 들어 새 문서를 만드는 요청이 실패할 경우 이 데이터베이스를 동시에 조회하는 다른 사용자에게 이후 제거된 문서의 일부가 보이지 않게 해줍니다.
* **DocumentDB 데이터베이스 쿼리는 컬렉션 수준으로 범위가 지정됩니다**. 단일 쿼리는 컬렉션 하나에서만 데이터를 검색할 수 있습니다. 여러 컬렉션에서 데이터를 검색해야 하는 경우, 각 컬렉션을 개별적으로 조회하고 응용 프로그램 코드에서 결과를 병합해야 합니다.
* **DocumentDB 데이터베이스는 문서와 함께 컬렉션에 모두 저장될 수 있는 프로그래밍 가능 항목을 지원합니다**. 여기에는 저장된 절차, 사용자가 정의한 기능 및 트리거(JavaScript로 작성됨)가 있습니다. 이들 항목은 동일한 컬렉션 내에서 모든 문서를 액세스할 수 있습니다. 또한, 이 항목은 주위 트랜잭션 범위 내부에서 실행되거나(문서에 대해 실행되는 만들기, 삭제 또는 바꾸기 작업의 결과로서 시작되는 트리거의 경우) 새 트랜잭션을 시작하여 실행됩니다(명시적인 클라이언트 요청의 결과로서 실행되는 저장된 절차의 경우). 프로그래밍 가능한 항목의 코드에서 예외가 발생하면, 이 트랜잭션은 롤백됩니다. 저장된 절차와 문서 간 무결성과 일관성을 유지하는 트리거를 사용할 수 있지만, 이 문서는 모두 동일한 컬렉션의 일부여야 합니다.
* **•	DocumentDB 계정에서 데이터베이스에 저장하려는 컬렉션은 컬렉션의 성능 수준에서 정의된 처리량 제한을 초과하지 않아야 합니다**. 이 제한은 Microsoft 웹사이트의 [DocumentDB 용량 요구 사항 관리] 페이지에 설명되어 있습니다. 이 제한에 도달할 것으로 예상되는 경우, 각기 다른 DocumentDB 계정의 데이터베이스에서 컬렉션을 분할하여 컬렉션당 부하를 줄이는 것이 좋습니다.

## Azure Search에 적합한 분할 전략
데이터를 검색하는 기능은 흔히 많은 웹 응용 프로그램에서 제공하는 탐색과 탐구의 주요 방법입니다. 이 기능을 통해 사용자는 검색 기준 조합에 따라 리소스를 빠르게 찾을 수 있습니다(예를 들어, 전자 상거래 응용 프로그램의 제품). Azure Search 서비스는 웹 콘텐츠를 통해 전체 텍스트 검색 기능을 제공하고, 거의 일치하는 항목을 기반으로 자동 완성, 제안된 쿼리, 다양한 탐색과 같은 여러 기능을 갖추고 있습니다. 이들 기능에 대한 전체 설명은 Microsoft 웹사이트의 [Azure Search란?] 페이지에 나와 있습니다. 

Azure Search는 검색 가능한 콘텐츠를 데이터베이스에 JSON 문서로 저장합니다. 이들 문서에 검색 가능한 필드를 지정하는 인덱스를 정의하고 이 정의를 Azure Search에 제공합니다. 사용자가 검색 요청을 제출하면, Azure Search는 적절한 인덱스를 사용해 일치하는 항목을 찾습니다. 

경합을 줄이기 위해 Azure Search가 사용하는 저장소는 파티션 1개, 2개, 3개, 4개, 6개, 12개 중 하나로 나뉠 수 있고 각 파티션은 최대 6회까지 복제될 수 있습니다. 파티션 개수에 복제본 수를 곱한 것을 검색 단위(SU)라고 합니다. Azure Search의 단일 인스턴스는 최대 36개 SU(파티션 12개를 갖는 데이터베이스는 최대 복제본 3개만을 지원함)를 포함할 수 있습니다. 

서비스에 할당된 각 SU별로 요금이 청구됩니다. 검색 가능 콘텐츠의 볼륨이 증가하거나 검색 요청 속도가 증가하면, Azure Search의 기존 인스턴스에 SU를 추가하여 추가 부하를 처리할 수 있습니다. Azure Search는 자체적으로 파티션 전체에 문서를 고르게 배포합니다. 현재 지원되는 수동 분할 전략은 없습니다. 

각 파티션은 최대 1500만 개의 문서를 포함하거나 300GB의 저장소 공간을 점유할 수 있습니다(어느 것이든 더 작은 것이 우선임). 최대 50개 인덱스를 만들 수 있습니다. 서비스 성능은 달라지고 이는 문서 복잡성, 가용 인덱스, 네트워크 대기 시간의 영향에 따라 다릅니다. 평균적으로 단일 복제본(1 SU)은 초당 쿼리(QPS) 15개를 처리할 수 있지만, 사용자 자체 데이터를 사용할 때 벤치마킹을 실행하여 더 정확한 처리량 평가를 확보하는 것을 권장합니다. 자세한 내용은 Microsoft 웹사이트의 [Azure Search의 서비스 제한]을 참조하십시오.

> [!참고]
> 검색 가능 문서에 문자열, 부울, 숫자 데이터, 날짜/시간 데이터, 일부 지리적 데이터를 포함하여 제한적인 데이터 형식 집합을 저장할 수 있습니다. 자세한 내용은 Microsoft 웹사이트의 [지원 데이터 형식(Azure Search)] 페이지를 참조하십시오. 
>

Azure Search가 서비스의 각 인스턴스별로 데이터를 분할하는 방법을 제한적으로 통제할 수 있습니다. 그렇지만, 다음 전략 중 하나를 이용해 서비스 자체를 분할하여 전역 환경에서 성능을 개선하고 대기 시간과 경합을 추가로 줄여야 할 수도 있습니다. 

•	각 지리적 영역에서 Azure Search의 인스턴스를 만들고, 클라이언트 응용 프로그램이 가장 가까운 가용 인스턴스로 전달되도록 보장해야 합니다. 이 전략에서는 모든 서비스 인스턴스에서 검색 가능한 콘텐츠 업데이트를 적시에 복제해야 합니다.

•	다음과 같이 Azure Search 계층 두 개를 만듭니다.

 o	해당 영역에서 사용자가 가장 자주 액세스하는 데이터를 포함하는 각 지역별 로컬 서비스. 사용자는 여기에서 요청을 전달하여 빠르지만 제한적인 결과를 받을 수 있습니다.
 
 o	모든 데이터를 포함하는 전역 서비스. 사용자는 여기에서 요청을 전달하여 느리지만 보다 완벽한 결과를 받을 수 있습니다.
 
이 접근 방식은 검색 중인 데이터에 중대한 지역 변동이 있을 때 가장 적합합니다. 

## Azure Redis Cache에 적합한 분할 전략
Azure Redis Cache는 Redis 키-값 데이터 저장소를 기반으로 하는 클라우드에서 공유된 캐싱 서비스를 제공합니다. 이름에서도 알 수 있듯이 Azure Redis Cache는 캐싱 솔루션으로 제작되었습니다. 일시적 데이터를 저장하는 용도로만 사용하고 영구 데이터 저장소로 사용해서는 안 됩니다. Azure Redis Cache를 활용하는 응용 프로그램은 캐시를 사용할 수 없는 경우에 계속 작동할 수 있어야 합니다. Azure Redis Cache는 일차/이차 복제를 지원하여 고가용성을 제공하지만, 현재 최대 캐시 크기는 53GB로 제한되어 있습니다. 이보다 큰 공간이 필요하면, 추가 캐시를 만들어야 합니다. 자세한 내용은 Microsoft 웹사이트의 [Azure Redis Cache] 페이지를 참조하십시오. 

Redis 데이터 저장소 분할에는 Redis 서비스 인스턴스에서의 데이터 분할이 포함됩니다. 각 인스턴스는 단일 파티션을 구성합니다. Azure Redis Cache는 파사드 뒤에서 Redis 서비스를 추상화하고 이것을 직접 노출하지는 않습니다. 분할을 구현하는 가장 간단한 방법은 여러 Azure Redis Cache 인스턴스를 만들고 여기에서 데이터를 분산시키는 것입니다. 

데이터 항목을 저장할 캐시를 지정하는 식별자(파티션 키)와 각 데이터 항목을 연결할 수 있습니다. 그런 다음 클라이언트 응용 프로그램 논리는 이 식별자를 사용해 요청을 적절한 파티션으로 전달할 수 있습니다. 이 체계는 매우 간단하지만, 분할 체계가 바뀌면(예를 들어, 추가 Azure Redis Cache 인스턴스를 만들 경우), 클라이언트 응용 프로그램을 재구성해야 할 수도 있습니다. 

네이티브 Redis(Azure Redis Cache가 아님)는 Redis 클러스터링을 기반으로 서버 측 분할을 지원합니다. 이 접근 방식에서는 해싱 메커니즘을 사용하여 데이터를 전체 서버에서 균등하게 나눌 수 있습니다. 각 Redis 서버는 파티션이 저장한 해시 키의 범위를 설명하는 메타데이터를 저장하고, 다른 서버에 있는 파티션에 위치한 해시 키에 대한 정보를 포함합니다. 

클라이언트 응용 프로그램은 참여하는 Redis 서버(아마도 가장 가까운 서버) 중 어느 것으로든 간단히 요청을 보냅니다. Redis 서버는 클라이언트 요청을 점검하고 이것을 로컬에서 해결할 수 없을 경우, 요청된 작업을 실행합니다. Redis 서버가 요청을 실행하지 않을 경우 적절한 서버로 요청을 전달하게 됩니다.

이 모델은 Redis 클러스터링을 사용해 구현되며, Redis 웹사이트의 [Redis 클러스터 자습서] 페이지에 자세히 설명되어 있습니다. Redis 클러스터링은 클라이언트 응용 프로그램에 투명합니다. 클라이언트를 재구성하지 않고 추가 Redis 서버를 클러스터에 추가할 수 있습니다(그리고 데이터를 다시 분할할 수 있음). 

> [!중요]
> Azure Redis Cache는 현재 Redis 클러스터링을 지원하지 않습니다. Azure를 사용하여 이 접근 방식을 구현하려면, Azure 가상 컴퓨터 집합에 Redis를 설치하고 수동으로 구성하여 자체 Redis 서버를 구현해야 합니다. Microsoft 웹사이트의 [Azure의 CentOS Linux VM에서 Redis 실행]페이지에는 Azure VM으로 실행되는 Redis 노드를 빌드하고 구성하는 방법을 보여 주는 예제가 나와 있습니다. 
>
>

Redis 웹사이트의 [분할: 다중 Redis 인스턴스에서 데이터를 분할하는 방법] 페이지에는 Redis를 사용하여 분할을 실행하는 방법에 대한 자세한 정보가 나와 있습니다. 이 섹션의 나머지 부분에서는 사용자가 클라이언트 측 또는 프록시 지원 분할을 구현하고 있다고 가정합니다. 

Azure Redis Cache를 사용하여 데이터를 분할하는 방법을 결정할 때 고려할 사항은 다음과 같습니다. 

•	Azure Redis Cache는 본래 영구 데이터 저장소 역할을 하지 않으므로, 구현할 분할 체계에 상관 없이 응용 프로그램 코드는 캐시가 아닌 위치에서 데이터를 검색할 수 있어야 합니다.

•	함께 자주 액세스하는 데이터는 동일한 파티션에 보관해야 합니다. Redis는 강력한 키-값 저장소로서 데이터를 구조화하는 여러 개의 매우 최적화된 메커니즘을 지원합니다. 이 메커니즘에는 다음과 같은 것들이 있습니다.

o	간단한 문자열(최대 512MB 길이의 이진 데이터)

o	목록과 같은 유형 집계(큐와 스택 기능 지원)

o	세트(정렬 및 비정렬)

o	해시(개체에서 필드를 나타내는 항목 등 관련 필드를 모두 그룹화할 수 있음)

* •	집계 유형을 통해 많은 관련 값을 동일한 키와 연결할 수 있습니다. Redis 키는 포함하는 데이터 항목 이외에 목록, 세트, 해시를 식별합니다. 이 유형은 모두 Azure Redis Cache에서 사용할 수 있고 Redis 웹사이트의 [데이터 형식] 페이지에 설명되어 있습니다. 예를 들어, 고객 주문을 추적하는 전자 상거래 시스템의 일부에서 각 고객의 세부 정보는 고객 ID를 사용하여 입력되는 Redis 해시에 저장될 수 있습니다. 각 해시는 고객의 주문 ID 컬렉션을 저장할 수 있습니다. 별도의 Redis 세트는 주문을 저장하고, 다시 해시로 구조화되고, 주문 ID를 사용하여 입력됩니다. 그림 10은 이 구조를 나타냅니다. Redis는 어느 형태의 참조 무결성도 구현하지 않으므로, 고객과 주문 관계를 유지하는 것은 개발자의 책임입니다.

![Suggested structure in Redis storage for recording customer orders and their details](./images/data-partitioning/RedisCustomersandOrders.png)

*그림 10. 고객 주문과 그 세부 정보를 기록하기 위한 Redis 저장소의 제안 구조*

> [!참고]
> Redis에서 모든 키는 이진 데이터 값(Redis 문자열 등)이고 최대 512MB의 데이터를 포함할 수 있습니다. 원칙적으로 키 하나는 거의 모든 정보를 포함할 수 있습니다. 그렇지만, 데이터 형식을 나타내고 엔터티를 식별하는 키의 일관된 명명 규칙을 채택하는 것을 권장합니다. 다만 이름이 지나치게 길어서는 안 됩니다. 일반적으로 "entity_type:ID" 형태의 키를 사용합니다. 예를 들어, "customer:99"를 사용하여 ID 99인 고객의 키를 나타낼 수 있습니다. 
>

* 동일한 데이터베이스의 각기 다른 집계에 관련 정보를 저장하여 수직 분할을 구현할 수 있습니다. 예를 들어, 전자 상거래 응용 프로그램에서 자주 액세스되는 제품 정보를 하나의 Redis 해시에 저장하고, 자주 사용하지 않는 세부 정보를 다른 해시에 저장할 수 있습니다. 이 두 해시는 키의 일부로서 동일한 제품 ID를 사용할 수 있습니다. 예를 들어, 제품 정보는 "product: *nn*" (여기서 *nn* 은 제품 ID임)을 사용하고 세부 데이터는 "product_details: *nn*" 을 사용할 수 있습니다. 이 전략은 대다수 쿼리가 검색할 가능성이 높은 데이터 볼륨을 줄이는 데 도움이 될 수 있습니다.

* Redis 데이터 저장소를 다시 분할할 수 있지만, 이것은 복잡하고 시간이 많이 걸리는 작업임을 명심해야 합니다. Redis 클러스터링은 데이터를 자동으로 다시 분할할 수 있지만, 이 기능은 Azure Redis Cache에서 사용할 수 없습니다. 그러므로, 분할 체계를 설계할 때에는 시간 경과에 따라 예상되는 데이터 증가를 감안하여 각 파티션에 충분한 여유 공간을 마련하도록 합니다. 그렇지만, Azure Redis Cache는 데이터를 일시적으로 캐싱하도록 제작되었고, 캐시에 저장된 데이터는 TTL(time-to-live) 값으로 지정된 수명이 제한적일 수 있음을 명심해야 합니다. 비교적 변동이 심한 데이터의 경우 TTL은 짧지만, 정적 데이터의 경우에는 TTL이 훨씬 더 길 수 있습니다. 이 데이터의 볼륨이 캐시를 채울 가능성이 높은 경우 캐시에서 수명이 긴 데이터를 많이 저장하지 않도록 합니다. 공간이 프리미엄일 경우 Azure Redis Cache가 데이터를 제거하도록 하는 제거 정책을 지정할 수 있습니다.

  > [!참고]
  > Azure Redis 캐시를 사용할 때 적절한 가격대를 선택하여 최대 캐시 크기(250MB~53GB)를 지정합니다. 그렇지만, Azure Redis Cache를 만든 후에는 그 크기를 증가(또는 감소)시킬 수 없습니다.
  >
  >
•	Redis 배치와 트랜잭션은 여러 연결을 포함할 수 없으므로, 배치 또는 트랜잭션의 영향을 받는 모든 데이터는 동일한 데이터베이스(샤드)에 저장해야 합니다.

  > [!참고]
  >Redis 트랜잭션에서 작업 순서가 반드시 원자성은 아닙니다. 트랜잭션을 구성하는 명령은 확인 과정을 거쳐  대기상태에 있다가 실행됩니다. 이 단계에서 오류가 발생하면, 전체 큐는 삭제됩니다. 그렇지만, 트랜잭션을 제출한 후 큐에 대기된 명령은 순서대로 실행됩니다. 어느 명령이든 실패하면, 해당 명령의 실행만이 중지됩니다. 큐에 있는 이전 및 후속 명령 전체가 실행됩니다. 자세한 내용은 Microsoft 웹사이트의 [트랜잭션] 페이지를 참조하십시오.
  >
  >
•	Redis는 제한적인 수의 원자성 작업을 지원합니다. 여러 키와 값을 지원하는 이 유형의 유일한 작업은 MGET 및 MSET 작업입니다. MGET 작업은 지정된 키 목록에서 값 컬렉션을 반환하고, MSET 작업은 지정된 키 목록에서 값 컬렉션을 저장합니다. 이 작업을 사용해야 하는 경우, MSET 및 MGET 명령이 참조하는 키-값 쌍을 동일한 데이터베이스 내에 저장해야 합니다.

## 파티션 균형 재조정
시스템이 발전해가고 사용자가 사용 패턴을 좀더 이해하게 되면 분할 체계를 조정해야 합니다. 예를 들어, 개별 파티션은 균형이 맞지 않는 트래픽 볼륨을 유입하고 사용량이 매우 많아져 과도한 경합을 유발할 수 있습니다. 또한, 일부 파티션에서 데이터 볼륨을 과소평가하여 이 파티션에서 저장소 용량 제한에 도달할 수 있습니다. 원인이 무엇이든 간에 때로는 파티션 균형을 재조정하여 부하를 더욱 고르게 분산시켜야 합니다. 

경우에 따라서는 데이터를 서버에 할당하는 방식을 공개적으로 표시하지 않은 데이터 저장소 시스템은 가용 리소스 제한 내에서 파티션 균형을 자동으로 재조정할 수 있습니다. 다른 상황에서 균형 재조정은 다음 2단계로 구성된 관리 작업입니다. 

1.	알아낼 새 분할 전략 결정:

   •	분할할 수 있는 파티션(또는 결합할 수 있는 파티션).
   
   •	새 파티션 키를 지정하여 이 새 파티션에 데이터를 할당하는 방법.

2. 기존 분할 체계를 새 파티션 세트로 마이그레이션.

> [!참고]
> DocumentDB 데이터베이스 컬렉션을 서버에 매핑하는 과정은 투명하지만, 여전히 DocumentDB 계정의 저장소 용량과 처리량 제한점에 도달하는 상황에 이를 수 있습니다. 이런 문제가 발생하면, 분할 체계를 다시 설계하고 데이터를 마이그레이션해야 합니다. 
>
>

데이터 저장소 기술과 데이터 저장소 시스템 설계에 따라 사용 중에 다른 파티션으로 데이터를 마이그레이션할 수 있습니다(온라인 마이그레이션). 이것이 가능하지 않을 경우, 데이터 위치를 변경하는 동안에는 일시적으로 해당 파티션을 사용할 수 없게 해야 합니다(오프라인 마이그레이션). 

## 오프라인 마이그레이션
오프라인 마이그레이션은 경합 발생 가능성을 낮춰주므로 확실히 가장 간단한 방법입니다. 이동하고 구조를 조정하는 동안 데이터를 변경하지 않아도 됩니다. 

개념적으로 이 프로세스는 다음 단계를 따릅니다. 

1.	샤드를 오프라인으로 표시합니다.
2.	분할-병합을 실행하고 데이터를 새 샤드로 이동합니다.
3.	데이터를 확인합니다.
4.	새 샤드를 온라인으로 전환합니다.
5.	이전 샤드를 제거합니다.


일부 가용성을 유지하기 위해 1단계에서 원래 샤드를 사용할 수 없음으로 표시하는 대신 않고 읽기 전용으로 표시할 수 있습니다. 이렇게 하면 데이터 이동 중에 응용 프로그램이 데이터를 읽을 수는 있지만 데이터는 변경할 수 없게됩니다. 

## 온라인 마이그레이션
온라인 마이그레이션은 실행하기가 더 복잡하지만 전체 절차 진행 괒어에서 데이터를 계속 사용할 수 있기 때문에 사용자 작업이 중단되는 경우가 줄어듭니다. 이 프로세스는 원래 샤드를 오프라인으로 표시(1단계)하지 않는다는 점을 제외하면 오프라인 마이그레이션에서 사용하는 프로세스와 비슷합니다. 마이그레이션 프로세스의 세분성(예를 들어, 항목별 또는 샤드별로 실행할지 여부)에 따라 클라이언트 응용 프로그램의 데이터 액세스 코드는 2개의 위치에 저장된 데이터에 대한 읽기와 쓰기(원래 샤드와 새 샤드)작업을 처리해야 합니다. 

온라인 마이그레이션을 지원하는 솔루션의 예는 Microsoft 웹사이트에서 [Elastic Database 분할-병합 도구를 사용한 크기 조정] 항목을 참조하십시오. 

## 관련 패턴 및 지침
데이터 일관성 구현 전략을 고려할 경우 다음 패턴들이 사용자의 시나리오와 관련되어 있을 수 있습니다. 

*	Microsoft 웹사이트의 [데이터 일관성 프라이머] 페이지에는 클라우드와 같은 분산 환경에서 일관성을 유지할 수 있는 전략에 대해 설명되어 있습니다.
* Microsoft 웹사이트의 [데이터 분할 지침] 페이지에는 분산 솔루션에서 다양한 기준에 부합하도록 파티션을 설계하는 방법에 대한 일반적인 개요가 나와 있습니다.
* Microsoft 웹사이트에 설명된 [샤딩 패턴]에는 일반적인 데이터 샤딩 전략에 대해 간략하게 나와 있습니다.
* Microsoft 웹사이트에 설명된 [인덱스 테이블 패턴]에는 데이터에 대한 보조 인덱스를 만드는 방법이 설명되어 있습니다. 응용 프로그램은 이 방식으로 데이터를 빠르게 검색할 수 있으며, 이때 컬렉션의 기본 키를 참조하지 않는 쿼리를 사용합니다.
* Microsoft 웹사이트에 설명된 [구체화된 보기 패턴] 에는 빠른 쿼리 작업을 지원하기 위해 데이터를 요약한 사전에 채운 보기를 생성하는 방법에 대한 설명이 나와 있습니다. 이 방법은 요약된 데이터를 포함하는 파티션을 여러 사이트에서 배포하는 경우 분할된 데이터 저장소에서 유용할 수 있습니다.
* Microsoft 웹사이트의 [Azure 콘텐츠 제공 네트워크(CDN) 사용] 항목에는 Azure 콘텐츠 제공 네트워크(CDN)를 구성하고 사용하는 방법에 대한 추가 지침이 나와 있습니다.

## 자세한 정보
* Microsoft 웹사이트의 [Azure SQL Database란?] 페이지에는 SQL 데이터베이스를 만들고 사용하는 방법을 설명한 세부 설명서가 나와 있습니다.
*  Microsoft 웹사이트의 [Elastic Database 기능 개요] 페이지에는 Elastic Database에 대한 포괄적인 소개가 나와 있습니다.
*  Microsoft 웹사이트의 [Elastic Database 분할-병합 도구를 사용한 크기 조정] 페이지에는 분할-병합 서비스를 사용하여 Elastic Database 샤드를 관리하는 방법에 대한 정보가 안내되어 있습니다.
*  Microsoft 웹사이트의 [Azure 저장소 확장성 및 성능 목표](https://msdn.microsoft.com/library/azure/dn249410.aspx) 페이지에는 Azure 저장소의 현재 크기 조정 및 처리량 제한에 대한 정보가 안내되어 있습니다.
*  Microsoft 웹사이트의 [엔터티 그룹 트랙잭션 실행] 페이지에는 Azure 테이블 저장소에 저장된 엔터티에서 트랜잭션 작업을 구현하는 방법에 대한 세부 정보가 안내되어 있습니다.
*  Microsoft 웹사이트의 [Azure 저장소 테이블 설계 가이드] 항목에는 Azure 테이블 저장소에서 데이터를 분할하는 방법에 대한 세부 정보가 안내되어 있습니다.
*  Microsoft 웹사이트의 [Azure 콘텐츠 제공 네트워크(CDN) 사용] 페이지에는 Azure blob 저장소에 저장된 데이터를 Azure 콘텐츠 제공 네트워크(CDN)를 사용하여 복제하는 방법에 대해 설명되어 있습니다.
*  Microsoft 웹사이트의 [DocumentDB 용량 요구 사항 관리] 페이지에는 Azure DocumentDB 데이터베이스가 리소스를 할당하는 방법에 대해 안내되어 있습니다.
*  Microsoft 웹사이트의 [Azure Search란?] 페이지에는 Azure Search에서 사용할 수 있는 기능에 대한 전체 설명이 안내되어 있습니다.
*  Microsoft 웹사이트의 [Azure Search의 서비스 제한] 페이지에는 각 Azure Search 인스턴스의 용량에 대한 정보가 안내되어 있습니다.
*  Microsoft 웹사이트의 [지원 데이터 형식(Azure Search)] 페이지에는 검색 가능한 문서와 인덱스에서 사용할 수 있는 데이터 형식에 대해 간략하게 설명되어 있습니다.
*  Microsoft 웹사이트의 [Azure Redis Cache] 페이지에는 Azure Redis Cache에 대한 소개가 안내되어 있습니다.
* Redis 웹사이트의 [분할: 다중 Redis 인스턴스에서 데이터를 분할하는 방법] 페이지에는 Redis를 사용하여 분할을 실행하는 방법에 대한 정보가 안내되어 있습니다.
*  Microsoft 웹사이트의 [Azure의 CentOS Linux VM에서 Redis 실행] 페이지에는 Azure VM으로 실행되는 Redis 노드를 빌드하고 구성하는 방법을 보여 주는 예제가 나와 있습니다.
* Redis 웹사이트의 [데이터 형식] 페이지에는 Redis와 Azure Redis Cache에서 사용할 수 있는 데이터 형식에 대한 설명이 안내되어 있습니다.

[Azure Redis Cache]: http://azure.microsoft.com/services/cache/
[Azure Storage Scalability and Performance Targets]: /azure/storage/storage-scalability-targets
[Azure Storage Table Design Guide]: /azure/storage/storage-table-design-guide
[Building a Polyglot Solution]: https://msdn.microsoft.com/library/dn313279.aspx
[Data Access for Highly-Scalable Solutions: Using SQL, NoSQL, and Polyglot Persistence]: https://msdn.microsoft.com/library/dn271399.aspx
[Data consistency primer]: http://aka.ms/Data-Consistency-Primer
[Data Partitioning Guidance]: https://msdn.microsoft.com/library/dn589795.aspx
[Data Types]: http://redis.io/topics/data-types
[DocumentDB limits and quotas]: /azure/documentdb/documentdb-limits
[Elastic Database features overview]: /azure/sql-database/sql-database-elastic-scale-introduction
[Federations Migration Utility]: https://code.msdn.microsoft.com/vstudio/Federations-Migration-ce61e9c1
[Index Table Pattern]: http://aka.ms/Index-Table-Pattern
[Manage DocumentDB capacity needs]: /azure/documentdb/documentdb-manage
[Materialized View Pattern]: http://aka.ms/Materialized-View-Pattern
[Multi-shard querying]: /azure/sql-database/sql-database-elastic-scale-multishard-querying
[Partitioning: how to split data among multiple Redis instances]: http://redis.io/topics/partitioning
[Performance levels in DocumentDB]: /azure/documentdb/documentdb-performance-levels
[Performing Entity Group Transactions]: https://msdn.microsoft.com/library/azure/dd894038.aspx
[Redis cluster tutorial]: http://redis.io/topics/cluster-tutorial
[Running Redis on a CentOS Linux VM in Azure]: http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx
[Scaling using the Elastic Database split-merge tool]: /azure/sql-database/sql-database-elastic-scale-overview-split-and-merge
[Using Azure Content Delivery Network]: /azure/cdn/cdn-create-new-endpoint
[Service Bus quotas]: /azure/service-bus-messaging/service-bus-quotas
[Service limits in Azure Search]:  /azure/search/search-limits-quotas-capacity
[Sharding pattern]: http://aka.ms/Sharding-Pattern
[Supported Data Types (Azure Search)]:  https://msdn.microsoft.com/library/azure/dn798938.aspx
[Transactions]: http://redis.io/topics/transactions
[What is Azure Search?]: /azure/search/search-what-is-azure-search
[What is Azure SQL Database?]: /azure/sql-database/sql-database-technical-overview
