---
title: 데이터 분할 지침
titleSuffix: Best practices for cloud applications
description: 별도로 관리하고 액세스할 수 있도록 파티션을 구분하는 방법에 대한 참고 자료입니다.
author: dragon119
ms.date: 11/04/2018
ms.custom: seodec18
ms.openlocfilehash: 9441c4404af991b327cd027c145604921f0223fb
ms.sourcegitcommit: 4ba3304eebaa8c493c3e5307bdd9d723cd90b655
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 12/12/2018
ms.locfileid: "53307098"
---
# <a name="horizontal-vertical-and-functional-data-partitioning"></a><span data-ttu-id="ea07a-103">수평, 수직 및 기능별 데이터 분할</span><span class="sxs-lookup"><span data-stu-id="ea07a-103">Horizontal, vertical, and functional data partitioning</span></span>

<span data-ttu-id="ea07a-104">대부분의 대규모 솔루션은 데이터를 개별적으로 관리하고 액세스할 수 있는 *파티션*으로 나눕니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-104">In many large-scale solutions, data is divided into *partitions* that can be managed and accessed separately.</span></span> <span data-ttu-id="ea07a-105">분할을 통해 확장성을 향상시키고 경합을 줄여 성능을 최적화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-105">Partitioning can improve scalability, reduce contention, and optimize performance.</span></span> <span data-ttu-id="ea07a-106">데이터를 사용 패턴에 따라 나누는 메커니즘도 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-106">It can also provide a mechanism for dividing data by usage pattern.</span></span> <span data-ttu-id="ea07a-107">예를 들어 더 오래된 데이터를 더 저렴한 데이터 스토리지에 보관할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-107">For example, you can archive older data in cheaper data storage.</span></span>

<span data-ttu-id="ea07a-108">하지만 부정적인 영향을 최소화하고 이점을 극대화할 수 있도록 분할 전략을 신중하게 선택해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-108">However, the partitioning strategy must be chosen carefully to maximize the benefits while minimizing adverse effects.</span></span>

> [!NOTE]
> <span data-ttu-id="ea07a-109">이 문서에서 용어 *분할*은 데이터를 별도의 데이터 저장소에 물리적으로 나누는 프로세스를 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-109">In this article, the term *partitioning* means the process of physically dividing data into separate data stores.</span></span> <span data-ttu-id="ea07a-110">SQL Server 테이블 분할과는 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-110">It is not the same as SQL Server table partitioning.</span></span>

<!-- markdownlint-disable MD026 -->

## <a name="why-partition-data"></a><span data-ttu-id="ea07a-111">데이터를 분할하는 이유</span><span class="sxs-lookup"><span data-stu-id="ea07a-111">Why partition data?</span></span>

<!-- markdownlint-enable MD026 -->

- <span data-ttu-id="ea07a-112">**확장성 향상**.</span><span class="sxs-lookup"><span data-stu-id="ea07a-112">**Improve scalability**.</span></span> <span data-ttu-id="ea07a-113">단일 데이터베이스 시스템을 확장하면 결국 물리적 하드웨어 한도에 도달하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-113">When you scale up a single database system, it will eventually reach a physical hardware limit.</span></span> <span data-ttu-id="ea07a-114">각각 별도의 서버에 호스트되어 있는 여러 파티션에 데이터를 나누면 시스템을 거의 무제한으로 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-114">If you divide data across multiple partitions, each hosted on a separate server, you can scale out the system almost indefinitely.</span></span>

- <span data-ttu-id="ea07a-115">**성능 향상**.</span><span class="sxs-lookup"><span data-stu-id="ea07a-115">**Improve performance**.</span></span> <span data-ttu-id="ea07a-116">각 파티션에 대한 데이터 액세스 작업은 더 작은 볼륨의 데이터에 대해 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-116">Data access operations on each partition take place over a smaller volume of data.</span></span> <span data-ttu-id="ea07a-117">분할을 올바르게 수행하면 시스템 효율성을 높일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-117">Correctly done, partitioning can make your system more efficient.</span></span> <span data-ttu-id="ea07a-118">둘 이상의 파티션에 영향을 주는 작업은 병렬로 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-118">Operations that affect more than one partition can run in parallel.</span></span>

- <span data-ttu-id="ea07a-119">**보안 기능 향상**.</span><span class="sxs-lookup"><span data-stu-id="ea07a-119">**Improve security**.</span></span> <span data-ttu-id="ea07a-120">경우에 따라 중요한 데이터와 중요하지 않은 데이터를 서로 다른 파티션에 분리하고 중요한 데이터에 다른 보안 컨트롤을 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-120">In some cases, you can separate sensitive and non-sensitive data into different partitions and apply different security controls to the sensitive data.</span></span>

- <span data-ttu-id="ea07a-121">**유연한 운영**.</span><span class="sxs-lookup"><span data-stu-id="ea07a-121">**Provide operational flexibility**.</span></span> <span data-ttu-id="ea07a-122">분할을 수행하면 작업을 미세 조정하고, 관리 효율성을 극대화하며, 비용을 최소화할 수 있는 기회가 늘어납니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-122">Partitioning offers many opportunities for fine tuning operations, maximizing administrative efficiency, and minimizing cost.</span></span> <span data-ttu-id="ea07a-123">예를 들어 각 파티션의 데이터 중요도에 따라 관리, 모니터링, 백업 및 복원, 기타 관리 작업에 다양한 전략을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-123">For example, you can define different strategies for management, monitoring, backup and restore, and other administrative tasks based on the importance of the data in each partition.</span></span>

- <span data-ttu-id="ea07a-124">**사용 패턴에 맞게 데이터 저장소 조정**.</span><span class="sxs-lookup"><span data-stu-id="ea07a-124">**Match the data store to the pattern of use**.</span></span> <span data-ttu-id="ea07a-125">분할은 데이터 저장소에서 제공하는 기본 제공 기능 및 비용에 따라 각 파티션을 다양한 유형의 데이터 저장소에 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-125">Partitioning allows each partition to be deployed on a different type of data store, based on cost and the built-in features that data store offers.</span></span> <span data-ttu-id="ea07a-126">예를 들어 대용량 이진 데이터는 Blob 스토리지에 저장할 수 있으며, 좀 더 구조화된 데이터는 문서 데이터베이스에 보관할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-126">For example, large binary data can be stored in blob storage, while more structured data can be held in a document database.</span></span> <span data-ttu-id="ea07a-127">[적절한 데이터 저장소 선택](../guide/technology-choices/data-store-overview.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ea07a-127">See [Choose the right data store](../guide/technology-choices/data-store-overview.md).</span></span>

- <span data-ttu-id="ea07a-128">**가용성 향상**.</span><span class="sxs-lookup"><span data-stu-id="ea07a-128">**Improve availability**.</span></span> <span data-ttu-id="ea07a-129">데이터를 여러 서버에 분리하면 단일 장애 지점이 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-129">Separating data across multiple servers avoids a single point of failure.</span></span> <span data-ttu-id="ea07a-130">한 인스턴스가 실패하면 해당 파티션의 데이터만 사용할 수 없게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-130">If one instance fails, only the data in that partition is unavailable.</span></span> <span data-ttu-id="ea07a-131">다른 파티션에 대한 작업은 계속 진행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-131">Operations on other partitions can continue.</span></span> <span data-ttu-id="ea07a-132">관리 PaaS 데이터 저장소의 경우 기본 제공 중복성을 사용하여 이러한 서비스를 디자인하므로 이 고려 사항이 별 관계가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-132">For managed PaaS data stores, this consideration is less relevant, because these services are designed with built-in redundancy.</span></span>

## <a name="designing-partitions"></a><span data-ttu-id="ea07a-133">파티션 디자인</span><span class="sxs-lookup"><span data-stu-id="ea07a-133">Designing partitions</span></span>

<span data-ttu-id="ea07a-134">데이터를 분할하는 세 가지 일반 전략이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-134">There are three typical strategies for partitioning data:</span></span>

- <span data-ttu-id="ea07a-135">**행 분할**(일반적으로 *분할*이라고 함).</span><span class="sxs-lookup"><span data-stu-id="ea07a-135">**Horizontal partitioning** (often called *sharding*).</span></span> <span data-ttu-id="ea07a-136">이 전략에서는 각 파티션이 별도의 데이터 저장소이지만, 모든 파티션의 스키마가 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-136">In this strategy, each partition is a separate data store, but all partitions have the same schema.</span></span> <span data-ttu-id="ea07a-137">각 파티션을 *분할된 데이터베이스*라고 하며, 특정 고객 집합의 주문 같은 구체적인 데이터 하위 집합을 보관합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-137">Each partition is known as a *shard* and holds a specific subset of the data, such as all the orders for a specific set of customers.</span></span>

- <span data-ttu-id="ea07a-138">**수직 분할**.</span><span class="sxs-lookup"><span data-stu-id="ea07a-138">**Vertical partitioning**.</span></span> <span data-ttu-id="ea07a-139">이 전략에서는 각 파티션에 데이터 저장소의 항목 필드 하위 집합이 보관됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-139">In this strategy, each partition holds a subset of the fields for items in the data store.</span></span> <span data-ttu-id="ea07a-140">필드는 해당 사용 패턴에 따라 구분됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-140">The fields are divided according to their pattern of use.</span></span> <span data-ttu-id="ea07a-141">예를 들어 자주 액세스되는 필드가 하나의 수직 분할에 배치되고 덜 자주 액세스되는 필드가 또 다른 수직 분할에 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-141">For example, frequently accessed fields might be placed in one vertical partition and less frequently accessed fields in another.</span></span>

- <span data-ttu-id="ea07a-142">**기능 분할**.</span><span class="sxs-lookup"><span data-stu-id="ea07a-142">**Functional partitioning**.</span></span> <span data-ttu-id="ea07a-143">이 전략에서는 시스템의 제한된 컨텍스트별로 데이터가 사용되는 방법에 따라 데이터를 집계합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-143">In this strategy, data is aggregated according to how it is used by each bounded context in the system.</span></span> <span data-ttu-id="ea07a-144">예를 들어 전자상거래 시스템에서 청구서 데이터와 제품 재고 데이터를 서로 다른 파티션에 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-144">For example, an e-commerce system might store invoice data in one partition and product inventory data in another.</span></span>

<span data-ttu-id="ea07a-145">이러한 전략을 결합하여 사용할 수 있으며, 파티션 구성표를 디자인할 때 모든 전략을 고려하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-145">These strategies can be combined, and we recommend that you consider them all when you design a partitioning scheme.</span></span> <span data-ttu-id="ea07a-146">예를 들어, 데이터를 분할된 데이터베이스에 나눈 후 각각의 분할된 데이터베이스에서 수직 분할을 사용하여 데이터를 더 세분화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-146">For example, you might divide data into shards and then use vertical partitioning to further subdivide the data in each shard.</span></span>

### <a name="horizontal-partitioning-sharding"></a><span data-ttu-id="ea07a-147">행 분할(분할)</span><span class="sxs-lookup"><span data-stu-id="ea07a-147">Horizontal partitioning (sharding)</span></span>

<span data-ttu-id="ea07a-148">그림 1은 행 분할 또는 분할을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-148">Figure 1 shows horizontal partitioning or sharding.</span></span> <span data-ttu-id="ea07a-149">이 예에서는 제품 재고 데이터가 제품 키에 따라 분할된 데이터베이스로 나뉩니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-149">In this example, product inventory data is divided into shards based on the product key.</span></span> <span data-ttu-id="ea07a-150">각각의 분할된 데이터베이스에는 연속된 분할 키 범위(A-G 및 H-Z)별로 데이터가 사전순으로 정렬되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-150">Each shard holds the data for a contiguous range of shard keys (A-G and H-Z), organized alphabetically.</span></span> <span data-ttu-id="ea07a-151">분할을 사용하면 더 많은 컴퓨터에 부하를 분산하여 경합을 줄이고 성능을 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-151">Sharding spreads the load over more computers, which reduces contention and improves performance.</span></span>

![파티션 키에 따라 데이터를 수평으로 분할](./images/data-partitioning/DataPartitioning01.png)

<span data-ttu-id="ea07a-153">*그림 1. 파티션 키에 따라 데이터를 수평으로 분할.*</span><span class="sxs-lookup"><span data-stu-id="ea07a-153">*Figure 1. Horizontally partitioning (sharding) data based on a partition key.*</span></span>

<span data-ttu-id="ea07a-154">가장 중요한 요소에는 분할 키의 선택입니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-154">The most important factor is the choice of a sharding key.</span></span> <span data-ttu-id="ea07a-155">시스템이 작동된 후에는 키를 변경하기 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-155">It can be difficult to change the key after the system is in operation.</span></span> <span data-ttu-id="ea07a-156">키는 분할된 데이터베이스에 워크로드가 최대한 균등하게 분산되도록 데이터를 분할해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-156">The key must ensure that data is partitioned to spread the workload as evenly as possible across the shards.</span></span>

<span data-ttu-id="ea07a-157">분할된 데이터베이스의 크기가 같을 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-157">The shards don't have to be the same size.</span></span> <span data-ttu-id="ea07a-158">요청 수의 균형을 맞추는 것이 더 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-158">It's more important to balance the number of requests.</span></span> <span data-ttu-id="ea07a-159">일부 분할된 데이터베이스는 용량이 매우 크지만 각 항목의 액세스 작업 수가 적습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-159">Some shards might be very large, but each item has a low number of access operations.</span></span> <span data-ttu-id="ea07a-160">용량은 작지만 각 항목이 더 자주 액세스될 수 있는 분할된 데이터베이스도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-160">Other shards might be smaller, but each item is accessed much more frequently.</span></span> <span data-ttu-id="ea07a-161">하나의 분할된 데이터베이스가 데이터 저장소의 확장 한도(용량 및 처리 리소스의 측면에서)를 초과하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-161">It's also important to ensure that a single shard does not exceed the scale limits (in terms of capacity and processing resources) of the data store.</span></span>

<span data-ttu-id="ea07a-162">성능 및 가용성에 영향을 미칠 수 있는 "핫" 파티션을 만들지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-162">Avoid creating "hot" partitions that can affect performance and availability.</span></span> <span data-ttu-id="ea07a-163">예를 들어 고객 이름의 첫 번째 문자를 사용하면 일부 문자가 보다 일반적이기 때문에 배포가 불균형하게 됩니다. 고객 식별자 해시를 대신 사용하여 파티션 간에 데이터를 보다 균등하게 배포해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-163">For example, using the first letter of a customer’s name causes an unbalanced distribution, because some letters are more common Instead, use a hash of a customer identifier to distribute data more evenly across partitions.</span></span>

<span data-ttu-id="ea07a-164">대용량의 분할된 데이터베이스를 분할하거나, 작은 분할된 데이터베이스를 대규모 파티션으로 병합하거나, 스키마를 변경해야 하는 등의 향후 요구 사항을 최소화하는 분할 키를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-164">Choose a sharding key that minimizes any future requirements to split large shards, coalesce small shards into larger partitions, or change the schema.</span></span> <span data-ttu-id="ea07a-165">이러한 작업에는 시간이 많이 소요될 수 있으며 작업이 수행되는 동안 하나 이상의 분할된 데이터베이스를 오프라인 상태로 설정해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-165">These operations can be very time consuming, and might require taking one or more shards offline while they are performed.</span></span>

<span data-ttu-id="ea07a-166">분할된 데이터베이스가 복제된 경우 일부 복제본은 다른 복제본을 분할, 병합 또는 재구성하는 동안 온라인 상태를 유지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-166">If shards are replicated, it might be possible to keep some of the replicas online while others are split, merged, or reconfigured.</span></span> <span data-ttu-id="ea07a-167">그러나 시스템에서 재구성 중에 수행 가능한 작업을 제한해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-167">However, the system might need to limit the operations that can be performed during the reconfiguration.</span></span> <span data-ttu-id="ea07a-168">예를 들어 데이터 불일치를 방지하기 위해 복제본의 데이터를 읽기 전용으로 표시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-168">For example, the data in the replicas might be marked as read-only to prevent data inconsistences.</span></span>

<span data-ttu-id="ea07a-169">행 분할에 대한 자세한 내용은 [분할 패턴]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ea07a-169">For more information about horizontal partitioning, see [Sharding pattern].</span></span>

### <a name="vertical-partitioning"></a><span data-ttu-id="ea07a-170">수직 분할</span><span class="sxs-lookup"><span data-stu-id="ea07a-170">Vertical partitioning</span></span>

<span data-ttu-id="ea07a-171">수직 분할은 자주 액세스하는 항목을 가져오는 것과 연관된 I/O 및 성능 저하를 줄이기 위해 가장 많이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-171">The most common use for vertical partitioning is to reduce the I/O and performance costs associated with fetching items that are frequently accessed.</span></span> <span data-ttu-id="ea07a-172">그림 2에서 수직 분할의 예제를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-172">Figure 2 shows an example of vertical partitioning.</span></span> <span data-ttu-id="ea07a-173">이 예제에서는 한 항목의 여러 속성이 서로 다른 파티션에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-173">In this example, different properties of an item are stored in different partitions.</span></span> <span data-ttu-id="ea07a-174">한 파티션은 제품의 이름, 설명 및 가격을 포함하여 더 자주 액세스되는 데이터를 보관합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-174">One partition holds data that is accessed more frequently, including product name, description, and price.</span></span> <span data-ttu-id="ea07a-175">다른 파티션은 재고 수, 마지막 주문 날짜 등의 인벤토리 데이터를 보관합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-175">Another partition holds inventory data: the stock count and last-ordered date.</span></span>

![사용 패턴에 따라 데이터를 수직으로 분할](./images/data-partitioning/DataPartitioning02.png)

<span data-ttu-id="ea07a-177">*그림 2. 사용 패턴에 따라 데이터를 수직으로 분할.*</span><span class="sxs-lookup"><span data-stu-id="ea07a-177">*Figure 2. Vertically partitioning data by its pattern of use.*</span></span>

<span data-ttu-id="ea07a-178">이 예제에서는 애플리케이션이 고객에게 제품 세부 정보를 표시할 때 제품 이름, 설명 및 가격을 정기적으로 쿼리합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-178">In this example, the application regularly queries the product name, description, and price when displaying the product details to customers.</span></span> <span data-ttu-id="ea07a-179">재고 수와 마지막 주문 날짜는 보통 함께 사용되기 때문에 별도의 파티션에 보관됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-179">Stock count and last- ordered date are held in a separate partition because these two items are commonly used together.</span></span>

<span data-ttu-id="ea07a-180">그 외에도 수직 분할은 다음과 같은 장점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-180">Other advantages of vertical partitioning:</span></span>

- <span data-ttu-id="ea07a-181">비교적 이동 속도가 느린 데이터(제품 이름, 설명 및 가격)와 동적 데이터(재고 수준 및 마지막 주문 날짜)를 분리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-181">Relatively slow-moving data (product name, description, and price) can be separated from the more dynamic data (stock level and last ordered date).</span></span> <span data-ttu-id="ea07a-182">이동 속도가 느린 데이터는 메모리에 캐시할 애플리케이션에 사용하기 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-182">Slow moving data is a good candidate for an application to cache in memory.</span></span>

- <span data-ttu-id="ea07a-183">중요한 데이터는 추가 보안 컨트롤이 적용되는 별도의 파티션에 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-183">Sensitive data can be stored in a separate partition with additional security controls.</span></span>

- <span data-ttu-id="ea07a-184">수직 분할은 필요한 동시 액세스의 양을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-184">Vertical partitioning can reduce the amount of concurrent access that's needed.</span></span>

<span data-ttu-id="ea07a-185">수직 분할은 데이터 저장소에서 엔터티 수준으로 수행되며, 특히 엔터티를 부분적으로 정규화하여 *범위가 넓은* 항목을 *범위가 좁은* 항목 집합으로 분할합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-185">Vertical partitioning operates at the entity level within a data store, partially normalizing an entity to break it down from a *wide* item to a set of *narrow* items.</span></span> <span data-ttu-id="ea07a-186">HBase 및 Cassandra와 같은 열 기반 데이터 저장소에 가장 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-186">It is ideally suited for column-oriented data stores such as HBase and Cassandra.</span></span> <span data-ttu-id="ea07a-187">열 컬렉션의 데이터가 변경될 가능성이 없는 경우 SQL Server의 열 저장소를 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-187">If the data in a collection of columns is unlikely to change, you can also consider using column stores in SQL Server.</span></span>

### <a name="functional-partitioning"></a><span data-ttu-id="ea07a-188">기능 분할</span><span class="sxs-lookup"><span data-stu-id="ea07a-188">Functional partitioning</span></span>

<span data-ttu-id="ea07a-189">애플리케이션에서 각 고유 비즈니스 영역의 제한된 컨텍스트를 식별할 수 있는 경우 기능 분할을 사용하면 격리 및 데이터 액세스 성능을 향상할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-189">When it's possible to identify a bounded context for each distinct business area in an application, functional partitioning is a way to improve isolation and data access performance.</span></span> <span data-ttu-id="ea07a-190">기능 분할의 또 다른 일반적인 용도는 읽기 전용 데이터에서 읽기-쓰기 데이터를 분리하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-190">Another common use for functional partitioning is to separate read-write data from read-only data.</span></span> <span data-ttu-id="ea07a-191">그림 3에서는 재고 데이터와 고객 데이터를 분리하는 기능 분할의 개요를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-191">Figure 3 shows an overview of functional partitioning where inventory data is separated from customer data.</span></span>

![제한된 컨텍스트 또는 하위 도메인별로 데이터를 기능적으로 분할](./images/data-partitioning/DataPartitioning03.png)

<span data-ttu-id="ea07a-193">*그림 3. 제한된 컨텍스트 또는 하위 도메인별로 데이터를 기능적으로 분할.*</span><span class="sxs-lookup"><span data-stu-id="ea07a-193">*Figure 3. Functionally partitioning data by bounded context or subdomain.*</span></span>

<span data-ttu-id="ea07a-194">이러한 분할 전략은 시스템의 여러 부분에서 데이터 액세스 경합을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-194">This partitioning strategy can help reduce data access contention across different parts of a system.</span></span>

## <a name="designing-partitions-for-scalability"></a><span data-ttu-id="ea07a-195">확장성을 위한 파티션 디자인</span><span class="sxs-lookup"><span data-stu-id="ea07a-195">Designing partitions for scalability</span></span>

<span data-ttu-id="ea07a-196">데이터가 분산되어 최대 확장성을 달성하도록 각 파티션의 크기 및 워크로드를 고려하여 부하를 분산해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-196">It's vital to consider size and workload for each partition and balance them so that data is distributed to achieve maximum scalability.</span></span> <span data-ttu-id="ea07a-197">그러나 데이터 분할도 수행하여 단일 파티션 저장소의 확장 한도를 초과하지 않도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-197">However, you must also partition the data so that it does not exceed the scaling limits of a single partition store.</span></span>

<span data-ttu-id="ea07a-198">확장성을 위해 파티션을 디자인하는 경우 다음 단계를 따르세요.</span><span class="sxs-lookup"><span data-stu-id="ea07a-198">Follow these steps when designing partitions for scalability:</span></span>

1. <span data-ttu-id="ea07a-199">애플리케이션을 분석하여 데이터 액세스 패턴(예: 각 쿼리에서 반환된 결과 집합의 크기, 액세스 빈도, 고유 대기 시간, 서버 쪽 계산 처리 요구 사항)을 이해합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-199">Analyze the application to understand the data access patterns, such as the size of the result set returned by each query, the frequency of access, the inherent latency, and the server-side compute processing requirements.</span></span> <span data-ttu-id="ea07a-200">대부분의 경우 소수의 주요 엔터티에서 대부분의 처리 리소스를 요청합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-200">In many cases, a few major entities will demand most of the processing resources.</span></span>
2. <span data-ttu-id="ea07a-201">이 분석을 사용하여 현재 및 미래의 확장성 목표(예: 데이터 크기 및 워크로드)를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-201">Use this analysis to determine the current and future scalability targets, such as data size and workload.</span></span> <span data-ttu-id="ea07a-202">그런 다음 확장성 목표에 맞도록 데이터를 파티션에 분산합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-202">Then distribute the data across the partitions to meet the scalability target.</span></span> <span data-ttu-id="ea07a-203">행 분할의 경우 데이터를 고르게 분산할 수 있도록 적절한 분할 키를 선택하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-203">For horizontal partitioning, choosing the right shard key is important to make sure distribution is even.</span></span> <span data-ttu-id="ea07a-204">자세한 내용은 [분할 패턴]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ea07a-204">For more information, see the [Sharding pattern].</span></span>
3. <span data-ttu-id="ea07a-205">데이터 크기 및 처리량의 관점에서, 각 파티션에는 확장성 요구 사항을 처리하기에 충분한 리소스가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-205">Make sure each partition has enough resources to handle the scalability requirements, in terms of data size and throughput.</span></span> <span data-ttu-id="ea07a-206">데이터 저장소에 따라 스토리지 공간의 양, 처리 능력 또는 파티션당 네트워크 대역폭에 제한이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-206">Depending on the data store, there might be a limit on the amount of storage space, processing power, or network bandwidth per partition.</span></span> <span data-ttu-id="ea07a-207">요구 사항이 이러한 제한을 초과할 가능성이 있는 경우 분할 전략을 세분화하거나 데이터를 더 분할해야 할 수 있습니다. 가능하다면 두 개 이상의 전략을 결합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-207">If the requirements are likely to exceed these limits, you may need to refine your partitioning strategy or split data out further, possibly combining two or more strategies.</span></span>
4. <span data-ttu-id="ea07a-208">시스템을 모니터링하여 데이터가 예상대로 분산되는지, 파티션에서 부하를 처리할 수 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-208">Monitor the system to verify that data is distributed as expected and that the partitions can handle the load.</span></span> <span data-ttu-id="ea07a-209">실제 사용량이 분석 예측과 항상 일치하는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-209">Actual usage does not always match what an analysis predicts.</span></span> <span data-ttu-id="ea07a-210">이 경우 파티션 균형을 다시 조정할 수 있고, 그렇지 않은 경우 시스템 일부를 다시 디자인하여 필요한 균형을 맞출 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-210">If so, it might be possible to rebalance the partitions, or else redesign some parts of the system to gain the required balance.</span></span>

<span data-ttu-id="ea07a-211">일부 클라우드 환경에서는 인프라 경계를 기준으로 리소스를 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-211">Some cloud environments allocate resources in terms of infrastructure boundaries.</span></span> <span data-ttu-id="ea07a-212">선택한 경계에 대한 제한이 데이터 저장소, 처리 능력 및 대역폭 측면에서 예상되는 데이터 볼륨 증가에 맞게 충분한 공간을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-212">Ensure that the limits of your selected boundary provide enough room for any anticipated growth in the volume of data, in terms of data storage, processing power, and bandwidth.</span></span>

<span data-ttu-id="ea07a-213">예를 들어 Azure 테이블 스토리지를 사용하는 경우 특정 기간에 단일 파티션에서 처리할 수 있는 요청 볼륨이 제한되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-213">For example, if you use Azure table storage, there is a limit to the volume of requests that can be handled by a single partition in a particular period of time.</span></span> <span data-ttu-id="ea07a-214">([Azure Storage 확장성 및 성능 목표]를 참조하세요.) 사용 중인 분할된 데이터베이스는 단일 파티션에서 처리할 수 있는 양보다 더 많은 리소스를 요구합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-214">(See [Azure storage scalability and performance targets].) A busy shard might require more resources than a single partition can handle.</span></span> <span data-ttu-id="ea07a-215">이 경우 부하 분산을 위해 분할된 데이터베이스를 다시 분할해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-215">If so, the shard might need to be repartitioned to spread the load.</span></span> <span data-ttu-id="ea07a-216">테이블의 총 크기 또는 처리량이 스토리지 계정 용량을 초과하면 추가 스토리지 계정을 만들어 해당 계정에 테이블을 분산해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-216">If the total size or throughput of these tables exceeds the capacity of a storage account, you might need to create additional storage accounts and spread the tables across these accounts.</span></span>

## <a name="designing-partitions-for-query-performance"></a><span data-ttu-id="ea07a-217">쿼리 성능을 위한 파티션 디자인</span><span class="sxs-lookup"><span data-stu-id="ea07a-217">Designing partitions for query performance</span></span>

<span data-ttu-id="ea07a-218">일반적으로 더 작은 데이터 집합을 사용하고 병렬 쿼리를 실행하여 쿼리 성능을 높일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-218">Query performance can often be boosted by using smaller data sets and by running parallel queries.</span></span> <span data-ttu-id="ea07a-219">각 파티션에는 전체 데이터 집합의 일부분이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-219">Each partition should contain a small proportion of the entire data set.</span></span> <span data-ttu-id="ea07a-220">이렇게 볼륨이 감소하면서 쿼리 성능이 개선될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-220">This reduction in volume can improve the performance of queries.</span></span> <span data-ttu-id="ea07a-221">그러나 분할은 데이터베이스를 적절하게 디자인하고 구성하는 작업에 대한 대안이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-221">However, partitioning is not an alternative for designing and configuring a database appropriately.</span></span> <span data-ttu-id="ea07a-222">예를 들어 필요한 인덱스가 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-222">For example, make sure that you have the necessary indexes in place.</span></span>

<span data-ttu-id="ea07a-223">쿼리 성능을 위해 파티션을 디자인하는 경우 다음 단계를 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-223">Follow these steps when designing partitions for query performance:</span></span>

1. <span data-ttu-id="ea07a-224">다음과 같이 애플리케이션 요구 사항 및 성능을 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-224">Examine the application requirements and performance:</span></span>

   - <span data-ttu-id="ea07a-225">비즈니스 요구 사항을 사용하여 항상 신속하게 수행해야 하는 중요 쿼리를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-225">Use business requirements to determine the critical queries that must always perform quickly.</span></span>
   - <span data-ttu-id="ea07a-226">시스템을 모니터링하여 느리게 수행되는 쿼리를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-226">Monitor the system to identify any queries that perform slowly.</span></span>
   - <span data-ttu-id="ea07a-227">어떤 쿼리가 가장 자주 수행되는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-227">Find which queries are performed most frequently.</span></span> <span data-ttu-id="ea07a-228">단일 쿼리의 비용이 가장 적을 수 있지만, 누적 리소스 사용량은 매우 높을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-228">Even if a single query has a minimal cost, the cumulative resource consumption could be significant.</span></span>

2. <span data-ttu-id="ea07a-229">성능 저하를 초래하는 데이터를 분할합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-229">Partition the data that is causing slow performance:</span></span>
   - <span data-ttu-id="ea07a-230">쿼리 응답 시간이 목표 범위에 해당하도록 각 파티션 크기를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-230">Limit the size of each partition so that the query response time is within target.</span></span>
   - <span data-ttu-id="ea07a-231">행 분할을 사용하는 경우 애플리케이션에서 적절한 파티션을 쉽게 선택할 수 있도록 분할된 데이터베이스 키를 디자인합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-231">If you use horizontal partitioning, design the shard key so that the application can easily select the right partition.</span></span> <span data-ttu-id="ea07a-232">이렇게 하면 쿼리가 모든 분할을 검색할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-232">This prevents the query from having to scan through every partition.</span></span>
   - <span data-ttu-id="ea07a-233">파티션의 위치를 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-233">Consider the location of a partition.</span></span> <span data-ttu-id="ea07a-234">가능한 경우 애플리케이션 및 액세스하는 사용자와 지리적으로 가까운 파티션에 데이터를 보관하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-234">If possible, try to keep data in partitions that are geographically close to the applications and users that access it.</span></span>

3. <span data-ttu-id="ea07a-235">엔터티에 처리량 및 쿼리 성능 요구 사항이 있는 경우 해당 엔터티를 기반으로 기능 분할을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-235">If an entity has throughput and query performance requirements, use functional partitioning based on that entity.</span></span> <span data-ttu-id="ea07a-236">기능 분할을 사용해도 요구 사항을 충족할 수 없는 경우 행 분할도 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-236">If this still doesn't satisfy the requirements, apply horizontal partitioning as well.</span></span> <span data-ttu-id="ea07a-237">대부분의 경우 단일 분할 전략으로 충분하지만, 일부의 경우 두 전략을 결합하는 것이 더 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-237">In most cases a single partitioning strategy will suffice, but in some cases it is more efficient to combine both strategies.</span></span>

4. <span data-ttu-id="ea07a-238">성능 개선을 위해 여러 파티션에서 쿼리를 병렬로 실행하는 방안을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-238">Consider running queries in parallel across partitions to improve performance.</span></span>

## <a name="designing-partitions-for-availability"></a><span data-ttu-id="ea07a-239">가용성을 위한 파티션 디자인</span><span class="sxs-lookup"><span data-stu-id="ea07a-239">Designing partitions for availability</span></span>

<span data-ttu-id="ea07a-240">데이터를 분할하면 전체 데이터 세트에 단일 실패 지점이 구성되지 않도록 하고, 데이터 세트의 개별 하위 집합을 독립적으로 관리할 수 있도록 하여 응용 프로그램의 가용성을 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-240">Partitioning data can improve the availability of applications by ensuring that the entire dataset does not constitute a single point of failure and that individual subsets of the dataset can be managed independently.</span></span>

<span data-ttu-id="ea07a-241">가용성에 영향을 주는 다음 요인을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-241">Consider the following factors that affect availability:</span></span>

<span data-ttu-id="ea07a-242">**비즈니스 운영에 대한 데이터의 중요도**</span><span class="sxs-lookup"><span data-stu-id="ea07a-242">**How critical the data is to business operations**.</span></span> <span data-ttu-id="ea07a-243">트랜잭션처럼 중요한 비즈니스 정보와 로그 파일처럼 중요도가 낮은 운영 데이터를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-243">Identify which data is critical business information, such as transactions, and which data is less critical operational data, such as log files.</span></span>

- <span data-ttu-id="ea07a-244">적절한 백업 계획을 사용하여 중요한 데이터를 가용성이 높은 파티션에 저장하는 방안을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-244">Consider storing critical data in highly-available partitions with an appropriate backup plan.</span></span>

- <span data-ttu-id="ea07a-245">여러 데이터 세트에 대한 별도의 관리 및 모니터링 절차를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-245">Establish separate management and monitoring procedures for the different datasets.</span></span>

- <span data-ttu-id="ea07a-246">적절한 빈도로 함께 백업할 수 있도록 중요도 수준이 동일한 데이터를 같은 파티션에 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-246">Place data that has the same level of criticality in the same partition so that it can be backed up together at an appropriate frequency.</span></span> <span data-ttu-id="ea07a-247">예를 들어 트랜잭션 데이터를 보관하는 파티션은 로깅 또는 추적 정보가 있는 파티션보다 더 자주 백업해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-247">For example, partitions that hold transaction data might need to be backed up more frequently than partitions that hold logging or trace information.</span></span>

<span data-ttu-id="ea07a-248">**개별 파티션을 관리하는 방법**</span><span class="sxs-lookup"><span data-stu-id="ea07a-248">**How individual partitions can be managed**.</span></span> <span data-ttu-id="ea07a-249">파티션을 독립적으로 관리 및 유지 관리할 수 있도록 디자인하면 몇 가지 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-249">Designing partitions to support independent management and maintenance provides several advantages.</span></span> <span data-ttu-id="ea07a-250">예: </span><span class="sxs-lookup"><span data-stu-id="ea07a-250">For example:</span></span>

- <span data-ttu-id="ea07a-251">한 파티션이 실패하는 경우 다른 파티션에 있는 데이터에 액세스하는 애플리케이션 없이 파티션을 독립적으로 복구할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-251">If a partition fails, it can be recovered independently without applications that access data in other partitions.</span></span>

- <span data-ttu-id="ea07a-252">데이터를 지리적 영역에 따라 분할하면 각 지역에서 사용량이 적은 시간에 예약된 유지 관리 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-252">Partitioning data by geographical area allows scheduled maintenance tasks to occur at off-peak hours for each location.</span></span> <span data-ttu-id="ea07a-253">이 기간 동안 계획된 모든 유지 관리 작업을 완료할 수 있도록 파티션이 너무 크지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-253">Ensure that partitions are not too big to prevent any planned maintenance from being completed during this period.</span></span>

<span data-ttu-id="ea07a-254">**파티션 간 중요 데이터를 복제하는지 여부**</span><span class="sxs-lookup"><span data-stu-id="ea07a-254">**Whether to replicate critical data across partitions**.</span></span> <span data-ttu-id="ea07a-255">이 전략은 가용성과 성능을 향상시킬 수 있지만, 일관성 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-255">This strategy can improve availability and performance, but can also introduce consistency issues.</span></span> <span data-ttu-id="ea07a-256">모든 복제본과 변경 내용을 동기화하려면 시간이 걸립니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-256">It takes time to synchronize changes with every replica.</span></span> <span data-ttu-id="ea07a-257">이 기간에는 다양한 파티션에 서로 다른 데이터 값이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-257">During this period, different partitions will contain different data values.</span></span>

## <a name="application-design-considerations"></a><span data-ttu-id="ea07a-258">응용 프로그램 디자인 고려 사항</span><span class="sxs-lookup"><span data-stu-id="ea07a-258">Application design considerations</span></span>

<span data-ttu-id="ea07a-259">분할을 사용하면 시스템 디자인 및 개발이 더 복잡해집니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-259">Partitioning adds complexity to the design and development of your system.</span></span> <span data-ttu-id="ea07a-260">초기 시스템에 하나의 파티션만 포함되어 있는 경우에도 시스템 디자인의 기본적인 부분으로 분할하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-260">Consider partitioning as a fundamental part of system design even if the system initially only contains a single partition.</span></span> <span data-ttu-id="ea07a-261">나중에 분할을 처리하면 이미 유지 관리할 라이브 시스템이 있으므로 더 어려워집니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-261">If you address partitioning as an afterthought, it will be more challenging because you already have a live system to maintain:</span></span>

- <span data-ttu-id="ea07a-262">데이터 액세스 논리를 수정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-262">Data access logic will need to be modified.</span></span>
- <span data-ttu-id="ea07a-263">대량의 기존 데이터를 마이그레이션하여 여러 파티션에 분산해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-263">Large quantities of existing data may need to be migrated, to distribute it across partitions</span></span>
- <span data-ttu-id="ea07a-264">사용자는 마이그레이션하는 동안 시스템을 계속 사용할 수 있기를 기대합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-264">Users expect to be able to continue using the system during the migration.</span></span>

<span data-ttu-id="ea07a-265">일부 경우에는 초기 데이터 세트가 작아 단일 서버로 쉽게 처리할 수 있기 때문에 분할을 중요하게 고려하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-265">In some cases, partitioning is not considered important because the initial dataset is small and can be easily handled by a single server.</span></span> <span data-ttu-id="ea07a-266">일부 워크로드에는 정답일 수 있지만, 대부분의 상용 시스템은 사용자가 증가하는 만큼 확장해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-266">This might be true for some workloads, but many commercial systems need to expand as the number of users increases.</span></span>

<span data-ttu-id="ea07a-267">또한 분할하는 것이 좋은 대용량 데이터 저장소만 있는 것이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-267">Moreover, it's not only large data stores that benefit from partitioning.</span></span> <span data-ttu-id="ea07a-268">예를 들어, 수백 개의 동시 클라이언트에서 작은 데이터 저장소에 과도하게 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-268">For example, a small data store might be heavily accessed by hundreds of concurrent clients.</span></span> <span data-ttu-id="ea07a-269">이러한 상황에서 데이터를 분할하면 경합을 줄이고 처리량을 향상시키는 데 도움이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-269">Partitioning the data in this situation can help to reduce contention and improve throughput.</span></span>

<span data-ttu-id="ea07a-270">데이터 파티션 구성표를 설계할 때 다음 사항을 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="ea07a-270">Consider the following points when you design a data partitioning scheme:</span></span>

<span data-ttu-id="ea07a-271">**파티션 간 데이터 액세스 작업을 최소화합니다**.</span><span class="sxs-lookup"><span data-stu-id="ea07a-271">**Minimize cross-partition data access operations**.</span></span> <span data-ttu-id="ea07a-272">가능한 경우 가장 많이 사용되는 데이터베이스 작업에 대한 데이터를 각 파티션에 함께 보관하여 파티션 간 데이터 액세스 작업을 최소화합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-272">Where possible, keep data for the most common database operations together in each partition to minimize cross-partition data access operations.</span></span> <span data-ttu-id="ea07a-273">여러 파티션에서 수행되는 쿼리는 단일 파티션에서 수행되는 쿼리보다 시간이 더 걸릴 수 있지만, 파티션을 하나의 쿼리 집합에 최적화하면 다른 쿼리 집합에 부정적인 영향을 미칠 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-273">Querying across partitions can be more time-consuming than querying within a single partition, but optimizing partitions for one set of queries might adversely affect other sets of queries.</span></span> <span data-ttu-id="ea07a-274">여러 파티션에서 쿼리해야 하는 경우 병렬 쿼리를 실행하고 애플리케이션 내에서 결과를 집계하여 쿼리 시간을 최소화합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-274">If you must query across partitions, minimize query time by running parallel queries and aggregating the results within the application.</span></span> <span data-ttu-id="ea07a-275">(이 방법은 한 쿼리의 결과가 그 다음 쿼리에 사용되는 경우와 비슷한 상황에서는 사용할 수 없습니다.)</span><span class="sxs-lookup"><span data-stu-id="ea07a-275">(This approach might not be possible in some cases, such as when the result from one query is used in the next query.)</span></span>

<span data-ttu-id="ea07a-276">**정적 참조 데이터를 복제하는 방안을 고려합니다.**</span><span class="sxs-lookup"><span data-stu-id="ea07a-276">**Consider replicating static reference data.**</span></span> <span data-ttu-id="ea07a-277">쿼리에서 상대적으로 정적인 참조 데이터(예: 우편 번호 테이블 또는 제품 목록)를 사용하는 경우 다른 파티션에서 별도로 조회해야 하는 작업을 줄이도록 해당 데이터를 모든 파티션에 복제하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-277">If queries use relatively static reference data, such as postal code tables or product lists, consider replicating this data in all of the partitions to reduce separate lookup operations in different partitions.</span></span> <span data-ttu-id="ea07a-278">또한 이 방법은 참조 데이터가 시스템 전체에서 트래픽이 많이 발생하는 "핫" 데이터 세트가 될 가능성을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-278">This approach can also reduce the likelihood of the reference data becoming a "hot" dataset, with heavy traffic from across the entire system.</span></span> <span data-ttu-id="ea07a-279">그러나 참조 데이터의 변경 내용을 동기화하기 위한 추가 비용이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-279">However, there is an additional cost associated with synchronizing any changes to the reference data.</span></span>

<span data-ttu-id="ea07a-280">**파티션 간 조인을 최소화합니다.**</span><span class="sxs-lookup"><span data-stu-id="ea07a-280">**Minimize cross-partition joins.**</span></span> <span data-ttu-id="ea07a-281">가능하면 수직 파티션과 기능 파티션 간 참조 무결성 요구 사항을 최소화합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-281">Where possible, minimize requirements for referential integrity across vertical and functional partitions.</span></span> <span data-ttu-id="ea07a-282">이 구성표에서 애플리케이션은 파티션 간 참조 무결성을 유지하는 책임을 맡습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-282">In these schemes, the application is responsible for maintaining referential integrity across partitions.</span></span> <span data-ttu-id="ea07a-283">여러 파티션에서 데이터를 조인하는 쿼리는 효율성이 떨어집니다. 왜냐하면 일반적으로 애플리케이션은 키 그리고 그 다음에는 외래 키를 기반으로 연속 쿼리를 수행해야 하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-283">Queries that join data across multiple partitions are inefficient because the application typically needs to perform consecutive queries based on a key and then a foreign key.</span></span> <span data-ttu-id="ea07a-284">대신, 관련 데이터를 복제하거나 비정규화하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-284">Instead, consider replicating or de-normalizing the relevant data.</span></span> <span data-ttu-id="ea07a-285">파티션 간 조인이 필요한 경우 파티션에 병렬 쿼리를 실행하고 애플리케이션으로 데이터를 조인합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-285">If cross-partition joins are necessary, run parallel queries over the partitions and join the data within the application.</span></span>

<span data-ttu-id="ea07a-286">**결과적 일관성 보장**.</span><span class="sxs-lookup"><span data-stu-id="ea07a-286">**Embrace eventual consistency**.</span></span> <span data-ttu-id="ea07a-287">강력한 일관성이 실제로 필요한지 여부를 평가합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-287">Evaluate whether strong consistency is actually a requirement.</span></span> <span data-ttu-id="ea07a-288">분산 시스템에서는 일반적으로 최종 일관성을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-288">A common approach in distributed systems is to implement eventual consistency.</span></span> <span data-ttu-id="ea07a-289">각 파티션에 있는 데이터가 개별적으로 업데이트되고, 애플리케이션 논리를 사용하여 업데이트를 모두 성공적으로 완료할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-289">The data in each partition is updated separately, and the application logic ensures that the updates are all completed successfully.</span></span> <span data-ttu-id="ea07a-290">또한 최종적으로 일치하는 작업이 실행되는 동안 데이터 쿼리에서 발생할 수 있는 불일치를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-290">It also handles the inconsistencies that can arise from querying data while an eventually consistent operation is running.</span></span>

<span data-ttu-id="ea07a-291">**쿼리가 올바른 파티션을 찾는 방법을 고려합니다**.</span><span class="sxs-lookup"><span data-stu-id="ea07a-291">**Consider how queries locate the correct partition**.</span></span> <span data-ttu-id="ea07a-292">쿼리가 필요한 데이터를 찾기 위해 모든 파티션을 검색해야 하는 경우에는 여러 개의 병렬 쿼리가 실행될 때에도 성능에 상당한 영향을 미치게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-292">If a query must scan all partitions to locate the required data, there is a significant impact on performance, even when multiple parallel queries are running.</span></span> <span data-ttu-id="ea07a-293">수직 분할 및 기능 분할을 사용하면 쿼리에서 기본적으로 파티션을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-293">With vertical and functional partitioning, queries can naturally specify the partition.</span></span> <span data-ttu-id="ea07a-294">반면, 행 분할을 사용하면 모든 분할된 데이터베이스의 스키마가 동일하기 때문에 항목을 찾기 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-294">Horizontal partitioning, on the other hand, can make locating an item difficult, because every shard has the same schema.</span></span> <span data-ttu-id="ea07a-295">일반적인 솔루션은 특정 항목의 분할된 데이터베이스 위치를 조회하는 데 사용되는 맵을 유지 관리하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-295">A typical solution to maintain a map that is used to look up the shard location for specific items.</span></span> <span data-ttu-id="ea07a-296">이 맵은 투명한 분할을 지원하는 경우 애플리케이션의 분할 논리에서 구현하거나 데이터 저장소에서 유지 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-296">This map can be implemented in the sharding logic of the application, or maintained by the data store if it supports transparent sharding.</span></span>

<span data-ttu-id="ea07a-297">**분할된 데이터베이스를 주기적으로 리밸런싱하는 방안을 고려합니다.**</span><span class="sxs-lookup"><span data-stu-id="ea07a-297">**Consider periodically rebalancing shards**.</span></span> <span data-ttu-id="ea07a-298">행 분할을 사용하면 분할된 데이터베이스를 리밸런싱하여 크기 및 워크로드에 따라 데이터를 균등하게 분산하여 핫스폿을 최소화하고, 쿼리 성능을 최대화하고, 실제 스토리지 제한 사항을 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-298">With horizontal partitioning, rebalancing shards can help distribute the data evenly by size and by workload to minimize hotspots, maximize query performance, and work around physical storage limitations.</span></span> <span data-ttu-id="ea07a-299">그러나 이 작업은 흔히 사용자 지정 도구 또는 프로세스를 사용해야 하는 복잡한 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-299">However, this is a complex task that often requires the use of a custom tool or process.</span></span>

<span data-ttu-id="ea07a-300">**파티션을 복제합니다.**</span><span class="sxs-lookup"><span data-stu-id="ea07a-300">**Replicate partitions.**</span></span> <span data-ttu-id="ea07a-301">각 파티션을 복제하면 실패를 방지할 수 있는 추가 보호 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-301">If you replicate each partition, it provides additional protection against failure.</span></span> <span data-ttu-id="ea07a-302">하나의 복제본이 실패하면 제대로 작동되는 복사본으로 쿼리를 전송하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-302">If a single replica fails, queries can be directed towards a working copy.</span></span>

<span data-ttu-id="ea07a-303">**분할 전략의 물리적 한도에 도달하면 확장성을 다른 수준으로 확장해야 합니다**.</span><span class="sxs-lookup"><span data-stu-id="ea07a-303">**If you reach the physical limits of a partitioning strategy, you might need to extend the scalability to a different level**.</span></span> <span data-ttu-id="ea07a-304">예를 들어 분할을 데이터베이스 수준에서 수행하는 경우 파티션을 여러 데이터베이스에 배치 또는 복제해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-304">For example, if partitioning is at the database level, you might need to locate or replicate partitions in multiple databases.</span></span> <span data-ttu-id="ea07a-305">데이터베이스 수준에서 이미 분할을 수행하고 있으며 물리적 한도가 문제인 경우에는 파티션을 여러 호스트 계정에 배치하거나 복제해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-305">If partitioning is already at the database level, and physical limitations are an issue, it might mean that you need to locate or replicate partitions in multiple hosting accounts.</span></span>

<span data-ttu-id="ea07a-306">**트랜잭션이 여러 파티션에 있는 데이터에 액세스하지 않도록 합니다**.</span><span class="sxs-lookup"><span data-stu-id="ea07a-306">**Avoid transactions that access data in multiple partitions**.</span></span> <span data-ttu-id="ea07a-307">데이터가 단일 파티션에 있는 경우에만 일부 데이터 저장소가 데이터를 수정하는 작업에 대해 트랜잭션 일관성 및 무결성을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-307">Some data stores implement transactional consistency and integrity for operations that modify data, but only when the data is located in a single partition.</span></span> <span data-ttu-id="ea07a-308">여러 파티션에서 트랜잭션 지원이 필요한 경우에는 대부분의 분할 시스템이 기본 지원을 제공하지 않기 때문에 애플리케이션 논리의 일부로 트랜잭션 지원을 구현해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-308">If you need transactional support across multiple partitions, you will probably need to implement this as part of your application logic because most partitioning systems do not provide native support.</span></span>

<span data-ttu-id="ea07a-309">모든 데이터 저장소에는 몇 가지 운영 관리 및 모니터링 활동이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-309">All data stores require some operational management and monitoring activity.</span></span> <span data-ttu-id="ea07a-310">이러한 작업에는 데이터 로드, 데이터 백업 및 복원, 데이터 재구성 및 시스템이 올바르고 효율적으로 수행되도록 보증하는 일까지 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-310">The tasks can range from loading data, backing up and restoring data, reorganizing data, and ensuring that the system is performing correctly and efficiently.</span></span>

<span data-ttu-id="ea07a-311">운영 관리에 영향을 주는 다음 요인을 고려하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-311">Consider the following factors that affect operational management:</span></span>

- <span data-ttu-id="ea07a-312">**데이터를 분할할 때 적절한 관리 및 운영 작업을 구현하는 방법**.</span><span class="sxs-lookup"><span data-stu-id="ea07a-312">**How to implement appropriate management and operational tasks when the data is partitioned**.</span></span> <span data-ttu-id="ea07a-313">이러한 작업에는 백업 및 복원, 데이터 보관, 시스템 모니터링 및 기타 관리 작업이 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-313">These tasks might include backup and restore, archiving data, monitoring the system, and other administrative tasks.</span></span> <span data-ttu-id="ea07a-314">예를 들어, 백업 및 복원 작업 중 논리적 일관성을 유지 관리하기 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-314">For example, maintaining logical consistency during backup and restore operations can be a challenge.</span></span>

- <span data-ttu-id="ea07a-315">**데이터를 여러 파티션으로 로드하는 방법 및 다른 원본에서 보낸 새 데이터를 추가하는 방법**.</span><span class="sxs-lookup"><span data-stu-id="ea07a-315">**How to load the data into multiple partitions and add new data that's arriving from other sources**.</span></span> <span data-ttu-id="ea07a-316">일부 도구 및 유틸리티는 분할된 데이터 작업(예: 데이터를 올바른 파티션으로 로드)을 지원하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-316">Some tools and utilities might not support sharded data operations such as loading data into the correct partition.</span></span>

- <span data-ttu-id="ea07a-317">**데이터를 정기적으로 보관하고 삭제하는 방법**.</span><span class="sxs-lookup"><span data-stu-id="ea07a-317">**How to archive and delete the data on a regular basis**.</span></span> <span data-ttu-id="ea07a-318">파티션이 과도하게 늘어나는 것을 방지하기 위해 데이터를 정기적으로(주로 월별) 보관하고 삭제해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-318">To prevent the excessive growth of partitions, you need to archive and delete data on a regular basis (perhaps monthly).</span></span> <span data-ttu-id="ea07a-319">다른 보관 스키마와 일치하도록 데이터를 변환해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-319">It might be necessary to transform the data to match a different archive schema.</span></span>

- <span data-ttu-id="ea07a-320">**데이터 무결성 문제를 찾는 방법**.</span><span class="sxs-lookup"><span data-stu-id="ea07a-320">**How to locate data integrity issues**.</span></span> <span data-ttu-id="ea07a-321">데이터 무결성 문제(예: 다른 파티션의 누락된 정보를 참조하는 파티션 데이터)를 찾을 수 있도록 정기적인 프로세스를 실행하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-321">Consider running a periodic process to locate any data integrity issues, such as data in one partition that references missing information in another.</span></span> <span data-ttu-id="ea07a-322">프로세스에서 자동으로 이러한 문제를 해결하려고 시도할 수도 있고 단순히 수동 검토를 위한 보고서를 생성할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-322">The process can either attempt to fix these issues automatically or simply generate a report for manual review.</span></span>

## <a name="rebalancing-partitions"></a><span data-ttu-id="ea07a-323">파티션 리밸런싱</span><span class="sxs-lookup"><span data-stu-id="ea07a-323">Rebalancing partitions</span></span>

<span data-ttu-id="ea07a-324">시스템이 성숙함에 따라 파티션 구성표를 조정해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-324">As a system matures, you might have to adjust the partitioning scheme.</span></span> <span data-ttu-id="ea07a-325">예를 들어 개인 파티션이 불균형적인 트래픽 볼륨을 가져오기 시작하여 핫 상태가 되고, 결국 과도한 경합으로 이어질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-325">For example, individual partitions might start get a disproportionate volume of traffic and become hot, leading to excessive contention.</span></span> <span data-ttu-id="ea07a-326">또는 일부 파티션의 데이터 볼륨을 과소 평가하여 일부 파티션이 저장소 용량 한도에 근접했을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-326">Or you might have underestimated the volume of data in some partitions, causing some partitions to approach capacity limits.</span></span>

<span data-ttu-id="ea07a-327">Cosmos DB 같은 일부 데이터 저장소는 자동으로 파티션을 리밸런싱할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-327">Some data stores, such as Cosmos DB, can automatically rebalance partitions.</span></span> <span data-ttu-id="ea07a-328">그 외의 경우에는 리밸런싱이 다음 두 단계로 구성되는 관리 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-328">In other cases, rebalancing is an administrative task that consists of two stages:</span></span>

1. <span data-ttu-id="ea07a-329">새로운 분할 전략을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-329">Determine a new partitioning strategy.</span></span>

    - <span data-ttu-id="ea07a-330">어떤 파티션을 분할해야 하나요(또는 결합도 가능)?</span><span class="sxs-lookup"><span data-stu-id="ea07a-330">Which partitions need to be split (or possibly combined)?</span></span>
    - <span data-ttu-id="ea07a-331">새 파티션 키는 무엇인가요?</span><span class="sxs-lookup"><span data-stu-id="ea07a-331">What is the new partition key?</span></span>

2. <span data-ttu-id="ea07a-332">기존 파티션 구성표의 데이터를 새 파티션 집합으로 마이그레이션합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-332">Migrate data from the old partitioning scheme to the new set of partitions.</span></span>

<span data-ttu-id="ea07a-333">데이터 저장소에 따라, 사용 중인 파티션 간에 데이터를 마이그레이션할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-333">Depending on the data store, you might be able to migrate data between partitions while they are in use.</span></span> <span data-ttu-id="ea07a-334">이를 *온라인 마이그레이션*이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-334">This is called *online migration*.</span></span> <span data-ttu-id="ea07a-335">이것이 불가능한 경우 데이터를 재배치하는 동안 파티션을 사용할 수 없도록 설정해야 할 수 있습니다(*오프라인 마이그레이션*).</span><span class="sxs-lookup"><span data-stu-id="ea07a-335">If that's not possible, you might need to make partitions unavailable while the data is relocated (*offline migration*).</span></span>

### <a name="offline-migration"></a><span data-ttu-id="ea07a-336">오프라인 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="ea07a-336">Offline migration</span></span>

<span data-ttu-id="ea07a-337">오프라인 마이그레이션은 경합이 발생할 가능성이 낮기 때문에 간단한 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-337">Offline migration is generally simpler, because it reduces the chances of contention occurring.</span></span> <span data-ttu-id="ea07a-338">개념적으로 오프라인 마이그레이션은 다음과 같이 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-338">Conceptually, offline migration works as follows:</span></span>

1. <span data-ttu-id="ea07a-339">파티션을 오프라인으로 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-339">Mark the partition offline.</span></span>
2. <span data-ttu-id="ea07a-340">데이터를 분할-병합한 후 새 파티션으로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-340">Split-merge and move the data to the new partitions.</span></span>
3. <span data-ttu-id="ea07a-341">데이터 확인</span><span class="sxs-lookup"><span data-stu-id="ea07a-341">Verify the data.</span></span>
4. <span data-ttu-id="ea07a-342">새 파티션을 온라인으로 전환합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-342">Bring the new partitions online.</span></span>
5. <span data-ttu-id="ea07a-343">기존 파티션을 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-343">Remove the old partition.</span></span>

<span data-ttu-id="ea07a-344">필요에 따라, 데이터를 이동하는 동안 애플리케이션에서 데이터를 계속 읽을 수 있도록 1단계에서 파티션을 읽기 전용으로 표시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-344">Optionally, you can mark a partition as read-only in step 1, so that applications can still read the data while it is being moved.</span></span>

## <a name="online-migration"></a><span data-ttu-id="ea07a-345">온라인 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="ea07a-345">Online migration</span></span>

<span data-ttu-id="ea07a-346">온라인 마이그레이션은 수행 방법이 복잡하지만 시스템 중단 시간이 짧습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-346">Online migration is more complex to perform but less disruptive.</span></span> <span data-ttu-id="ea07a-347">프로세스는 원래 파티션을 오프라인으로 표시하지 않는 점을 제외하고 오프라인 마이그레이션과 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-347">The process is similar to offline migration, except the original partition is not marked offline.</span></span> <span data-ttu-id="ea07a-348">마이그레이션 프로세스의 세분성(예: 항목 단위 또는 분할된 데이터베이스 단위)에 따라 클라이언트 애플리케이션의 데이터 액세스 코드에서 두 위치(원래 파티션 및 새 파티션)에 보관된 데이터의 읽기 및 쓰기를 처리해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-348">Depending on the granularity of the migration process (for example, item by item versus shard by shard), the data access code in the client applications might have to handle reading and writing data that's held in two locations, the original partition and the new partition.</span></span>

## <a name="related-patterns"></a><span data-ttu-id="ea07a-349">관련된 패턴</span><span class="sxs-lookup"><span data-stu-id="ea07a-349">Related patterns</span></span>

<span data-ttu-id="ea07a-350">다음 디자인 패턴이 시나리오와 관련될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-350">The following design patterns might be relevant to your scenario:</span></span>

- <span data-ttu-id="ea07a-351">[분할 패턴](../patterns/sharding.md)은 데이터를 분할하는 일반적인 전략을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-351">The [sharding pattern](../patterns/sharding.md) describes some common strategies for sharding data.</span></span>

- <span data-ttu-id="ea07a-352">[인덱스 테이블 패턴](../patterns/index-table.md)은 데이터에 대한 보조 인덱스를 만드는 방법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-352">The [index table pattern](../patterns/index-table.md) shows how to create secondary indexes over data.</span></span> <span data-ttu-id="ea07a-353">이 방법을 사용하면 애플리케이션에서 컬렉션의 기본 키를 참조하지 않는 쿼리를 사용하여 데이터를 신속하게 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-353">An application can quickly retrieve data with this approach, by using queries that do not reference the primary key of a collection.</span></span>

- <span data-ttu-id="ea07a-354">[구체화된 뷰 패턴](../patterns/materialized-view.md)은 빠른 쿼리 작업을 지원하도록 데이터를 요약하고 미리 채워진 뷰 생성 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-354">The [materialized view pattern](../patterns/materialized-view.md) describes how to generate pre-populated views that summarize data to support fast query operations.</span></span> <span data-ttu-id="ea07a-355">이 방법은 요약되는 데이터가 포함된 파티션을 여러 사이트에 분산하는 경우 분할된 데이터 저장소에서 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-355">This approach can be useful in a partitioned data store if the partitions that contain the data being summarized are distributed across multiple sites.</span></span>

## <a name="next-steps"></a><span data-ttu-id="ea07a-356">다음 단계</span><span class="sxs-lookup"><span data-stu-id="ea07a-356">Next steps</span></span>

- <span data-ttu-id="ea07a-357">특정 Azure 서비스에 대한 분할 전략을 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="ea07a-357">Learn about partitioning strategies for specific Azure services.</span></span> <span data-ttu-id="ea07a-358">[데이터 분할 전략](./data-partitioning-strategies.md) 보기</span><span class="sxs-lookup"><span data-stu-id="ea07a-358">See [Data partitioning strategies](./data-partitioning-strategies.md)</span></span>

[Azure Storage 확장성 및 성능 목표]: /azure/storage/storage-scalability-targets
[Azure Storage Scalability and Performance Targets]: /azure/storage/storage-scalability-targets
