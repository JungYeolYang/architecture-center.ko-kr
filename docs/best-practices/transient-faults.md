---
title: 재시도 일반 지침
titleSuffix: Best practices for cloud applications
description: 일시적인 오류 처리를 위한 재시도 관련 지침입니다.
author: dragon119
ms.date: 07/13/2016
ms.custom: seodec18
ms.openlocfilehash: fe07364e1a6846f9b7b47b2b79ce8031122edbbd
ms.sourcegitcommit: 4ba3304eebaa8c493c3e5307bdd9d723cd90b655
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 12/12/2018
ms.locfileid: "53307115"
---
# <a name="transient-fault-handling"></a><span data-ttu-id="05ca4-103">일시적인 오류 처리</span><span class="sxs-lookup"><span data-stu-id="05ca4-103">Transient fault handling</span></span>

<span data-ttu-id="05ca4-104">원격 서비스 및 리소스와 통신하는 모든 애플리케이션은 일시적인 오류에 민감해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-104">All applications that communicate with remote services and resources must be sensitive to transient faults.</span></span> <span data-ttu-id="05ca4-105">특히 클라우드에서 실행되는 애플리케이션의 경우는 더욱 그렇습니다. 이러한 애플리케이션에서는 환경 및 인터넷을 통한 연결이라는 특성으로 인해 이러한 유형의 오류가 더 자주 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-105">This is especially the case for applications that run in the cloud, where the nature of the environment and connectivity over the Internet means these types of faults are likely to be encountered more often.</span></span> <span data-ttu-id="05ca4-106">일시적인 오류로는 구성 요소 및 서비스의 순간적인 네트워크 연결 끊김, 서비스의 일시적인 사용 중단, 서비스가 사용 중일 때 발생하는 시간 제한 등이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-106">Transient faults include the momentary loss of network connectivity to components and services, the temporary unavailability of a service, or timeouts that arise when a service is busy.</span></span> <span data-ttu-id="05ca4-107">이러한 오류는 종종 자동으로 해결되며 적절한 시간을 두고 동작을 반복하면 성공할 가능성이 매우 높습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-107">These faults are often self-correcting, and if the action is repeated after a suitable delay it is likely succeed.</span></span>

<span data-ttu-id="05ca4-108">이 문서에서는 일시적인 오류 처리에 대한 일반적인 지침을 소개합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-108">This document covers general guidance for transient fault handling.</span></span> <span data-ttu-id="05ca4-109">Microsoft Azure 서비스를 사용하는 경우 일시적인 오류 처리에 대한 자세한 내용은 [Azure 서비스 관련 재시도 지침](./retry-service-specific.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="05ca4-109">For information about handling transient faults when using Microsoft Azure services, see [Azure service-specific retry guidelines](./retry-service-specific.md).</span></span>

<!-- markdownlint-disable MD026 -->

## <a name="why-do-transient-faults-occur-in-the-cloud"></a><span data-ttu-id="05ca4-110">클라우드에서 일시적인 오류가 발생하는 이유</span><span class="sxs-lookup"><span data-stu-id="05ca4-110">Why do transient faults occur in the cloud?</span></span>

<!-- markdownlint-enable MD026 -->

<span data-ttu-id="05ca4-111">일시적인 오류는 환경, 플랫폼 또는 운영 체제 및 애플리케이션의 종류에 관계없이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-111">Transient faults can occur in any environment, on any platform or operating system, and in any kind of application.</span></span> <span data-ttu-id="05ca4-112">로컬, 온-프레미스 인프라에서 실행되는 솔루션에서는 애플리케이션과 해당 구성 요소의 성능 및 사용 가능성이 일반적으로 비용이 많이 들고 충분히 활용되지 않는 하드웨어 중복성을 통해 유지 관리되며 구성 요소와 리소스는 서로 가깝게 배치되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-112">In solutions that run on local, on-premises infrastructure, performance and availability of the application and its components is typically maintained through expensive and often under-used hardware redundancy, and components and resources are located close to each another.</span></span> <span data-ttu-id="05ca4-113">따라서 오류가 발생할 가능성은 줄어들지만 일시적인 오류는 계속 발생합니다. 외부 전원 공급 장치나 네트워크 문제 같은 예측하지 못한 이벤트를 통한 중단이나 다른 재해 시나리오를 통해서도 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-113">While this makes a failure less likely, it can still result in transient faults - and even an outage through unforeseen events such as external power supply or network issues, or other disaster scenarios.</span></span>

<span data-ttu-id="05ca4-114">사설 클라우드 시스템을 비롯한 클라우드 호스팅에서는 엄청난 수의 상용 계산 노드 간에 공유 리소스, 중복성, 자동 장애 조치(failover) 및 동적 리소스 할당을 사용하여 전체적인 가용성을 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-114">Cloud hosting, including private cloud systems, can offer a higher overall availability by using shared resources, redundancy, automatic failover, and dynamic resource allocation across a huge number of commodity compute nodes.</span></span> <span data-ttu-id="05ca4-115">그러나 이러한 환경의 특성상 일시적인 오류가 발생할 가능성이 더 높을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-115">However, the nature of these environments can mean that transient faults are more likely to occur.</span></span> <span data-ttu-id="05ca4-116">이는 다음과 같은 여러 가지 원인 때문일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-116">There are several reasons for this:</span></span>

- <span data-ttu-id="05ca4-117">클라우드 환경에서는 많은 리소스가 공유되며, 이러한 리소스를 보호하기 위해 리소스에 대한 액세스가 제한될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-117">Many resources in a cloud environment are shared, and access to these resources is subject to throttling in order to protect the resource.</span></span> <span data-ttu-id="05ca4-118">일부 서비스는 부하가 특정 수준까지 증가하는 경우, 최대 처리 속도에 도달하는 경우 또는 기존 요청을 처리하고 모든 사용자에 대해 서비스 성능을 유지 관리하기 위해 연결을 거부합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-118">Some services will refuse connections when the load rises to a specific level, or a maximum throughput rate is reached, in order to allow processing of existing requests and to maintain performance of the service for all users.</span></span> <span data-ttu-id="05ca4-119">제한은 공유 리소스를 사용하여 인접 라우터 및 기타 테넌트에 대해 서비스 품질을 유지 관리하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-119">Throttling helps to maintain the quality of service for neighbors and other tenants using the shared resource.</span></span>

- <span data-ttu-id="05ca4-120">클라우드 환경은 방대한 수의 상용 하드웨어 장치를 사용하여 구축됩니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-120">Cloud environments are built using vast numbers of commodity hardware units.</span></span> <span data-ttu-id="05ca4-121">또한 여러 컴퓨팅 장치 및 인프라 구성 요소 간에 부하를 동적으로 분산시켜 성능을 제공하고 오류가 발생한 장치를 자동으로 재활용하거나 대체하여 안정성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-121">They deliver performance by dynamically distributing the load across multiple computing units and infrastructure components, and deliver reliability by automatically recycling or replacing failed units.</span></span> <span data-ttu-id="05ca4-122">이러한 동적 특성으로 인해 일시적인 오류 및 임시 연결 오류가 가끔 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-122">This dynamic nature means that transient faults and temporary connection failures may occasionally occur.</span></span>

- <span data-ttu-id="05ca4-123">라우터 및 부하 분산 장치 같은 네트워크 인프라를 포함하여 애플리케이션과 해당 애플리케이션에서 사용하는 리소스 및 서비스 간에 하드웨어 구성 요소가 더 많은 경우가 종종 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-123">There are often more hardware components, including network infrastructure such as routers and load balancers, between the application and the resources and services it uses.</span></span> <span data-ttu-id="05ca4-124">이러한 추가 인프라로 인해 가끔 추가 연결 대기 시간 및 일시적인 연결 오류가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-124">This additional infrastructure can occasionally introduce additional connection latency and transient connection faults.</span></span>

- <span data-ttu-id="05ca4-125">클라이언트와 서버 간 네트워크 상태가 일정하지 않을 수 있으며, 특히 인터넷을 통한 통신의 경우는 더욱 그렇습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-125">Network conditions between the client and the server may be variable, especially when communication crosses the Internet.</span></span> <span data-ttu-id="05ca4-126">심지어 온-프레미스 위치에서도 트래픽 부하가 매우 많은 경우 통신 속도가 느려지고 일시적인 연결 오류가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-126">Even in on-premises locations, very heavy traffic loads may slow communication and cause intermittent connection failures.</span></span>

## <a name="challenges"></a><span data-ttu-id="05ca4-127">과제</span><span class="sxs-lookup"><span data-stu-id="05ca4-127">Challenges</span></span>

<span data-ttu-id="05ca4-128">일시적인 오류는 예측 가능한 모든 환경에서 완벽하게 테스트된 경우에도 애플리케이션의 인지된 가용성에 엄청난 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-128">Transient faults can have a huge impact on the perceived availability of an application, even if it has been thoroughly tested under all foreseeable circumstances.</span></span> <span data-ttu-id="05ca4-129">클라우드 호스팅 애플리케이션이 안정적으로 작동하도록 하려면 다음과 같은 과제에 응답할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-129">To ensure that cloud-hosted applications operate reliably, they must be able to respond to the following challenges:</span></span>

- <span data-ttu-id="05ca4-130">애플리케이션은 오류가 발생하면 감지하고 이러한 오류가 일시적인지, 더 오래 지속되는지, 터미널 오류인지를 결정할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-130">The application must be able to detect faults when they occur, and determine if these faults are likely to be transient, more long-lasting, or are terminal failures.</span></span> <span data-ttu-id="05ca4-131">리소스에 따라 오류가 발생할 때 서로 다른 응답을 반환할 수 있으며 이러한 응답은 작업의 컨텍스트에 따라 달라질 수도 있습니다. 예를 들어 저장소에서 읽을 때 오류에 대한 응답은 저장소에 쓸 때 오류에 대한 응답과 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-131">Different resources are likely to return different responses when a fault occurs, and these responses may also vary depending on the context of the operation; for example, the response for an error when reading from storage may be different from response for an error when writing to storage.</span></span> <span data-ttu-id="05ca4-132">많은 리소스와 서비스에는 잘 문서화된 일시적인 오류 계약이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-132">Many resources and services have well-documented transient failure contracts.</span></span> <span data-ttu-id="05ca4-133">그러나 이러한 정보를 사용할 수 없는 경우 오류의 특성 및 일시적인지 여부를 검색하기 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-133">However, where such information is not available, it may be difficult to discover the nature of the fault and whether it is likely to be transient.</span></span>

- <span data-ttu-id="05ca4-134">응용 프로그램은 오류가 일시적인 것으로 확인되면 작업을 재시도할 수 있어야 하고 작업이 재시도된 횟수를 추적해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-134">The application must be able to retry the operation if it determines that the fault is likely to be transient and keep track of the number of times the operation was retried.</span></span>

- <span data-ttu-id="05ca4-135">애플리케이션은 재시도에 적합한 전략을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-135">The application must use an appropriate strategy for the retries.</span></span> <span data-ttu-id="05ca4-136">이 전략은 재시도 횟수, 각 시도 사이의 지연 및 시도 실패 후 수행할 조치를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-136">This strategy specifies the number of times it should retry, the delay between each attempt, and the actions to take after a failed attempt.</span></span> <span data-ttu-id="05ca4-137">적절한 시도 횟수 및 각 시도 사이의 지연은 결정하기 어려운 경우가 많으며 리소스 유형뿐만 아니라 리소스와 애플리케이션 자체의 현재 작동 상태에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-137">The appropriate number of attempts and the delay between each one are often difficult to determine, and vary based on the type of resource as well as the current operating conditions of the resource and the application itself.</span></span>

## <a name="general-guidelines"></a><span data-ttu-id="05ca4-138">일반 지침</span><span class="sxs-lookup"><span data-stu-id="05ca4-138">General guidelines</span></span>

<span data-ttu-id="05ca4-139">다음 지침은 애플리케이션에 적합한 일시적인 오류 처리 메커니즘을 설계하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-139">The following guidelines will help you to design a suitable transient fault handing mechanism for your applications:</span></span>

- <span data-ttu-id="05ca4-140">**기본 제공 재시도 메커니즘이 있는지 확인:**</span><span class="sxs-lookup"><span data-stu-id="05ca4-140">**Determine if there is a built-in retry mechanism:**</span></span>

  - <span data-ttu-id="05ca4-141">대부분의 서비스는 일시적인 오류 처리 메커니즘을 포함하는 SDK 또는 클라이언트 라이브러리를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-141">Many services provide an SDK or client library that contains a transient fault handling mechanism.</span></span> <span data-ttu-id="05ca4-142">일반적으로 사용되는 재시도 정책은 대상 서비스의 특성 및 요구 사항에 맞게 조정됩니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-142">The retry policy it uses is typically tailored to the nature and requirements of the target service.</span></span> <span data-ttu-id="05ca4-143">또는 서비스에 대한 REST 인터페이스는 재시도가 적절한지 여부 및 다음 재시도까지 대기해야 하는 시간을 결정하는 데 도움이 되는 정보를 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-143">Alternatively, REST interfaces for services may return information that is useful in determining whether a retry is appropriate, and how long to wait before the next retry attempt.</span></span>

  - <span data-ttu-id="05ca4-144">다른 재시도 동작을 의미하는 잘 이해할 수 있는 특정 요구 사항이 없을 경우 사용 가능한 기본 제공 재시도 메커니즘을 사용하는 것이 더 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-144">Use the built-in retry mechanism where one is available unless you have specific and well-understood requirements that mean a different retry behavior is more appropriate.</span></span>

- <span data-ttu-id="05ca4-145">**작업이 재시도에 적합한지 확인**:</span><span class="sxs-lookup"><span data-stu-id="05ca4-145">**Determine if the operation is suitable for retrying**:</span></span>

  - <span data-ttu-id="05ca4-146">오류가 일시적인 경우(일반적으로 오류의 특성으로 표시됨) 및 재시도할 경우 작업이 성공할 가능성이 어느 정도 있는 경우에만 작업을 재시도해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-146">You should only retry operations where the faults are transient (typically indicated by the nature of the error), and if there is at least some likelihood that the operation will succeed when reattempted.</span></span> <span data-ttu-id="05ca4-147">존재하지 않는 항목에 대한 데이터베이스 업데이트와 같은 잘못된 작업을 나타내는 작업이나 치명적인 오류가 발생한 서비스나 리소스에 대한 요청은 재시도할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-147">There is no point in reattempting operations that indicate an invalid operation such as a database update to an item that does not exist, or requests to a service or resource that has suffered a fatal error</span></span>

  - <span data-ttu-id="05ca4-148">일반적으로 이 작업의 전체적인 영향을 확인할 수 있고 조건을 잘 이해하고 유효성을 검사할 수 있는 경우에만 재시도를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-148">In general, you should implement retries only where the full impact of this can be determined, and the conditions are well understood and can be validated.</span></span> <span data-ttu-id="05ca4-149">그렇지 않은 경우 재시도를 구현하는 호출 코드를 그대로 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-149">If not, leave it to the calling code to implement retries.</span></span> <span data-ttu-id="05ca4-150">제어할 수 없는 리소스 및 서비스에서 반환된 오류는 시간에 따라 변경될 수 있으므로 일시적인 오류 검색 논리를 다시 확인해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-150">Remember that the errors returned from resources and services outside your control may evolve over time, and you may need to revisit your transient fault detection logic.</span></span>

  - <span data-ttu-id="05ca4-151">서비스 또는 구성 요소를 만드는 경우 클라이언트에서 실패한 작업을 재시도해야 하는지 여부를 결정하는 데 도움이 되는 메시지 및 오류 코드를 구현하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-151">When you create services or components, consider implementing error codes and messages that will help clients determine whether they should retry failed operations.</span></span> <span data-ttu-id="05ca4-152">특히 **isTransient** 값을 반환하여 클라이언트에서 작업을 재시도해야 하는지를 나타내고 다음 재시도 전까지 적합한 지연 시간을 제안합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-152">In particular, indicate if the client should retry the operation (perhaps by returning an **isTransient** value) and suggest a suitable delay before the next retry attempt.</span></span> <span data-ttu-id="05ca4-153">웹 서비스를 구축하는 경우에는 서비스 계약 내에 정의된 사용자 지정 오류를 반환하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-153">If you build a web service, consider returning custom errors defined within your service contracts.</span></span> <span data-ttu-id="05ca4-154">일반 클라이언트에서 이러한 오류를 읽을 수 없는 경우에도 사용자 지정 클라이언트를 구축할 때 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-154">Even though generic clients may not be able to read these, they will be useful when building custom clients.</span></span>

- <span data-ttu-id="05ca4-155">**적절한 재시도 횟수 및 간격 결정:**</span><span class="sxs-lookup"><span data-stu-id="05ca4-155">**Determine an appropriate retry count and interval:**</span></span>

  - <span data-ttu-id="05ca4-156">사용 사례의 유형에 따라 재시도 횟수 및 간격을 최적화해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-156">It is vital to optimize the retry count and the interval to the type of use case.</span></span> <span data-ttu-id="05ca4-157">충분한 횟수만큼 재시도하지 않으면 애플리케이션에서 작업을 완료할 수 없고 오류가 발생할 가능성이 높습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-157">If you do not retry a sufficient number of times, the application will be unable to complete the operation and is likely to experience a failure.</span></span> <span data-ttu-id="05ca4-158">너무 많이 재시도하거나 재시도 간 간격이 너무 짧은 경우 애플리케이션에서 스레드, 연결 및 메모리와 같은 리소스를 오랫동안 보유하여 애플리케이션의 상태에 부정적인 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-158">If you retry too many times, or with too short an interval between tries, the application can potentially hold resources such as threads, connections, and memory for long periods, which will adversely affect the health of the application.</span></span>

  - <span data-ttu-id="05ca4-159">재시도 시간 간격 및 횟수에 적합한 값은 시도하려는 작업의 유형에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-159">The appropriate values for the time interval and the number of retry attempts depend on the type of operation being attempted.</span></span> <span data-ttu-id="05ca4-160">예를 들어 작업이 사용자 조작 방식의 일부인 경우 사용자가 응답을 대기하지 않도록 하여 열린 연결을 보유하고 다른 사용자에 대한 가용성을 줄이려면 간격이 짧아야 하고 몇 번만 재시도되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-160">For example, if the operation is part of a user interaction, the interval should be short and only a few retries attempted to avoid making users wait for a response (which holds open connections and can reduce availability for other users).</span></span> <span data-ttu-id="05ca4-161">작업이 장기 실행 또는 중요한 워크플로의 일부여서 프로세스를 취소하고 다시 시작하면 비용이 많이 들거나 시간이 많이 소요되는 경우에는 시도 사이에 더 오래 기다리고 더 여러 번 재시도하는 것이 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-161">If the operation is part of a long running or critical workflow, where cancelling and restarting the process is expensive or time-consuming, it is appropriate to wait longer between attempts and retry more times.</span></span>

  - <span data-ttu-id="05ca4-162">재시도 사이의 적절한 간격을 결정하는 것은 성공적인 전략 설계에서 가장 어려운 부분입니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-162">Determining the appropriate intervals between retries is the most difficult part of designing a successful strategy.</span></span> <span data-ttu-id="05ca4-163">일반적인 전략에서는 다음과 같은 유형의 다시 시도 간격을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-163">Typical strategies use the following types of retry interval:</span></span>

    - <span data-ttu-id="05ca4-164">**지수적 백오프**.</span><span class="sxs-lookup"><span data-stu-id="05ca4-164">**Exponential back-off**.</span></span> <span data-ttu-id="05ca4-165">애플리케이션이 첫 번째 재시도 전까지 짧은 시간 동안 대기한 다음, 이후 각 재시도 사이의 시간을 기하급수적으로 늘립니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-165">The application waits a short time before the first retry, and then exponentially increasing times between each subsequent retry.</span></span> <span data-ttu-id="05ca4-166">예를 들어 3초, 12초, 30초 등 후에 작업을 재시도할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-166">For example, it may retry the operation after 3 seconds, 12 seconds, 30 seconds, and so on.</span></span>

    - <span data-ttu-id="05ca4-167">**증분 간격**.</span><span class="sxs-lookup"><span data-stu-id="05ca4-167">**Incremental intervals**.</span></span> <span data-ttu-id="05ca4-168">애플리케이션이 첫 번째 재시도 전까지 짧은 시간 동안 대기한 다음, 이후 각 재시도 사이의 시간을 증분하여 늘립니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-168">The application waits a short time before the first retry, and then incrementally increasing times between each subsequent retry.</span></span> <span data-ttu-id="05ca4-169">예를 들어 3초, 7초, 13초 등 후에 작업을 재시도할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-169">For example, it may retry the operation after 3 seconds, 7 seconds, 13 seconds, and so on.</span></span>

    - <span data-ttu-id="05ca4-170">**정기적 간격**.</span><span class="sxs-lookup"><span data-stu-id="05ca4-170">**Regular intervals**.</span></span> <span data-ttu-id="05ca4-171">애플리케이션이 각 시도 사이에 동일한 기간 동안 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-171">The application waits for the same period of time between each attempt.</span></span> <span data-ttu-id="05ca4-172">예를 들어 3초마다 작업을 재시도할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-172">For example, it may retry the operation every 3 seconds.</span></span>

    - <span data-ttu-id="05ca4-173">**즉시 재시도**.</span><span class="sxs-lookup"><span data-stu-id="05ca4-173">**Immediate retry**.</span></span> <span data-ttu-id="05ca4-174">경우에 따라 일시적인 오류가 매우 짧을 수 있습니다. 이는 네트워크 패킷 충돌 또는 하드웨어 구성 요소의 스파이크와 같은 이벤트에 의해 발생하는 경우일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-174">Sometimes a transient fault is extremely short, perhaps caused by an event such as a network packet collision or a spike in a hardware component.</span></span> <span data-ttu-id="05ca4-175">이런 경우 애플리케이션이 다음 요청을 어셈블하여 보내는 데 걸리는 시간 동안 오류가 해결되어 성공할 수 있으므로 작업을 즉시 재시도하는 것이 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-175">In this case, retrying the operation immediately is appropriate because it may succeed if the fault has cleared in the time it takes the application to assemble and send the next request.</span></span> <span data-ttu-id="05ca4-176">그러나 즉시 재시도 횟수는 두 번 이상이면 안 되므로 즉시 재시도가 실패할 경우 지수적 백오프 또는 대체 동작과 같은 다른 전략으로 전환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-176">However, there should never be more than one immediate retry attempt, and you should switch to alternative strategies, such as such as exponential back-off or fallback actions, if the immediate retry fails.</span></span>

    - <span data-ttu-id="05ca4-177">**불규칙**.</span><span class="sxs-lookup"><span data-stu-id="05ca4-177">**Randomization**.</span></span> <span data-ttu-id="05ca4-178">위에 나열된 재시도 전략에는 여러 클라이언트 인스턴스에서 이후 재시도 횟수를 동시에 보낼 수 없도록 하는 불규칙이 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-178">Any of the retry strategies listed above may include a randomization to prevent multiple instances of the client sending subsequent retry attempts at the same time.</span></span> <span data-ttu-id="05ca4-179">예를 들어 한 인스턴스는 3초, 11초, 28초 등 후에 작업을 재시도하고 다른 인스턴스는 4초, 12초, 26초 등 후에 작업을 재시도할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-179">For example, one instance may retry the operation after 3 seconds, 11 seconds, 28 seconds, and so on while another instance may retry the operation after 4 seconds, 12 seconds, 26 seconds, and so on.</span></span> <span data-ttu-id="05ca4-180">불규칙은 다른 전략과 함께 사용할 수 있는 유용한 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-180">Randomization is a useful technique that may be combined with other strategies.</span></span>

  - <span data-ttu-id="05ca4-181">일반적인 지침으로 백그라운드 작업에는 지수적 백오프를 사용하고 대화형 작업에는 즉시 또는 정기적 간격 재시도 전략을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-181">As a general guideline, use an exponential back-off strategy for background operations, and immediate or regular interval retry strategies for interactive operations.</span></span> <span data-ttu-id="05ca4-182">두 경우 모두, 모든 재시도 횟수의 최대 대기 시간이 필요한 종단 간 대기 시간 요구 사항 내에 포함되도록 지연 시간 및 재시도 횟수를 선택해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-182">In both cases, you should choose the delay and the retry count so that the maximum latency for all retry attempts is within the required end-to-end latency requirement.</span></span>

  - <span data-ttu-id="05ca4-183">재시도된 작업의 전체적인 최대 제한 시간에 영향을 주는 모든 요인의 조합을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-183">Take into account the combination of all the factors that contribute to the overall maximum timeout for a retried operation.</span></span> <span data-ttu-id="05ca4-184">이러한 요인에는 재시도 횟수와 최대 재시도 횟수 간 지연뿐만 아니라 실패한 연결에서 응답을 생성하는 데 걸린 시간(일반적으로 클라이언트에서 제한 시간 값으로 설정)이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-184">These factors include the time taken for a failed connection to produce a response (typically set by a timeout value in the client) as well as the delay between retry attempts and the maximum number of retries.</span></span> <span data-ttu-id="05ca4-185">이러한 모든 시간을 합하면 전체적인 작업 시간이 매우 커질 수 있습니다. 특히 재시도 간 간격이 각 실패 후 빠르게 증가하는 지수적 지연 전략을 사용하는 경우는 더욱 그렇습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-185">The total of all these times can result in very large overall operation times, especially when using an exponential delay strategy where the interval between retries grows rapidly after each failure.</span></span> <span data-ttu-id="05ca4-186">프로세스가 특정 SLA(서비스 수준 계약)를 충족해야 하는 경우 모든 제한 시간 및 지연을 포함한 전체적인 작업 시간은 SLA에 정의된 시간 내에 포함되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-186">If a process must meet a specific service level agreement (SLA), the overall operation time, including all timeouts and delays, must be within that defined in the SLA.</span></span>

  - <span data-ttu-id="05ca4-187">간격이 너무 짧거나 재시도 횟수가 너무 많아 지나치게 적극적인 재시도 전략은 대상 리소스 또는 서비스에 악영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-187">Over-aggressive retry strategies, which have too short intervals or too may retries, can have an adverse effect on the target resource or service.</span></span> <span data-ttu-id="05ca4-188">따라서 리소스나 서비스가 오버로드된 상태에서 복구되지 않아 요청을 계속 차단하거나 거부할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-188">This may prevent the resource or service from recovering from its overloaded state, and it will continue to block or refuse requests.</span></span> <span data-ttu-id="05ca4-189">이 결과 점점 더 많은 요청이 리소스나 서비스로 전송되어 결과적으로 복구 능력이 더 저하되는 악순환이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-189">This results in a vicious circle where more and more requests are sent to the resource or service, and consequently its ability to recover is further reduced.</span></span>

  - <span data-ttu-id="05ca4-190">이후 시도가 즉시 시작되지 않도록 다시 시도 간격을 선택하려는 경우(예: 제한 시간 기간이 다시 시도 간격과 유사한 경우) 작업의 제한 시간을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-190">Take into account the timeout of the operations when choosing the retry intervals to avoid launching a subsequent attempt immediately (for example, if the timeout period is similar to the retry interval).</span></span> <span data-ttu-id="05ca4-191">또한 가능한 총 기간(제한 시간과 다시 시도 간격을 합한 시간)을 특정 총 시간 아래로 유지해야 하는 경우를 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-191">Also consider if you need to keep the total possible period (the timeout plus the retry intervals) to below a specific total time.</span></span> <span data-ttu-id="05ca4-192">일반적으로 제한 시간이 짧거나 매우 긴 작업은 대기 시간 및 작업을 재시도하는 빈도에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-192">Operations that have unusually short or very long timeouts may influence how long to wait, and how often to retry the operation.</span></span>

  - <span data-ttu-id="05ca4-193">다시 시도 간격 및 횟수를 최적화하려면 예외의 유형과 해당 예외에 포함된 데이터 또는 서비스에 반환된 오류 코드 및 메시지를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-193">Use the type of the exception and any data it contains, or the error codes and messages returned from the service, to optimize the interval and the number of retries.</span></span> <span data-ttu-id="05ca4-194">예를 들어 일부 예외 또는 오류 코드(예: HTTP 코드 503 Retry After 헤더에서 서비스를 사용할 수 없음)는 오류가 지속될 수 있는 기간을 나타내거나 서비스가 실패하여 이후 모든 시도에 응답하지 않음을 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-194">For example, some exceptions or error codes (such as the HTTP code 503 Service Unavailable with a Retry-After header in the response) may indicate how long the error might last, or that the service has failed and will not respond to any subsequent attempt.</span></span>

- <span data-ttu-id="05ca4-195">**안티패턴 방지**</span><span class="sxs-lookup"><span data-stu-id="05ca4-195">**Avoid anti-patterns**:</span></span>

  - <span data-ttu-id="05ca4-196">대부분의 경우 중복된 재시도 코드 계층을 포함하는 구현을 피해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-196">In the vast majority of cases, you should avoid implementations that include duplicated layers of retry code.</span></span> <span data-ttu-id="05ca4-197">계단식 재시도 메커니즘을 포함하거나 특정 요구 사항이 없다면 요청의 계층 구조를 포함하는 작업의 모든 단계에서 재시도를 구현하는 설계는 피하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-197">Avoid designs that include cascading retry mechanisms, or that implement retry at every stage of an operation that involves a hierarchy of requests, unless you have specific requirements that demand this.</span></span> <span data-ttu-id="05ca4-198">이러한 예외적인 경우 과도하게 많은 재시도 및 지연 기간을 방지하는 정책을 사용하고 결과를 이해하고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-198">In these exceptional circumstances, use policies that prevent excessive numbers of retries and delay periods, and make sure you understand the consequences.</span></span> <span data-ttu-id="05ca4-199">예를 들어 한 구성 요소에서 다른 구성 요소를 요청한 다음 대상 서비스에 액세스하고 두 호출에서 세 번 재시도를 구현하면 서비스에 대한 총 재시도 횟수는 9번이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-199">For example, if one component makes a request to another, which then accesses the target service, and you implement retry with a count of three on both calls there will be nine retry attempts in total against the service.</span></span> <span data-ttu-id="05ca4-200">많은 서비스와 리소스는 기본 제공 재시도 메커니즘을 구현하고 더 높은 수준에서 재시도를 구현해야 하는 경우 이 메커니즘을 사용하지 않도록 설정하거나 수정하는 방법을 조사해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-200">Many services and resources implement a built-in retry mechanism and you should investigate how you can disable or modify this if you need to implement retries at a higher level.</span></span>

  - <span data-ttu-id="05ca4-201">무한 재시도 메커니즘을 구현하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-201">Never implement an endless retry mechanism.</span></span> <span data-ttu-id="05ca4-202">이 메커니즘을 구현하면 리소스나 서비스가 오버로드 상황에서 복구되지 않고 제한 및 거부된 연결이 오랫동안 계속되도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-202">This is likely to prevent the resource or service recovering from overload situations, and cause throttling and refused connections to continue for a longer period.</span></span> <span data-ttu-id="05ca4-203">한정된 수의 재시도를 사용하거나 [회로 차단기](../patterns/circuit-breaker.md) 같은 패턴을 구현하여 서비스에서 복구할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-203">Use a finite number or retries, or implement a pattern such as [Circuit Breaker](../patterns/circuit-breaker.md) to allow the service to recover.</span></span>

  - <span data-ttu-id="05ca4-204">즉시 재시도를 두 번 이상 수행하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-204">Never perform an immediate retry more than once.</span></span>

  - <span data-ttu-id="05ca4-205">Azure에서 서비스 및 리소스에 액세스할 때 특히 재시도 횟수가 많은 경우 정기적인 다시 시도 간격을 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-205">Avoid using a regular retry interval, especially when you have a large number of retry attempts, when accessing services and resources in Azure.</span></span> <span data-ttu-id="05ca4-206">이 시나리오에서 최적의 방법은 회로 차단 기능이 있는 지수적 백오프 전략입니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-206">The optimum approach is this scenario is an exponential back-off strategy with a circuit-breaking capability.</span></span>

  - <span data-ttu-id="05ca4-207">동일한 클라이언트의 여러 인스턴스 또는 다른 클라이언트의 여러 인스턴스에서 동시에 재시도를 보내지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-207">Prevent multiple instances of the same client, or multiple instances of different clients, from sending retries at the same times.</span></span> <span data-ttu-id="05ca4-208">이런 경우 다시 시도 간격에 불규칙을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-208">If this is likely to occur, introduce randomization into the retry intervals.</span></span>

- <span data-ttu-id="05ca4-209">**재시도 전략 및 구현 테스트:**</span><span class="sxs-lookup"><span data-stu-id="05ca4-209">**Test your retry strategy and implementation:**</span></span>

  - <span data-ttu-id="05ca4-210">최대한 광범위한 상황에서 특히, 애플리케이션과 해당 애플리케이션에서 사용하는 대상 리소스 또는 서비스가 모두 극단적인 부하를 받는 경우 재시도 전략 및 구현을 완벽하게 테스트해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-210">Ensure you fully test your retry strategy implementation under as wide a set of circumstances as possible, especially when both the application and the target resources or services it uses are under extreme load.</span></span> <span data-ttu-id="05ca4-211">테스트 중 동작을 확인하려면 다음을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-211">To check behavior during testing, you can:</span></span>

    - <span data-ttu-id="05ca4-212">서비스에 일시적 오류 및 영구 오류를 주입합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-212">Inject transient and non-transient faults into the service.</span></span> <span data-ttu-id="05ca4-213">예를 들어 잘못된 요청을 보내거나 테스트 요청을 감지하고 다양한 유형의 오류로 응답하는 코드를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-213">For example, send invalid requests or add code that detects test requests and responds with different types of errors.</span></span> <span data-ttu-id="05ca4-214">TestApi를 사용하는 예제는 [TestApi로 오류 주입 테스트](https://msdn.microsoft.com/magazine/ff898404.aspx) 및 [TestApi 소개 - 5부: 관리 코드 오류 주입 API](https://blogs.msdn.microsoft.com/ivo_manolov/2009/11/25/introduction-to-testapi-part-5-managed-code-fault-injection-apis/)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="05ca4-214">For an example using TestApi, see [Fault Injection Testing with TestApi](https://msdn.microsoft.com/magazine/ff898404.aspx) and [Introduction to TestApi – Part 5: Managed Code Fault Injection APIs](https://blogs.msdn.microsoft.com/ivo_manolov/2009/11/25/introduction-to-testapi-part-5-managed-code-fault-injection-apis/).</span></span>

    - <span data-ttu-id="05ca4-215">실제 서비스에서 반환할 수 있는 오류의 범위를 반환하는 리소스 또는 서비스의 모형을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-215">Create a mock of the resource or service that returns a range of errors that the real service may return.</span></span> <span data-ttu-id="05ca4-216">재시도 전략에서 감지하도록 설계된 모든 유형의 오류를 포함해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-216">Ensure you cover all the types of error that your retry strategy is designed to detect.</span></span>

    - <span data-ttu-id="05ca4-217">사용자가 만들고 배포한 사용자 지정 오류인 경우 임시로 서비스를 사용하지 않도록 설정하거나 오버로드하여 강제로 일시적인 오류가 발생하도록 합니다. 물론 Azure 내에서 공유 리소스나 공유 서비스를 오버로드하려고 해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-217">Force transient errors to occur by temporarily disabling or overloading the service if it is a custom service that you created and deployed (you should not, of course, attempt to overload any shared resources or shared services within Azure).</span></span>

    - <span data-ttu-id="05ca4-218">HTTP 기반 API의 경우 왕복 시간을 더 추가하거나 응답(예: HTTP 상태 코드, 헤더, 본문 또는 기타 요인)을 변경하여 자동화된 테스트에서 FiddlerCore 라이브러리를 사용하여 HTTP 요청의 결과를 변경하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-218">For HTTP-based APIs, consider using the FiddlerCore library in your automated tests to change the outcome of HTTP requests, either by adding extra roundtrip times or by changing the response (such as the HTTP status code, headers, body, or other factors).</span></span> <span data-ttu-id="05ca4-219">이렇게 하면 일시적인 오류인지 다른 유형의 오류인지에 관계없이 오류 상태의 하위 집합을 결정적으로 테스트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-219">This enables deterministic testing of a subset of the failure conditions, whether transient faults or other types of failure.</span></span> <span data-ttu-id="05ca4-220">자세한 내용은 [FiddlerCore](https://www.telerik.com/fiddler/fiddlercore)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="05ca4-220">For more information, see [FiddlerCore](https://www.telerik.com/fiddler/fiddlercore).</span></span> <span data-ttu-id="05ca4-221">라이브러리, 특히 **HttpMangler** 클래스를 사용하는 방법에 대한 예제는 [Azure Storage SDK에 대한 소스 코드](https://github.com/Azure/azure-storage-net/tree/master/Test)(영문)를 검토하세요.</span><span class="sxs-lookup"><span data-stu-id="05ca4-221">For examples of how to use the library, particularly the **HttpMangler** class, examine the [source code for the Azure Storage SDK](https://github.com/Azure/azure-storage-net/tree/master/Test).</span></span>

    - <span data-ttu-id="05ca4-222">높은 로드 비율 및 동시 테스트를 수행하여 재시도 메커니즘 및 전략이 이러한 상황에서 올바르게 작동하는지 확인하고 클라이언트의 작업에 악영향을 주거나 요청 간 교차 오염이 발생하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-222">Perform high load factor and concurrent tests to ensure that the retry mechanism and strategy works correctly under these conditions, and does not have an adverse effect on the operation of the client or cause cross-contamination between requests.</span></span>

- <span data-ttu-id="05ca4-223">**재시도 정책 구성 관리:**</span><span class="sxs-lookup"><span data-stu-id="05ca4-223">**Manage retry policy configurations:**</span></span>

  - <span data-ttu-id="05ca4-224">*재시도 정책*은 재시도 전략의 모든 요소를 조합한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-224">A *retry policy* is a combination of all of the elements of your retry strategy.</span></span> <span data-ttu-id="05ca4-225">이 정책은 오류가 일시적인지 여부, 사용할 간격의 유형(예: 정기, 지수적 백오프 및 불규칙), 실제 간격 값 및 재시도 횟수를 결정하는 검색 메커니즘을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-225">It defines the detection mechanism that determines whether a fault is likely to be transient, the type of interval to use (such as regular, exponential back-off, and randomization), the actual interval value(s), and the number of times to retry.</span></span>

  - <span data-ttu-id="05ca4-226">재시도는 가장 간단한 애플리케이션 내의 여러 위치 및 더 복잡한 애플리케이션의 모든 계층에서 구현되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-226">Retries must be implemented in many places within even the simplest application, and in every layer of more complex applications.</span></span> <span data-ttu-id="05ca4-227">여러 위치에서 각 정책의 요소를 하드 코딩하는 대신 모든 정책을 저장할 중앙 지점을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-227">Rather than hard-coding the elements of each policy at multiple locations, consider using a central point for storing all the policies.</span></span> <span data-ttu-id="05ca4-228">예를 들어 간격 및 재시도 횟수와 같은 값을 애플리케이션 구성 파일에 저장하여 런타임에 읽고 프로그래밍 방식으로 재시도 정책을 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-228">For example, store the values such as the interval and retry count in application configuration files, read them at runtime, and programmatically build the retry policies.</span></span> <span data-ttu-id="05ca4-229">그러면 더 쉽게 설정을 관리하고 값을 수정하고 미세 조정하여 변화하는 요구 사항 및 시나리오에 응답할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-229">This makes it easier to manage the settings, and to modify and fine tune the values in order to respond to changing requirements and scenarios.</span></span> <span data-ttu-id="05ca4-230">그러나 매번 구성 파일을 다시 읽는 대신 값을 저장하도록 시스템을 설계하면 구성에서 값을 가져올 수 없는 경우 적절한 기본값이 사용되도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-230">However, design the system to store the values rather than rereading a configuration file every time, and ensure suitable defaults are used if the values cannot be obtained from configuration.</span></span>

  - <span data-ttu-id="05ca4-231">Azure Cloud Services 애플리케이션에서는 런타임에 재시도 정책을 작성하는 데 사용되는 값을 서비스 구성 파일에 저장하여 애플리케이션을 다시 시작하지 않고도 변경할 수 있도록 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-231">In an Azure Cloud Services application, consider storing the values that are used to build the retry policies at runtime in the service configuration file so that they can be changed without needing to restart the application.</span></span>

  - <span data-ttu-id="05ca4-232">사용하는 클라이언트 API에서 제공되는 기본 제공 또는 기본 재시도 전략을 활용하지만 시나리오에 적합한 경우에만 활용합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-232">Take advantage of built-in or default retry strategies available in the client APIs you use, but only where they are appropriate for your scenario.</span></span> <span data-ttu-id="05ca4-233">일반적으로 이러한 전략은 범용입니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-233">These strategies are typically general-purpose.</span></span> <span data-ttu-id="05ca4-234">일부 시나리오에서는 모두 필요하지만 일부 시나리오에서는 특정 요구 사항에 맞는 다양한 옵션을 제공하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-234">In some scenarios they may be all that is required, but in other scenarios they may not offer the full range of options to suit your specific requirements.</span></span> <span data-ttu-id="05ca4-235">가장 적합한 값을 결정하려면 테스트를 통해 설정이 애플리케이션에 어떻게 영향을 주는지를 이해해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-235">You must understand how the settings will affect your application through testing to determine the most appropriate values.</span></span>

- <span data-ttu-id="05ca4-236">**일시적 오류 및 영구 오류 기록 및 추적:**</span><span class="sxs-lookup"><span data-stu-id="05ca4-236">**Log and track transient and non-transient faults:**</span></span>

  - <span data-ttu-id="05ca4-237">재시도 전략의 일부로 재시도가 수행될 때 기록되는 예외 처리 및 기타 계측을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-237">As part of your retry strategy, include exception handling and other instrumentation that logs when retry attempts are made.</span></span> <span data-ttu-id="05ca4-238">가끔 일시적인 오류 및 재시도가 예상되지만 문제를 나타내지 않으면 정기적이고 증가하는 재시도 횟수는 종종 오류의 원인이 되거나 현재 애플리케이션 성능 및 가용성에 영향을 주고 있는 문제를 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-238">While an occasional transient failure and retry are to be expected, and do not indicate a problem, regular and increasing numbers of retries are often an indicator of an issue that may cause a failure, or is currently impacting application performance and availability.</span></span>

  - <span data-ttu-id="05ca4-239">일시적인 오류를 오류 항목이 아닌 경고 항목으로 기록하여 모니터링 시스템에서 허위 경고를 트리거할 수 있는 애플리케이션 오류로 감지하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-239">Log transient faults as Warning entries rather than Error entries so that monitoring systems do not detect them as application errors that may trigger false alerts.</span></span>

  - <span data-ttu-id="05ca4-240">재시도가 서비스의 제한에 의해 발생되었는지 연결 오류와 같은 다른 유형의 오류에 의해 발생되었는지를 나타내는 값을 로그 항목에 저장하여 데이터 분석 중 구분할 수 있도록 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-240">Consider storing a value in your log entries that indicates if the retries were caused by throttling in the service, or by other types of faults such as connection failures, so that you can differentiate them during analysis of the data.</span></span> <span data-ttu-id="05ca4-241">제한 오류 수의 증가는 애플리케이션의 설계에 결함이 있음을 나타내거나 전용 하드웨어를 제공하는 프리미엄 서비스로 전환해야 함을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-241">An increase in the number of throttling errors is often an indicator of a design flaw in the application or the need to switch to a premium service that offers dedicated hardware.</span></span>

  - <span data-ttu-id="05ca4-242">재시도 메커니즘을 포함하는 작업에 걸린 전체 시간을 측정하고 기록하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-242">Consider measuring and logging the overall time taken for operations that include a retry mechanism.</span></span> <span data-ttu-id="05ca4-243">이 시간은 사용자 응답 시간, 프로세스 대기 시간 및 애플리케이션 사용 사례의 효율성에 대한 일시적인 오류의 전체적인 효과를 적절하게 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-243">This is a good indicator of the overall effect of transient faults on user response times, process latency, and the efficiency of the application use cases.</span></span> <span data-ttu-id="05ca4-244">또한 응답 시간에 영향을 주는 요인을 파악하기 위해 수행된 재시도 횟수를 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-244">Also log the number of retries occurred in order to understand the factors that contributed to the response time.</span></span>

  - <span data-ttu-id="05ca4-245">오류 수 및 비율, 평균 재시도 횟수 또는 작업이 성공하는 데 걸린 전체 시간이 증가하는 경우 원격 분석을 구현하고 경고를 발생시킬 수 있는 시스템을 모니터링하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-245">Consider implementing a telemetry and monitoring system that can raise alerts when the number and rate of failures, the average number of retries, or the overall times taken for operations to succeed, is increasing.</span></span>

- <span data-ttu-id="05ca4-246">**계속해서 실패하는 작업 관리:**</span><span class="sxs-lookup"><span data-stu-id="05ca4-246">**Manage operations that continually fail:**</span></span>
  
  - <span data-ttu-id="05ca4-247">시도할 때마다 작업이 계속 실패하는 상황이 있으면 이러한 상황을 처리할 방법을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-247">There will be circumstances where the operation continues to fail at every attempt, and it is vital to consider how you will handle this situation:</span></span>

    - <span data-ttu-id="05ca4-248">재시도 전략에서 작업을 재시도해야 하는 최대 횟수를 정의하지만 애플리케이션이 동일한 재시도 횟수로 작업을 다시 반복하는 것을 방지하지는 못합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-248">Although a retry strategy will define the maximum number of times that an operation should be retried, it does not prevent the application repeating the operation again, with the same number of retries.</span></span> <span data-ttu-id="05ca4-249">예를 들어 주문 처리 서비스가 영구적으로 작동하지 못하게 하는 치명적인 오류로 실패하는 경우 재시도 전략에서 연결 제한 시간을 감지하고 일시적인 오류로 간주할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-249">For example, if an order processing service fails with a fatal error that puts it out of action permanently, the retry strategy may detect a connection timeout and consider it to be a transient fault.</span></span> <span data-ttu-id="05ca4-250">코드는 지정된 횟수만큼 작업을 재시도한 후 포기합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-250">The code will retry the operation a specified number of times and then give up.</span></span> <span data-ttu-id="05ca4-251">그러나 다른 고객이 주문하면 작업이 다시 시도되며, 매번 분명히 실패하는 경우에도 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-251">However, when another customer places an order, the operation will be attempted again - even though it is sure to fail every time.</span></span>

    - <span data-ttu-id="05ca4-252">계속 실패하는 작업에 대해 지속적인 재시도를 방지하려면 [회로 차단기 패턴](../patterns/circuit-breaker.md)(영문)을 구현하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-252">To prevent continual retries for operations that continually fail, consider implementing the [Circuit Breaker pattern](../patterns/circuit-breaker.md).</span></span> <span data-ttu-id="05ca4-253">이 패턴에서는 지정한 기간 내의 오류 수가 임계값을 초과하는 경우 요청이 실패한 리소스 또는 서비스에 대한 액세스를 시도하지 않고 호출자에게 즉시 오류로 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-253">In this pattern, if the number of failures within a specified time window exceeds the threshold, requests are returned to the caller immediately as errors, without attempting to access the failed resource or service.</span></span>

    - <span data-ttu-id="05ca4-254">애플리케이션은 간헐적으로 및 요청 사이에 매우 긴 간격을 두어 서비스를 정기적으로 테스트하여 사용할 수 있게 되면 이를 감지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-254">The application can periodically test the service, on an intermittent basis and with very long intervals between requests, to detect when it becomes available.</span></span> <span data-ttu-id="05ca4-255">적절한 간격은 작업의 중요성 및 서비스의 특성과 같은 시나리오에 따라 달라지며 몇 분에서 몇 시간 사이일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-255">An appropriate interval will depend on the scenario, such as the criticality of the operation and the nature of the service, and might be anything between a few minutes and several hours.</span></span> <span data-ttu-id="05ca4-256">테스트가 성공하는 지점에서 애플리케이션은 일반적인 작업을 다시 시작하고 새로 복구된 서비스에 요청을 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-256">At the point where the test succeeds, the application can resume normal operations and pass requests to the newly recovered service.</span></span>

    - <span data-ttu-id="05ca4-257">그 동안 서비스의 다른 인스턴스(다른 데이터 센터 또는 애플리케이션)로 폴 백하거나, 호환되는 더 간단한 기능을 제공하는 유사한 서비스를 사용하거나, 서비스를 곧 사용할 수 있게 된다는 기대로 다른 몇 가지 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-257">In the meantime, it may be possible to fall back to another instance of the service (perhaps in a different datacenter or application), use a similar service that offers compatible (perhaps simpler) functionality, or perform some alternative operations in the hope that the service will become available soon.</span></span> <span data-ttu-id="05ca4-258">예를 들어 서비스에 대한 요청을 큐 또는 데이터 저장소에 저장하고 나중에 다시 재생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-258">For example, it may be appropriate to store requests for the service in a queue or data store and replay them later.</span></span> <span data-ttu-id="05ca4-259">그렇지 않으면 사용자를 애플리케이션의 다른 인스턴스로 리디렉션하거나, 애플리케이션의 성능은 저하되지만 허용되는 기능을 계속 제공하거나, 현재 애플리케이션을 사용할 수 없다는 메시지를 사용자에게 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-259">Otherwise you might be able to redirect the user to an alternative instance of the application, degrade the performance of the application but still offer acceptable functionality, or just return a message to the user indicating that the application is not available at present.</span></span>

- <span data-ttu-id="05ca4-260">**기타 고려 사항**</span><span class="sxs-lookup"><span data-stu-id="05ca4-260">**Other considerations**</span></span>
  
  - <span data-ttu-id="05ca4-261">정책에 대해 재시도 횟수 및 다시 시도 간격 값을 결정할 때는 서비스 또는 리소스의 작업이 장기 실행 또는 다단계 작업의 일부인지를 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-261">When deciding on the values for the number of retries and the retry intervals for a policy, consider if the operation on the service or resource is part of a long-running or multi-step operation.</span></span> <span data-ttu-id="05ca4-262">한 단계가 실패할 경우 이미 성공한 다른 모든 작업 단계를 보완하기가 어렵거나 비용이 많을 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-262">It may be difficult or expensive to compensate all the other operational steps that have already succeeded when one fails.</span></span> <span data-ttu-id="05ca4-263">이런 경우 매우 긴 간격 및 매우 많은 재시도 횟수가 부족한 리소스를 보유하거나 잠가 다른 작업을 차단하지 않는 한 허용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-263">In this case, a very long interval and a large number of retries may be acceptable as long as it does not block other operations by holding or locking scarce resources.</span></span>

  - <span data-ttu-id="05ca4-264">동일한 작업을 재시도하여 데이터 불일치가 발생할 수 있는 경우를 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-264">Consider if retrying the same operation may cause inconsistencies in data.</span></span> <span data-ttu-id="05ca4-265">다단계 프로세스의 일부가 반복되고 작업이 멱등이 아닌 경우 불일치가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-265">If some parts of a multi-step process are repeated, and the operations are not idempotent, it may result in an inconsistency.</span></span> <span data-ttu-id="05ca4-266">예를 들어 값이 증가하는 작업이 반복되는 경우 잘못된 결과가 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-266">For example, an operation that increments a value, if repeated, will produce an invalid result.</span></span> <span data-ttu-id="05ca4-267">큐에 메시지를 전송하는 작업을 반복하면 중복 메시지를 감지할 수 없는 경우 소비자에게 메시지 불일치가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-267">Repeating an operation that sends a message to a queue may cause an inconsistency in the message consumer if it cannot detect duplicate messages.</span></span> <span data-ttu-id="05ca4-268">이를 방지하려면 각 단계를 멱등 작업으로 설계해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-268">To prevent this, ensure that you design each step as an idempotent operation.</span></span> <span data-ttu-id="05ca4-269">멱등에 대한 자세한 내용은 [멱등 패턴][idempotency-patterns]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="05ca4-269">For more information about idempotency, see [Idempotency patterns][idempotency-patterns].</span></span>

  - <span data-ttu-id="05ca4-270">재시도할 작업의 범위를 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-270">Consider the scope of the operations that will be retried.</span></span> <span data-ttu-id="05ca4-271">예를 들어 여러 작업을 포함하는 수준에서 재시도 코드를 더 쉽게 구현할 수 있으면 한 작업이 실패할 경우 모든 작업을 재시도합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-271">For example, it may be easier to implement retry code at a level that encompasses several operations, and retry them all if one fails.</span></span> <span data-ttu-id="05ca4-272">그러나 이렇게 하면 멱등 문제나 불필요한 롤백 작업이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-272">However, doing this may result in idempotency issues or unnecessary rollback operations.</span></span>

  - <span data-ttu-id="05ca4-273">여러 작업을 포함하는 재시도 범위를 선택한 경우 다시 시도 간격을 결정할 때, 걸린 시간을 모니터링할 때 및 오류에 대해 경고를 발생하기 전에 모든 작업의 총 대기 시간을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-273">If you choose a retry scope that encompasses several operations, take into account the total latency of all of them when determining the retry intervals, when monitoring the time taken, and before raising alerts for failures.</span></span>

  - <span data-ttu-id="05ca4-274">재시도 전략이 인접 라우터 및 공유 애플리케이션의 기타 테넌트에 어떻게 영향을 줄 수 있는지 또는 공유 리소스 및 서비스를 사용하는 경우를 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-274">Consider how your retry strategy may affect neighbors and other tenants in a shared application, or when using shared resources and services.</span></span> <span data-ttu-id="05ca4-275">적극적인 재시도 정책으로 인해 이러한 다른 사용자 및 리소스와 서비스를 공유하는 애플리케이션에 대해 일시적인 오류 수가 증가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-275">Aggressive retry policies can cause an increasing number of transient faults to occur for these other users and for applications that share the resources and services.</span></span> <span data-ttu-id="05ca4-276">마찬가지로 애플리케이션은 리소스 및 서비스의 다른 사용자가 구현한 재시도 정책의 영향을 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-276">Likewise, your application may be affected by the retry policies implemented by other users of the resources and services.</span></span> <span data-ttu-id="05ca4-277">중요 업무용 애플리케이션의 경우 공유되지 않은 프리미엄 서비스를 사용하도록 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-277">For mission-critical applications, you may decide to use premium services that are not shared.</span></span> <span data-ttu-id="05ca4-278">그러면 이러한 리소스 및 서비스의 부하와 그에 따른 제한을 보다 효율적으로 제어하여 추가 비용을 정당화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05ca4-278">This provides you with much more control over the load and consequent throttling of these resources and services, which can help to justify the additional cost.</span></span>

## <a name="more-information"></a><span data-ttu-id="05ca4-279">자세한 정보</span><span class="sxs-lookup"><span data-stu-id="05ca4-279">More information</span></span>

- [<span data-ttu-id="05ca4-280">Azure 서비스 관련 재시도 지침</span><span class="sxs-lookup"><span data-stu-id="05ca4-280">Azure service-specific retry guidelines</span></span>](./retry-service-specific.md)
- [<span data-ttu-id="05ca4-281">회로 차단기 패턴</span><span class="sxs-lookup"><span data-stu-id="05ca4-281">Circuit Breaker pattern</span></span>](../patterns/circuit-breaker.md)
- [<span data-ttu-id="05ca4-282">보상 트랜잭션 패턴</span><span class="sxs-lookup"><span data-stu-id="05ca4-282">Compensating Transaction pattern</span></span>](../patterns/compensating-transaction.md)
- <span data-ttu-id="05ca4-283">[멱등 패턴][idempotency-patterns]</span><span class="sxs-lookup"><span data-stu-id="05ca4-283">[Idempotency patterns][idempotency-patterns]</span></span>

<!-- links -->

[idempotency-patterns]: https://blog.jonathanoliver.com/idempotency-patterns/
