---
title: 재시도 일반 지침
description: 일시적인 오류 처리를 위한 재시도 관련 지침입니다.
author: dragon119
ms.date: 07/13/2016
pnp.series.title: Best Practices
ms.openlocfilehash: 9562e3447b2219fe2f3df96cfca24b845efa39b0
ms.sourcegitcommit: c53adf50d3a787956fc4ebc951b163a10eeb5d20
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/23/2017
---
# <a name="transient-fault-handling"></a>일시적인 오류 처리

[!INCLUDE [header](../_includes/header.md)]

원격 서비스 및 리소스와 통신하는 모든 응용 프로그램은 일시적인 오류에 민감해야 합니다. 특히 클라우드에서 실행되는 응용 프로그램의 경우는 더욱 그렇습니다. 이러한 응용 프로그램에서는 환경 및 인터넷을 통한 연결이라는 특성으로 인해 이러한 유형의 오류가 더 자주 발생할 수 있습니다. 일시적인 오류로는 구성 요소 및 서비스의 순간적인 네트워크 연결 끊김, 서비스의 일시적인 사용 중단, 서비스가 사용 중일 때 발생하는 시간 제한 등이 있습니다. 이러한 오류는 종종 자동으로 해결되며 적절한 시간을 두고 동작을 반복하면 성공할 가능성이 매우 높습니다.

이 문서에서는 일시적인 오류 처리에 대한 일반적인 지침을 소개합니다. Microsoft Azure 서비스를 사용하는 경우 일시적인 오류 처리에 대한 자세한 내용은 [Azure 서비스 관련 재시도 지침](./retry-service-specific.md)을 참조하세요.

## <a name="why-do-transient-faults-occur-in-the-cloud"></a>클라우드에서 일시적인 오류가 발생하는 이유
일시적인 오류는 환경, 플랫폼 또는 운영 체제 및 응용 프로그램의 종류에 관계없이 발생할 수 있습니다. 로컬, 온-프레미스 인프라에서 실행되는 솔루션에서는 응용 프로그램과 해당 구성 요소의 성능 및 사용 가능성이 일반적으로 비용이 많이 들고 충분히 활용되지 않는 하드웨어 중복성을 통해 유지 관리되며 구성 요소와 리소스는 서로 가깝게 배치되어 있습니다. 따라서 오류가 발생할 가능성은 줄어들지만 일시적인 오류는 계속 발생합니다. 외부 전원 공급 장치나 네트워크 문제 같은 예측하지 못한 이벤트를 통한 중단이나 다른 재해 시나리오를 통해서도 발생할 수 있습니다.

사설 클라우드 시스템을 비롯한 클라우드 호스팅에서는 엄청난 수의 상용 계산 노드 간에 공유 리소스, 중복성, 자동 장애 조치(failover) 및 동적 리소스 할당을 사용하여 전체적인 가용성을 향상시킬 수 있습니다. 그러나 이러한 환경의 특성상 일시적인 오류가 발생할 가능성이 더 높을 수 있습니다. 이는 다음과 같은 여러 가지 원인 때문일 수 있습니다.

* 클라우드 환경에서는 많은 리소스가 공유되며, 이러한 리소스를 보호하기 위해 리소스에 대한 액세스가 제한될 수 있습니다. 일부 서비스는 부하가 특정 수준까지 증가하는 경우, 최대 처리 속도에 도달하는 경우 또는 기존 요청을 처리하고 모든 사용자에 대해 서비스 성능을 유지 관리하기 위해 연결을 거부합니다. 제한은 공유 리소스를 사용하여 인접 라우터 및 기타 테넌트에 대해 서비스 품질을 유지 관리하는 데 도움이 됩니다.
* 클라우드 환경은 방대한 수의 상용 하드웨어 장치를 사용하여 구축됩니다. 또한 여러 컴퓨팅 장치 및 인프라 구성 요소 간에 부하를 동적으로 분산시켜 성능을 제공하고 오류가 발생한 장치를 자동으로 재활용하거나 대체하여 안정성을 제공합니다. 이러한 동적 특성으로 인해 일시적인 오류 및 임시 연결 오류가 가끔 발생할 수 있습니다.
* 라우터 및 부하 분산 장치 같은 네트워크 인프라를 포함하여 응용 프로그램과 해당 응용 프로그램에서 사용하는 리소스 및 서비스 간에 하드웨어 구성 요소가 더 많은 경우가 종종 있습니다. 이러한 추가 인프라로 인해 가끔 추가 연결 대기 시간 및 일시적인 연결 오류가 발생할 수 있습니다.
* 클라이언트와 서버 간 네트워크 상태가 일정하지 않을 수 있으며, 특히 인터넷을 통한 통신의 경우는 더욱 그렇습니다. 심지어 온-프레미스 위치에서도 트래픽 부하가 매우 많은 경우 통신 속도가 느려지고 일시적인 연결 오류가 발생할 수 있습니다.

## <a name="challenges"></a>과제
일시적인 오류는 예측 가능한 모든 환경에서 완벽하게 테스트된 경우에도 응용 프로그램의 인지된 가용성에 엄청난 영향을 줄 수 있습니다. 클라우드 호스팅 응용 프로그램이 안정적으로 작동하도록 하려면 다음과 같은 과제에 응답할 수 있어야 합니다.

* 응용 프로그램은 오류가 발생하면 감지하고 이러한 오류가 일시적인지, 더 오래 지속되는지, 터미널 오류인지를 결정할 수 있어야 합니다. 리소스에 따라 오류가 발생할 때 서로 다른 응답을 반환할 수 있으며 이러한 응답은 작업의 컨텍스트에 따라 달라질 수도 있습니다. 예를 들어 저장소에서 읽을 때 오류에 대한 응답은 저장소에 쓸 때 오류에 대한 응답과 다를 수 있습니다. 많은 리소스와 서비스에는 잘 문서화된 일시적인 오류 계약이 있습니다. 그러나 이러한 정보를 사용할 수 없는 경우 오류의 특성 및 일시적인지 여부를 검색하기 어려울 수 있습니다.
* 응용 프로그램은 오류가 일시적인 것으로 확인되면 작업을 재시도할 수 있어야 하고 작업이 재시도된 횟수를 추적해야 합니다.
* 응용 프로그램은 재시도에 적합한 전략을 사용해야 합니다. 이 전략은 재시도 횟수, 각 시도 사이의 지연 및 시도 실패 후 수행할 조치를 지정합니다. 적절한 시도 횟수 및 각 시도 사이의 지연은 결정하기 어려운 경우가 많으며 리소스 유형뿐만 아니라 리소스와 응용 프로그램 자체의 현재 작동 상태에 따라 달라집니다.

## <a name="general-guidelines"></a>일반 지침
다음 지침은 응용 프로그램에 적합한 일시적인 오류 처리 메커니즘을 설계하는 데 도움이 됩니다.

* **기본 제공 재시도 메커니즘이 있는지 확인:**
  * 대부분의 서비스는 일시적인 오류 처리 메커니즘을 포함하는 SDK 또는 클라이언트 라이브러리를 제공합니다. 일반적으로 사용되는 재시도 정책은 대상 서비스의 특성 및 요구 사항에 맞게 조정됩니다. 또는 서비스에 대한 REST 인터페이스는 재시도가 적절한지 여부 및 다음 재시도까지 대기해야 하는 시간을 결정하는 데 도움이 되는 정보를 반환할 수 있습니다.
  * 다른 재시도 동작을 의미하는 잘 이해할 수 있는 특정 요구 사항이 없을 경우 사용 가능한 기본 제공 재시도 메커니즘을 사용하는 것이 더 적합합니다.
* **작업이 재시도에 적합한지 확인**:
  * 오류가 일시적인 경우(일반적으로 오류의 특성으로 표시됨) 및 재시도할 경우 작업이 성공할 가능성이 어느 정도 있는 경우에만 작업을 재시도해야 합니다. 존재하지 않는 항목에 대한 데이터베이스 업데이트와 같은 잘못된 작업을 나타내는 작업이나 치명적인 오류가 발생한 서비스나 리소스에 대한 요청은 재시도할 필요가 없습니다.
  * 일반적으로 이 작업의 전체적인 영향을 확인할 수 있고 조건을 잘 이해하고 유효성을 검사할 수 있는 경우에만 재시도를 구현해야 합니다. 그렇지 않은 경우 재시도를 구현하는 호출 코드를 그대로 유지합니다. 제어할 수 없는 리소스 및 서비스에서 반환된 오류는 시간에 따라 변경될 수 있으므로 일시적인 오류 검색 논리를 다시 확인해야 할 수 있습니다.
  * 서비스 또는 구성 요소를 만드는 경우 클라이언트에서 실패한 작업을 재시도해야 하는지 여부를 결정하는 데 도움이 되는 메시지 및 오류 코드를 구현하는 것이 좋습니다. 특히 **isTransient** 값을 반환하여 클라이언트에서 작업을 재시도해야 하는지를 나타내고 다음 재시도 전까지 적합한 지연 시간을 제안합니다. 웹 서비스를 구축하는 경우에는 서비스 계약 내에 정의된 사용자 지정 오류를 반환하는 것이 좋습니다. 일반 클라이언트에서 이러한 오류를 읽을 수 없는 경우에도 사용자 지정 클라이언트를 구축할 때 도움이 됩니다.
* **적절한 재시도 횟수 및 간격 결정:**
  * 사용 사례의 유형에 따라 재시도 횟수 및 간격을 최적화해야 합니다. 충분한 횟수만큼 재시도하지 않으면 응용 프로그램에서 작업을 완료할 수 없고 오류가 발생할 가능성이 높습니다. 너무 많이 재시도하거나 재시도 간 간격이 너무 짧은 경우 응용 프로그램에서 스레드, 연결 및 메모리와 같은 리소스를 오랫동안 보유하여 응용 프로그램의 상태에 부정적인 영향을 줄 수 있습니다.
  * 재시도 시간 간격 및 횟수에 적합한 값은 시도하려는 작업의 유형에 따라 달라집니다. 예를 들어 작업이 사용자 조작 방식의 일부인 경우 사용자가 응답을 대기하지 않도록 하여 열린 연결을 보유하고 다른 사용자에 대한 가용성을 줄이려면 간격이 짧아야 하고 몇 번만 재시도되어야 합니다. 작업이 장기 실행 또는 중요한 워크플로의 일부여서 프로세스를 취소하고 다시 시작하면 비용이 많이 들거나 시간이 많이 소요되는 경우에는 시도 사이에 더 오래 기다리고 더 여러 번 재시도하는 것이 적합합니다.
  * 재시도 사이의 적절한 간격을 결정하는 것은 성공적인 전략 설계에서 가장 어려운 부분입니다. 일반적인 전략에서는 다음과 같은 유형의 다시 시도 간격을 사용합니다.
    * **지수적 백오프**. 응용 프로그램이 첫 번째 재시도 전까지 짧은 시간 동안 대기한 다음 이후 각 재시도 사이의 시간을 기하급수적으로 늘립니다. 예를 들어 3초, 12초, 30초 등 후에 작업을 재시도할 수 있습니다.
    * **증분 간격**. 응용 프로그램이 첫 번째 재시도 전까지 짧은 시간 동안 대기한 다음 이후 각 재시도 사이의 시간을 증분하여 늘립니다. 예를 들어 3초, 7초, 13초 등 후에 작업을 재시도할 수 있습니다.
    * **정기적 간격**. 응용 프로그램이 각 시도 사이에 동일한 기간 동안 대기합니다. 예를 들어 3초마다 작업을 재시도할 수 있습니다.
    * **즉시 재시도**. 경우에 따라 일시적인 오류가 매우 짧을 수 있습니다. 이는 네트워크 패킷 충돌 또는 하드웨어 구성 요소의 스파이크와 같은 이벤트에 의해 발생하는 경우일 수 있습니다. 이런 경우 응용 프로그램이 다음 요청을 어셈블하여 보내는 데 걸리는 시간 동안 오류가 해결되어 성공할 수 있으므로 작업을 즉시 재시도하는 것이 적합합니다. 그러나 즉시 재시도 횟수는 두 번 이상이면 안 되므로 즉시 재시도가 실패할 경우 지수적 백오프 또는 대체 동작과 같은 다른 전략으로 전환해야 합니다.
    * **불규칙**. 위에 나열된 재시도 전략에는 여러 클라이언트 인스턴스에서 이후 재시도 횟수를 동시에 보낼 수 없도록 하는 불규칙이 포함될 수 있습니다. 예를 들어 한 인스턴스는 3초, 11초, 28초 등 후에 작업을 재시도하고 다른 인스턴스는 4초, 12초, 26초 등 후에 작업을 재시도할 수 있습니다. 불규칙은 다른 전략과 함께 사용할 수 있는 유용한 기술입니다.  
  * 일반적인 지침으로 백그라운드 작업에는 지수적 백오프를 사용하고 대화형 작업에는 즉시 또는 정기적 간격 재시도 전략을 사용합니다. 두 경우 모두, 모든 재시도 횟수의 최대 대기 시간이 필요한 종단 간 대기 시간 요구 사항 내에 포함되도록 지연 시간 및 재시도 횟수를 선택해야 합니다.
  * 재시도된 작업의 전체적인 최대 제한 시간에 영향을 주는 모든 요인의 조합을 고려해야 합니다. 이러한 요인에는 재시도 횟수와 최대 재시도 횟수 간 지연뿐만 아니라 실패한 연결에서 응답을 생성하는 데 걸린 시간(일반적으로 클라이언트에서 제한 시간 값으로 설정)이 포함됩니다. 이러한 모든 시간을 합하면 전체적인 작업 시간이 매우 커질 수 있습니다. 특히 재시도 간 간격이 각 실패 후 빠르게 증가하는 지수적 지연 전략을 사용하는 경우는 더욱 그렇습니다. 프로세스가 특정 SLA(서비스 수준 계약)를 충족해야 하는 경우 모든 제한 시간 및 지연을 포함한 전체적인 작업 시간은 SLA에 정의된 시간 내에 포함되어야 합니다.
  * 간격이 너무 짧거나 재시도 횟수가 너무 많아 지나치게 적극적인 재시도 전략은 대상 리소스 또는 서비스에 악영향을 줄 수 있습니다. 따라서 리소스나 서비스가 오버로드된 상태에서 복구되지 않아 요청을 계속 차단하거나 거부할 수 있습니다. 이 결과 점점 더 많은 요청이 리소스나 서비스로 전송되어 결과적으로 복구 능력이 더 저하되는 악순환이 발생합니다.
  * 이후 시도가 즉시 시작되지 않도록 다시 시도 간격을 선택하려는 경우(예: 제한 시간 기간이 다시 시도 간격과 유사한 경우) 작업의 제한 시간을 고려합니다. 또한 가능한 총 기간(제한 시간과 다시 시도 간격을 합한 시간)을 특정 총 시간 아래로 유지해야 하는 경우를 고려합니다. 일반적으로 제한 시간이 짧거나 매우 긴 작업은 대기 시간 및 작업을 재시도하는 빈도에 영향을 줄 수 있습니다.
  * 다시 시도 간격 및 횟수를 최적화하려면 예외의 유형과 해당 예외에 포함된 데이터 또는 서비스에 반환된 오류 코드 및 메시지를 사용합니다. 예를 들어 일부 예외 또는 오류 코드(예: HTTP 코드 503 Retry After 헤더에서 서비스를 사용할 수 없음)는 오류가 지속될 수 있는 기간을 나타내거나 서비스가 실패하여 이후 모든 시도에 응답하지 않음을 나타낼 수 있습니다.
* **안티패턴 방지**
  * 대부분의 경우 중복된 재시도 코드 계층을 포함하는 구현을 피해야 합니다. 계단식 재시도 메커니즘을 포함하거나 특정 요구 사항이 없다면 요청의 계층 구조를 포함하는 작업의 모든 단계에서 재시도를 구현하는 설계는 피하는 것이 좋습니다. 이러한 예외적인 경우 과도하게 많은 재시도 및 지연 기간을 방지하는 정책을 사용하고 결과를 이해하고 있어야 합니다. 예를 들어 한 구성 요소에서 다른 구성 요소를 요청한 다음 대상 서비스에 액세스하고 두 호출에서 세 번 재시도를 구현하면 서비스에 대한 총 재시도 횟수는 9번이 됩니다. 많은 서비스와 리소스는 기본 제공 재시도 메커니즘을 구현하고 더 높은 수준에서 재시도를 구현해야 하는 경우 이 메커니즘을 사용하지 않도록 설정하거나 수정하는 방법을 조사해야 합니다.
  * 무한 재시도 메커니즘을 구현하지 않습니다. 이 메커니즘을 구현하면 리소스나 서비스가 오버로드 상황에서 복구되지 않고 제한 및 거부된 연결이 오랫동안 계속되도록 할 수 있습니다. 한정된 수의 재시도를 사용하거나 [회로 차단기](http://msdn.microsoft.com/library/dn589784.aspx) 같은 패턴을 구현하여 서비스에서 복구할 수 있도록 합니다.
  * 즉시 재시도를 두 번 이상 수행하지 않습니다.
  * Azure에서 서비스 및 리소스에 액세스할 때 특히 재시도 횟수가 많은 경우 정기적인 다시 시도 간격을 사용하지 않습니다. 이 시나리오에서 최적의 방법은 회로 차단 기능이 있는 지수적 백오프 전략입니다.
  * 동일한 클라이언트의 여러 인스턴스 또는 다른 클라이언트의 여러 인스턴스에서 동시에 재시도를 보내지 않도록 합니다. 이런 경우 다시 시도 간격에 불규칙을 적용합니다.
* **재시도 전략 및 구현 테스트:**
  * 최대한 광범위한 상황에서 특히, 응용 프로그램과 해당 응용 프로그램에서 사용하는 대상 리소스 또는 서비스가 모두 극단적인 부하를 받는 경우 재시도 전략 및 구현을 완벽하게 테스트해야 합니다. 테스트 중 동작을 확인하려면 다음을 수행할 수 있습니다.
    * 서비스에 일시적 오류 및 영구 오류를 주입합니다. 예를 들어 잘못된 요청을 보내거나 테스트 요청을 감지하고 다양한 유형의 오류로 응답하는 코드를 추가합니다. TestApi를 사용하는 예제는 [TestApi로 오류 주입 테스트](http://msdn.microsoft.com/magazine/ff898404.aspx) 및 [TestApi 소개 - 5부: 관리 코드 오류 주입 API](http://blogs.msdn.com/b/ivo_manolov/archive/2009/11/25/9928447.aspx)를 참조하세요.
    * 실제 서비스에서 반환할 수 있는 오류의 범위를 반환하는 리소스 또는 서비스의 모형을 만듭니다. 재시도 전략에서 감지하도록 설계된 모든 유형의 오류를 포함해야 합니다.
    * 사용자가 만들고 배포한 사용자 지정 오류인 경우 임시로 서비스를 사용하지 않도록 설정하거나 오버로드하여 강제로 일시적인 오류가 발생하도록 합니다. 물론 Azure 내에서 공유 리소스나 공유 서비스를 오버로드하려고 해서는 안 됩니다.
    * HTTP 기반 API의 경우 왕복 시간을 더 추가하거나 응답(예: HTTP 상태 코드, 헤더, 본문 또는 기타 요인)을 변경하여 자동화된 테스트에서 FiddlerCore 라이브러리를 사용하여 HTTP 요청의 결과를 변경하는 것이 좋습니다. 이렇게 하면 일시적인 오류인지 다른 유형의 오류인지에 관계없이 오류 상태의 하위 집합을 결정적으로 테스트할 수 있습니다. 자세한 내용은 [FiddlerCore](http://www.telerik.com/fiddler/fiddlercore)를 참조하세요. 라이브러리, 특히 **HttpMangler** 클래스를 사용하는 방법에 대한 예제는 [Azure Storage SDK에 대한 소스 코드](https://github.com/Azure/azure-storage-net/tree/master/Test)(영문)를 검토하세요.
    * 높은 로드 비율 및 동시 테스트를 수행하여 재시도 메커니즘 및 전략이 이러한 상황에서 올바르게 작동하는지 확인하고 클라이언트의 작업에 악영향을 주거나 요청 간 교차 오염이 발생하지 않도록 합니다.
* **재시도 정책 구성 관리:**
  * *재시도 정책*은 재시도 전략의 모든 요소를 조합한 것입니다. 이 정책은 오류가 일시적인지 여부, 사용할 간격의 유형(예: 정기, 지수적 백오프 및 불규칙), 실제 간격 값 및 재시도 횟수를 결정하는 검색 메커니즘을 정의합니다.
  * 재시도는 가장 간단한 응용 프로그램 내의 여러 위치 및 더 복잡한 응용 프로그램의 모든 계층에서 구현되어야 합니다. 여러 위치에서 각 정책의 요소를 하드 코딩하는 대신 모든 정책을 저장할 중앙 지점을 사용하는 것이 좋습니다. 예를 들어 간격 및 재시도 횟수와 같은 값을 응용 프로그램 구성 파일에 저장하여 런타임에 읽고 프로그래밍 방식으로 재시도 정책을 작성합니다. 그러면 더 쉽게 설정을 관리하고 값을 수정하고 미세 조정하여 변화하는 요구 사항 및 시나리오에 응답할 수 있습니다. 그러나 매번 구성 파일을 다시 읽는 대신 값을 저장하도록 시스템을 설계하면 구성에서 값을 가져올 수 없는 경우 적절한 기본값이 사용되도록 할 수 있습니다.
  * Azure Cloud Services 응용 프로그램에서는 런타임에 재시도 정책을 작성하는 데 사용되는 값을 서비스 구성 파일에 저장하여 응용 프로그램을 다시 시작하지 않고도 변경할 수 있도록 하는 것이 좋습니다.
  * 사용하는 클라이언트 API에서 제공되는 기본 제공 또는 기본 재시도 전략을 활용하지만 시나리오에 적합한 경우에만 활용합니다. 일반적으로 이러한 전략은 범용입니다. 일부 시나리오에서는 모두 필요하지만 일부 시나리오에서는 특정 요구 사항에 맞는 다양한 옵션을 제공하지 못할 수 있습니다. 가장 적합한 값을 결정하려면 테스트를 통해 설정이 응용 프로그램에 어떻게 영향을 주는지를 이해해야 합니다.
* **일시적 오류 및 영구 오류 기록 및 추적:**
  * 재시도 전략의 일부로 재시도가 수행될 때 기록되는 예외 처리 및 기타 계측을 포함합니다. 가끔 일시적인 오류 및 재시도가 예상되지만 문제를 나타내지 않으면 정기적이고 증가하는 재시도 횟수는 종종 오류의 원인이 되거나 현재 응용 프로그램 성능 및 가용성에 영향을 주고 있는 문제를 나타낼 수 있습니다.
  * 일시적인 오류를 오류 항목이 아닌 경고 항목으로 기록하여 모니터링 시스템에서 허위 경고를 트리거할 수 있는 응용 프로그램 오류로 감지하지 않도록 합니다.
  * 재시도가 서비스의 제한에 의해 발생되었는지 연결 오류와 같은 다른 유형의 오류에 의해 발생되었는지를 나타내는 값을 로그 항목에 저장하여 데이터 분석 중 구분할 수 있도록 하는 것이 좋습니다. 제한 오류 수의 증가는 응용 프로그램의 설계에 결함이 있음을 나타내거나 전용 하드웨어를 제공하는 프리미엄 서비스로 전환해야 함을 나타냅니다.  
  * 재시도 메커니즘을 포함하는 작업에 걸린 전체 시간을 측정하고 기록하는 것이 좋습니다. 이 시간은 사용자 응답 시간, 프로세스 대기 시간 및 응용 프로그램 사용 사례의 효율성에 대한 일시적인 오류의 전체적인 효과를 적절하게 나타냅니다. 또한 응답 시간에 영향을 주는 요인을 파악하기 위해 수행된 재시도 횟수를 기록합니다.
  * 오류 수 및 비율, 평균 재시도 횟수 또는 작업이 성공하는 데 걸린 전체 시간이 증가하는 경우 원격 분석을 구현하고 경고를 발생시킬 수 있는 시스템을 모니터링하는 것이 좋습니다.
* **계속해서 실패하는 작업 관리:**
  
  * 시도할 때마다 작업이 계속 실패하는 상황이 있으면 이러한 상황을 처리할 방법을 고려해야 합니다.
    * 재시도 전략에서 작업을 재시도해야 하는 최대 횟수를 정의하지만 응용 프로그램이 동일한 재시도 횟수로 작업을 다시 반복하는 것을 방지하지는 못합니다. 예를 들어 주문 처리 서비스가 영구적으로 작동하지 못하게 하는 치명적인 오류로 실패하는 경우 재시도 전략에서 연결 제한 시간을 감지하고 일시적인 오류로 간주할 수 있습니다. 코드는 지정된 횟수만큼 작업을 재시도한 후 포기합니다. 그러나 다른 고객이 주문하면 작업이 다시 시도되며, 매번 분명히 실패하는 경우에도 시도됩니다.
    * 계속 실패하는 작업에 대해 지속적인 재시도를 방지하려면 [회로 차단기 패턴](http://msdn.microsoft.com/library/dn589784.aspx)(영문)을 구현하는 것이 좋습니다. 이 패턴에서는 지정한 기간 내의 오류 수가 임계값을 초과하는 경우 요청이 실패한 리소스 또는 서비스에 대한 액세스를 시도하지 않고 호출자에게 즉시 오류로 반환됩니다.
    * 응용 프로그램은 간헐적으로 및 요청 사이에 매우 긴 간격을 두어 서비스를 정기적으로 테스트하여 사용할 수 있게 되면 이를 감지할 수 있습니다. 적절한 간격은 작업의 중요성 및 서비스의 특성과 같은 시나리오에 따라 달라지며 몇 분에서 몇 시간 사이일 수 있습니다. 테스트가 성공하는 지점에서 응용 프로그램은 일반적인 작업을 다시 시작하고 새로 복구된 서비스에 요청을 전달할 수 있습니다.
    * 그 동안 서비스의 다른 인스턴스(다른 데이터 센터 또는 응용 프로그램)로 폴백하거나, 호환되는 더 간단한 기능을 제공하는 유사한 서비스를 사용하거나, 서비스를 곧 사용할 수 있게 된다는 기대로 다른 몇 가지 작업을 수행할 수 있습니다. 예를 들어 서비스에 대한 요청을 큐 또는 데이터 저장소에 저장하고 나중에 다시 재생할 수 있습니다. 그렇지 않으면 사용자를 응용 프로그램의 다른 인스턴스로 리디렉션하거나, 응용 프로그램의 성능은 저하되지만 허용되는 기능을 계속 제공하거나, 현재 응용 프로그램을 사용할 수 없다는 메시지를 사용자에게 반환할 수 있습니다.
* **기타 고려 사항**
  
  * 정책에 대해 재시도 횟수 및 다시 시도 간격 값을 결정할 때는 서비스 또는 리소스의 작업이 장기 실행 또는 다단계 작업의 일부인지를 고려합니다. 한 단계가 실패할 경우 이미 성공한 다른 모든 작업 단계를 보완하기가 어렵거나 비용이 많을 들 수 있습니다. 이런 경우 매우 긴 간격 및 매우 많은 재시도 횟수가 부족한 리소스를 보유하거나 잠가 다른 작업을 차단하지 않는 한 허용될 수 있습니다.
  * 동일한 작업을 재시도하여 데이터 불일치가 발생할 수 있는 경우를 고려합니다. 다단계 프로세스의 일부가 반복되고 작업이 멱등이 아닌 경우 불일치가 발생할 수 있습니다. 예를 들어 값이 증가하는 작업이 반복되는 경우 잘못된 결과가 생성됩니다. 큐에 메시지를 전송하는 작업을 반복하면 중복 메시지를 감지할 수 없는 경우 소비자에게 메시지 불일치가 발생할 수 있습니다. 이를 방지하려면 각 단계를 멱등 작업으로 설계해야 합니다. 멱등에 대한 자세한 내용은 [멱등 패턴][idempotency-patterns]을 참조하세요.
  * 재시도할 작업의 범위를 고려합니다. 예를 들어 여러 작업을 포함하는 수준에서 재시도 코드를 더 쉽게 구현할 수 있으면 한 작업이 실패할 경우 모든 작업을 재시도합니다. 그러나 이렇게 하면 멱등 문제나 불필요한 롤백 작업이 발생할 수 있습니다.
  * 여러 작업을 포함하는 재시도 범위를 선택한 경우 다시 시도 간격을 결정할 때, 걸린 시간을 모니터링할 때 및 오류에 대해 경고를 발생하기 전에 모든 작업의 총 대기 시간을 고려합니다.
  * 재시도 전략이 인접 라우터 및 공유 응용 프로그램의 기타 테넌트에 어떻게 영향을 줄 수 있는지 또는 공유 리소스 및 서비스를 사용하는 경우를 고려합니다. 적극적인 재시도 정책으로 인해 이러한 다른 사용자 및 리소스와 서비스를 공유하는 응용 프로그램에 대해 일시적인 오류 수가 증가할 수 있습니다. 마찬가지로 응용 프로그램은 리소스 및 서비스의 다른 사용자가 구현한 재시도 정책의 영향을 받을 수 있습니다. 중요 업무용 응용 프로그램의 경우 공유되지 않은 프리미엄 서비스를 사용하도록 결정할 수 있습니다. 그러면 이러한 리소스 및 서비스의 부하와 그에 따른 제한을 보다 효율적으로 제어하여 추가 비용을 정당화할 수 있습니다.

## <a name="more-information"></a>자세한 정보
* [Azure 서비스 관련 재시도 지침](./retry-service-specific.md)
* [일시적인 오류 처리 응용 프로그램 블록(영문)](http://msdn.microsoft.com/library/hh680934.aspx)
* [회로 차단기 패턴(영문)](http://msdn.microsoft.com/library/dn589784.aspx)
* [트랜잭션 패턴 보상](http://msdn.microsoft.com/library/dn589804.aspx)
* [멱등 패턴][idempotency-patterns]

[idempotency-patterns]: http://blog.jonathanoliver.com/idempotency-patterns/

