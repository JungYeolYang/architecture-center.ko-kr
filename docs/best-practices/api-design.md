---
title: API design guidance
description: Guidance upon how to create a well designed API.
author: dragon119
ms.service: guidance
ms.topic: article
ms.date: 07/13/2016
ms.author: pnp

pnp.series.title: Best Practices
---
# API 설계
[!INCLUDE [header](../_includes/header.md)]

현대의 상당수 웹 기반 솔루션은 원격 클라이언트 응용 프로그램에 기능을 제공하기 위해 웹 서버에 의해 호스팅 되는 웹 서비스를 활용합니다. 웹 서비스가 표시하는 모든 작업이 웹 API를 구성합니다. 잘 설계된 웹 API의 목표는 다음을 지원하는 것이어야 합니다.

* **플랫폼 독립성**. 클라이언트 응용 프로그램은 API가 표시하는 데이터 또는 작업이 실제로 어떻게 구현되는지와 상관없이 웹 서비스가 제공하는 API를 활용할 수 있어야 합니다. 이를 위해서 API는 공통적인 표준을 준수합니다. 공통적인 표준을 통해 클라이언트 응용 프로그램과 웹 서비스는 어떤 데이터 형식을 사용할 것인지, 그리고 클라이언트 응용 프로그램과 웹 서비스 간에 교환되는 데이터의 구조에 관해 합의할 수 있습니다.
* **서비스 진화**. 웹 서비스는 클라이언트 응용 프로그램과는 독립적으로 진화하고 기능을 추가 (또는 제거)할 수 있어야 합니다. 기존의 클라이언트 응용 프로그램은 웹 서비스가 제공하는 기능이 변경되더라도 수정되지 않은 상태로 계속 작동해야 합니다. 클라이언트 응용 프로그램이 완전하게 활용할 수 있도록 모든 기능이 검색 가능해야 합니다.

본 지침의 목적은 웹 API를 설계할 때 고려해야 할 문제를 기술하는 데 있습니다.

## REST(Representational State Transfer) 소개
로이 필딩(Roy Fielding)은 2000년 자신의 논문에서 웹 서비스가 표시하는 작업을 구조화하는 데 있어 대안이 되는 아키텍처 접근방식인 REST를 제안했습니다. REST는 하이퍼미디어를 기반으로 분산 시스템을 구축하기 위한 하나의 아키텍처 스타일입니다. REST 모델이 공개 표준을 기반으로 하고 REST 모델의 구현이나 REST 모델에 액세스할 클라이언트 응용 프로그램을 특정 구현과 결부시키지 않는다는 점이 REST 모델의 기본적인 장점입니다. 예를 들어, REST 웹 서비스는 Microsoft ASP.NET Web API를 사용해 구현 가능하며, 클라이언트 응용 프로그램은 HTTP 요청 및 구문 분석 HTTP 응답을 생성할 수 있는 언어와 도구 집합을 사용해 개발할 수 있습니다. 

> [!참고]
> REST는 실질적으로 기본 프로토콜과는 관계가 없으며 반드시 HTTP에 연결될 필요도 없습니다. 그러나 REST를 기반으로 하는 가장 공통적인 시스템 구현은 요청을 전송 및 수신하기 위한 응용 프로그램 프로토콜로 HTTP를 활용합니다. 본 지침은 HTTP를 사용해 작동하도록 설계된 시스템에 REST 원칙을 매핑하는 데 초점을 맞춥니다. 
>
>

REST 모델은 네트워크를 통해 개체와 서비스를 나타내는 데 탐색 스키마 사용합니다(*리소스*라고 함). REST를 구현하는 많은 시스템이 이러한 리소스에 액세스하기 위한 요청을 전송하는 데 HTTP 프로토콜을 사용하는 것이 일반적입니다. 이러한 시스템에서 클라이언트 응용 프로그램은 리소스를 식별하는 URI 형태로 요청과 해당 리소스에서 수행될 작업을 표시하는 HTTP 메서드(가장 일반적으로 GET, POST, PUT, DELETE)를 제출합니다. HTTP 요청의 본문에는 해당 작업을 수행하는 데 필요한 데이터가 포함되어 있습니다. REST가 상태 비저장 요청 모델을 정의한다는 것이 이해해야 할 중요한 사항입니다. HTTP 요청은 독립적이어야 하고 어떠한 순서로든 발생해, 요청이 가능하지 않을 때 일시적 상태 정보를 유지하려고 시도할 수 있습니다. 정보가 저장되는 유일한 장소가 리소스 그 자체이며, 각각의 요청은 원자성 작업이 되어야 합니다. 효과적으로 REST 모델은 요청이 잘 정의된 비 일시적 상태에서 다른 상태로 리소스를 전환하는 유한 상태 컴퓨터를 구현합니다. 

> [!참고]
> REST 모델에서 개별적인 요청의 상태 비저장 속성 덕분에 다음 원칙에 따라 시스템을 매우 확장성 있게 구성할 수 있습니다. 일련의 요청을 하는 클라이언트 응용 프로그램과 이러한 요청을 처리하는 특정 웹 서버 간에 선호도를 유지할 필요가 없습니다. 
>
>

효과적인 REST 모델을 구현하는 데 있어 중요한 또 다른 사항은 REST 모델이 액세스를 제공하는 다양한 리소스 간의 관계를 이해하는 것입니다. 일반적으로 이러한 리소스는 컬렉션과 관계로 조직화되어 있습니다. 예를 들어, Ecommerce 시스템에 대한 빠른 분석을 통해 클라이언트 응용 프로그램이 관심을 가질 가능성이 있는 두 가지 컬렉션, 즉, order(주문)와 customer(고객)가 존재하는 것으로 나타났다고 가정해 봅시다. 각 주문과 고객은 식별을 위해 고유한 키를 가지고 있어야 합니다. 주문 컬렉션에 액세스하기 위한 URl는 */orders*와 같이 간단한 무언가가 될 수 있고, 이와 비슷하게 모든 고객을 검색하기 위한 URI는 */customers*가 될 수 있습니다. */orders*에 대해 HTTP GET 요청을 발행하는 URI는 HTTP 응답으로 인코드된 컬렉션의 모든 주문을 표시하는 목록을 반환해야 합니다. 

```HTTP
GET http://adventure-works.com/orders HTTP/1.1
...
```

아래 표시된 응답은 JSON 목록 구조로 주문을 인코드합니다.

```HTTP
HTTP/1.1 200 OK
...
Date: Fri, 22 Aug 2014 08:49:02 GMT
Content-Length: ...
[{"orderId":1,"orderValue":99.90,"productId":1,"quantity":1},{"orderId":2,"orderValue":10.00,"productId":4,"quantity":2},{"orderId":3,"orderValue":16.60,"productId":2,"quantity":4},{"orderId":4,"orderValue":25.90,"productId":3,"quantity":1},{"orderId":5,"orderValue":99.90,"productId":1,"quantity":1}]
```
개별적인 주문을 가져오려면 *orders* 리소스의 주문에 대한 식별자를 지정해야 합니다(예:*/orders/2*). 

```HTTP
GET http://adventure-works.com/orders/2 HTTP/1.1
...
```

```HTTP
HTTP/1.1 200 OK
...
Date: Fri, 22 Aug 2014 08:49:02 GMT
Content-Length: ...
{"orderId":2,"orderValue":10.00,"productId":4,"quantity":2}
```

> [!참고]
> 단순하게 하기 위해 이러한 예는 JSON 텍스트 데이터로 반환되는 응답의 정보를 보여줍니다. 그러나 리소스에 바이너리 또는 암호화된 정보와 같이 HTTP가 지원하는 다른 형식의 데이터가 포함되지 않아야 할 이유는 전혀 없습니다. HTTP 응답의 콘텐츠 형식이 해당 형식을 지정해야 합니다. 또한 REST 모델은 XML 또는 JSON과 같은 다른 형식의 동일한 데이터를 반환할 수 있습니다. 이러한 경우 웹 서비스는 요청하는 클라이언트와 콘텐츠 협상을 수행해야 합니다. 요청에는 클라이언트가 수신하길 원하고 웹 서비스가 가능하면 적용하려고 시도해야 하는 기본 설정 형식을 지정하는 *Accept(수락)* 헤더가 포함될 수 있습니다.
>
>

REST 요청의 응답은 표준 HTTP 상태 코드를 활용한다는 점을 유념합니다. 예를 들어, 유효한 데이터를 반환하는 요청에는 HTTP 응답 코드 200(OK(확인))이 포함되어야 하지만 지정된 리소스 검색 또는 삭제에 실패한 요청은 HTTP 상태 코드 404(Not Found(찾을 수 없음))가 포함된 응답을 반환해야 합니다. 

## RESTful web API 설계 및 구조
웹 API를 성공적으로 설계하는 데 있어 핵심은 단순도와 일관성입니다. 이러한 두 가지 요소를 나타내는 웹 API는 API를 사용해야 하는 클라이언트 응용 프로그램 구축을 더욱 용이하게 만들어 줍니다.

RESTful web API는 연결된 리소스 세트를 표시하고, 응용 프로그램이 이러한 리소스를 조작하고 리소스 간 쉽게 탐색 가능하도록 지원하는 핵심 작업을 제공하는 데 중점을 둡니다. 이러한 이유로 일반적인 RESTful web API를 구성하는 URI는 URI가 표시하는 데이터를 향해야 하며, 이러한 데이터를 기반으로 작동할 수 있도록 HTTP가 제공하는 시설을 사용해야 합니다. 이러한 접근 방식에는 개체 및 클래스의 동작에 의해 더 많은 동기가 부여되는 경향이 있는 개체 지향 API에서 클래스 세트를 설계할 때 일반적으로 가지는 것과는 다른 마음가짐이 필요합니다. 이와 더불어, RESTful web API는 상태 비저장이어야 하고 특정 시퀀스에 의해 호출되는 작업에 의존해서는 안 됩니다. 다음 섹션에서는 RESTful web API를 설계할 때 고려해야 할 점을 요약해 설명합니다. 

### 리소스 주변에 웹 API 구성
> [!팁]
> REST 웹 서비스가 표시하는 URI는 동사(응용 프로그램이 데이터로 할 수 있는 것)가 아니라 명사(웹 API가 액세스를 제공하는 데이터)에 기반을 두어야 합니다. 
>
>

웹 API가 표시하는 비즈니스 엔티티에 초점을 맞추십시오. 예를 들어, 앞서 설명한 Ecommerce 시스템을 지원하도록 설계된 웹 API에서 기본 엔티티는 고객과 주문입니다. 주문하는 행위와 같은 프로세스는 주문 정보를 가져와 해당 고객에 대한 주문 목록에 주문을 추가하는 HTTP POST 작업을 제공함으로써 실현될 수 있습니다. 내부적으로 이러한 POST 작업은 재고 수준 확인 및 고객에게 청구와 같은 작업을 수행할 수 있습니다. HTTP 응답은 주문이 성공적으로 이루어졌는지 아닌지를 표시할 수 있습니다. 리소스는 단일 실제 데이터 항목에 기반을 둘 필요가 없다는 점을 유념합니다. 예를 들어, 주문 리소스는 관계형 데이터베이스의 테이블 여러 개로 분배되는 많은 행에서 집계된 정보를 사용해 내부적으로 구현될 수 있지만, 클라이언트에 단일 엔티티로 제공될 수도 있습니다.

> [!팁]
> REST 인터페이스가 표시하는 데이터의 내부 구조에 의존하거나 미러링하는 REST 인터페이스는 설계하지 마십시오. REST는 관계형 데이터베이스의 별도 테이블에 단순한 CRUD(Create(생성), Retrieve(검색), Update(업데이트), Delete(삭제) 작업을 구현하는 것 이상을 의미합니다. REST의 목표는 비즈니스 엔티티와 이러한 엔티티에서 응용 프로그램이 수행할 수 있는 작업을 이러한 엔티티의 물리적인 구현에 매핑하는 데 있지만, 클라이언트가 이러한 물리적인 세부 정보에 노출되어서는 안 됩니다. 
>
>

(일부 단일 개체가 존재할 수는 있어도) 개별적인 비즈니스 엔티티가 고립된 상태로 존재하는 경우는 거의 없고 그 대신 컬렉션으로 함께 그룹화되는 경향이 있습니다. REST의 관점에서 볼 때 각각의 엔티티와 각각의 컬렉션이 리소스입니다. RESTful web API에서 각 컬렉션은 웹 서비스 내에 고유한 URI를 보유하고, URI를 통해 컬렉션에 대한 HTTP GET 요청을 수행할 때 해당 컬렉션의 항목 목록을 검색합니다. 각각의 개별적인 항목은 고유한 URI를 보유하고, 응용 프로그램은 해당 항목의 세부 정보를 검색하기 위해 URI를 사용하여 다른 HTTP GET 요청을 제출할 수 있습니다. 계층적인 방법으로 컬렉션과 항목에 대한 URI를 구성해야 합니다. Ecommerce 시스템에서 URI */customers*는 고객의 컬렉션을 나타내고 */customers/5*는 이 컬렉션에서 ID 5를 사용하는 단일 고객의 세부 정보를 검색합니다. 이 접근 방식은 웹 API를 직관적으로 유지하는 데 도움을 줍니다. 

> [!팁]
> URI에서 일관성 있는 명명 규칙을 채택하십시오. 일반적으로 컬렉션을 참조하는 URI에 대해서 복수형 명사를 사용하는 것이 도움이 됩니다. 
>
>

또한, 다양한 형식의 리소스 간 관계와 이러한 연결을 어떻게 표시할 것인지를 고려해야 합니다. 예를 들어, 고객은 0개 이상의 주문을 할 수 있습니다. 이러한 관계를 표시하는 자연스러운 방법은 고객 5에 대한 모든 주문을 검색하기 위해 */customers/5/orders*와 같은 URI를 사용하는 것입니다. 주문 99에 대한 고객을 검색하기 위해 */orders/99/customer*와 같은 URI를 통해 거꾸로 주문에서 특정 고객으로의 연결을 나타내는 것을 고려해 볼 수 있지만, 이 모델은 구현하는 것이 너무 번거로울 수 있습니다. 더 나은 솔루션은 주문이 쿼리될 때 반환되는 HTTP 응답 메시지의 본문에 고객과 같은 연결된 리소스에 대한 탐색 가능 링크를 제공하는 것입니다. 이 메커니즘은 나중에 본 지침의 관련 리소스에 대한 탐색을 사용하는 HATEOAS 접근 방식 사용 섹션에서 보다 자세하게 설명합니다. 

더욱 복잡한 시스템의 경우 훨씬 더 많은 형식의 엔티티가 존재할 수 있고, 고객 1이 한 주문 99에서 제품 목록을 얻기 위해 클라이언트 응용 프로그램이 */customers/1/orders/99/products*와 같은 여러 수준의 관계를 탐색하도록 하는 URI를 제공하는 것이 매력적일 수 있습니다. 그러나 이러한 수준의 복잡성은 유지하기 어려울 수 있고 향후 리소스 간의 관계가 변화하는 경우 유연하지 않습니다. 따라서, 그 보다는 URI를 상대적으로 단순하게 유지하도록 해야 합니다. 응용 프로그램이 일단 리소스를 참조하면 해당 리소스와 관련된 항목을 검색하는 데 이 참조를 사용하는 것이 가능해야 한다는 점을 유념하십시오. 이전 쿼리는 고객 1에 대한 모든 주문을 검색하기 위한 URI */customers/1/orders*로 대체될 수 있고, 그 다음 쿼리는 이 주문의 모든 제품을 검색하기 위한 URI */orders/99/products*로 대체될 수 있습니다(주문 99를 고객 1이 했다고 가정). 

> [!팁]
> *collection/item/collection(컬렉션/항목/컬렉션)* 보다 복잡한 리소스 URI를 요구하지 마십시오. 
>
>

모든 웹 요청은 웹 서버에 부하를 가져오고, 요청 수가 늘어날수록 부하도 커진다는 점을 고려해야 합니다. 많은 수의 작은 리소스를 표시하는 "수다스러운" 웹 API가 되지 않도록 리소스를 정의하려고 시도해야 합니다. 이러한 API에는 요구하는 모든 데이터를 검색하기 위해 여러 개의 요청을 제출하는 클라이언트 응용 프로그램이 필요할 수 있습니다. 데이터를 비정규화하고 관련 정보와 결합해 단일 요청 발행으로 검색 가능한 더 큰 리소스로 만드는 것이 유익할 수 있습니다. 그러나 이러한 접근 방식은 클라이언트가 자주 요구하지 않는 데이터를 가져올 때의 오버헤드와 비교해 균형을 맞추어야 합니다. 큰 개체 검색은 요청 대기 시간을 늘리고, 추가 데이터가 자주 사용되지 않는 경우에는 별 것 아닌 혜택으로 인해 대역폭 비용이 추가로 발생할 수 있습니다. 

웹 API와 기본 데이터 소스의 구조, 형식, 위치 간의 의존성을 추가하지 마십시오. 예를 들어, 데이터가 관계형 데이터베이스에 위치한 경우 웹 API는 리소스 컬렉션으로 각 테이블을 표시할 필요가 없습니다. 웹 API를 데이터베이스의 추상화로 간주하고, 필요한 경우 데이터베이스와 웹 API 간의 매핑 레이어를 추가하십시오. 이러한 방식을 사용하면, 데이터베이스의 설계 또는 구현이 변화하는 경우 (예를 들어, 정규화된 테이블의 컬렉션이 포함되어 있는 관계형 데이터베이스에서 문서 데이터베이스와 같이 비정규화된 NoSQL 저장 시스템으로 이동하는 경우) 클라이언트 응용 프로그램은 이러한 변화에 영향을 받지 않습니다. 

> [!팁]
> 웹 API를 지탱하는 데이터 소스가 데이터 저장소가 될 필요는 없지만, 다른 서비스 또는 기간 업무 응용 프로그램이나 심지어는 조직 내 온프레미스에서 실행하는 레거시 응용 프로그램이 될 수 있습니다. 
>
>

마지막으로 웹 API가 구현하는 모든 작업을 특정 리소스에 매핑하는 것은 가능하지 않습니다. 일부 기능을 호출하고 HTTP 응답 메시지로 결과를 반환하는 HTTP GET 요청을 통해 이러한 *non-resource(비리소스)* 시나리오도 처리할 수 있습니다. 더하기 및 빼기와 같은 단순한 계산기 스타일의 작업을 구현하는 웹 API는 의사 리소스로 이러한 작업을 표시하는 URI를 제공하고 필요한 매개 변수를 지정하는 데 쿼리 문자열을 활용할 수 있습니다. 예를 들어, URI */add?operand1=99&operand2=1*에 대한 GET 요청은 값 100이 포함된 본문과 함께 응답 메시지를 반환할 수 있고, URI */subtract?operand1=50&operand2=20*에 대한 GET 요청은 값 30이 포함된 본문과 함께 응답 메시지를 반환할 수 있습니다. 그러나 이러한 형식의 URI는 조금만 사용하십시오. 

### HTTP 메서드 관점에서 작업 정의
HTTP 프로토콜은 요청에 유의적 의미를 할당하는 수 많은 메서드를 정의합니다. 대부분의 RESTful web API에서 사용하는 공통적인 HTTP 메서드는 다음과 같습니다. :

* **GET**, 지정된 URI에서 리소스 사본을 검색할 때 사용. 응답 메시지의 본문에는 요청 리소스에 대한 세부 정보가 포함되어 있습니다.
* **POST**, 지정된 URI에서 새로운 리소스를 생성할 때 사용. 요청 메시지의 본문은 새로운 리소스에 대한 세부 정보를 제공합니다. POST는 실제로 리소스를 생성하지 않고 작업을 트리거하는 데 사용할 수도 있다는 점을 유념합니다.
* **PUT**, 지정된 URI에서 리소스를 대체하거나 업데이트할 때 사용. 요청 메시지의 본문에서는 수정이 필요한 리소스 및 적용되어야 하는 값을 지정합니다.
* **DELETE**, 지정된 URI에서 리소스를 제거할 때 사용.

> [!참고]
> HTTP 프로토콜은 리소스에 대한 선택적인 업데이트를 요청하는 데 사용되는 PATCH, 리소스 설명을 요청하는 데 사용되는 HEAD, 클라이언트 정보가 서버에서 지원하는 통신 옵션에 관한 정보를 획득하도록 하는 OPTIONS, 클라이언트가 테스트 및 진단 목적으로 사용할 수 있는 정보를 요청하도록 허용하는 TRACE 등 덜 공통적으로 사용되는 메서드도 정의합니다. 
>
>

특정 요청의 영향은 요청이 적용되는 리소스가 컬렉션인지 아니면 개별적인 항목인지에 따라 달라집니다. 다음 표는 Ecommerce 예를 사용해 대부분의 RESTful 구현에서 채택하는 공통적인 규칙을 요약해 보여줍니다. 이러한 모든 요청이 구현되는 것은 아니며, 특정 시나리오에 따라 달라진다는 점을 유념합니다. 

| **리소스** | **POST** | **GET** | **PUT** | **DELETE** |
| --- | --- | --- | --- | --- |
| /customers |새 고객 생성 |모든 고객 검색 |고객 일괄 업데이트(*구현되는 경우*) |모든 고객 제거 |
| /customers/1 |오류 |고객 1에 대한 세부 정보 검색 |존재하는 경우 고객 1 세부 정보 업데이트, 불가능한 경우 오류 반환 |고객 1 제거 |
| /customers/1/orders |고객 1에 대한 새 주문 생성 |고객 1에 대한 모든 주문 검색 |고객 1에 대한 주문 일괄 업데이트(*구현되는 경우*) |고객 1에 대한 모든 주문 제거(*구현되는 경우*) |

GET 및 DELETE 요청의 목적은 상대적으로 간단하지만, POST 및 PUT 요청의 목적과 영향과 관련해 혼란이 있을 수 있습니다. 

POST 요청은 요청 본문에서 제공된 데이터를 사용해 새 리소스를 생성해야 합니다. REST 모델의 경우 POST 요청을 컬렉션인 리소스에 자주 적용합니다. 새로운 리소스가 컬렉션에 추가됩니다. 

> [!참고]
> 일부 기능을 트리거하는 POST 요청을 정의할 수도 있고 (반드시 데이터를 반환하는 것은 아님), 이러한 유형의 요청을 컬렉션에 적용할 수도 있습니다. 예를 들어, POST 요청을 사용해 급료 지불 명세서 처리 서비스에 작업표를 전달하고 응답으로 계산된 세금을 받아볼 수 있습니다. 
>
>

PUT 요청의 목적은 기존 리소스를 수정하는 것입니다. 지정된 리소스가 존재하지 않는 경우 PUT 요청은 오류를 반환할 수 있습니다(일부 경우에는 실제로 리소스를 생성할 수 있습니다.). PUT 요청은 컬렉션에 적용될 수 있지만 (덜 공통적으로 구현됨) (특정 고객 또는 주문과 같은) 개별적인 항목에 적용되는 경우가 가장 많습니다. PUT 요청은 idempotent인 반면에 POST 요청은 그렇지 않다는 점을 유념합니다. 응용 프로그램에서 동일한 PUT 요청을 여러 번 제출하는 경우 결과는 항상 동일하지만 (동일한 리소스가 동일한 값으로 수정됨), 응용 프로그램에서 동일한 POST 요청을 반복하는 경우 결과는 여러 개의 리소스가 생성되는 것입니다. 

> [!참고]
> 엄밀히 말하면, HTTP PUT 요청은 기존 리소스를 요청 본문에 지정된 리소스로 대체합니다. 리소스의 속성 선택을 수정하지만 다른 속성은 변경되지 않은 상태로 두는 것이 목적이라면 이는 HTTP PATCH 요청을 사용해 구현해야 합니다. 그러나 상당수 RESTful RESTful 구현이 이러한 규칙을 완화시켰고 두 가지 상황 모두에서 PUT를 사용합니다. 
>
>

### HTTP 요청 처리
클라이언트 응용 프로그램에 의해 상당수 HTTP 요청에 포함된 데이터와 웹 서버의 해당 응답 메시지는 다양한 형식 (또는 미디어 유형)으로 표시될 수 있습니다. 예를 들어, 고객 또는 주문에 대한 세부 정보를 지정하는 데이터는 XML, JSON 또는 일부 인코드 된 압축 형식으로 제공될 수 있습니다. RESTful web API는 요청을 제출하는 클라이언트 응용 프로그램이 요청하는 다양한 미디어 유형을 지원해야 합니다. 

클라이언트 응용 프로그램이 메시지 본문에서 데이터 반환 요청을 전송하는 경우 요청의 Accept(수락) 헤더에서 처리할 수 있는 미디어 유형을 지정할 수 있습니다. 다음 코드는 고객 1의 세부 정보를 검색하는 HTTP GET 요청 및 결과를 JSON으로 반환하는 요청을 보여줍니다(클라이언트는 반환 데이터 형식을 확인하기 위해 응답에서 데이터 미디어 유형을 검사해야 합니다.). 

```HTTP
GET http://adventure-works.com/orders/2 HTTP/1.1
...
Accept: application/json
...
```

웹 서버가 이 미디어 유형을 지원하는 경우 메시지 본문에 데이터 형식을 지정하는 Content-Type(콘텐츠 유형) 헤더가 포함된 응답으로 회신할 수 있습니다. 

> [!참고]
> 상호 운용성을 최대화하기 위해 Accept(수락) 및 Content-Type(콘텐츠 유형) 헤더에서 참조된 미디어 유형은 일부 사용자 지정 미디어 유형이 아니라 인식된 MIME 유형이어야 합니다. 
>
>

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
{"orderID":2,"productID":4,"quantity":2,"orderValue":10.00}
```

웹 서버가 요청한 미디어 유형을 지원하지 않는 경우 다른 형식으로 데이터를 전송할 수 있습니다. 모든 경우에 Content-Type(콘텐츠 유형) 헤더에서 미디어 유형 (예:*application/json*)을 지정해야 합니다. 응답 메시지를 구문 분석하고 메시지 본문에서 결과를 적절하게 해석하는 것은 클라이언트 응용 프로그램의 책임입니다. 

이 예에서 웹 서버는 성공적으로 요청 데이터를 검색하고 응답 헤더에 상태 코드 200을 다시 전달함으로써 성공을 표시한다는 점을 유념합니다. 일치하는 데이터가 검색되지 않는 경우에는 상태 코드 404(not found(찾을 수 없음))를 대신 반환하고 응답 메시지 본문에 추가 정보를 포함할 수 있습니다. 이 정보 형식은 아래 예에서 확인할 수 있는 것처럼 Content-Type(콘텐츠 유형) 헤더에서 지정합니다. 

```HTTP
GET http://adventure-works.com/orders/222 HTTP/1.1
...
Accept: application/json
...
```

주문 222가 존재하지 않는 경우 응답 메시지는 다음과 같습니다.

```HTTP
HTTP/1.1 404 Not Found
...
Content-Type: application/json; charset=utf-8
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
{"message":"No such order"}
```

응용 프로그램이 리소스 업데이트를 위해 HTTP PUT 요청을 전송하는 경우 리소스의 URI를 지정하고 요청 메시지 본문에 수정할 데이터를 제공합니다. Content-Type(콘텐츠 유형) 헤더를 사용해 이 데이터의 형식도 지정해야 합니다. 텍스트 기반 정보에 대해 사용되는 공통적인 형식은 *application/x-www-form-urlencoded*로 정관사 the와 문자로 구별되는 이름/값 쌍의 세트로 구성됩니다. 다음 예는 주문 1의 정보를 수정하는 HTTP PUT 요청을 보여줍니다. 

```HTTP
PUT http://adventure-works.com/orders/1 HTTP/1.1
...
Content-Type: application/x-www-form-urlencoded
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
ProductID=3&Quantity=5&OrderValue=250
```

성공적으로 수정한 경우 프로세스가 성공적으로 처리되었음을 나타내는 HTTP 204 상태 코드로 응답하는 것이 이상적이지만, 응답 본문에는 추가 정보가 포함되지 않습니다. 응답의 Location(위치) 헤더에는 새롭게 업데이트된 리소스의 URI가 포함됩니다. 

```HTTP
HTTP/1.1 204 No Content
...
Location: http://adventure-works.com/orders/1
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
```

> [!팁]
> HTTP PUT 요청 메시지의 데이터에 날짜 및 시간 정보가 포함되는 경우 웹 서비스가 ISO 8601 표준에 따라 포맷된 날짜 및 시간을 수락하는지 확인하십시오. >
>

업데이트할 리소스가 존재하지 않는 경우 웹 서버는 앞서 설명한 것처럼 Not Found(찾을 수 없음) 응답으로 응답할 수 있습니다. 또는 웹 서버가 실제로 개체 자체를 생성한 경우 상태 코드 HTTP 200(OK(확인)) 또는 HTTP 201(Created(생성됨))을 반환할 수 있고 응답 본문에는 새로운 리소스에 대한 데이터가 포함될 수 있습니다. 요청의 Content-Type(콘텐츠 유형) 헤더가 웹 서버에서 처리할 수 없는 데이터를 지정한 경우 HTTP 상태 코드 415(Unsupported Media Type(지원되지 않는 미디어 유형))로 응답해야 합니다. 

> [!팁]
> 컬렉션에서 여러 개의 리소스를 배치 업데이트할 수 있는 일괄 HTTP PUT 작업 구현을 고려해 보십시오. PUT 요청은 컬렉션의 URI를 지정해야 하고, 요청 본문은 수정할 리소스의 세부 정보를 지정해야 합니다. 이 접근 방식은 수다스러움을 줄이고 성능을 개선하는 데 도움을 줄 수 있습니다. 
>
>

새로운 리소스를 생성하는 HTTP POST 요청의 형식은 PUT 요청의 형식과 유사합니다. 메시지 본문에는 추가할 새로운 리소스의 세부 정보가 포함됩니다. 그러나 일반적으로 URI는 리소스를 추가해야 하는 컬렉션을 지정합니다. 다음 예에서는 새로운 주문을 생성하고 주문을 주문 컬렉션에 추가합니다. 

```HTTP
POST http://adventure-works.com/orders HTTP/1.1
...
Content-Type: application/x-www-form-urlencoded
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
productID=5&quantity=15&orderValue=400
```

요청이 성공적인 경우 웹 서버는 HTTP 상태 코드 201(Created(생성됨))로 응답해야 합니다. Location(위치) 헤더에는 새롭게 생성된 리소스의 URI가 포함되어야 하고 응답 본문에는 새로운 리소스 사본이 포함되어야 합니다. Content-Type(콘텐츠 유형) 헤더가 이 데이터의 형식을 지정합니다. 

```HTTP
HTTP/1.1 201 Created
...
Content-Type: application/json; charset=utf-8
Location: http://adventure-works.com/orders/99
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
{"orderID":99,"productID":5,"quantity":15,"orderValue":400}
```

> [!팁]
> PUT 또는 POST 요청에서 제공한 데이터가 잘못된 경우 웹 서버는 HTTP 상태 코드 400(Bad Request(잘못된 요청))이 포함된 메시지로 응답해야 합니다. 이 메시지의 본문에는 요청 및 예상되는 형식과 관련된 문제에 대한 추가 정보가 포함되거나 더욱 자세한 세부 정보를 제공하는 URL 링크가 포함될 수 있습니다. 
>
>

리소스를 제거하려면 HTTP DELETE 요청이 제거할 리소스의 URI를 제공하기만 하면 됩니다. 다음 예에서는 주문 99 제거를 시도합니다. 

```HTTP
DELETE http://adventure-works.com/orders/99 HTTP/1.1
...
```

삭제 작업이 성공적인 경우 웹 서버는 프로세스가 성공적으로 처리되었음을 나타내는 HTTP 상태 코드 204로 응답해야 하지만, 응답 본문에는 추가 정보가 포함되지 않습니다(이는 성공적인 PUT 작업으로 인해 반환되는 응답과 동일하지만 리소스가 더 이상 존재하지 않기 때문에 Location(위치) 헤더는 없습니다.). 삭제가 비동기적으로 수행된 경우 DELETE 요청이 HTTP 상태 코드 200(OK(확인)) 또는 202(Accepted(수락됨))를 반환할 수 있습니다. 

```HTTP
HTTP/1.1 204 No Content
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
```

리소스가 검색되지 않는 경우 웹 서버는 404(Not Found(찾을 수 없음)) 메시지를 대신 반환해야 합니다. 

> [!팁]
> 컬렉션의 모든 리소스를 삭제해야 하는 경우 응용 프로그램이 해당 컬렉션의 각 리소스를 차례대로 제거하도록 강제하는 것이 아니라 컬렉션의 URI에 대해 HTTP DELETE 요청이 지정될 수 있도록 하십시오. 
>
>

### 데이터 필터링 및 페이지 매기기
URI를 단순하고 직관적으로 유지하도록 노력해야 합니다. 단일 URI를 통해 리소스 컬렉션을 표시하는 것이 이러한 측면에서는 도움이 되지만 정보의 하위 집합만 필요한 경우에도 응용 프로그램에서 대량의 데이터를 가져오도록 합니다. 많은 양의 트래픽을 생성하는 것은 웹 서버의 성능 및 확장성에 영향을 줄 뿐만 아니라 데이터를 요청하는 클라이언트 응용 프로그램의 응답성에도 부정적인 영향을 미칩니다. 

예를 들어, 주문에 해당 주문에 대해 지불된 가격이 포함되어 있는 경우 특정 값을 초과하는 비용의 모든 주문을 검색해야 하는 클라이언트 응용 프로그램은 */orders* URI에서 모든 주문을 검색한 다음 이러한 주문을 로컬에서 필터링해야 합니다. 이러한 프로세스가 매우 비효율적이고 네트워크 대역폭 및 웹 API를 호스팅하는 서버의 처리 능력을 낭비하는 것은 분명합니다. 

*/orders/ordervalue_greater_than_n*와 같은 URI 스키마를 제공하는 것이 하나의 솔루션이 될 수 있습니다. 여기서 *n*은 주문 가격이지만, 제한된 수의 가격을 제외하고 이러한 접근 방식은 실용적이지 않습니다. 또한 다른 조건에 근거해 주문을 쿼리해야 하는 경우 직관적이지 않은 이름이 포함된 긴 URI 목록을 제공하는 것으로 끝날 가능성이 있습니다. 

데이터를 필터링하는 더 나은 전략은 */orders?ordervaluethreshold=n*과 같이 웹 API에 전달하는 쿼리 문자열에 필터링 조건을 제공하는 것입니다. 이 예의 경우 웹 API의 해당 작업이 쿼리 문자열의 `ordervaluethreshold` 매개 변수를 구문 분석 및 처리하고 HTTP 응답에서 필터링 된 결과를 반환할 책임이 있습니다.

컬렉션 리소스에 대한 일부 단순한 HTTP GET 요청이 많은 수의 항목을 반환할 가능성이 있습니다. 이러한 경우가 발생할 가능성을 없애기 위해 단일 요청에 의해 반환되는 데이터의 양을 제한하도록 웹 API를 설계해야 합니다. 사용자가 검색할 항목의 최대수를 지정하도록 하는 쿼리 문자열(이 문자열 자체도 서비스 거부 공격을 방지하는 데 도움을 주기 위한 upperbound 제한의 적용을 받음)을 지원하거나 컬렉션에 대한 오프셋을 시작함으로써 앞서 기술한 것과 같이 웹 API를 설계할 수 있습니다. 예를 들어, URI */orders?limit=25&offset=50*의 쿼리 문자열은 해당 주문 컬렉션에서 검색한 50번째 주문으로 시작하는 25개 주문을 검색해야 합니다. 데이터 필터링과 마찬가지로 웹 API에서 GET 요청을 구현하는 작업이 쿼리 문자열에서  `limit` 및 `offset` 매개 변수를 구문 분석하고 처리할 책임이 있습니다. 클라이언트 응용 프로그램을 지원하기 위해 페이지 매겨진 데이터를 반환하는 GET 요청에는 해당 컬렉션에서 사용 가능한 총 리소스 수를 표시하는 몇 가지 양식의 메타데이터가 포함되어야 합니다. 기타 지능형 페이징 전략을 고려할 수도 있습니다. 자세한 정보는 다음을 참조하십시오.[API 설계 참고: 스마트 페이징](http://bizcoder.com/api-design-notes-smart-paging)

데이터를 가져올 때 데이터 정렬에 대해서도 비슷한 전략을 따를 수 있습니다. */orders?sort=ProductID*와 같은 값으로 필드 이름을 가져오는 정렬 매개 변수를 제공할 수도 있습니다. 그러나 이 접근 방식은 캐싱에 유해한 영향을 미칠 수 있다는 점을 유념해야 합니다(쿼리 문자열 매개 변수는 캐시된 데이터에 대한 키로 많은 캐시 구현에 사용되는 리소스 식별자의 일부를 구성합니다.). 

이러한 접근 방식을 확대해 단일 리소스 항목에 많은 양의 데이터가 포함된 경우 반환되는 필드를 제한(프로젝트)할 수 있습니다. 예를 들어, */orders?fields=ProductID,Quantity*와 같이 쉼표로 분리된 필드 목록을 수락하는 쿼리 문자열 매개 변수를 사용할 수 있습니다. 

> [!팁]
> 쿼리 문자열의 모든 선택적 매개 변수에 의미 있는 기본값을 부여하십시오. 예를 들어, 페이지 매김을 구현하는 경우 `limit` 매개 변수는 10으로, `offset` 매개 변수는 0으로 설정하십시오. 순서 지정을 구현하는 경우 정렬 매개 변수는 리소스의 키로 설정하고 프로젝션을 지원하는 경우 `fields` 매개 변수를 리소스의 모든 필드에 설정하십시오.
>
>

### 큰 바이너리 리소스 처리
단일 리소스에는 파일 또는 이미지와 같은 큰 바이너리 필드가 포함될 수 있습니다. 신뢰할 수 없는 일시적 연결로 인해 야기되는 전송 문제를 해결하고 응답 시간을 개선할 수 있도록, 이러한 리소스가 클라이언트 응용 프로그램에 의해 청크에서 검색되도록 하는 작업을 제공하는 것을 고려해 보십시오. 이를 위해서 웹 API는 큰 리소스에 대한 GET 요청을 위해 Accept-Ranges(범위 수락) 헤더를 지원하고, 이러한 리소스에 대한 HTTP HEAD 요청을 구현하는 것이 이상적입니다. Accept-Ranges(범위 수락) 헤더는 GET 작업이 부분적인 결과를 지원하고, 클라이언트 응용 프로그램이 바이트 범위로 지정된 리소스 하위 집합을 반환하는 GET 요청을 제출할 수 있음을 나타냅니다. HEAD 요청은 리소스와 비어 있는 메시지 본문을 설명하는 헤더만 반환한다는 점을 제외하면 GET 요청과 유사합니다. 클라이언트 응용 프로그램은 부분적인 GET 요청을 사용함으로써 리소스를 가져올지를 결정하기 위한 HEAD 요청을 발행할 수 있습니다. 다음 예는 제품 이미지에 대한 정보를 받는 HEAD 요청을 보여줍니다. 

```HTTP
HEAD http://adventure-works.com/products/10?fields=productImage HTTP/1.1
...
```

응답 메시지에는 리소스 크기(4580바이트)를 포함하는 헤더와 해당 GET 작업이 부분적인 결과를 지원하는 Accept-Ranges(범위 수락) 헤더가 포함되어 있습니다. 

```HTTP
HTTP/1.1 200 OK
...
Accept-Ranges: bytes
Content-Type: image/jpeg
Content-Length: 4580
...
```

클라이언트 응용 프로그램은 이 정보를 사용해 더 작은 청크에서 이미지를 검색하기 위한 일련의 GET 작업을 구성할 수 있습니다. 첫 번째 요청은 Range(범위) 헤더를 사용해 처음 2500바이트를 가져옵니다. 

```HTTP
GET http://adventure-works.com/products/10?fields=productImage HTTP/1.1
Range: bytes=0-2499
...
```

응답 메시지는 HTTP 상태 코드 206을 반환함으로써 부분적인 응답임을 나타냅니다. Content-Length(콘텐츠 길이) 헤더는 메시지 본문에서 반환된 (리소스 크기가 아니라) 실제 바이트 수를 지정하고, Content-Range(콘텐츠 범위) 헤더는 어떤 부분의 리소스가 여기에 해당하는지를 표시합니다(4580 중 0-2499바이트). 

```HTTP
HTTP/1.1 206 Partial Content
...
Accept-Ranges: bytes
Content-Type: image/jpeg
Content-Length: 2500
Content-Range: bytes 0-2499/4580
...
_{binary data not shown}_
```

클라이언트 응용 프로그램의 후속 요청은 적절한 Range(범위) 헤더를 사용해 리소스의 나머지를 검색할 수 있습니다. 

```HTTP
GET http://adventure-works.com/products/10?fields=productImage HTTP/1.1
Range: bytes=2500-
...
```

해당 결과 메시지는 다음과 같습니다. 

```HTTP
HTTP/1.1 206 Partial Content
...
Accept-Ranges: bytes
Content-Type: image/jpeg
Content-Length: 2080
Content-Range: bytes 2500-4580/4580
...
```

## 관련 리소스에 탐색을 적용하기 위한 HATEOAS 접근 방식 사용
REST를 사용하는 기본적인 동기 중 하나는 URI 스키마에 대한 사전 지식 없이 리소스 전체 세트를 탐색할 수 있어야 한다는 것입니다. 각 HTTP GET 요청은 응답에 포함된 하이퍼링크를 통해 요청된 개체와 직접적으로 관련된 리소스를 검색하는 데 필요한 정보를 반환해야 하고, 이러한 리소스 각각에서 사용 가능한 작업을 설명하는 정보도 함께 제공되어야 합니다. 이러한 원칙은 HATEOAS(Hypertext as the Engine of Application State)로 알려져 있습니다. 이 시스템은 실질적으로 유한 상태 컴퓨터이고, 각 요청에 대한 응답에는 하나의 상태에서 다른 상태로 이동하는 데 필요한 정보가 포함되어 있습니다. 그 외 다른 정보는 필요하지 않아야 합니다. 

> [!참고]
> 현재 HATEOAS 원칙을 모델링하는 방법을 정의한 표준이나 사양은 없습니다. 이 섹션에서 제공하는 예를 통해 한 가지 솔루션을 제안합니다. 
>
>

하나의 예로서, 고객과 주문 사이의 관계를 처리하기 위해 특정 주문에 대한 응답으로 반환된 데이터에는 해당 주문을 한 고객을 식별하는 하이퍼링크 양식의 URI와 해당 고객에 대해 수행될 수 있는 작업이 포함되어야 합니다. 

```HTTP
GET http://adventure-works.com/orders/3 HTTP/1.1
Accept: application/json
...
```

응답 메시지 본문에는 관계의 속성(*Customer*)을 지정하는 `links` 배열(코드 예에서 강조 표시되어 있음), 고객의 URI (*http://adventure-works.com/customers/3*), 이 고객의 세부 정보를 검색하는 방법(*GET*), 웹 서버가 이 정보 검색에 대해 지원하는 MIME 유형(*text/xml* 및 *application/json*)이 포함되어 있습니다. 이것이 클라이언트 응용 프로그램이 고객의 세부 정보를 가져오는 데 필요한 모든 정보입니다. 또한 Link(링크) 배열에는 PUT(웹 서버에서 클라이언트가 제공하기를 기대하는 형식과 더불어 고객을 수정할 때 사용) 및 DELETE 등 수행 가능한 다른 작업에 대한 링크도 포함되어 있습니다.

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"orderID":3,"productID":2,"quantity":4,"orderValue":16.60,"links":[(some links omitted){"rel":"customer","href":" http://adventure-works.com/customers/3", "action":"GET","types":["text/xml","application/json"]},{"rel":"
customer","href":" http://adventure-works.com /customers/3", "action":"PUT","types":["application/x-www-form-urlencoded"]},{"rel":"customer","href":" http://adventure-works.com /customers/3","action":"DELETE","types":[]}]}
```

완결성을 위해 Links(링크) 배열에는 검색된 리소스와 관련된 자신을 참조하는 정보도 포함되어야 합니다. 이러한 링크가 이전 예에서는 생략되었지만 다음 코드에서는 강조 표시되어 있습니다. 이러한 링크에서 관계 *self*는 이것이 해당 작업에 의해 반환 중인 리소스에 대한 참조임을 나타내기 위해 사용되었습니다. 

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"orderID":3,"productID":2,"quantity":4,"orderValue":16.60,"links":[{"rel":"self","href":" http://adventure-works.com/orders/3", "action":"GET","types":["text/xml","application/json"]},{"rel":" self","href":" http://adventure-works.com /orders/3", "action":"PUT","types":["application/x-www-form-urlencoded"]},{"rel":"self","href":" http://adventure-works.com /orders/3", "action":"DELETE","types":[]},{"rel":"customer",
"href":" http://adventure-works.com /customers/3", "action":"GET","types":["text/xml","application/json"]},{"rel":" customer" (customer links omitted)}]}
```

이 접근 방식이 효과적으로 구현되기 위해서는 클라이언트 응용 프로그램이 이러한 추가 정보를 검색하고 구문 분석할 준비가 되어 있어야 합니다. 

## RESTful web API 버전 관리
가장 간단한 상황을 제외하면, 웹 API가 정적으로 유지될 가능성은 매우 낮습니다. 비즈니스 요구 사항이 변화하고 새로운 리소스 컬렉션이 추가됨에 따라 리소스 간의 관계가 변화하고, 리소스의 데이터 구조가 수정될 수 있습니다. 새롭거나 다른 요구 사항을 처리하기 위해 웹 API를 업데이트하는 것은 상대적으로 간단한 프로세스이지만, 이러한 변경이 웹 API를 사용하는 클라이언트 응용 프로그램에 미칠 영향을 반드시 고려해야 합니다. 웹 API를 설계 및 구현하는 개발자가 해당 API에 대한 모든 권한을 보유하지만 개발자가 제삼자가 구축하고 원격으로 운영되는 클라이언트 응용 프로그램에 대해서도 동일한 수준의 권한을 보유하는 것은 아닙니다. 기본적으로 새로운 클라이언트 응용 프로그램이 새로운 기능 및 리소스를 이용하는 것을 허용하면서 기존 클라이언트 응용 프로그램이 변경되지 않은 상태로 계속 작동하도록 해야 합니다. 

버전 관리를 통해 웹 API는 웹 API가 표시하는 기능 및 리소스를 표시할 수 있고, 클라이언트 응용 프로그램은 기능 또는 리소스의 특정 버전으로 지정되는 요청을 제출할 수 있습니다. 다음 섹션에서는 다양한 접근 방식을 설명합니다. 각 접근 방식에는 고유의 장점과 단점이 있습니다. 

### 버전 관리 안 함
가장 간단한 접근 방식이며, 일부 내부 API용으로 허용될 수 있습니다. 대대적인 변경은 새로운 리소스 또는 새로운 링크로 나타낼 수 있습니다. 기존 리소스에 콘텐츠를 추가하는 것은 해당 콘텐츠가 추가될 것으로 예상하지 않고 있는 클라이언트 응용 프로그램이 단순하게 무시해버리기 때문에 새로운 변경으로 표시되지 않을 수 있습니다. 

예를 들어, URI *http://adventure-works.com/customers/3*에 대한 요청은 클라이언트 응용 프로그램이 예상하는 `id`, `name` 및 `address` 필드를 포함한 단일 고객의 세부 정보를 반환해야 합니다.

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"id":3,"name":"Contoso LLC","address":"1 Microsoft Way Redmond WA 98053"}
```

> [!참고]
> 단순도 및 명확성을 위해 이 섹션에서 제공되는 응답 예에는 HATEOAS 링크가 포함되어 있지 않습니다. 
>
>

만일 `DateCreated` 필드를 고객 리소스 스키마에 추가하는 경우 응답은 다음과 같습니다. 

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"id":3,"name":"Contoso LLC","dateCreated":"2014-09-04T12:11:38.0376089Z","address":"1 Microsoft Way Redmond WA 98053"}
```

기존 클라이언트 응용 프로그램에 인식할 수 없는 필드를 무시하는 기능이 있다면 기존 클라이언트 응용 프로그램은 계속해서 올바르게 작동하고 이 새로운 필드를 처리하도록 클라이언트 응용 프로그램을 새로 설계할 수 있습니다. 그러나 리소스 스키마에 대한 보다 근본적인 변경이 이루어지거나(예: 필드 제거 또는 이름 바꾸기) 리소스 간의 관계가 변경되는 경우 이러한 변경은 기존 클라이언트 응용 프로그램이 올바르게 작동하지 못하도록 방해하는 새로운 변경을 구성할 수 있습니다. 이러한 경우에는 다음 접근 방식 중 하나를 고려해야 합니다. 

### URI 버전 관리
웹 API를 수정하거나 리소스 스키마를 변경할 때마다 각 리소스에 대한 URI에 버전 번호를 추가합니다. 이전에 존재하는 URI는 이전과 마찬가지로 계속 작동하고, 원래의 스키마를 준수하는 리소스를 반환해야 합니다. 

앞의 예를 확대해 `address` 필드가 주소의 각 구성 요소(예:`streetAddress`, `city`, `state`, `zipCode`)를 포함하는 하위 필드로 재구성되는 경우 이 리소스 버전은 http://adventure-works.com/v2/customers/3과 같은 버전 번호를 포함하는 URI를 통해 표시될 수 있습니다. 

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"id":3,"name":"Contoso LLC","dateCreated":"2014-09-04T12:11:38.0376089Z","address":{"streetAddress":"1 Microsoft Way","city":"Redmond","state":"WA","zipCode":98053}}
```

이 버전 관리 메커니즘은 단순하지만, 요청을 적절한 끝점으로 라우팅하는 서버에 따라 달라집니다. 그러나 웹 API가 여러 번의 반복 횟수를 통해 발달하고 서버가 다양한 버전을 지원해야 함에 따라 번거로울 수 있습니다. 또한, 순수주의자의 관점에서 볼 때 이러한 모든 경우에 클라이언트 응용 프로그램이 동일한 데이터(고객 3)를 가져오므로 URI가 버전에 따라 정말로 다른 것은 아닙니다. 모든 링크가 모든 링크의 URI에 버전 번호를 포함해야 하므로 이 스키마는 HATEOAS 구현을 복잡하게 만듭니다. 

### 쿼리 문자열 버전 관리
여러 개의 URI를 제공하는 것이 아니라 *http://adventure-works.com/customers/3?version=2* 와 같이 HTTP 요청에 추가된 쿼리 문자열 내의 매개 변수를 사용해 리소스 버전을 지정할 수 있습니다. 이 버전 매개 변수는 이전 클라이언트 응용 프로그램에 의해 생략된 경우 1과 같이 의미 있는 값을 기본값으로 가져야 합니다.

이 접근 방식은 동일한 리소스가 항상 동일한 URI에서 검색된다는 유의적 장점을 가지고 있지만 쿼리 문자열을 구문 분석하고 적절한 HTTP 응답으로 다시 전송하기 위한 요청을 처리하는 코드에 따라 달라집니다. 또한, 이 접근 방식은 URI 버전 관리 메커니즘으로 HATEOAS를 구현할 때 나타나는 문제가 동일하게 나타납니다. 

> [!참고]
> 일부 이전 웹 브라우저 및 웹 프록시는 URL에 쿼리 문자열을 포함하는 요청에 대한 응답을 캐시하지 않습니다. 이는 웹 API를 사용하고 이러한 웹 브라우저 내에서 실행되는 웹 응용 프로그램의 성능에 부정적인 영향을 미칠 수 있습니다. 
>
>

### 헤더 버전 관리
쿼리 문자열 매개 변수로 버전 번호를 첨부하는 것이 아니라 리소스의 버전을 표시하는 사용자 지정 헤더를 구현할 수 있습니다. 이 접근 방식을 사용하려면, 버전 헤더가 생략된 경우 클라이언트 요청을 처리하는 코드가 기본값(버전 1)을 사용할 수 있지만, 클라이언트 응용 프로그램은 요청에 적절한 헤더를 추가해야 합니다. 다음 예는 *Custom-Header(사용자 정의 헤더)*라고 이름 붙여진 사용자 헤더를 활용합니다. 사용자 정의 헤더의 값은 웹 API의 버전을 나타냅니다. 

버전 1:

```HTTP
GET http://adventure-works.com/customers/3 HTTP/1.1
...
Custom-Header: api-version=1
...
```

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"id":3,"name":"Contoso LLC","address":"1 Microsoft Way Redmond WA 98053"}
```

버전 2:

```HTTP
GET http://adventure-works.com/customers/3 HTTP/1.1
...
Custom-Header: api-version=2
...
```

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"id":3,"name":"Contoso LLC","dateCreated":"2014-09-04T12:11:38.0376089Z","address":{"streetAddress":"1 Microsoft Way","city":"Redmond","state":"WA","zipCode":98053}}
```

앞서 기술한 두 가지 접근 방식과 마찬가지로 HATEOAS를 구현하려면 적절한 사용자 정의 헤더가 링크에 포함되어야 한다는 점을 유념합니다. 

### 미디어 유형 버전 관리
클라이언트 응용 프로그램이 웹 서버에 HTTP GET 요청을 전송할 때 본 지침에서 앞서 설명한 것처럼 Accept(수락) 헤더를 사용해 처리할 수 있는 콘텐츠의 형식을 명기해야 합니다. *Accept(수락)* 헤더의 일반적인 목적은 응답의 본문이 XML, JSON 또는 클라이언트가 구문 분석할 수 있는 기타 공통적인 형식인지 클라이언트 응용 프로그램이 지정하도록 허용하는 데 있습니다. 그러나 클라이언트 응용 프로그램이 예상하는 리소스 버전이 무엇인지를 표시하도록 하는 정보를 포함한 사용자 정의 미디어 유형을 정의하는 것도 가능합니다. 다음 예는 값 *application/vnd.adventure-works.v1+json*으로 *Accept(수락)* 헤더를 지정하는 요청을 보여줍니다. *vnd.adventure-works.v1* 요소는 웹 서버가 리소스 버전 1을 반환해야 함을 웹 서버에 표시하고, *json* 요소는 응답 본문의 형식이 JSON이 되어야 함을 지정합니다.

```HTTP
GET http://adventure-works.com/customers/3 HTTP/1.1
...
Accept: application/vnd.adventure-works.v1+json
...
```

요청을 처리하는 코드는 *Accept(수락)* 헤더를 처리하고 가능한 한 적용해야 할 책임이 있습니다(클라이언트 응용 프로그램은 *Accept(수락)* 헤더에서 여러 개의 형식을 지정할 수 있으며, 이러한 경우 웹 서버가 응답 본문에 대해 가장 적절한 형식을 선택할 수 있습니다.). 웹 서버는 Content-Type(콘텐츠 유형) 헤더를 사용해 응답 본문에서 데이터 형식을 확인합니다. 

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/vnd.adventure-works.v1+json; charset=utf-8
...
Content-Length: ...
{"id":3,"name":"Contoso LLC","address":"1 Microsoft Way Redmond WA 98053"}
```

Accept(수락) 헤더가 알려진 미디어 유형을 지정하지 않는 경우 웹 서버는 HTTP 406(Not Acceptable(허용되지 않음)) 응답 메시지를 생성하거나 기본 미디어 유형으로 메시지를 반환할 수 있습니다. 

논란의 여지가 있기는 하지만 이 접근 방식은 버전 관리 메커니즘 중에서 가장 간단하며, 자연스럽게 리소스 링크에 관련 데이터의 MIME 유형을 포함시킬 수 있는 HATEOAS에 적합합니다. 

> [!참고]
> 버전 관리 전략을 선택할 때 특히 웹 서버에서의 캐싱을 포함해 성능에 미치는 영향을 고려해야 합니다. URI 버전 관리 및 쿼리 문자열 버전 관리 스키마는 동일한 URI/쿼리 문자열 조합이 매번 동일한 데이터를 참조하는 한 캐시 친화적입니다. 
>
> 헤더 버전 관리 및 미디어 유형 버전 관리 메커니즘에는 일반적으로 Custom(사용자 정의) 헤더 또는 Accept(수락) 헤더에서 값을 검사하기 위한 추가 로직이 필요합니다. 대규모 환경에서 다양한 버전의 웹 API를 사용하는 많은 클라이언트는 서버 쪽 캐시에서 상당한 양의 중복된 데이터를 생성할 수 있습니다. 클라이언트 응용 프로그램이 캐싱을 구현하는 프록시를 통해 웹 서버와 통신하는 경우 이 문제는 심각해질 수 있고, 캐시에 요청된 데이터 사본을 현재 보유하고 있지 않은 경우에는 웹 서버로만 요청을 전달합니다. 
>
>

## 자세한 정보
* [RESTful 쿡북](http://restcookbook.com/)에는 RESTful API 구축에 대한 소개가 포함되어 있습니다.
* 웹 [API 체크리스트](https://mathieu.fenniak.net/the-api-checklist/)에는 웹 API를 설계 및 구현할 때 고려해야 할 유용한 항목 리스트가 포함되어 있습니다.
