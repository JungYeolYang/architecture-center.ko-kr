---
title: 클라우드 응용 프로그램에 대한 성능 안티패턴
description: 확장성 문제를 일으킬 가능성이 있는 일반적인 사례입니다.
author: dragon119
ms.date: 06/05/2017
ms.openlocfilehash: 423fe6533e57268610f625f523714cd1bce89546
ms.sourcegitcommit: b0482d49aab0526be386837702e7724c61232c60
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/14/2017
ms.locfileid: "24851508"
---
# <a name="performance-antipatterns-for-cloud-applications"></a><span data-ttu-id="64657-103">클라우드 응용 프로그램에 대한 성능 안티패턴</span><span class="sxs-lookup"><span data-stu-id="64657-103">Performance antipatterns for cloud applications</span></span>

<span data-ttu-id="64657-104">*성능 안티패턴*은 응용 프로그램이 압력을 받고 있을 때 확장성 문제를 일으킬 가능성이 있는 일반적인 사례입니다.</span><span class="sxs-lookup"><span data-stu-id="64657-104">A *performance antipattern* is a common practice that is likely to cause scalability problems when an application is under pressure.</span></span> 

<span data-ttu-id="64657-105">일반적인 시나리오는 다음과 같습니다. 응용 프로그램이 성능 테스트 중에 잘 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="64657-105">Here is a common scenario: An application behaves well during performance testing.</span></span> <span data-ttu-id="64657-106">그래서 프로덕션에 릴리스되고 실제 워크로드를 처리하기 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="64657-106">It's released to production, and begins to handle real workloads.</span></span> <span data-ttu-id="64657-107">이 시점에 성능이 저하되기 시작하여 &mdash; 사용자 요청 거부, 지연 또는 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="64657-107">At that point, it starts to perform poorly &mdash; rejecting user requests, stalling, or throwing exceptions.</span></span> <span data-ttu-id="64657-108">이때 개발 팀은 다음 두 가지 질문에 직면합니다.</span><span class="sxs-lookup"><span data-stu-id="64657-108">The development team is then faced with two questions:</span></span>

- <span data-ttu-id="64657-109">테스트하는 동안 이 동작이 나타나지 않은 이유는 무엇입니까?</span><span class="sxs-lookup"><span data-stu-id="64657-109">Why didn't this behavior show up during testing?</span></span>
- <span data-ttu-id="64657-110">이 문제를 어떻게 해결합니까?</span><span class="sxs-lookup"><span data-stu-id="64657-110">How do we fix it?</span></span>

<span data-ttu-id="64657-111">첫 번째 질문에 대한 답은 간단합니다.</span><span class="sxs-lookup"><span data-stu-id="64657-111">The answer to the first question is straightforward.</span></span> <span data-ttu-id="64657-112">테스트 환경에서 실제 사용자, 해당 사용자의 행동 패턴 및 사용자가 수행할 수 있는 작업의 양을 시뮬레이션하기는 매우 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="64657-112">It's very difficult in a test environment to simulate real users, their behavior patterns, and the volumes of work they might perform.</span></span> <span data-ttu-id="64657-113">시스템이 부하를 받을 때 동작하는 방법을 완전하게 확실히 이해하는 유일한 방법은 프로덕션 중에 관찰하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="64657-113">The only completely sure way to understand how a system behaves under load is to observe it in production.</span></span> <span data-ttu-id="64657-114">확실히 말할 수 있는 것은 성능 테스트를 건너뛰지 말라는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="64657-114">To be clear, we aren't suggesting that you should skip performance testing.</span></span> <span data-ttu-id="64657-115">성능 테스트는 기준선 성능 메트릭을 얻기 위해 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="64657-115">Performance tests are crucial for getting baseline performance metrics.</span></span> <span data-ttu-id="64657-116">그러나 성능 문제가 작동 중인 시스템에서 발생하는 경우 관찰하고 해결할 수 있도록 준비해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="64657-116">But you must be prepared to observe and correct performance issues when they arise in the live system.</span></span>

<span data-ttu-id="64657-117">두 번째 질문, 문제를 해결하는 방법에 대한 답은 그리 간단치 않습니다.</span><span class="sxs-lookup"><span data-stu-id="64657-117">The answer to the second question, how to fix the problem, is less straightforward.</span></span> <span data-ttu-id="64657-118">수많은 요인이 기여할 수 있으며 경우에 따라 문제가 특정 상황에서만 명확히 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="64657-118">Any number of factors might contribute, and sometimes the problem only manifests under certain circumstances.</span></span> <span data-ttu-id="64657-119">계측 및 로깅은 근본 원인을 찾는 열쇠이지만 찾고 있는 내용이 무엇인지 알고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="64657-119">Instrumentation and logging are key to finding the root cause, but you also have to know what to look for.</span></span> 

<span data-ttu-id="64657-120">Microsoft Azure 고객의 참여를 바탕으로 고객이 프로덕션 중에 보게 되는 가장 일반적인 성능 문제를 식별했습니다.</span><span class="sxs-lookup"><span data-stu-id="64657-120">Based on our engagements with Microsoft Azure customers, we've identified some of the most common performance issues that customers see in production.</span></span> <span data-ttu-id="64657-121">각 안티패턴에 대해 안티패턴이 일반적으로 발생하는 이유, 안티패턴의 증상 및 문제를 해결하는 기술을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="64657-121">For each antipattern, we describe why the antipattern typically occurs, symptoms of the antipattern, and techniques for resolving the problem.</span></span> <span data-ttu-id="64657-122">또한 안티패턴과 권장 솔루션을 보여 주는 샘플 코드도 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="64657-122">We also provide sample code that illustrates both the antipattern and a suggested solution.</span></span> 

<span data-ttu-id="64657-123">이러한 안티패턴 중 일부는 설명을 읽을 때에는 명백해 보일 수 있지만 생각보다 더 자주 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="64657-123">Some of these antipatterns may seem obvious when you read the descriptions, but they occur more often than you might think.</span></span> <span data-ttu-id="64657-124">경우에 따라 응용 프로그램이 온-프레미스로 작동하는 디자인을 상속하지만 클라우드에서 크기 조정이 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="64657-124">Sometimes an application inherits a design that worked on-premises, but doesn't scale in the cloud.</span></span> <span data-ttu-id="64657-125">또는 응용 프로그램이 아주 간결한 디자인으로 시작할 수 있지만 새 기능이 추가되는 경우 이러한 안티패턴 중 하나 이상이 도사리고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64657-125">Or an application might start with a very clean design, but as new features are added, one or more of these antipatterns creeps in.</span></span> <span data-ttu-id="64657-126">그런데도 이 가이드는 이러한 안티패턴을 식별하고 해결하는 데 도움이 될 것입니다.</span><span class="sxs-lookup"><span data-stu-id="64657-126">Regardless, this guide will help you to identify and fix these antipatterns.</span></span>

<span data-ttu-id="64657-127">다음은 식별된 안티패턴의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="64657-127">Here is the list of the antipatterns that we've identified:</span></span> 

| <span data-ttu-id="64657-128">안티패턴</span><span class="sxs-lookup"><span data-stu-id="64657-128">Antipattern</span></span> | <span data-ttu-id="64657-129">설명</span><span class="sxs-lookup"><span data-stu-id="64657-129">Description</span></span> |
|-------------|-------------|
| <span data-ttu-id="64657-130">[사용량이 많은 데이터베이스][BusyDatabase]</span><span class="sxs-lookup"><span data-stu-id="64657-130">[Busy Database][BusyDatabase]</span></span> | <span data-ttu-id="64657-131">너무 많은 처리가 데이터 저장소에서 오프로드로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="64657-131">Offloading too much processing to a data store.</span></span> |
| <span data-ttu-id="64657-132">[사용량이 많은 프런트 엔드][BusyFrontEnd]</span><span class="sxs-lookup"><span data-stu-id="64657-132">[Busy Front End][BusyFrontEnd]</span></span> | <span data-ttu-id="64657-133">리소스를 많이 사용하는 작업을 백그라운드로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="64657-133">Moving resource-intensive tasks onto background threads.</span></span> |
| <span data-ttu-id="64657-134">[번잡한 I/O][ChattyIO]</span><span class="sxs-lookup"><span data-stu-id="64657-134">[Chatty I/O][ChattyIO]</span></span> | <span data-ttu-id="64657-135">계속해서 많은 작은 네트워크 요청을 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="64657-135">Continually sending many small network requests.</span></span> |
| <span data-ttu-id="64657-136">[불필요한 가져오기][ExtraneousFetching]</span><span class="sxs-lookup"><span data-stu-id="64657-136">[Extraneous Fetching][ExtraneousFetching]</span></span> | <span data-ttu-id="64657-137">필요한 것보다 더 많은 데이터를 검색하면 불필요한 I/O 처리가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="64657-137">Retrieving more data than is needed, resulting in unnecessary I/O.</span></span> |
| <span data-ttu-id="64657-138">[부적절한 인스턴스화][ImproperInstantiation]</span><span class="sxs-lookup"><span data-stu-id="64657-138">[Improper Instantiation][ImproperInstantiation]</span></span> | <span data-ttu-id="64657-139">공유 및 다시 사용하도록 설계된 개체를 반복적으로 만들고 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="64657-139">Repeatedly creating and destroying objects that are designed to be shared and reused.</span></span> |
| <span data-ttu-id="64657-140">[모놀리식 지속성][MonolithicPersistence]</span><span class="sxs-lookup"><span data-stu-id="64657-140">[Monolithic Persistence][MonolithicPersistence]</span></span> | <span data-ttu-id="64657-141">매우 다른 사용량 패턴을 가진 데이터에 동일한 데이터 저장소를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="64657-141">Using the same data store for data with very different usage patterns.</span></span> |
| <span data-ttu-id="64657-142">[캐싱 없음][NoCaching]</span><span class="sxs-lookup"><span data-stu-id="64657-142">[No Caching][NoCaching]</span></span> | <span data-ttu-id="64657-143">데이터를 캐시하지 못합니다.</span><span class="sxs-lookup"><span data-stu-id="64657-143">Failing to cache data.</span></span> |
| <span data-ttu-id="64657-144">[동기 I/O][SynchronousIO]</span><span class="sxs-lookup"><span data-stu-id="64657-144">[Synchronous I/O][SynchronousIO]</span></span> | <span data-ttu-id="64657-145">I/O가 완료하는 동안 호출 스레드를 차단합니다.</span><span class="sxs-lookup"><span data-stu-id="64657-145">Blocking the calling thread while I/O completes.</span></span> | 

[BusyDatabase]: ./busy-database/index.md
[BusyFrontEnd]: ./busy-front-end/index.md
[ChattyIO]: ./chatty-io/index.md
[ExtraneousFetching]: ./extraneous-fetching/index.md
[ImproperInstantiation]: ./improper-instantiation/index.md
[MonolithicPersistence]: ./monolithic-persistence/index.md
[NoCaching]: ./no-caching/index.md
[SynchronousIO]: ./synchronous-io/index.md