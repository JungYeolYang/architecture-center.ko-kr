---
title: 관계형 데이터
description: ''
author: zoinerTejada
ms.date: 02/12/2018
ms.topic: guide
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.openlocfilehash: d68bddcb75e5c8f786a7739e85de2645a2c3d641
ms.sourcegitcommit: 1b50810208354577b00e89e5c031b774b02736e2
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/23/2019
ms.locfileid: "54484937"
---
# <a name="traditional-relational-database-solutions"></a><span data-ttu-id="3e5e2-102">기존 관계형 데이터베이스 솔루션</span><span class="sxs-lookup"><span data-stu-id="3e5e2-102">Traditional relational database solutions</span></span>

<span data-ttu-id="3e5e2-103">관계형 데이터는 관계형 모델을 사용하여 모델링되는 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-103">Relational data is data modeled using the relational model.</span></span> <span data-ttu-id="3e5e2-104">이 모델에서 데이터는 튜플으로 표현됩니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-104">In this model, data is expressed as tuples.</span></span> <span data-ttu-id="3e5e2-105">*튜플*은 특성/값 쌍의 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-105">A *tuple* is a set of attribute/value pairs.</span></span> <span data-ttu-id="3e5e2-106">예를 들어, 튜플은 (itemid = 5, orderid = 1, item = "Chair", amount = 200.00)일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-106">For example, a tuple might be (itemid = 5, orderid = 1, item = "Chair", amount = 200.00).</span></span> <span data-ttu-id="3e5e2-107">모두 동일한 특성을 공유하는 튜플 집합을 *관계*라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-107">A set of tuples that all share the same attributes is called a *relation*.</span></span>

<span data-ttu-id="3e5e2-108">관계는 기본적으로 테이블로 표시됩니다. 이 경우 각 튜플은 테이블의 행으로 노출됩니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-108">Relations are naturally represented as tables, where each tuple is exposed as a row in the table.</span></span> <span data-ttu-id="3e5e2-109">그러나 행은 튜플과 달리 명시적 순서를 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-109">However, rows have an explicit ordering, unlike tuples.</span></span> <span data-ttu-id="3e5e2-110">데이터베이스 스키마는 각 테이블의 열(머리글)을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-110">The database schema defines the columns (headings) of each table.</span></span> <span data-ttu-id="3e5e2-111">각 열은 테이블의 모든 행에서 해당 열에 저장된 모든 값의 이름 및 데이터 형식으로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-111">Each column is defined with a name and a data type for all values stored in that column across all rows in the table.</span></span>

![관계형 데이터베이스를 사용하는 데이터를 보여 주는 예제](../images/example-relational.png)

<span data-ttu-id="3e5e2-113">관계형 모델을 사용하여 데이터를 구성하는 데이터 저장소를 관계형 데이터베이스라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-113">A data store that organizes data using the relational model is referred to as a relational database.</span></span> <span data-ttu-id="3e5e2-114">기본 키는 테이블 내에서 행을 고유하게 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-114">Primary keys uniquely identify rows within a table.</span></span> <span data-ttu-id="3e5e2-115">외래 키 필드는 한 테이블에서 다른 테이블의 기본 키를 참조하여 다른 테이블의 행을 참조하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-115">Foreign key fields are used in one table to refer to a row in another table by referencing the primary key of the other table.</span></span> <span data-ttu-id="3e5e2-116">외래 키는 참조 무결성을 유지하여, 참조하는 행이 참조된 행에 의존하는 동안 참조된 행이 변경 또는 삭제되지 않도록 하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-116">Foreign keys are used to maintain referential integrity, ensuring that the referenced rows are not altered or deleted while the referencing row depends on them.</span></span>

![관계형 데이터베이스를 사용하는 데이터를 보여 주는 예제](../images/example-relational2.png)

<span data-ttu-id="3e5e2-118">관계형 데이터베이스는 데이터 무결성을 보장하는 데 도움이 되는 다양한 유형의 제약 조건을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-118">Relational databases support various types of constraints that help to ensure data integrity:</span></span>

- <span data-ttu-id="3e5e2-119">UNIQUE 제약 조건은 열의 모든 값이 고유하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-119">Unique constraints ensure that all values in a column are unique.</span></span>

- <span data-ttu-id="3e5e2-120">FOREIGN KEY 제약 조건은 두 테이블의 데이터 간에 연결을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-120">Foreign key constraints enforce a link between the data in two tables.</span></span> <span data-ttu-id="3e5e2-121">외래 키는 기본 키 또는 다른 테이블에서 다른 고유 키를 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-121">A foreign key references the primary key or another unique key from another table.</span></span> <span data-ttu-id="3e5e2-122">FOREIGN KEY 제약 조건은 참조 무결성을 적용하여 외래 키 값을 유효하지 않게 하는 변경을 허용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-122">A foreign key constraint enforces referential integrity, disallowing changes that cause invalid foreign key values.</span></span>

- <span data-ttu-id="3e5e2-123">엔터티 무결성 제약 조건이라고도 하는 CHECK 제약 조건은 단일 열 내에 저장할 수 있거나 같은 행의 다른 열에 있는 값과의 관계에 따라 저장될 수 있는 값을 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-123">Check constraints, also known as entity integrity constraints, limit the values that can be stored within a single column, or in relationship to values in other columns of the same row.</span></span>

<span data-ttu-id="3e5e2-124">대부분의 관계형 데이터베이스는 쿼리에 대한 선언적 접근 방식을 허용하는 SQL(구조적 쿼리 언어) 언어를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-124">Most relational databases use the Structured Query Language (SQL) language that enables a declarative approach to querying.</span></span> <span data-ttu-id="3e5e2-125">쿼리는 원하는 결과를 설명하지만 쿼리를 실행하는 단계는 설명하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-125">The query describes the desired result, but not the steps to execute the query.</span></span> <span data-ttu-id="3e5e2-126">그러면 엔진은 쿼리를 실행하는 가장 좋은 방법을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-126">The engine then decides the best way to execute the query.</span></span> <span data-ttu-id="3e5e2-127">이 방법은 쿼리 프로그램이 처리 단계를 명시적으로 지정하는 절차적 방법과는 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-127">This differs from a procedural approach, where the query program specifies the processing steps explicitly.</span></span> <span data-ttu-id="3e5e2-128">그러나 관계형 데이터베이스는 실행 가능한 코드 루틴을 선언적 및 절차적 접근 방식을 혼합할 수 있는 저장 프로시저 및 함수 형태로 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-128">However, relational databases can store executable code routines in the form of stored procedures and functions, which enables a mixture of declarative and procedural approaches.</span></span>

<span data-ttu-id="3e5e2-129">쿼리 성능 향상을 위해 관계형 데이터베이스는 *인덱스*를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-129">To improve query performance, relational databases use *indexes*.</span></span> <span data-ttu-id="3e5e2-130">기본 키로 사용되는 기본 인덱스는 디스크에 배치되는 데이터의 순서를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-130">Primary indexes, which are used by the primary key, define the order of the data as it sits on disk.</span></span> <span data-ttu-id="3e5e2-131">보조 인덱스는 디스크의 전체 데이터를 다시 정렬하지 않고도, 원하는 행을 효율적으로 쿼리할 수 있도록 대체 필드 조합을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-131">Secondary indexes provide an alternative combination of fields, so the desired rows can be queried efficiently, without having to re-sort the entire data on disk.</span></span>

<span data-ttu-id="3e5e2-132">관계형 데이터베이스는 참조 무결성을 적용하기 때문에 관계형 데이터베이스 크기를 조정하는 것은 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-132">Because relational databases enforce referential integrity, scaling a relational database can become challenging.</span></span> <span data-ttu-id="3e5e2-133">쿼리 또는 삽입 작업이 임의 개수의 테이블을 조작할 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-133">That's because any query or insert operation might touch any number of tables.</span></span> <span data-ttu-id="3e5e2-134">데이터를 *분할*하여 관계형 데이터베이스를 스케일 아웃할 수 있지만 이를 위해 스키마를 신중히 디자인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-134">You can scale out a relational database by *sharding* the data, but this requires careful design of the schema.</span></span> <span data-ttu-id="3e5e2-135">자세한 내용은 [분할 패턴](../../patterns/sharding.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-135">For more information, see the [Sharding pattern](../../patterns/sharding.md).</span></span>

<span data-ttu-id="3e5e2-136">데이터가 관계형이 아니거나, 관계형 데이터베이스에 적합하지 않은 요구를 갖는 경우 [비관계형 또는 NoSQL](../big-data/non-relational-data.md) 데이터 저장소를 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="3e5e2-136">If data is non-relational or has requirements that are not suited to a relational database, consider a [Non-relational or NoSQL](../big-data/non-relational-data.md) data store.</span></span>
