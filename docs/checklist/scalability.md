---
title: 확장성 검사 목록
titleSuffix: Azure Design Review Framework
description: Azure 자동 크기 조정에 대한 디자인 고려 사항을 제공하는 확장성 검사 목록 지침
author: dragon119
ms.date: 01/10/2018
ms.custom: checklist
ms.openlocfilehash: 8bb31e8176238fb32bdf4424aa733b812b5eeb68
ms.sourcegitcommit: 4ba3304eebaa8c493c3e5307bdd9d723cd90b655
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 12/12/2018
ms.locfileid: "53307149"
---
# <a name="scalability-checklist"></a><span data-ttu-id="3fd86-103">확장성 검사 목록</span><span class="sxs-lookup"><span data-stu-id="3fd86-103">Scalability checklist</span></span>

<span data-ttu-id="3fd86-104">확장성은 증가된 부하를 처리하는 시스템의 기능이며 [소프트웨어 품질의 핵심 요소](../guide/pillars.md) 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-104">Scalability is the ability of a system to handle increased load, and is one of the [pillars of software quality](../guide/pillars.md).</span></span> <span data-ttu-id="3fd86-105">이 검사 목록을 사용하여 확장성의 관점에서 응용 프로그램 아키텍처를 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-105">Use this checklist to review your application architecture from a scalability standpoint.</span></span>

## <a name="application-design"></a><span data-ttu-id="3fd86-106">응용 프로그램 설계</span><span class="sxs-lookup"><span data-stu-id="3fd86-106">Application design</span></span>

<span data-ttu-id="3fd86-107">**워크로드 분할**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-107">**Partition the workload**.</span></span> <span data-ttu-id="3fd86-108">프로세스의 각 부분을 불연속 및 분해되도록 디자인합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-108">Design parts of the process to be discrete and decomposable.</span></span> <span data-ttu-id="3fd86-109">관심 분야의 분리에 대한 일반적인 규칙 및 단일 책임 원칙을 따르면서 각 부분의 크기를 최소화합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-109">Minimize the size of each part, while following the usual rules for separation of concerns and the single responsibility principle.</span></span> <span data-ttu-id="3fd86-110">이렇게 하면 각 계산 단위(예: 역할 또는 데이터베이스 서버)의 사용을 극대화하는 방식으로 구성 요소 부분을 분산시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-110">This allows the component parts to be distributed in a way that maximizes use of each compute unit (such as a role or database server).</span></span> <span data-ttu-id="3fd86-111">특정 리소스의 인스턴스를 추가하여 응용 프로그램을 보다 쉽게 확장할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-111">It also makes it easier to scale the application by adding instances of specific resources.</span></span> <span data-ttu-id="3fd86-112">복합 도메인의 경우 [마이크로 서비스 아키텍처](..//guide/architecture-styles/microservices.md)를 도입하는 방안을 고려해 봅니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-112">For complex domains, consider adopting a [microservices architecture](..//guide/architecture-styles/microservices.md).</span></span>

<span data-ttu-id="3fd86-113">**크기 조정을 고려한 디자인**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-113">**Design for scaling**.</span></span> <span data-ttu-id="3fd86-114">크기 조정을 사용하면 응용 프로그램에서 사용하는 역할, 큐 및 기타 서비스의 인스턴스 수를 늘리거나 줄여 가변 부하에 대응할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-114">Scaling allows applications to react to variable load by increasing and decreasing the number of instances of roles, queues, and other services they use.</span></span> <span data-ttu-id="3fd86-115">그러나 이 점을 염두에 두고 응용 프로그램을 디자인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-115">However, the application must be designed with this in mind.</span></span> <span data-ttu-id="3fd86-116">예를 들어 응용 프로그램과 응용 프로그램에서 사용하는 서비스는 요청이 모든 인스턴스로 라우팅되도록 상태를 저장하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-116">For example, the application and the services it uses must be stateless, to allow requests to be routed to any instance.</span></span> <span data-ttu-id="3fd86-117">또한 이렇게 하면 특정 인스턴스의 추가 또는 제거가 현재 사용자에게 부정적인 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-117">This also prevents the addition or removal of specific instances from adversely impacting current users.</span></span> <span data-ttu-id="3fd86-118">또한 인스턴스가 추가 및 제거될 때 응용 프로그램의 코드가 필요한 라우팅을 수행할 수 있도록 인스턴스의 구성 또는 자동 검색을 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-118">You should also implement configuration or auto-detection of instances as they are added and removed, so that code in the application can perform the necessary routing.</span></span> <span data-ttu-id="3fd86-119">예를 들어 웹 응용 프로그램은 라운드 로빈 방식으로 큐 집합을 사용하여 작업자 역할에서 실행되는 백그라운드 서비스로 요청을 라우팅할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-119">For example, a web application might use a set of queues in a round-robin approach to route requests to background services running in worker roles.</span></span> <span data-ttu-id="3fd86-120">성공적으로 요청을 라우팅하고 응용 프로그램의 부하를 분산시키기 위해서는 웹 응용 프로그램에서 큐 수 변경을 검색할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-120">The web application must be able to detect changes in the number of queues, to successfully route requests and balance the load on the application.</span></span>

<span data-ttu-id="3fd86-121">**단위로 크기 조정**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-121">**Scale as a unit**.</span></span> <span data-ttu-id="3fd86-122">규모 증가에 맞게 리소스를 추가할 계획을 수립합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-122">Plan for additional resources to accommodate growth.</span></span> <span data-ttu-id="3fd86-123">각 리소스에 대해 크기 조정 상한을 알고 이러한 한도를 초과하려면 분할 또는 분해를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-123">For each resource, know the upper scaling limits, and use sharding or decomposition to go beyond these limits.</span></span> <span data-ttu-id="3fd86-124">잘 정의된 리소스 집합을 기준으로 시스템에 대한 배율 단위를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-124">Determine the scale units for the system in terms of well-defined sets of resources.</span></span> <span data-ttu-id="3fd86-125">이렇게 하면 규모 확장 작업을 보다 쉽게 적용할 수 있으며, 전체 시스템의 일부분에서 리소스 부족으로 인해 응용 프로그램이 부정적인 영향을 받을 가능성이 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-125">This makes applying scale-out operations easier, and less prone to negative impact on the application through limitations imposed by lack of resources in some part of the overall system.</span></span> <span data-ttu-id="3fd86-126">예를 들어 x개의 웹 및 작업자 역할을 추가하려면 역할에서 생성되는 추가 워크로드를 처리하기 위해 y개의 추가 쿼리 및 z개의 저장소 계정이 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-126">For example, adding x number of web and worker roles might require y number of additional queues and z number of storage accounts to handle the additional workload generated by the roles.</span></span> <span data-ttu-id="3fd86-127">따라서 배율 단위는 x개의 웹 및 작업자 역할, *y*개의 큐 및 *z*개의 저장소 계정으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-127">So a scale unit could consist of x web and worker roles, *y* queues, and *z* storage accounts.</span></span> <span data-ttu-id="3fd86-128">하나 이상의 배율 단위를 추가하여 쉽게 확장할 수 있도록 응용 프로그램을 디자인하세요.</span><span class="sxs-lookup"><span data-stu-id="3fd86-128">Design the application so that it's easily scaled by adding one or more scale units.</span></span>

<span data-ttu-id="3fd86-129">**클라이언트 선호도 방지**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-129">**Avoid client affinity**.</span></span> <span data-ttu-id="3fd86-130">가능한 경우, 응용 프로그램에서 선호도를 요구하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-130">Where possible, ensure that the application does not require affinity.</span></span> <span data-ttu-id="3fd86-131">이에 따라 요청이 모든 인스턴스로 라우팅될 수 있고 인스턴스 수는 관련이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-131">Requests can thus be routed to any instance, and the number of instances is irrelevant.</span></span> <span data-ttu-id="3fd86-132">이는 각 사용자의 상태 정보에 대한 저장, 검색 및 유지 관리 오버헤드도 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-132">This also avoids the overhead of storing, retrieving, and maintaining state information for each user.</span></span>

<span data-ttu-id="3fd86-133">**플랫폼 자동 크기 조정 기능 활용**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-133">**Take advantage of platform autoscaling features**.</span></span> <span data-ttu-id="3fd86-134">호스팅 플랫폼이 Azure 자동 크기 조정과 같은 자동 크기 조정 기능을 지원하는 경우 기본 제공 메커니즘이 요구 사항을 이행할 수 없는 경우가 아니라면 사용자 지정 또는 타사 메커니즘으로 기본 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-134">Where the hosting platform supports an autoscaling capability, such as Azure Autoscale, prefer it to custom or third-party mechanisms unless the built-in mechanism can't fulfill your requirements.</span></span> <span data-ttu-id="3fd86-135">가능한 경우 예약된 크기 조정 규칙을 사용하여 시작 지연 없이 리소스를 사용할 수 있도록 하되, 예기치 않은 수요 변화에 대처하기 위해 적절한 경우 규칙에 반응적 자동 크기 조정을 추가하세요.</span><span class="sxs-lookup"><span data-stu-id="3fd86-135">Use scheduled scaling rules where possible to ensure resources are available without a start-up delay, but add reactive autoscaling to the rules where appropriate to cope with unexpected changes in demand.</span></span> <span data-ttu-id="3fd86-136">Service Management API에 자동 크기 조정 작업을 사용하여 자동 크기 조정을 미세 조정하고 규칙에 사용자 지정 카운터를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-136">You can use the autoscaling operations in the Service Management API to adjust autoscaling, and to add custom counters to rules.</span></span> <span data-ttu-id="3fd86-137">자세한 내용은 [자동 크기 조정 지침](../best-practices/auto-scaling.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3fd86-137">For more information, see [Auto-scaling guidance](../best-practices/auto-scaling.md).</span></span>

<span data-ttu-id="3fd86-138">**집약적인 CPU/IO 작업을 백그라운드 작업으로 오프로드**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-138">**Offload intensive CPU/IO tasks as background tasks**.</span></span> <span data-ttu-id="3fd86-139">서비스 요청을 실행하는 데 시간이 오래 걸리거나 많은 리소스가 사용될 것으로 예상되는 경우 이 요청 처리를 별도 작업으로 오프로드합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-139">If a request to a service is expected to take a long time to run or absorb considerable resources, offload the processing for this request to a separate task.</span></span> <span data-ttu-id="3fd86-140">호스팅 플랫폼에 따라 작업자 역할 또는 백그라운드 작업을 사용하여 이러한 작업을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-140">Use worker roles or background jobs (depending on the hosting platform) to execute these tasks.</span></span> <span data-ttu-id="3fd86-141">이 전략을 사용하면 서비스가 추가 요청을 계속 받고 응답을 유지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-141">This strategy enables the service to continue receiving further requests and remain responsive.</span></span>  <span data-ttu-id="3fd86-142">자세한 내용은 [백그라운드 작업 지침](../best-practices/background-jobs.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3fd86-142">For more information, see [Background jobs guidance](../best-practices/background-jobs.md).</span></span>

<span data-ttu-id="3fd86-143">**백그라운드 작업에 대한 워크로드 분산**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-143">**Distribute the workload for background tasks**.</span></span> <span data-ttu-id="3fd86-144">많은 백그라운드 작업이 있거나 작업에 상당한 시간 또는 리소스가 필요한 경우 여러 계산 단위(예: 작업자 역할 또는 백그라운드 작업)로 작업을 분산합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-144">Where there are many background tasks, or the tasks require considerable time or resources, spread the work across multiple compute units (such as worker roles or background jobs).</span></span> <span data-ttu-id="3fd86-145">한 가지 가능한 솔루션에 대해서는 [경쟁 소비자 패턴](../patterns/competing-consumers.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3fd86-145">For one possible solution, see the [Competing Consumers pattern](../patterns/competing-consumers.md).</span></span>

<span data-ttu-id="3fd86-146">***shared-nothing* 아키텍처로 전환하는 것이 좋습니다**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-146">**Consider moving towards a *shared-nothing* architecture**.</span></span> <span data-ttu-id="3fd86-147">비공유 아키텍처는 공유 서비스 또는 저장소와 같은 단일 경합 지점이 없는 독립 노드 및 자가 충족 노드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-147">A shared-nothing architecture uses independent, self-sufficient nodes that have no single point of contention (such as shared services or storage).</span></span> <span data-ttu-id="3fd86-148">이론적으로 이러한 시스템은 거의 무제한적으로 확장될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-148">In theory, such a system can scale almost indefinitely.</span></span> <span data-ttu-id="3fd86-149">완전한 비공유 접근 방법은 일반적으로 대부분의 응용 프로그램에 현실적이지 않지만 더 나은 확장성을 위한 디자인 기회를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-149">While a fully shared-nothing approach is generally not practical for most applications, it may provide opportunities to design for better scalability.</span></span> <span data-ttu-id="3fd86-150">예를 들어 서버 쪽 세션 상태, 클라이언트 선호도 및 데이터 분할을 사용하지 못하도록 하는 것은 비공유 아키텍처로 전환하는 좋은 예입니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-150">For example, avoiding the use of server-side session state, client affinity, and data partitioning are good examples of moving towards a shared-nothing architecture.</span></span>

## <a name="data-management"></a><span data-ttu-id="3fd86-151">데이터 관리</span><span class="sxs-lookup"><span data-stu-id="3fd86-151">Data management</span></span>

<span data-ttu-id="3fd86-152">**데이터 분할 사용**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-152">**Use data partitioning**.</span></span> <span data-ttu-id="3fd86-153">데이터를 여러 데이터베이스 및 데이터베이스 서버로 분할하거나, 이러한 분할을 투명하게 제공할 수 있는 데이터 저장소 서비스(예: Azure SQL Database Elastic Database 및 Azure 테이블 저장소)를 사용하도록 응용 프로그램을 디자인합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-153">Divide the data across multiple databases and database servers, or design the application to use data storage services that can provide this partitioning transparently (examples include Azure SQL Database Elastic Database, and Azure Table storage).</span></span> <span data-ttu-id="3fd86-154">이 접근 방법은 성능을 극대화하고 크기 조정을 간편하게 해줍니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-154">This approach can help to maximize performance and allow easier scaling.</span></span> <span data-ttu-id="3fd86-155">수평, 수직, 기능 등의 다양한 분할 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-155">There are different partitioning techniques, such as horizontal, vertical, and functional.</span></span> <span data-ttu-id="3fd86-156">이러한 기술의 조합을 사용하여 향상된 쿼리 성능, 간편한 확장성, 보다 유연한 관리, 더 나은 가용성 등의 이점을 극대화하고 저장소 유형을 해당 데이터에 일치시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-156">You can use a combination of these to achieve maximum benefit from increased query performance, simpler scalability, more flexible management, better availability, and to match the type of store to the data it will hold.</span></span> <span data-ttu-id="3fd86-157">또한 특정 데이터 형식에 최적화된 정도에 따라 형식을 선택하여 다양한 데이터 형식에 서로 다른 유형의 데이터 저장소를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-157">Also, consider using different types of data store for different types of data, choosing the types based on how well they are optimized for the specific type of data.</span></span> <span data-ttu-id="3fd86-158">여기에는 관계형 데이터베이스 대신 또는 관계형 데이터베이스와 함께 테이블 저장소, 문서 데이터베이스 또는 열 패밀리 데이터 저장소를 사용하는 것이 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-158">This may include using table storage, a document database, or a column-family data store, instead of, or as well as, a relational database.</span></span> <span data-ttu-id="3fd86-159">자세한 내용은 [데이터 분할 지침](../best-practices/data-partitioning.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3fd86-159">For more information, see [Data partitioning guidance](../best-practices/data-partitioning.md).</span></span>

<span data-ttu-id="3fd86-160">**결과적 일관성을 위한 디자인**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-160">**Design for eventual consistency**.</span></span> <span data-ttu-id="3fd86-161">결과적 일관성은 여러 저장소에 분할된 관련 데이터를 동기화하는 데 필요한 시간을 줄이거나 제거하여 확장성을 향상시킵니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-161">Eventual consistency improves scalability by reducing or removing the time needed to synchronize related data partitioned across multiple stores.</span></span> <span data-ttu-id="3fd86-162">하지만 데이터를 읽을 때 데이터가 일관적이지 않을 수 있고 일부 쓰기 작업이 충돌을 일으킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-162">The cost is that data is not always consistent when it is read, and some write operations may cause conflicts.</span></span> <span data-ttu-id="3fd86-163">결과적 일관성은 동일한 데이터의 읽기 빈도는 높은 반면, 쓰기 빈도는 낮은 경우에 이상적입니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-163">Eventual consistency is ideal for situations where the same data is read frequently but written infrequently.</span></span> <span data-ttu-id="3fd86-164">자세한 내용은 [데이터 일관성 입문서](https://msdn.microsoft.com/library/dn589800.aspx)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3fd86-164">For more information, see the [Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span>

<span data-ttu-id="3fd86-165">**구성 요소와 서비스 간의 수다스러운 상호 작용 감소**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-165">**Reduce chatty interactions between components and services**.</span></span> <span data-ttu-id="3fd86-166">응용 프로그램이 한 번의 호출로 모든 데이터를 반환하는 것이 아니라 서비스를 여러 번 호출(각 호출에서 소량의 데이터 반환)해야 하는 조작 디자인을 피해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-166">Avoid designing interactions in which an application is required to make multiple calls to a service (each of which returns a small amount of data), rather than a single call that can return all of the data.</span></span> <span data-ttu-id="3fd86-167">가능한 경우, 대기 시간이 긴 서비스 또는 구성 요소를 호출하는 경우 여러 관련 작업을 단일 요청으로 결합합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-167">Where possible, combine several related operations into a single request when the call is to a service or component that has noticeable latency.</span></span> <span data-ttu-id="3fd86-168">이렇게 하면 성능을 모니터링하고 복잡한 작업을 최적화하는 것이 쉬워집니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-168">This makes it easier to monitor performance and optimize complex operations.</span></span> <span data-ttu-id="3fd86-169">예를 들어 데이터베이스의 저장 프로시저를 사용하여 복잡한 논리를 캡슐화하고 왕복 및 리소스 잠금 횟수를 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-169">For example, use stored procedures in databases to encapsulate complex logic, and reduce the number of round trips and resource locking.</span></span>

<span data-ttu-id="3fd86-170">**큐를 사용하여 고속 데이터 쓰기에 대한 부하 평준화**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-170">**Use queues to level the load for high velocity data writes**.</span></span> <span data-ttu-id="3fd86-171">서비스 요청이 급증하면 해당 서비스에 과부하가 걸리고 오류가 급증할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-171">Surges in demand for a service can overwhelm that service and cause escalating failures.</span></span> <span data-ttu-id="3fd86-172">이를 방지하려면 [큐 기반 부하 평준화 패턴](../patterns/queue-based-load-leveling.md)을 구현하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-172">To prevent this, consider implementing the [Queue-Based Load Leveling pattern](../patterns/queue-based-load-leveling.md).</span></span> <span data-ttu-id="3fd86-173">작업과 해당 작업에서 호출하는 서비스 간의 버퍼 역할을 하는 큐를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-173">Use a queue that acts as a buffer between a task and a service that it invokes.</span></span> <span data-ttu-id="3fd86-174">이렇게 하면 서비스 실패 또는 작업 시간 초과를 일으킬 수 있는 일시적 과부하를 원활하게 유지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-174">This can smooth intermittent heavy loads that may otherwise cause the service to fail or the task to time out.</span></span>

<span data-ttu-id="3fd86-175">**데이터 저장소에 대한 부하 최소화**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-175">**Minimize the load on the data store**.</span></span> <span data-ttu-id="3fd86-176">데이터 저장소는 일반적으로 처리 병목 지점인 동시에 비용이 많이 드는 리소스이므로 규모를 쉽게 확장할 수 없는 경우가 많습니다. 가능한 경우, 데이터 저장소에서 논리(예: XML 문서 또는 JSON 개체 처리)를 제거하고 응용 프로그램 내에서 처리를 수행하세요.</span><span class="sxs-lookup"><span data-stu-id="3fd86-176">The data store is commonly a processing bottleneck, a costly resource, and often not easy to scale out. Where possible, remove logic (such as processing XML documents or JSON objects) from the data store, and perform processing within the application.</span></span> <span data-ttu-id="3fd86-177">예를 들어 데이터베이스로 XML(저장소에 대한 불투명 문자열 제외)을 전달하는 대신 응용 프로그램 계층 내에서 XML을 serialize 또는 deserialize하여 데이터 저장소에 네이티브한 형식으로 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-177">For example, instead of passing XML to the database (other than as an opaque string for storage), serialize or deserialize the XML within the application layer and pass it in a form that is native to the data store.</span></span> <span data-ttu-id="3fd86-178">일반적으로 데이터 저장소보다 응용 프로그램이 규모를 확장하기 훨씬 쉬우므로 계산 집약적인 처리는 가능한 한 대부분 응용 프로그램 내에서 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-178">It's typically much easier to scale out the application than the data store, so you should attempt to do as much of the compute-intensive processing as possible within the application.</span></span>

<span data-ttu-id="3fd86-179">**검색되는 데이터 양 최소화**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-179">**Minimize the volume of data retrieved**.</span></span> <span data-ttu-id="3fd86-180">열을 지정하고 조건을 사용하여 행을 선택하는 방식으로 필요한 데이터만 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-180">Retrieve only the data you require by specifying columns and using criteria to select rows.</span></span> <span data-ttu-id="3fd86-181">테이블 값 매개 변수 및 적절한 격리 수준을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-181">Make use of table value parameters and the appropriate isolation level.</span></span> <span data-ttu-id="3fd86-182">엔터티 태그 같은 메커니즘을 사용하여 불필요한 데이터 검색을 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-182">Use mechanisms like entity tags to avoid retrieving data unnecessarily.</span></span>

<span data-ttu-id="3fd86-183">**적극적으로 캐싱 사용**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-183">**Aggressively use caching**.</span></span> <span data-ttu-id="3fd86-184">가급적 캐싱을 사용하여 데이터를 생성하거나 전달하는 리소스 및 서비스에 대한 부하를 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-184">Use caching wherever possible to reduce the load on resources and services that generate or deliver data.</span></span> <span data-ttu-id="3fd86-185">캐싱은 일반적으로 비교적 정적인 데이터 또는 가져오기 위해 상당한 처리가 필요한 데이터에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-185">Caching is typically suited to data that is relatively static, or that requires considerable processing to obtain.</span></span> <span data-ttu-id="3fd86-186">캐싱은 해당되는 경우 데이터 액세스 및 사용자 인터페이스 생성을 포함하여 응용 프로그램의 각 계층 내 모든 수준에서 발생해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-186">Caching should occur at all levels where appropriate in each layer of the application, including data access and user interface generation.</span></span> <span data-ttu-id="3fd86-187">자세한 내용은 [캐싱 지침](../best-practices/caching.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3fd86-187">For more information, see the [Caching Guidance](../best-practices/caching.md).</span></span>

<span data-ttu-id="3fd86-188">**데이터 증가 및 보존 처리**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-188">**Handle data growth and retention**.</span></span> <span data-ttu-id="3fd86-189">응용 프로그램에서 저장하는 데이터 양은 시간이 지남에 따라 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-189">The amount of data stored by an application grows over time.</span></span> <span data-ttu-id="3fd86-190">이로 인해 저장소 비용을 증가하고 데이터 액세스 대기 시간이 증가하며, 이는 응용 프로그램 처리량 및 성능에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-190">This growth increases storage costs, and increases latency when accessing the data — which affects application throughput and performance.</span></span> <span data-ttu-id="3fd86-191">더 이상 액세스하지 않는 오래된 데이터의 일부를 주기적으로 보관하거나, 거의 액세스하지 않는 데이터를 액세스 대기 시간이 더 긴 경우에도 보다 비용 효율적인 장기 저장소로 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-191">It may be possible to periodically archive some of the old data that is no longer accessed, or move data that is rarely accessed into long-term storage that is more cost efficient, even if the access latency is higher.</span></span>

<span data-ttu-id="3fd86-192">**효율적인 이진 형식을 사용하여 DTO(Data Transfer Object) 최적화**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-192">**Optimize Data Transfer Objects (DTOs) using an efficient binary format**.</span></span> <span data-ttu-id="3fd86-193">DTO는 응용 프로그램 계층 간에 여러 번 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-193">DTOs are passed between the layers of an application many times.</span></span> <span data-ttu-id="3fd86-194">크기를 최소화하면 리소스 및 네트워크에 대한 부하가 감소합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-194">Minimizing the size reduces the load on resources and the network.</span></span> <span data-ttu-id="3fd86-195">그러나 데이터를 해당 데이터가 사용되는 각 위치에서 필요한 형식으로 변환하는 오버헤드와 비용 절감의 균형을 유지하세요.</span><span class="sxs-lookup"><span data-stu-id="3fd86-195">However, balance the savings with the overhead of converting the data to the required format in each location where it is used.</span></span> <span data-ttu-id="3fd86-196">상호 운용성이 가장 뛰어난 형식을 채택하여 구성 요소를 손쉽게 다시 사용할 수 있도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-196">Adopt a format that has the maximum interoperability to enable easy reuse of a component.</span></span>

<span data-ttu-id="3fd86-197">**캐시 제어 설정**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-197">**Set cache control**.</span></span> <span data-ttu-id="3fd86-198">가능한 경우 출력 캐싱 또는 조각 캐싱을 사용하도록 응용 프로그램을 디자인 및 구성하여 처리 부하를 최소화합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-198">Design and configure the application to use output caching or fragment caching where possible, to minimize processing load.</span></span>

<span data-ttu-id="3fd86-199">**클라이언트 쪽 캐싱 사용**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-199">**Enable client side caching**.</span></span> <span data-ttu-id="3fd86-200">웹 응용 프로그램은 캐시 가능한 콘텐츠에 대해 캐시 설정을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-200">Web applications should enable cache settings on the content that can be cached.</span></span> <span data-ttu-id="3fd86-201">일반적으로 이 기능은 기본적으로 사용하지 않도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-201">This is commonly disabled by default.</span></span> <span data-ttu-id="3fd86-202">프록시 서버 및 클라이언트에서 콘텐츠를 캐시할 수 있게 적절한 캐시 제어 헤더를 제공하도록 서버를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-202">Configure the server to deliver the appropriate cache control headers to enable caching of content on proxy servers and clients.</span></span>

<span data-ttu-id="3fd86-203">**Azure Blob 저장소 및 Azure Content Delivery Network를 사용하여 응용 프로그램 부하 감소**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-203">**Use Azure blob storage and the Azure Content Delivery Network to reduce the load on the application**.</span></span> <span data-ttu-id="3fd86-204">이미지, 리소스, 스크립트, 스타일 시트 등 정적이거나 비교적 정적인 공용 콘텐츠를 Blob 저장소에 저장하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-204">Consider storing static or relatively static public content, such as images, resources, scripts, and style sheets, in blob storage.</span></span> <span data-ttu-id="3fd86-205">이 접근 방식은 각 요청에 대해 이러한 콘텐츠를 동적으로 생성함에 따라 발생하는 응용 프로그램 부하를 줄여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-205">This approach relieves the application of the load caused by dynamically generating this content for each request.</span></span> <span data-ttu-id="3fd86-206">또한 Content Delivery Network를 사용하여 이 콘텐츠를 캐시하고 클라이언트에 배달하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-206">Additionally, consider using the Content Delivery Network to cache this content and deliver it to clients.</span></span> <span data-ttu-id="3fd86-207">Content Delivery Network를 사용하면 콘텐츠가 Content Delivery Network 캐시를 포함하는 지리적으로 가장 가까운 데이터 센터에서 배달되기 때문에 클라이언트의 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-207">Using the Content Delivery Network can improve performance at the client because the content is delivered from the geographically closest datacenter that contains a Content Delivery Network cache.</span></span> <span data-ttu-id="3fd86-208">자세한 내용은 [Content Delivery Network 지침](../best-practices/cdn.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3fd86-208">For more information, see the [Content Delivery Network Guidance](../best-practices/cdn.md).</span></span>

<span data-ttu-id="3fd86-209">**SQL 쿼리 및 인덱스 최적화 및 튜닝**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-209">**Optimize and tune SQL queries and indexes**.</span></span> <span data-ttu-id="3fd86-210">일부 T-SQL 문 또는 구문은 성능에 영향을 줄 수 있으며, 이러한 영향은 저장 프로시저의 코드를 최적화하여 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-210">Some T-SQL statements or constructs may have an impact on performance that can be reduced by optimizing the code in a stored procedure.</span></span> <span data-ttu-id="3fd86-211">예를 들어 **datetime** 리터럴 값과 비교하기 전에 **datetime** 형식을 **varchar**로 변환하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="3fd86-211">For example, avoid converting **datetime** types to a **varchar** before comparing with a **datetime** literal value.</span></span> <span data-ttu-id="3fd86-212">대신 date/time 비교 함수를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-212">Use date/time comparison functions instead.</span></span> <span data-ttu-id="3fd86-213">적절한 인덱스가 없으면 쿼리 실행 속도가 느려질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-213">Lack of appropriate indexes can also slow query execution.</span></span> <span data-ttu-id="3fd86-214">개체/관계형 매핑 프레임워크를 사용하는 경우 작동 방식 및 데이터 액세스 계층의 성능에 영향을 줄 수 있는 방식을 이해해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-214">If you use an object/relational mapping framework, understand how it works and how it may affect performance of the data access layer.</span></span> <span data-ttu-id="3fd86-215">자세한 내용은 [쿼리 튜닝](https://technet.microsoft.com/library/ms176005.aspx)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3fd86-215">For more information, see [Query Tuning](https://technet.microsoft.com/library/ms176005.aspx).</span></span>

<span data-ttu-id="3fd86-216">**데이터 비정규화**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-216">**Consider de-normalizing data**.</span></span> <span data-ttu-id="3fd86-217">데이터 정규화는 중복 및 불일치를 방지하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-217">Data normalization helps to avoid duplication and inconsistency.</span></span> <span data-ttu-id="3fd86-218">그러나 여러 인덱스를 유지 관리하고, 참조 무결성을 확인하고, 소량의 데이터에 여러 번 액세스하고, 테이블을 조인하여 데이터를 다시 어셈블해야 하기 때문에 성능에 영향을 줄 수 있는 오버헤드가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-218">However, maintaining multiple indexes, checking for referential integrity, performing multiple accesses to small chunks of data, and joining tables to reassemble the data imposes an overhead that can affect performance.</span></span> <span data-ttu-id="3fd86-219">데이터 저장소의 부하를 줄이기 위해 일부 추가 저장소 볼륨 및 중복을 허용할지 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="3fd86-219">Consider if some additional storage volume and duplication is acceptable in order to reduce the load on the data store.</span></span> <span data-ttu-id="3fd86-220">또한 데이터 저장소의 부하를 줄이기 위해 참조 무결성 관리와 같은 작업을 응용 프로그램 자체(일반적으로 확장이 보다 간편함)에서 수행할 수 있는지 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="3fd86-220">Also, consider if the application itself (which is typically easier to scale) can be relied upon to take over tasks such as managing referential integrity in order to reduce the load on the data store.</span></span> <span data-ttu-id="3fd86-221">자세한 내용은 [데이터 분할 지침](../best-practices/data-partitioning.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3fd86-221">For more information, see [Data partitioning guidance](../best-practices/data-partitioning.md).</span></span>

## <a name="implementation"></a><span data-ttu-id="3fd86-222">구현</span><span class="sxs-lookup"><span data-stu-id="3fd86-222">Implementation</span></span>

<span data-ttu-id="3fd86-223">**성능 안티패턴을 검토합니다**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-223">**Review the performance antipatterns**.</span></span> <span data-ttu-id="3fd86-224">응용 프로그램이 압력을 받고 있을 때 확장성 문제를 일으킬 가능성이 있는 일반적인 사례는 [클라우드 응용 프로그램의 성능 안티패턴](../antipatterns/index.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3fd86-224">See [Performance antipatterns for cloud applications](../antipatterns/index.md) for common practices that are likely to cause scalability problems when an application is under pressure.</span></span>

<span data-ttu-id="3fd86-225">**비동기 호출 사용**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-225">**Use asynchronous calls**.</span></span> <span data-ttu-id="3fd86-226">호출 스레드 잠금을 방지하기 위하여 가능한 경우 I/O 또는 네트워크 대역폭으로 제한될 수 있거나 대기 시간이 긴 리소스 또는 서비스에 액세스할 때 비동기 코드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-226">Use asynchronous code wherever possible when accessing resources or services that may be limited by I/O or network bandwidth, or that have a noticeable latency, in order to avoid locking the calling thread.</span></span>

<span data-ttu-id="3fd86-227">**리소스 잠금을 방지하고, 대신 낙관적 접근 방식 사용**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-227">**Avoid locking resources, and use an optimistic approach instead**.</span></span> <span data-ttu-id="3fd86-228">저장소 또는 대기 시간이 긴 기타 서비스와 같은 리소스에 대한 액세스를 잠그면 안 됩니다. 이는 성능 저하의 주요 원인입니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-228">Never lock access to resources such as storage or other services that have noticeable latency, because this is a primary cause of poor performance.</span></span> <span data-ttu-id="3fd86-229">항상 낙관적 접근 방법을 사용하여 저장소에 쓰기와 같은 동시 작업을 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-229">Always use optimistic approaches to managing concurrent operations, such as writing to storage.</span></span> <span data-ttu-id="3fd86-230">저장소 기능을 사용하여 충돌을 관리하세요.</span><span class="sxs-lookup"><span data-stu-id="3fd86-230">Use features of the storage layer to manage conflicts.</span></span> <span data-ttu-id="3fd86-231">분산된 응용 프로그램에서는 데이터의 일관성이 결과적으로만 유지될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-231">In distributed applications, data may be only eventually consistent.</span></span>

<span data-ttu-id="3fd86-232">**대기 시간이 높고 대역폭이 낮은 네트워크를 통해 압축성이 뛰어난 데이터 압축**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-232">**Compress highly compressible data over high latency, low bandwidth networks**.</span></span> <span data-ttu-id="3fd86-233">웹 응용 프로그램의 경우 대부분 응용 프로그램에 의해 생성되고 네트워크를 통해 전달되는 데이터는 클라이언트 요청에 대한 HTTP 응답입니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-233">In the majority of cases in a web application, the largest volume of data generated by the application and passed over the network is HTTP responses to client requests.</span></span> <span data-ttu-id="3fd86-234">HTTP 압축은 특히 정적 콘텐츠의 경우 이러한 데이터를 크게 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-234">HTTP compression can reduce this considerably, especially for static content.</span></span> <span data-ttu-id="3fd86-235">따라서 비용이 절감되고 네트워크 부하가 감소할 수 있습니다. 다만, 동적 콘텐츠 압축은 서버에 부분적으로 더 높은 부하를 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-235">This can reduce cost as well as reducing the load on the network, though compressing dynamic content does apply a fractionally higher load on the server.</span></span> <span data-ttu-id="3fd86-236">보다 일반적인 다른 환경에서는 데이터 압축을 통해 전송되는 데이터 양을 줄임으로써 전송 시간 비용을 최소화할 수 있지만 압축 및 압축 해제 프로세스는 오버헤드를 발생시킵니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-236">In other, more generalized environments, data compression can reduce the volume of data transmitted and minimize transfer time and costs, but the compression and decompression processes incur overhead.</span></span> <span data-ttu-id="3fd86-237">따라서 압축은 성능에 명확히 유익한 경우에만 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-237">As such, compression should only be used when there is a demonstrable gain in performance.</span></span> <span data-ttu-id="3fd86-238">JSON 또는 이진 인코딩과 같은 다른 직렬화 메서드는 성능에 대한 영향 없이 페이로드 크기를 줄일 수 있는 반면, XML은 이를 증가시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-238">Other serialization methods, such as JSON or binary encodings, may reduce the payload size while having less impact on performance, whereas XML is likely to increase it.</span></span>

<span data-ttu-id="3fd86-239">**연결 및 리소스 사용 시간 최소화**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-239">**Minimize the time that connections and resources are in use**.</span></span> <span data-ttu-id="3fd86-240">사용해야 하는 시간 동안만 연결 및 리소스를 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-240">Maintain connections and resources only for as long as you need to use them.</span></span> <span data-ttu-id="3fd86-241">예를 들어 연결을 최대한 늦게 열고 최대한 빨리 연결 풀로 되돌아갈 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-241">For example, open connections as late as possible, and allow them to be returned to the connection pool as soon as possible.</span></span> <span data-ttu-id="3fd86-242">또한 리소스를 최대한 늦게 획득하고 최대한 빨리 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-242">Acquire resources as late as possible, and dispose of them as soon as possible.</span></span>

<span data-ttu-id="3fd86-243">**필요한 연결 수 최소화**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-243">**Minimize the number of connections required**.</span></span> <span data-ttu-id="3fd86-244">서비스 연결에는 리소스가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-244">Service connections absorb resources.</span></span> <span data-ttu-id="3fd86-245">필요한 수를 제한하고 가급적 기존 연결을 다시 사용할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-245">Limit the number that are required and ensure that existing connections are reused whenever possible.</span></span> <span data-ttu-id="3fd86-246">예를 들어 인증을 수행한 후에는 적절한 경우 가장을 사용하여 코드를 특정 ID로 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-246">For example, after performing authentication, use impersonation where appropriate to run code as a specific identity.</span></span> <span data-ttu-id="3fd86-247">이렇게 하면 연결을 다시 사용하여 연결 풀 사용을 최적화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-247">This can help to make best use of the connection pool by reusing connections.</span></span>
  
> [!NOTE]
> <span data-ttu-id="3fd86-248">서비스 관련 지침을 따를 경우 일부 서비스용 API는 자동으로 연결을 다시 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-248">APIs for some services automatically reuse connections, provided service-specific guidelines are followed.</span></span> <span data-ttu-id="3fd86-249">응용 프로그램에서 사용하는 각 서비스에 연결을 다시 사용하는 조건을 이해하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-249">It's important that you understand the conditions that enable connection reuse for each service that your application uses.</span></span>

<span data-ttu-id="3fd86-250">**요청을 일괄 처리로 보내 네트워크 사용 최적화**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-250">**Send requests in batches to optimize network use**.</span></span> <span data-ttu-id="3fd86-251">예를 들어 큐에 액세스할 때 메시지를 일괄 처리로 보내고 읽고, 저장소 또는 캐시에 액세스할 때 여러 읽기 또는 쓰기를 일괄 처리로 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-251">For example, send and read messages in batches when accessing a queue, and perform multiple reads or writes as a batch when accessing storage or a cache.</span></span> <span data-ttu-id="3fd86-252">이렇게 하면 네트워크를 통한 호출 수를 줄여 서비스 및 데이터 저장소의 효율성을 최대화시키는데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-252">This can help to maximize efficiency of the services and data stores by reducing the number of calls across the network.</span></span>

<span data-ttu-id="3fd86-253">**가능한 경우 서버 쪽 세션 상태에 대한 요구 사항 방지** .</span><span class="sxs-lookup"><span data-stu-id="3fd86-253">**Avoid a requirement to store server-side session state** where possible.</span></span> <span data-ttu-id="3fd86-254">서버 쪽 세션 상태를 관리하려면 일반적으로 클라이언트 선호도(즉, 각 요청을 동일한 서버 인스턴스로 라우팅)가 필요하며, 이는 시스템 확장성에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-254">Server-side session state management typically requires client affinity (that is, routing each request to the same server instance), which affects the ability of the system to scale.</span></span> <span data-ttu-id="3fd86-255">클라이언트를 사용하는 서버에 대해 상태를 저장하지 않도록 클라이언트를 디자인하는 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-255">Ideally, you should design clients to be stateless with respect to the servers that they use.</span></span> <span data-ttu-id="3fd86-256">그러나 응용 프로그램에서 세션 상태를 유지해야 하는 경우에는 중요한 데이터 또는 대량의 클라이언트별 데이터를 응용 프로그램의 모든 인스턴스에서 액세스할 수 있는 분산된 서버 쪽 캐시에 저장하세요.</span><span class="sxs-lookup"><span data-stu-id="3fd86-256">However, if the application must maintain session state, store sensitive data or large volumes of per-client data in a distributed server-side cache that all instances of the application can access.</span></span>

<span data-ttu-id="3fd86-257">**테이블 저장소 스키마 최적화**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-257">**Optimize table storage schemas**.</span></span> <span data-ttu-id="3fd86-258">테이블 및 열 이름을 모든 쿼리와 함께 전달하고 처리해야 하는 테이블 저장소(예: Azure 테이블 저장소)를 사용하는 경우 짧은 이름을 사용하여 이 오버헤드를 줄이는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-258">When using table stores that require the table and column names to be passed and processed with every query, such as Azure table storage, consider using shorter names to reduce this overhead.</span></span> <span data-ttu-id="3fd86-259">그러나 너무 간결한 이름을 사용하여 가독성 및 관리 효율성이 저하되지 않도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-259">However, do not sacrifice readability or manageability by using overly compact names.</span></span>

<span data-ttu-id="3fd86-260">**배포 중 또는 응용 프로그램 시작 시 리소스 종속성 만들기**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-260">**Create resource dependencies during deployment or at application startup**.</span></span> <span data-ttu-id="3fd86-261">리소스 존재 여부를 테스트한 다음, 없는 경우 리소스를 만드는 메서드에 대한 반복적인 호출을 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-261">Avoid repeated calls to methods that test the existence of a resource and then create the resource if it does not exist.</span></span> <span data-ttu-id="3fd86-262">Azure Storage 클라이언트 라이브러리의 *CloudTable.CreateIfNotExists* 및 *CloudQueue.CreateIfNotExists*와 같은 메서드가 이 패턴을 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-262">Methods such as *CloudTable.CreateIfNotExists* and *CloudQueue.CreateIfNotExists* in the Azure Storage Client Library follow this pattern.</span></span> <span data-ttu-id="3fd86-263">저장소 테이블 또는 저장소 큐에 액세스할 때마다 이러한 메서드가 사전에 호출되면 상당한 오버헤드가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-263">These methods can impose considerable overhead if they are invoked before each access to a storage table or storage queue.</span></span> <span data-ttu-id="3fd86-264">대신,</span><span class="sxs-lookup"><span data-stu-id="3fd86-264">Instead:</span></span>

- <span data-ttu-id="3fd86-265">응용 프로그램을 배포하거나 처음 시작할 때 필요한 리소스를 만듭니다(웹 또는 작업자 역할의 시작 코드에 대한 응답마다 *CreateIfNotExists*에 대한 단일 호출만 허용됨).</span><span class="sxs-lookup"><span data-stu-id="3fd86-265">Create the required resources when the application is deployed, or when it first starts (a single call to *CreateIfNotExists* for each resource in the startup code for a web or worker role is acceptable).</span></span> <span data-ttu-id="3fd86-266">그러나 코드에서 존재하지 않는 리소스에 대한 액세스를 시도하는 경우에 발생할 수 있는 예외를 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-266">However, be sure to handle exceptions that may arise if your code attempts to access a resource that doesn't exist.</span></span> <span data-ttu-id="3fd86-267">이러한 경우는 예외를 기록하고 리소스가 누락되었음을 작업자에게 경고해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-267">In these situations, you should log the exception, and possibly alert an operator that a resource is missing.</span></span>
- <span data-ttu-id="3fd86-268">경우에 따라 예외 처리 코드의 일부로 누락된 리소스를 만드는 것이 적절할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-268">Under some circumstances, it may be appropriate to create the missing resource as part of the exception handling code.</span></span> <span data-ttu-id="3fd86-269">그러나 리소스가 없는 것이 프로그래밍 오류(예: 철자가 잘못된 리소스 이름) 또는 다른 인프라 수준의 문제를 나타낼 수 있으므로 주의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-269">But you should adopt this approach with caution as the non-existence of the resource might be indicative of a programming error (a misspelled resource name for example), or some other infrastructure-level issue.</span></span>

<span data-ttu-id="3fd86-270">**경량 프레임워크 사용**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-270">**Use lightweight frameworks**.</span></span> <span data-ttu-id="3fd86-271">리소스 사용, 실행 시간 및 응용 프로그램의 전체 부하를 최소화하려면 사용할 API 및 프레임워크를 신중히 선택해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-271">Carefully choose the APIs and frameworks you use to minimize resource usage, execution time, and overall load on the application.</span></span> <span data-ttu-id="3fd86-272">예를 들어 Web API를 사용하여 서비스 요청을 처리하면 응용 프로그램 설치 공간을 줄이고 실행 속도를 높일 수 있지만 Windows Communication Foundation의 추가 기능이 필요한 고급 시나리오에는 적합하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-272">For example, using Web API to handle service requests can reduce the application footprint and increase execution speed, but it may not be suitable for advanced scenarios where the additional capabilities of Windows Communication Foundation are required.</span></span>

<span data-ttu-id="3fd86-273">**서비스 계정 수 최소화**.</span><span class="sxs-lookup"><span data-stu-id="3fd86-273">**Consider minimizing the number of service accounts**.</span></span> <span data-ttu-id="3fd86-274">예를 들어 연결을 제한하거나 유지 관리되는 연결 수가 적을수록 성능이 뛰어난 리소스 또는 서비스에 액세스할 경우 특정 계정을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-274">For example, use a specific account to access resources or services that impose a limit on connections, or perform better where fewer connections are maintained.</span></span> <span data-ttu-id="3fd86-275">이 접근 방법은 데이터베이스와 같은 서비스에 일반적이지만, 원래 사용자의 가장으로 인해 작업을 정확하게 감사하는 기능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-275">This approach is common for services such as databases, but it can affect the ability to accurately audit operations due to the impersonation of the original user.</span></span>

<span data-ttu-id="3fd86-276">**성능 프로파일링 및 부하 테스트 수행** 배포 중, 테스트 루틴 과정, 최종 릴리스 전에 수행하여 응용 프로그램이 정상적으로 실행되고 필요에 따라 확장되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-276">**Carry out performance profiling and load testing** during development, as part of test routines, and before final release to ensure the application performs and scales as required.</span></span> <span data-ttu-id="3fd86-277">이 테스트는 데이터 및 사용자 부하의 유형 및 양이 프로덕션에서 발생하는 것과 동일한 상태에서 프로덕션 플랫폼과 동일한 유형의 하드웨어에서 수행되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3fd86-277">This testing should occur on the same type of hardware as the production platform, and with the same types and quantities of data and user load as it will encounter in production.</span></span> <span data-ttu-id="3fd86-278">자세한 내용은 [클라우드 서비스의 성능 테스트](/azure/vs-azure-tools-performance-profiling-cloud-services/)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3fd86-278">For more information, see [Testing the performance of a cloud service](/azure/vs-azure-tools-performance-profiling-cloud-services/).</span></span>
