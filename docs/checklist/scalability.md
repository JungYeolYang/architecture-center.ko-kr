---
title: 확장성 검사 목록
titleSuffix: Azure Design Review Framework
description: Azure 자동 크기 조정에 대한 디자인 고려 사항을 제공하는 확장성 검사 목록 지침
author: dragon119
ms.date: 01/10/2018
ms.topic: checklist
ms.service: architecture-center
ms.subservice: cloud-design-principles
ms.custom: checklist
ms.openlocfilehash: 7157ba4982b42a7f4f56422185d3b857bd909a78
ms.sourcegitcommit: 1b50810208354577b00e89e5c031b774b02736e2
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/23/2019
ms.locfileid: "54483672"
---
# <a name="scalability-checklist"></a>확장성 검사 목록

확장성은 증가된 부하를 처리하는 시스템의 기능이며 [소프트웨어 품질의 핵심 요소](../guide/pillars.md) 중 하나입니다. 이 검사 목록을 사용하여 확장성의 관점에서 애플리케이션 아키텍처를 검토합니다.

## <a name="application-design"></a>애플리케이션 설계

**워크로드 분할**. 프로세스의 각 부분을 불연속 및 분해되도록 디자인합니다. 관심 분야의 분리에 대한 일반적인 규칙 및 단일 책임 원칙을 따르면서 각 부분의 크기를 최소화합니다. 이렇게 하면 각 컴퓨팅 단위(예: 역할 또는 데이터베이스 서버)의 사용을 극대화하는 방식으로 구성 요소 부분을 분산시킬 수 있습니다. 특정 리소스의 인스턴스를 추가하여 애플리케이션을 보다 쉽게 확장할 수도 있습니다. 복합 도메인의 경우 [마이크로 서비스 아키텍처](..//guide/architecture-styles/microservices.md)를 도입하는 방안을 고려해 봅니다.

**크기 조정을 고려한 디자인**. 크기 조정을 사용하면 애플리케이션에서 사용하는 역할, 큐 및 기타 서비스의 인스턴스 수를 늘리거나 줄여 가변 부하에 대응할 수 있습니다. 그러나 이 점을 염두에 두고 애플리케이션을 디자인해야 합니다. 예를 들어 애플리케이션과 애플리케이션에서 사용하는 서비스는 요청이 모든 인스턴스로 라우팅되도록 상태를 저장하지 않아야 합니다. 또한 이렇게 하면 특정 인스턴스의 추가 또는 제거가 현재 사용자에게 부정적인 영향을 주지 않습니다. 또한 인스턴스가 추가 및 제거될 때 애플리케이션의 코드가 필요한 라우팅을 수행할 수 있도록 인스턴스의 구성 또는 자동 검색을 구현해야 합니다. 예를 들어 웹 애플리케이션은 라운드 로빈 방식으로 큐 집합을 사용하여 작업자 역할에서 실행되는 백그라운드 서비스로 요청을 라우팅할 수 있습니다. 성공적으로 요청을 라우팅하고 애플리케이션의 부하를 분산시키기 위해서는 웹 애플리케이션에서 큐 수 변경을 검색할 수 있어야 합니다.

**단위로 크기 조정**. 규모 증가에 맞게 리소스를 추가할 계획을 수립합니다. 각 리소스에 대해 크기 조정 상한을 알고 이러한 한도를 초과하려면 분할 또는 분해를 사용합니다. 잘 정의된 리소스 집합을 기준으로 시스템에 대한 배율 단위를 결정합니다. 이렇게 하면 스케일 아웃 작업을 보다 쉽게 적용할 수 있으며, 전체 시스템의 일부분에서 리소스 부족으로 인해 애플리케이션이 부정적인 영향을 받을 가능성이 줄어듭니다. 예를 들어 x개의 웹 및 작업자 역할을 추가하려면 역할에서 생성되는 추가 워크로드를 처리하기 위해 y개의 추가 쿼리 및 z개의 저장소 계정이 필요할 수 있습니다. 따라서 배율 단위는 x개의 웹 및 작업자 역할, *y*개의 큐 및 *z*개의 저장소 계정으로 구성됩니다. 하나 이상의 배율 단위를 추가하여 쉽게 확장할 수 있도록 애플리케이션을 디자인하세요.

**클라이언트 선호도 방지**. 가능한 경우, 애플리케이션에서 선호도를 요구하지 않도록 합니다. 이에 따라 요청이 모든 인스턴스로 라우팅될 수 있고 인스턴스 수는 관련이 없습니다. 이는 각 사용자의 상태 정보에 대한 저장, 검색 및 유지 관리 오버헤드도 방지합니다.

**플랫폼 자동 크기 조정 기능 활용**. 호스팅 플랫폼이 Azure 자동 크기 조정과 같은 자동 크기 조정 기능을 지원하는 경우 기본 제공 메커니즘이 요구 사항을 이행할 수 없는 경우가 아니라면 사용자 지정 또는 타사 메커니즘으로 기본 설정합니다. 가능한 경우 예약된 크기 조정 규칙을 사용하여 시작 지연 없이 리소스를 사용할 수 있도록 하되, 예기치 않은 수요 변화에 대처하기 위해 적절한 경우 규칙에 반응적 자동 크기 조정을 추가하세요. Service Management API에 자동 크기 조정 작업을 사용하여 자동 크기 조정을 미세 조정하고 규칙에 사용자 지정 카운터를 추가할 수 있습니다. 자세한 내용은 [자동 크기 조정 지침](../best-practices/auto-scaling.md)을 참조하세요.

**집약적인 CPU/IO 작업을 백그라운드 작업으로 오프로드**. 서비스 요청을 실행하는 데 시간이 오래 걸리거나 많은 리소스가 사용될 것으로 예상되는 경우 이 요청 처리를 별도 작업으로 오프로드합니다. 호스팅 플랫폼에 따라 작업자 역할 또는 백그라운드 작업을 사용하여 이러한 작업을 실행할 수 있습니다. 이 전략을 사용하면 서비스가 추가 요청을 계속 받고 응답을 유지할 수 있습니다.  자세한 내용은 [백그라운드 작업 지침](../best-practices/background-jobs.md)을 참조하세요.

**백그라운드 작업에 대한 워크로드 분산**. 많은 백그라운드 작업이 있거나 작업에 상당한 시간 또는 리소스가 필요한 경우 여러 컴퓨팅 단위(예: 작업자 역할 또는 백그라운드 작업)로 작업을 분산합니다. 한 가지 가능한 솔루션에 대해서는 [경쟁 소비자 패턴](../patterns/competing-consumers.md)을 참조하세요.

***shared-nothing* 아키텍처로 전환하는 것이 좋습니다**. 비공유 아키텍처는 공유 서비스 또는 저장소와 같은 단일 경합 지점이 없는 독립 노드 및 자가 충족 노드를 사용합니다. 이론적으로 이러한 시스템은 거의 무제한적으로 확장될 수 있습니다. 완전한 비공유 접근 방법은 일반적으로 대부분의 애플리케이션에 현실적이지 않지만 더 나은 확장성을 위한 디자인 기회를 제공할 수 있습니다. 예를 들어 서버 쪽 세션 상태, 클라이언트 선호도 및 데이터 분할을 사용하지 못하도록 하는 것은 비공유 아키텍처로 전환하는 좋은 예입니다.

## <a name="data-management"></a>데이터 관리

**데이터 분할 사용**. 데이터를 여러 데이터베이스 및 데이터베이스 서버로 분할하거나, 이러한 분할을 투명하게 제공할 수 있는 데이터 스토리지 서비스(예: Azure SQL Database Elastic Database 및 Azure Table Storage)를 사용하도록 응용 프로그램을 디자인합니다. 이 접근 방법은 성능을 극대화하고 크기 조정을 간편하게 해줍니다. 수평, 수직, 기능 등의 다양한 분할 방법이 있습니다. 이러한 기술의 조합을 사용하여 향상된 쿼리 성능, 간편한 확장성, 보다 유연한 관리, 더 나은 가용성 등의 이점을 극대화하고 저장소 유형을 해당 데이터에 일치시킬 수 있습니다. 또한 특정 데이터 형식에 최적화된 정도에 따라 형식을 선택하여 다양한 데이터 형식에 서로 다른 유형의 데이터 저장소를 사용하는 것이 좋습니다. 여기에는 관계형 데이터베이스 대신 또는 관계형 데이터베이스와 함께 Table Storage, 문서 데이터베이스 또는 열 패밀리 데이터 스토리지를 사용하는 것이 포함될 수 있습니다. 자세한 내용은 [데이터 분할 지침](../best-practices/data-partitioning.md)을 참조하세요.

**결과적 일관성을 위한 디자인**. 결과적 일관성은 여러 저장소에 분할된 관련 데이터를 동기화하는 데 필요한 시간을 줄이거나 제거하여 확장성을 향상시킵니다. 하지만 데이터를 읽을 때 데이터가 일관적이지 않을 수 있고 일부 쓰기 작업이 충돌을 일으킬 수 있습니다. 결과적 일관성은 동일한 데이터의 읽기 빈도는 높은 반면, 쓰기 빈도는 낮은 경우에 이상적입니다. 자세한 내용은 [데이터 일관성 입문서](https://msdn.microsoft.com/library/dn589800.aspx)를 참조하세요.

**구성 요소와 서비스 간의 수다스러운 상호 작용 감소**. 애플리케이션이 한 번의 호출로 모든 데이터를 반환하는 것이 아니라 서비스를 여러 번 호출(각 호출에서 소량의 데이터 반환)해야 하는 조작 디자인을 피해야 합니다. 가능한 경우, 대기 시간이 긴 서비스 또는 구성 요소를 호출하는 경우 여러 관련 작업을 단일 요청으로 결합합니다. 이렇게 하면 성능을 모니터링하고 복잡한 작업을 최적화하는 것이 쉬워집니다. 예를 들어 데이터베이스의 저장 프로시저를 사용하여 복잡한 논리를 캡슐화하고 왕복 및 리소스 잠금 횟수를 줄입니다.

**큐를 사용하여 고속 데이터 쓰기에 대한 부하 평준화**. 서비스 요청이 급증하면 해당 서비스에 과부하가 걸리고 오류가 급증할 수 있습니다. 이를 방지하려면 [큐 기반 부하 평준화 패턴](../patterns/queue-based-load-leveling.md)을 구현하는 것이 좋습니다. 작업과 해당 작업에서 호출하는 서비스 간의 버퍼 역할을 하는 큐를 사용합니다. 이렇게 하면 서비스 실패 또는 작업 시간 초과를 일으킬 수 있는 일시적 과부하를 원활하게 유지할 수 있습니다.

**데이터 저장소에 대한 부하 최소화**. 데이터 저장소는 일반적으로 처리 병목 지점인 동시에 비용이 많이 드는 리소스이므로 규모를 쉽게 확장할 수 없는 경우가 많습니다. 가능한 경우, 데이터 저장소에서 논리(예: XML 문서 또는 JSON 개체 처리)를 제거하고 애플리케이션 내에서 처리를 수행하세요. 예를 들어 데이터베이스로 XML(스토리지에 대한 불투명 문자열 제외)을 전달하는 대신 애플리케이션 계층 내에서 XML을 serialize 또는 deserialize하여 데이터 저장소에 네이티브한 형식으로 전달합니다. 일반적으로 데이터 저장소보다 애플리케이션이 규모를 확장하기 훨씬 쉬우므로 계산 집약적인 처리는 가능한 한 대부분 애플리케이션 내에서 수행해야 합니다.

**검색되는 데이터 양 최소화**. 열을 지정하고 조건을 사용하여 행을 선택하는 방식으로 필요한 데이터만 검색합니다. 테이블 값 매개 변수 및 적절한 격리 수준을 사용합니다. 엔터티 태그 같은 메커니즘을 사용하여 불필요한 데이터 검색을 방지합니다.

**적극적으로 캐싱 사용**. 가급적 캐싱을 사용하여 데이터를 생성하거나 전달하는 리소스 및 서비스에 대한 부하를 줄입니다. 캐싱은 일반적으로 비교적 정적인 데이터 또는 가져오기 위해 상당한 처리가 필요한 데이터에 적합합니다. 캐싱은 해당되는 경우 데이터 액세스 및 사용자 인터페이스 생성을 포함하여 애플리케이션의 각 계층 내 모든 수준에서 발생해야 합니다. 자세한 내용은 [캐싱 지침](../best-practices/caching.md)을 참조하세요.

**데이터 증가 및 보존 처리**. 애플리케이션에서 저장된 데이터 양은 시간이 지남에 따라 증가합니다. 이로 인해 스토리지 비용을 증가하고 데이터 액세스 대기 시간이 증가하며, 이는 애플리케이션 처리량 및 성능에 영향을 줍니다. 더 이상 액세스하지 않는 오래된 데이터의 일부를 주기적으로 보관하거나, 거의 액세스하지 않는 데이터를 액세스 대기 시간이 더 긴 경우에도 보다 비용 효율적인 장기 저장소로 이동할 수 있습니다.

**효율적인 이진 형식을 사용하여 DTO(Data Transfer Object) 최적화**. DTO는 애플리케이션 계층 간에 여러 번 전달됩니다. 크기를 최소화하면 리소스 및 네트워크에 대한 부하가 감소합니다. 그러나 데이터를 해당 데이터가 사용되는 각 위치에서 필요한 형식으로 변환하는 오버헤드와 비용 절감의 균형을 유지하세요. 상호 운용성이 가장 뛰어난 형식을 채택하여 구성 요소를 손쉽게 다시 사용할 수 있도록 해야 합니다.

**캐시 제어 설정**. 가능한 경우 출력 캐싱 또는 조각 캐싱을 사용하도록 애플리케이션을 디자인 및 구성하여 처리 부하를 최소화합니다.

**클라이언트 쪽 캐싱 사용**. 웹 애플리케이션은 캐시 가능한 콘텐츠에 대해 캐시 설정을 사용해야 합니다. 일반적으로 이 기능은 기본적으로 사용하지 않도록 설정됩니다. 프록시 서버 및 클라이언트에서 콘텐츠를 캐시할 수 있게 적절한 캐시 제어 헤더를 제공하도록 서버를 구성합니다.

**Azure Blob Storage 및 Azure Content Delivery Network를 사용하여 응용 프로그램 부하 감소**. 이미지, 리소스, 스크립트, 스타일 시트 등 정적이거나 비교적 정적인 공용 콘텐츠를 Blob Storage에 저장하는 것이 좋습니다. 이 접근 방식은 각 요청에 대해 이러한 콘텐츠를 동적으로 생성함에 따라 발생하는 애플리케이션 부하를 줄여 줍니다. 또한 Content Delivery Network를 사용하여 이 콘텐츠를 캐시하고 클라이언트에 배달하는 것이 좋습니다. Content Delivery Network를 사용하면 콘텐츠가 Content Delivery Network 캐시를 포함하는 지리적으로 가장 가까운 데이터 센터에서 배달되기 때문에 클라이언트의 성능이 향상됩니다. 자세한 내용은 [Content Delivery Network 지침](../best-practices/cdn.md)을 참조하세요.

**SQL 쿼리 및 인덱스 최적화 및 튜닝**. 일부 T-SQL 문 또는 구문은 성능에 영향을 줄 수 있으며, 이러한 영향은 저장 프로시저의 코드를 최적화하여 줄일 수 있습니다. 예를 들어 **datetime** 리터럴 값과 비교하기 전에 **datetime** 형식을 **varchar**로 변환하지 마세요. 대신 date/time 비교 함수를 사용합니다. 적절한 인덱스가 없으면 쿼리 실행 속도가 느려질 수 있습니다. 개체/관계형 매핑 프레임워크를 사용하는 경우 작동 방식 및 데이터 액세스 계층의 성능에 영향을 줄 수 있는 방식을 이해해야 합니다. 자세한 내용은 [쿼리 튜닝](https://technet.microsoft.com/library/ms176005.aspx)을 참조하세요.

**데이터 비정규화**. 데이터 정규화는 중복 및 불일치를 방지하는 데 도움이 됩니다. 그러나 여러 인덱스를 유지 관리하고, 참조 무결성을 확인하고, 소량의 데이터에 여러 번 액세스하고, 테이블을 조인하여 데이터를 다시 어셈블해야 하기 때문에 성능에 영향을 줄 수 있는 오버헤드가 발생합니다. 데이터 저장소의 부하를 줄이기 위해 일부 추가 저장소 볼륨 및 중복을 허용할지 고려하세요. 또한 데이터 저장소의 부하를 줄이기 위해 참조 무결성 관리와 같은 작업을 애플리케이션 자체(일반적으로 확장이 보다 간편함)에서 수행할 수 있는지 고려하세요. 자세한 내용은 [데이터 분할 지침](../best-practices/data-partitioning.md)을 참조하세요.

## <a name="implementation"></a>구현

**성능 안티패턴을 검토합니다**. 애플리케이션이 압력을 받고 있을 때 확장성 문제를 일으킬 가능성이 있는 일반적인 사례는 [클라우드 애플리케이션의 성능 안티패턴](../antipatterns/index.md)을 참조하세요.

**비동기 호출 사용**. 호출 스레드 잠금을 방지하기 위하여 가능한 경우 I/O 또는 네트워크 대역폭으로 제한될 수 있거나 대기 시간이 긴 리소스 또는 서비스에 액세스할 때 비동기 코드를 사용합니다.

**리소스 잠금을 방지하고, 대신 낙관적 접근 방식 사용**. 저장소 또는 대기 시간이 긴 기타 서비스와 같은 리소스에 대한 액세스를 잠그면 안 됩니다. 이는 성능 저하의 주요 원인입니다. 항상 낙관적 접근 방법을 사용하여 저장소에 쓰기와 같은 동시 작업을 관리합니다. 저장소 기능을 사용하여 충돌을 관리하세요. 분산된 애플리케이션에서는 데이터의 일관성이 결과적으로만 유지될 수 있습니다.

**대기 시간이 높고 대역폭이 낮은 네트워크를 통해 압축성이 뛰어난 데이터 압축**. 웹 애플리케이션의 경우 대부분 애플리케이션에 의해 생성되고 네트워크를 통해 전달되는 데이터는 클라이언트 요청에 대한 HTTP 응답입니다. HTTP 압축은 특히 정적 콘텐츠의 경우 이러한 데이터를 크게 줄일 수 있습니다. 따라서 비용이 절감되고 네트워크 부하가 감소할 수 있습니다. 다만, 동적 콘텐츠 압축은 서버에 부분적으로 더 높은 부하를 적용합니다. 보다 일반적인 다른 환경에서는 데이터 압축을 통해 전송되는 데이터 양을 줄임으로써 전송 시간 비용을 최소화할 수 있지만 압축 및 압축 해제 프로세스는 오버헤드를 발생시킵니다. 따라서 압축은 성능에 명확히 유익한 경우에만 사용해야 합니다. JSON 또는 이진 인코딩과 같은 다른 직렬화 메서드는 성능에 대한 영향 없이 페이로드 크기를 줄일 수 있는 반면, XML은 이를 증가시킬 수 있습니다.

**연결 및 리소스 사용 시간 최소화**. 사용해야 하는 시간 동안만 연결 및 리소스를 유지 관리합니다. 예를 들어 연결을 최대한 늦게 열고 최대한 빨리 연결 풀로 되돌아갈 수 있도록 합니다. 또한 리소스를 최대한 늦게 획득하고 최대한 빨리 삭제합니다.

**필요한 연결 수 최소화**. 서비스 연결에는 리소스가 사용됩니다. 필요한 수를 제한하고 가급적 기존 연결을 다시 사용할 수 있도록 합니다. 예를 들어 인증을 수행한 후에는 적절한 경우 가장을 사용하여 코드를 특정 ID로 실행합니다. 이렇게 하면 연결을 다시 사용하여 연결 풀 사용을 최적화할 수 있습니다.
  
> [!NOTE]
> 서비스 관련 지침을 따를 경우 일부 서비스용 API는 자동으로 연결을 다시 사용합니다. 애플리케이션에서 사용하는 각 서비스에 연결을 다시 사용하는 조건을 이해하는 것이 중요합니다.

**요청을 일괄 처리로 보내 네트워크 사용 최적화**. 예를 들어 큐에 액세스할 때 메시지를 일괄 처리로 보내고 읽고, 저장소 또는 캐시에 액세스할 때 여러 읽기 또는 쓰기를 일괄 처리로 수행합니다. 이렇게 하면 네트워크를 통한 호출 수를 줄여 서비스 및 데이터 저장소의 효율성을 최대화시키는데 도움이 됩니다.

**가능한 경우 서버 쪽 세션 상태에 대한 요구 사항 방지** . 서버 쪽 세션 상태를 관리하려면 일반적으로 클라이언트 선호도(즉, 각 요청을 동일한 서버 인스턴스로 라우팅)가 필요하며, 이는 시스템 확장성에 영향을 줍니다. 클라이언트를 사용하는 서버에 대해 상태를 저장하지 않도록 클라이언트를 디자인하는 것이 가장 좋습니다. 그러나 애플리케이션에서 세션 상태를 유지해야 하는 경우에는 중요한 데이터 또는 대량의 클라이언트별 데이터를 애플리케이션의 모든 인스턴스에서 액세스할 수 있는 분산된 서버 쪽 캐시에 저장하세요.

**Table Storage 스키마 최적화**. 테이블 및 열 이름을 모든 쿼리와 함께 전달하고 처리해야 하는 Table Storage(예: Azure Table Storage)를 사용하는 경우 짧은 이름을 사용하여 이 오버헤드를 줄이는 것이 좋습니다. 그러나 너무 간결한 이름을 사용하여 가독성 및 관리 효율성이 저하되지 않도록 해야 합니다.

**배포 중 또는 애플리케이션 시작 시 리소스 종속성 만들기**. 리소스 존재 여부를 테스트한 다음, 없는 경우 리소스를 만드는 메서드에 대한 반복적인 호출을 방지합니다. Azure Storage 클라이언트 라이브러리의 *CloudTable.CreateIfNotExists* 및 *CloudQueue.CreateIfNotExists*와 같은 메서드가 이 패턴을 따릅니다. 저장소 테이블 또는 저장소 큐에 액세스할 때마다 이러한 메서드가 사전에 호출되면 상당한 오버헤드가 발생할 수 있습니다. 대신,

- 애플리케이션을 배포하거나 처음 시작할 때 필요한 리소스를 만듭니다(웹 또는 작업자 역할의 시작 코드에 대한 응답마다 *CreateIfNotExists* 에 대한 단일 호출만 허용됨). 그러나 코드에서 존재하지 않는 리소스에 대한 액세스를 시도하는 경우에 발생할 수 있는 예외를 처리해야 합니다. 이러한 경우는 예외를 기록하고 리소스가 누락되었음을 작업자에게 경고해야 합니다.
- 경우에 따라 예외 처리 코드의 일부로 누락된 리소스를 만드는 것이 적절할 수 있습니다. 그러나 리소스가 없는 것이 프로그래밍 오류(예: 철자가 잘못된 리소스 이름) 또는 다른 인프라 수준의 문제를 나타낼 수 있으므로 주의해야 합니다.

**경량 프레임워크 사용**. 리소스 사용, 실행 시간 및 애플리케이션의 전체 부하를 최소화하려면 사용할 API 및 프레임워크를 신중히 선택해야 합니다. 예를 들어 Web API를 사용하여 서비스 요청을 처리하면 애플리케이션 설치 공간을 줄이고 실행 속도를 높일 수 있지만 Windows Communication Foundation의 추가 기능이 필요한 고급 시나리오에는 적합하지 않을 수 있습니다.

**서비스 계정 수 최소화**. 예를 들어 연결을 제한하거나 유지 관리되는 연결 수가 적을수록 성능이 뛰어난 리소스 또는 서비스에 액세스할 경우 특정 계정을 사용합니다. 이 접근 방법은 데이터베이스와 같은 서비스에 일반적이지만, 원래 사용자의 가장으로 인해 작업을 정확하게 감사하는 기능에 영향을 줄 수 있습니다.

**성능 프로파일링 및 부하 테스트 수행** 배포 중, 테스트 루틴 과정, 최종 릴리스 전에 수행하여 애플리케이션이 정상적으로 실행되고 필요에 따라 확장되도록 합니다. 이 테스트는 데이터 및 사용자 부하의 유형 및 양이 프로덕션에서 발생하는 것과 동일한 상태에서 프로덕션 플랫폼과 동일한 유형의 하드웨어에서 수행되어야 합니다. 자세한 내용은 [클라우드 서비스의 성능 테스트](/azure/vs-azure-tools-performance-profiling-cloud-services/)를 참조하세요.
