---
title: Scalability checklist
description: Scalability checklist guidance for design concerns for Azure Autoscaling.
author: dragon119
ms.service: guidance
ms.topic: article
ms.date: 03/24/2017
ms.author: pnp
ms.custom: checklist
---
# 확장성 체크리스트
[!INCLUDE [header](../_includes/header.md)]

## 서비스 설계

* **워크로드를 분할합니다.** 프로세스 각 부분은 불연속적이고 분리 가능하도록 설계합니다. 각 부분의 크기를 최소화하면서, 관심사 분리(separation of concerns) 및 단일 책임 원칙에 대한 일반적 규칙을 따릅니다. 이를 통해 각 계산 단위(역할 또는 데이터베이스 서버 등)를 최대한 사용해 구성 요소 파트를  배포할 수 있습니다.  또한, 특정 리소스의 인스턴스를 추가함으로써 응용 프로그램의 크기를 더 간편하게 조정할 수 있습니다. 자세한 내용은 [계산 분할 지침](https://msdn.microsoft.com/library/dn589773.aspx)을 참조하십시오.

* **크기 조정이 가능하도록 설계합니다.** 크기 조정을 사용하면 응용 프로그램에서 역할, 큐, 기타 사용하는 서비스의 인스턴스 개수를 늘리거나 줄여 가변 부하에 대응할 수 있습니다.  단, 응용 프로그램 설계 시 이를 염두에 두어야 합니다. 예를 들어, 응용 프로그램 및 그에 사용되는 서비스는 상태 비저장(stateless)이어야, 요청을 다른 인스턴스로 라우팅할 수 있습니다. 이는 또한 특정 인스턴스를 추가 또는 제거할 때 현재 사용자에게 부정적인 영향이 미치지 않도록 합니다. 또한, 인스턴스 추가 및 삭제에 따른 인스턴스의 구성 또는 자동 감지를 구현하여, 응용 프로그램의 코드로 필요한 라우팅을 수행할 수 있도록 합니다. 예를 들어, 웹 응용 프로그램은 라운드 로빈 방식의 큐를 사용해 작업자 역할로 실행 중인 백그라운드 서비스에 요청을 라우팅할 수 있습니다.  웹 응용 프로그램은 요청을 성공적으로 라우팅하고 응용 프로그램의 부하를 분산하기 위해 큐 개수 변경을 감지할 수 있어야 합니다.

* **한 단위로 크기 조정을 수행합니다.** 추가 리소스가 증가에 대응할 수 있도록 계획합니다. 각 리소스에 대한 크기 상한값을 파악하고 이 한도를 초과하려면 분할이나 구성 분해를 적용합니다. 잘 정의된 리소스 집합을 기준으로 시스템의 크기 조정 단위를 결정합니다. 이렇게 함으로써, 크기 조정 작업을 간편하게 적용할 수 있으며, 전체 시스템 중 일부 파트의 리소스 부족으로 인한 제한을 통해 응용 프로그램에 부정적 영향을 줄 가능성이 줄어 듭니다. 예를 들어, 웹 및 작업자 역할 x개를 추가하면, 해당 역할에서 발생하는 추가 작업을 처리하기 위해 큐 y개와 저장소 계정 z개가 더 필요할 수 있습니다.  그러므로 크기 조정 단위는 x개의 웹 및 작업자 역할, y개의 큐, z개의 저장소 계정으로 구성될 수 있습니다. 응용 프로그램은 한 개 이상의 크기 조정 단위를 추가하여 간편하게 크기를 조정할 수 있도록 설계합니다.

* **클라이언트 선호도를 사용하지 않습니다.** 응용 프로그램은 최대한 선호도를 사용하지 않도록 해야 합니다. 그래야 어느 인스턴스에나 요청을 라우팅할 수 있으며, 인스턴스의 수는 관련이 없습니다. 이는 또한 각 사용자의 저장, 검색, 유지 관리 상태 정보에 대한 오버헤드를 방지합니다. 

* **플랫폼 자동 크기 조정 기능을 활용합니다.** 호스트 플랫폼이 Azure Autoscale 등의 자동 크기 조정 기능을 지원하는 경우, 기본 제공 메커니즘으로 요구사항이 충족된다면 사용자 지정 또는 타사 메커니즘보다 좋습니다. 가능하면 계획된 크기 조정 규칙을 사용하여 스타트업 지연 없이 리소스를 사용할 수 있도록 하며, 단 해당되는 경우 반응적 자동 크기 조정을 규칙에 추가하여 예상치 못한 요구 사항 변화에 대처하도록 합니다. 서비스 관리 API의 자동 크기 조정 동작을 사용하여 크기를 자동 조정하고 사용자 지정 카운터를 규칙에 추가할 수 있습니다. 자세한 내용은 [자동 크기 조정 지침](../best-practices/auto-scaling.md)을 참조하십시오.

* **집약적 CPU/IO 작업을 백그라운드 작업으로 오프로딩합니다.** 서비스 요청이 장시간 동안 상당한 리소스를 실행하거나 차지할 것으로 예상되는 경우, 해당 요청의 처리를 별도의 작업으로 오프로딩합니다. 작업자 역할 또는 백그라운드 작업을 사용해(호스팅 플랫폼에 따라 결정) 이러한 작업을 실행합니다. 이러한 전략으로 서비스는 계속 요청을 받고 응답 상태를 유지할 수 있습니다. 자세한 내용은 [백그라운드 작업 지침](../best-practices/background-jobs.md)을 참조하십시오.

* **백그라운드 작업의 워크로드를 분산합니다.** 백그라운드 작업이 많거나 작업에 상당한 시간 또는 리소스가 소요되는 경우, 작업을 여러 계산 단위로(작업자 역할, 백그라운드 작업 등) 분배합니다. [경쟁적 소비자 패턴](https://msdn.microsoft.com/library/dn568101.aspx)에서 가능성 있는 솔루션 한 가지를 확인하십시오.

* ***비공유(shared-nothing)* 아키텍처로 전환합니다.** 비공유 아키텍처는 단일 경합 지점(공유 서비스 또는 저장소 등)이 없는 독립적 자급 노드를 사용합니다.  이론상 그러한 시스템은 거의 무제한으로 크기 조정이 가능합니다. 일반적으로 완전 무공유 방식은 대부분의 응용 프로그램에 실현 가능성은 없지만, 확장성 향상시키는 설계를 할 기회가 될 수 있습니다.  예를 들어, 서버 쪽 세션 상태, 클라이언트 선호도, 데이터 분할을 사용하지 않는 것은 비공유 아키텍처로 이동하는 좋은 예가 됩니다.

## 데이터 관리

* **데이터 분할을 사용합니다.** 데이터를 여러 개의 데이터베이스 및 데이터베이스 서버로 나누거나, 응용 프로그램에서 투명한 분할 기능이 있는 데이터 저장소 서비스를 사용하도록 설계합니다(Azure SQL 데이터베이스 Elastic Database, Azure 테이블 저장소 등). 이러한 방식을 통해 성능을 최대화하고 간편하게 크기를 조정할 수 있습니다. 분할 기술은 수평, 수직, 기능 분할 등 다양하게 있습니다. 이 중 여러 기술을 결합해서 쿼리 성능 증대, 간소한 확장성, 유연한 관리, 가용성 향상 등의 장점을 극대화하고 저장소 유형과 저장할 데이터를 일치시킬 수 있습니다. 또한, 다양한 데이터 유형에 대해 여러 유형의 데이터 저장소를 사용하고, 특정 데이터 유형에 최적화되는 상태에 따라 저장소 유형을 선택하는 것이 좋습니다.  여기에는 관계형 데이터베이스 대신에 또는 이와 더불어 테이블 저장소, 문서 데이터베이스 또는 칼럼 패밀리(column-family) 데이터 저장소의 사용이 포함될 수 있습니다. 자세한 내용은 [데이터 분할 지침](../best-practices/data-partitioning.md)을 참조하십시오.

* **최종 일관성을 고려해 설계합니다.** 최종 일관성은 여러 저장소로 분할된 관련 데이터를 동기화하는 데 소요되는 시간을 단축하거나 제거함으로써 확장성을 개선합니다. 단, 데이터 읽기 시 데이터가 항상 일관적이지 않으며, 쓰기 작업으로 충돌이 발생하는 경우가 있습니다. 최종 일관성은 같은 데이터를 자주 읽지만 쓰기는 자주 수행하지 않는 경우에 적합합니다. 자세한 내용은 [데이터 일관성 지침](https://msdn.microsoft.com/library/dn589800.aspx)을 참조하십시오.

* **구성 요소와 서비스 간 수다스러운 상호 작용을 줄입니다.** 모든 데이터를 반환할 수 있는 단일 호출이 아니라, 응용 프로그램이 서비스를 여러 번 호출해야(호출마다 소량의 데이터를 반환함) 하는 상호 작용은 설계하지 않습니다. 지연이 두드러지는 서비스 또는 구성 요소에 호출할 때 가능하면 관련된 여러 작업을 단일 요청으로 결합합니다. 이렇게 함으로써 간편하게 성능을 최적화하고 복잡한 작업을 최적화할 수 있습니다. 예를 들어, 데이터베이스에 저장된 절차를 사용해 복잡한 논리를 캡슐화하고, 왕복 및 리소스 잠금 횟수를 줄입니다.

* **큐를 사용해 고속 데이터 쓰기에 대한 부하를 평준화합니다.** 서비스 요청이 급증하면 해당 서비스에 과부하가 걸리고 오류가 확대될 수 있습니다. 이를 방지하려면 [큐 기반 부하 평준화 패턴](https://msdn.microsoft.com/library/dn589783.aspx)을 구현하는 것이 좋습니다. 작업과 그로 인해 호출되는 서비스 간에 버퍼 역할을 할 큐를 사용합니다. 이렇게 하면 서비스 실패 또는 작업 시간 초과를 일으킬 수 있는 일시적 과부하를 해결할 수 있습니다.

* **데이터 저장소의 부하를 최소화합니다.** 데이터 저장소는 대개 처리 병목 지점으로 비용이 높은 리소스이며 규모를 쉽게 확장할 수 없는 경우가 많습니다.  가능하면 데이터 저장소에서 논리(XML 문서 또는 JSON 개체 처리 등)를 제거하고 응용 프로그램 내에서 처리합니다.  예를 들어, XML을 데이터베이스로 전달하는 대신(저장소에 대한 불명확한 문자열이 아닌), 응용 프로그램 계층 내에서 XML을 직렬화 또는 역직렬화하여 이를 데이터 저장소의 기본 형식으로 전달합니다. 일반적으로 데이터 저장소보다 응용 프로그램을 확장하는 것이 훨씬 쉬우므로 계산 집약적인 처리는 가능한 응용 프로그램 내에서 수행합니다.

* **검색된 데이터의 볼륨을 최소화합니다.** 열을 지정하고 행 선택 기준을 적용하여 필요한 데이터만 검색합니다. 테이블 값 매개 변수 및 적절한 격리 수준을 사용합니다.  엔터티 태그 같은 매커니즘을 사용하여 불필요한 데이터 검색을 방지합니다. 

* **적극적으로 캐싱을 사용합니다.** 캐싱을 최대한 사용하여 데이터를 생성하거나 전달하는 리소스 및 서비스에 대한 부하를 줄입니다. 일반적으로 캐싱은 비교적 정적인 데이터 또는 가져오기 처리가 복잡한 데이터에 적합합니다.  해당되는 경우, 캐싱은 데이터 액세스 및 사용자 인터페이스 생성을 포함해 응용 프로그램의 각 계층 내 모든 수준에서 발생해야 합니다. 자세한 내용은 [캐싱 지침](../best-practices/caching.md)을 참조하십시오.

* **데이터 증가 및 보존을 관리합니다.** 응용 프로그램에서 저장하는 데이터 양은 시간이 지나면서 증가합니다. 이로 인해 저장소 비용이 올라가고 데이터 액세스 대기 시간이 길어져, 응용 프로그램 처리량과 성능에 영향을 줍니다.  액세스가 없는 일부 노후 데이터는 주기적으로 아카이브로 압축하거나, 가끔 액세스하는 데이터는 장기 저장소로 이동하면 액세스 대기 시간이 더 길더라도 비용 효율성을 높일 수 있습니다.

* **효율적 이진 형식을 사용해 DTO(Data Transfer Object)를 최적화합니다.** DTO는 응용 프로그램 계층 간에 여러 번 전달됩니다. 크기를 최소화하면 리소스 및 네트워크에 대한 부하가 감소합니다. 그러나, 이러한 부하 감소는 데이터를 각 사용 위치에 필요한 형식으로 변환하는 오버헤드에 의해 상쇄됩니다. 상호 운용성이 가장 뛰어난 형식을 채택하여 구성 요소를 쉽게 재사용할 수 있도록 합니다.

* **캐싱 제어를 설정합니다.** 가능하면 출력 캐싱 또는 조각 캐싱을 사용하도록 응용 프로그램을 설계, 구성하여 처리 부하를 최소화합니다.

* **클라이언트 쪽 캐싱을 사용합니다.** 웹 응용 프로그램에서 캐싱 가능한 콘텐츠에 대해 캐싱을 설정할 수 있어야 합니다.  일반적으로 이 기능은 기본값으로 비활성화되어 있습니다. 서버가 적절한 캐시 제어 헤더를 제공하도록 구성하여, 프록시 서버 및 클라이언트에 콘텐츠를 캐시할 수 있도록 합니다.

* **Azure Blob 저장소 및 Azure 콘텐츠 전달 네트워크를 사용하여 응용 프로그램의 부하를 줄입니다.** 이미지, 리소스, 스크립트, 스타일 시트 등 정적 혹은 상대적으로 정적인 공용 콘텐츠를 Blob 저장소에 저장하는 것이 좋습니다.  이 방식을 적용하면, 각 요청에 대해 이러한 콘텐츠를 동적으로 생성함으로써 발생하는 응용 프로그램 부하가 감소합니다. 또한 ,콘텐츠 배달 네트워크를 사용해 이 콘텐츠를 캐시하고 이를 클라이언트에 배달하는 것이 좋습니다.  콘텐츠 배달 네트워크를 사용하면 가장 인접해 있으면서 콘텐츠 배달 네트워크 캐시를 포함한 데이터 센터에서 콘텐츠가 배달되기 때문에 클라이언트에서 성능을 개선할 수 있습니다.  자세한 내용은 [콘텐츠 배달 네트워크 지침](../best-practices/cdn.md)을 참조하십시오.

* **SQL 쿼리 및 인덱스를 최적화하고 튜닝합니다.** 일부 T-SQL 설명문 또는 구문은 성능에 영향을 줄 수 있으며, 이는 저장 절차의 코드를 최적화하여 줄일 수 있습니다. 예를 들어, datetime 리터럴 값과 비교하기 전에 datetime 형식을 varchar로 변환하지 않습니다.  대신 date/time 비교 함수를 사용합니다.  적절한 인덱스가 없으면 쿼리 실행 속도가 느려질 수 있습니다. 개체/관계형 매핑 프레임워크를 사용하는 경우 그 원리와 데이터 액세스 계층 성능에 미칠 수 있는 영향을 이해해야 합니다. 자세한 내용은 [쿼리 튜닝](https://technet.microsoft.com/library/ms176005.aspx)을 참조하십시오.

* **데이터를 비정규화합니다.** 데이터 정규화는 중복 및 불일치를 방지할 수 있습니다. 그러나 여러 인덱스를 유지 관리하고 참조 무결성을 확인하고 소량의 데이터에 여러 번 액세스하고 테이블을 결합하여 데이터를 다시 조합하면서 성능에 영향을 주는 오버헤드가 발생합니다. 데이터 저장소의 부하를 줄이기 위해 일부 추가 저장소 볼륨 및 중복을 허용할 지 고려합니다.  또한, 데이터 저장소의 부하를 줄이기 위해 참조 무결성 관리와 같은 작업을 응용 프로그램 자체(일반적으로 확장이 더욱 간편함)에서 수행할 수 있는지 고려합니다.  자세한 내용은 [데이터 분할 지침](../best-practices/data-partitioning.md)을 참조하십시오.

## 서비스 구현

* **비동기 호출을 사용합니다.** 호출 스레드 잠금을 사용하지 않으려면, I/O 또는 네트워크 대역폭으로 제한하거나 대기 시간이 긴 리소스 또는 서비스에 액세스할 때 가능하면 비동기 코드를 사용합니다.  비동기 작업을 구현하려면 [작업 기반 비동기 패턴(TAP)](https://msdn.microsoft.com/library/hh873175.aspx)을 사용합니다.

* **리소스 잠금 대신 낙관적 방식을 사용합니다.** 저장소 등의 리소스 또는 대기 시간이 긴 기타 서비스에 대한 액세스는 잠글 수 없습니다. 성능 저하의 주요 원인이 되기 때문입니다. 저장소에 쓰기 등 동시 작업을 관리할 때는 반드시 낙관적 방식을 적용합니다. 저장소 계층 기능을 사용하여 충돌을 관리합니다. 분산 응용 프로그램에서, 데이터는  최종 일관성만 확보할 수 있습니다.

* **대기 시간이 길고 대역폭이 낮은 네트워크에서 고압축성 데이터를 압축합니다.** 일반적으로 웹 응용 프로그램에서, 응용 프로그램에 의해 생성되고 네트워크를 통해 전달되는 데이터는 대부분 클라이언트 요청에 대한 HTTP 응답입니다. HTTP 압축으로 특히 정적 콘텐츠에 대해 이를 크게 줄일 수 있습니다.  따라서 비용을 절감하고 네트워크 부하를 줄일 수 있습니다. 단, 동적 콘텐츠 압축으로 인해 서버에 가해지는 부하는 약간 더 증가합니다. 보다 일반적인 다른 환경에서는 데이터 압축을 통해 데이터 전송량을 줄이고 전송 시간과 비용을 최소화할 수 있지만, 압축 및 압축 해제 프로세스는 오버헤드를 발생시킵니다.  따라서 압축은 성능에 명백하게 향상되는 경우에만 사용해야 합니다.  JSON 또는 이진 인코딩과 같은 다른 직렬화 메서드는 성능을 크게 저하시키지 않고 페이로드 크기를 줄일 수 있지만, XML은 이를 증가시킬 수 있습니다.

* **연결 및 리소스 사용 시간을 최소화합니다.** 연결 및 리소스를 사용하는 동안만 유지합니다.  예를 들어, 연결을 최대한 늦게 인가하고 최대한 빨리 연결 풀로 반환되도록 합니다.  리소스는 최대한 늦게 가져오고 최대한 빨리 삭제합니다.

* **필요한 연결 수를 최소화합니다.** 서비스 연결에는 리소스가 사용됩니다.  필요한 수를 제한하고 가능하면 기존 연결을 다시 사용할 수 있도록 합니다.  예를 들어 인증을 수행한 후에는, 필요에 따라 대리 실행 기능을 사용해 특정 ID로 코드를 실행합니다.  이렇게 하면 연결을 다시 사용하여 연결 풀 사용을 최대한 활용할 수 있습니다.
  
  > [!참고]
  > : 서비스별 지침을 따를 경우 일부 서비스의 API는 자동으로 연결을 다시 사용합니다.  응용 프로그램에서 사용하는 각 서비스에 대해 연결 재사용 조건을 파악해야 합니다.
  > 
  > 
* **일괄 요청 전송으로 네트워크 사용을 최적화합니다.** 예를 들어 큐에 액세스할 때 메시지를 일괄적으로 보내고 읽으며, 저장소 또는 캐시에 액세스할 때 여러 번의 읽기 또는 쓰기를 일괄적으로 수행합니다.  이렇게 하면 네트워크 상의 호출 수를 줄여 서비스 및 데이터 저장소의 효율성을 극대화할 수 있습니다.

* **서버 쪽 세션 상태 저장 요구사항을 사용하지 않습니다.** 서버 쪽 세션 상태 관리에는 대개 클라이언트 선호도(각 요청을 동일한 서버 인스턴스로 라우팅하는 것)가 필요하며, 이는 시스템 확장성에 영향을 줍니다.  클라이언트는 해당 서버에 관한 상태를 저장하지 않도록 설계하는 것이 가장 좋습니다. 그러나 응용 프로그램에서 세션 상태를 유지해야 하는 경우 중요한 데이터 또는 대량의 클라이언트별 데이터를 분산된 서버 쪽 캐시에 저장하여 응용 프로그램의 모든 인스턴스에서 액세스할 수 있게 합니다.

* **테이블 저장소 스키마를 최적화합니다.** Azure 테이블 저장소와 같이, 모든 쿼리에 테이블 및 열 이름이 같이 전달되고 처리되는 테이블 저장소(예: Azure 테이블 저장소)의 경우, 짧은 이름을 사용하여 이러한 오버헤드를 줄이는 것이 좋습니다.  그러나 너무 간결한 이름을 사용하여 가독성이나 관리 효율성이 떨어지지 않도록 합니다.

* **TPL(작업 병렬 라이브러리)를 사용하여 비동기 작업을 수행합니다.** TPL을 사용하면 I/O 바인딩된 작업을 수행하는 비동기 코드를 쉽게 작성할 수 있습니다. 가능하면 ConfigureAwait(false)를 사용하여 특정 동기화 환경에서 구성 종속성을 제거합니다.  이렇게 하면 스레드 교착 상태의 발생 가능성이 낮아집니다.

* **배포 중 또는 응용 프로그램 시작 시 리소스 종속성을 만듭니다.** 리소스 존재 여부를 테스트한 다음 존재하지 않는 경우 리소스를 만드는 메서드에 대해 반복 호출을 하지 않습니다. (Azure 저장소 클라이언트 라이브러리의 *CloudTable.CreateIfNotExists* 및 *CloudQueue.CreateIfNotExists* 등의 메서드가 이 패턴을 따릅니다.) 저장소 테이블 또는 저장소 큐에 액세스할 때마다 이러한 메서드를 호출하면 상당한 오버헤드가 발생할 수 있습니다. 대신 다음과 같이 수행합니다.

  * 응용 프로그램을 배포하거나 처음 시작할 때 필요한 리소스를 만듭니다(웹 또는 작업자 역할의 시작 코드에 있는 각 리소스에 대해 *CreateIfNotExists*에 대한 단일 호출만 허용됨).  단, 코드가 존재하지 않는 리소스에 액세스를 시도할 때 발생할 수 있는 예외를 처리해야 합니다.  이러한 경우, 예외를 기록하고 리소스가 누락되었음을 작업자에게 경고해야 합니다.
  
  * 경우에 따라 예외 처리 코드의 일부로 누락된 리소스를 만드는 것이 좋습니다. 그러나 리소스가 존재하지 않는다는 것은 프로그래밍 오류(리소스 이름의 철자 오류 등) 또는 기타 인프라 수준의 문제를 나타낼 수 있으므로 신중하게 접근해야 합니다. 
  
* **경량 프레임워크를 사용합니다.** 리소스 사용, 실행 시간, 응용 프로그램의 전체 부하를 최소화하려면 사용할 API 및 프레임워크를 신중히 선택해야 합니다. 예를 들어, Web API를 사용해 서비스 요청을 처리하면 응용 프로그램 설치 공간을 줄이고 실행 속도를 높일 수 있지만 Windows Communication Foundation의 추가 기능이 필요한 고급 시나리오에는 적합하지 않을 수 있습니다.

* **서비스 계정 수를 최소화합니다.** 예를 들어, 연결을 제한하거나 유지되는 연결 수가 적어 성능이 뛰어난 리소스 또는 서비스에 액세스할 때 특정 계정을 사용합니다.  이러한 방식은 데이터베이스와 같은 서비스에는 일반적이지만, 원래 사용자의 대리 실행으로 인해 작업 감사의 정확성에 영향을 줄 수 있습니다.

* **테스트 루틴의 한 과정으로 배포하는 동안 그리고 최종 릴리스 전에 성능 프로파일링 및 부하 테스팅을 수행하여, 응용 프로그램의 성능과 크기가 요구사항에 맞는지 확인합니다.** 이 테스트는 프로덕션 플랫폼과 같은 유형의 하드웨어에서, 프로덕션과 똑같은 유형 및 수량의 데이터와 사용자 부하를 가하여 실시해야 합니다. 자세한 내용은 [클라우드 서비스 성능 테스트](/azure/vs-azure-tools-performance-profiling-cloud-services/)를 참조하십시오.

