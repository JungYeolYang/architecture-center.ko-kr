---
title: "가용성 검사 목록"
description: "설계하는 동안 가용성 문제에 대한 지침을 제공하는 검사 목록입니다."
author: dragon119
ms.date: 03/24/2017
ms.custom: checklist
ms.openlocfilehash: 14e6cd6f25f613ea9793b5cf6c4f1abe6f405b74
ms.sourcegitcommit: b0482d49aab0526be386837702e7724c61232c60
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/14/2017
---
# <a name="availability-checklist"></a><span data-ttu-id="f2134-103">가용성 검사 목록</span><span class="sxs-lookup"><span data-stu-id="f2134-103">Availability checklist</span></span>
[!INCLUDE [header](../_includes/header.md)]

## <a name="application-design"></a><span data-ttu-id="f2134-104">응용 프로그램 설계</span><span class="sxs-lookup"><span data-stu-id="f2134-104">Application design</span></span>
* <span data-ttu-id="f2134-105">**모든 단일 지점 장애를 방지합니다.**</span><span class="sxs-lookup"><span data-stu-id="f2134-105">**Avoid any single point of failure.**</span></span> <span data-ttu-id="f2134-106">모든 구성 요소, 서비스, 리소스 및 계산 인스턴스는 여러 인스턴스로 배포하여 단일 실패 지점이 가용성에 영향을 주지 않도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-106">All components, services, resources, and compute instances should be deployed as multiple instances to prevent a single point of failure from affecting availability.</span></span> <span data-ttu-id="f2134-107">여기에 인증 메커니즘을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-107">This includes authentication mechanisms.</span></span> <span data-ttu-id="f2134-108">여러 인스턴스를 사용한 구성이 가능하도록 응용 프로그램을 설계하고 플랫폼이 자동으로 이를 수행하지 않는 곳에서 자동으로 오류를 검색하며 실패하지 않은 인스턴스에 요청을 리디렉션합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-108">Design the application to be configurable to use multiple instances, and to automatically detect failures and redirect requests to non-failed instances where the platform does not do this automatically.</span></span>
* <span data-ttu-id="f2134-109">**다른 서비스 수준 계약당 워크로드를 분해합니다.**</span><span class="sxs-lookup"><span data-stu-id="f2134-109">**Decompose workload per different service-level agreement.**</span></span> <span data-ttu-id="f2134-110">서비스가 중요하고 덜 중요한 워크로드로 구성되면 다르게 관리하도록 하고 해당 가용성 요구 사항에 맞게 서비스 기능 및 인스턴스 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-110">If a service is composed of critical and less-critical workloads, manage them differently and specify the service features and number of instances to meet their availability requirements.</span></span>
* <span data-ttu-id="f2134-111">**서비스 종속성을 최소화하고 이해합니다.**</span><span class="sxs-lookup"><span data-stu-id="f2134-111">**Minimize and understand service dependencies.**</span></span> <span data-ttu-id="f2134-112">사용 가능한 경우 다른 서비스의 수를 최소화하고 모든 시스템에 존재하는 기능 및 서비스 종속성을 이해합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-112">Minimize the number of different services used where possible, and ensure you understand all of the feature and service dependencies that exist in the system.</span></span> <span data-ttu-id="f2134-113">이는 이러한 종속성의 특성 및 전체 응용 프로그램에서 각각의 실패 또는 성능 저하의 영향을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-113">This includes the nature of these dependencies, and the impact of failure or reduced performance in each one on the overall application.</span></span> <span data-ttu-id="f2134-114">Microsoft는 대부분의 서비스에 대해 99.9%의 가용성을 보장하지만 이것은 잠재적으로 응용 프로그램이 의존하는 모든 추가 서비스가 시스템의 전반적인 가용성 SLA을 0.1% 낮춘다는 점을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-114">Microsoft guarantees at least 99.9 percent availability for most services, but this means that every additional service an application relies on potentially reduces the overall availability SLA of your system by 0.1 percent.</span></span>
* <span data-ttu-id="f2134-115">**가능한 경우에 멱등된(안전하게 반복 가능한) 작업 및 메시지 설계**하여 중복된 요청에 문제가 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-115">**Design tasks and messages to be idempotent (safely repeatable) where possible**, so that duplicated requests will not cause problems.</span></span> <span data-ttu-id="f2134-116">예를 들어, 서비스는 생산자로 작동하는 시스템의 다른 부분의 요청으로 전송된 메시지를 처리하는 소비자로 작동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-116">For example, a service can act as a consumer that handles messages sent as requests by other parts of the system that act as producers.</span></span> <span data-ttu-id="f2134-117">소비자가 메시지를 처리한 후 실패하면 처리가 승인되기 전에 생산자는 소비자의 다른 인스턴스에 의해 처리될 수 있는 반복 요청을 제출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-117">If the consumer fails after processing the message, but before acknowledging that it has been processed, a producer might submit a repeat request which could be handled by another instance of the consumer.</span></span> <span data-ttu-id="f2134-118">이러한 이유로 소비자와 소비자가 수행하는 작업은 멱등하므로 이전에 실행된 작업을 반복하는 것이 잘못된 결과를 렌더링하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-118">For this reason, consumers and the operations they carry out should be idempotent so that repeating a previously executed operation does not render the results invalid.</span></span> <span data-ttu-id="f2134-119">이는 충돌 처리에 대해 낙관적 접근법을 사용하여 중복된 메시지를 감지 또는 일관성 보장을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-119">This may mean detecting duplicated messages, or ensuring consistency by using an optimistic approach to handling conflicts.</span></span>
* <span data-ttu-id="f2134-120">**중요한 트랜잭션에 대한 고가용성을 구현하는 메시지 브로커를 사용합니다.**</span><span class="sxs-lookup"><span data-stu-id="f2134-120">**Use a message broker that implements high availability for critical transactions.**</span></span> <span data-ttu-id="f2134-121">작업을 시작하거나 원격 서비스에 액세스 하는 대부분의 시나리오는 응용 프로그램 및 대상 서비스 간에 지침을 전달하기 위해 메시징을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-121">Many scenarios for initiating tasks or accessing remote services use messaging to pass instructions between the application and the target service.</span></span> <span data-ttu-id="f2134-122">최상의 성능을 위해 응용 프로그램에서 메시지를 보내고 회신을 기다릴 필요 없이 더 많은 요청을 처리하려고 돌아갈 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-122">For best performance, the application should be able to send the message and then return to process more requests, without needing to wait for a reply.</span></span> <span data-ttu-id="f2134-123">메시지 배달을 보장하려면 메시징 시스템이 고가용성을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-123">To guarantee delivery of messages, the messaging system should provide high availability.</span></span> <span data-ttu-id="f2134-124">Azure Service Bus 메시지 큐는 *한 번 이상* 의미 체계를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-124">Azure Service Bus message queues implement *at least once* semantics.</span></span> <span data-ttu-id="f2134-125">즉 특정 상황에서 중복된 복사본을 배달할 수 있지만 큐에 게시된 각 메시지가 손실되지 않음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-125">This means that each message posted to a queue will not be lost, although duplicate copies may be delivered under certain circumstances.</span></span> <span data-ttu-id="f2134-126">메시지 처리가 멱등 상태이면(이전 항목 참조) 반복된 배달이 문제가 아니어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-126">If message processing is idempotent (see the previous item), repeated delivery should not be a problem.</span></span>
* <span data-ttu-id="f2134-127">리소스 한계에 도달하는 경우 **응용 프로그램을 정상적으로 저하하여 설계하고** 사용자에 대한 영향을 최소화하기 위해 적절 한 동작을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-127">**Design applications to gracefully degrade** when reaching resource limits, and take appropriate action to minimize the impact for the user.</span></span> <span data-ttu-id="f2134-128">일부 경우에는 응용 프로그램에서 부하가 하나 이상의 부분 용량을 초과하여 가용성을 감소시키고 연결이 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-128">In some cases, the load on the application may exceed the capacity of one or more parts, causing reduced availability and failed connections.</span></span> <span data-ttu-id="f2134-129">크기 조정은 이를 완화하는데 도움이 되지만 리소스 가용성 또는 비용 같은 다른 요인에 의해 제한에 도달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-129">Scaling can help to alleviate this, but it may reach a limit imposed by other factors, such as resource availability or cost.</span></span> <span data-ttu-id="f2134-130">이 상황에서 응용 프로그램을 디자인하여 정상적이게끔 자동으로 저하되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-130">Design the application so that, in this situation, it can automatically degrade gracefully.</span></span> <span data-ttu-id="f2134-131">예를 들어, 전자 상거래 시스템에서 주문 처리 하위 시스템이 부담을 받으면(또는 완전히 실패하면) 다른 기능을 계속 허용하는 동안 임시로 사용하지 않을 수 있습니다 (예: 제품 카탈로그 찾아보기)</span><span class="sxs-lookup"><span data-stu-id="f2134-131">For example, in an ecommerce system, if the order-processing subsystem is under strain (or has even failed completely), it can be temporarily disabled while allowing other functionality (such as browsing the product catalog) to continue.</span></span> <span data-ttu-id="f2134-132">예를 들어 주문 하위 시스템을 다시 사용할 수 있는 경우 주문을 제출할 수 있지만 나중에 처리하기 위해 저장하는 것처럼 결함이 있는 하위 시스템에 요청을 연기하는 것이 적절할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-132">It might be appropriate to postpone requests to a failing subsystem, for example still enabling customers to submit orders but saving them for later processing, when the orders subsystem is available again.</span></span>
* <span data-ttu-id="f2134-133">**빠른 버스트 이벤트를 정상적으로 처리 합니다.**</span><span class="sxs-lookup"><span data-stu-id="f2134-133">**Gracefully handle rapid burst events.**</span></span> <span data-ttu-id="f2134-134">대부분의 응용 프로그램은 비즈니스 응용 프로그램에서 아침 또는 전자 상거래 사이트에서 새 제품 출시 시에 최대치와 같은 시간에 따라 다양한 워크로드를 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-134">Most applications need to handle varying workloads over time, such as peaks first thing in the morning in a business application or when a new product is released in an ecommerce site.</span></span> <span data-ttu-id="f2134-135">자동 크기 조정은 부하를 처리를 도울 수 있지만 추가 인스턴스를 온라인 상태로 전환하고 요청을 처리하는 데 약간의 시간이 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-135">Auto-scaling can help to handle the load, but it may take some time for additional instances to come online and handle requests.</span></span> <span data-ttu-id="f2134-136">응용 프로그램이 사용하는 서비스에 대한 큐 요청에 맞고 큐가 전체 용량에 가까운 경우 정상적으로 저하되도록 설계하여 응용 프로그램에 부담을 주는 갑작스럽고 예상하지 않은 활동의 버스트를 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-136">Prevent sudden and unexpected bursts of activity from overwhelming the application: design it to queue requests to the services it uses and degrade gracefully when queues are near to full capacity.</span></span> <span data-ttu-id="f2134-137">버스트하지 않은 조건에서 사용 가능한 충분한 성능 및 용량이 있는지 확인하여 큐를 비우고 처리되지 않은 요청을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-137">Ensure that there is sufficient performance and capacity available under non-burst conditions to drain the queues and handle outstanding requests.</span></span> <span data-ttu-id="f2134-138">자세한 내용은 [큐 기반 부하 평준화 패턴](https://msdn.microsoft.com/library/dn589783.aspx)을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="f2134-138">For more information, see the [Queue-Based Load Leveling Pattern](https://msdn.microsoft.com/library/dn589783.aspx).</span></span>

## <a name="deployment-and-maintenance"></a><span data-ttu-id="f2134-139">배포 및 유지 관리</span><span class="sxs-lookup"><span data-stu-id="f2134-139">Deployment and maintenance</span></span>
* <span data-ttu-id="f2134-140">**각 서비스에 대한 역할의 여러 인스턴스를 배포합니다.**</span><span class="sxs-lookup"><span data-stu-id="f2134-140">**Deploy multiple instances of roles for each service.**</span></span> <span data-ttu-id="f2134-141">Microsoft는 사용자가 만들고 배포하는 서비스에 대한 가용성을 보장하지만 이러한 보장은 서비스에서 각 역할의 둘 이상의 인스턴스를 배포하는 경우에만 유효합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-141">Microsoft makes availability guarantees for services that you create and deploy, but these guarantees are only valid if you deploy at least two instances of each role in the service.</span></span> <span data-ttu-id="f2134-142">이렇게 하면 다른 역할들이 활성 상태로 유지되는 동안 한 역할을 사용할 수 없게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-142">This enables one role to be unavailable while the other remains active.</span></span> <span data-ttu-id="f2134-143">이는 클라이언트의 작업을 중단하지 않고 라이브 시스템에 업데이트를 배포하는 경우에 특히 중요합니다. 인스턴스는 다른 작업을 온라인으로 계속하는 동안 개별적으로 작동을 중단하고 업그레이드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-143">This is especially important if you need to deploy updates to a live system without interrupting clients' activities; instances can be taken down and upgraded individually while the others continue online.</span></span>
* <span data-ttu-id="f2134-144">**여러 데이터 센터의 응용 프로그램을 호스팅합니다.**</span><span class="sxs-lookup"><span data-stu-id="f2134-144">**Host applications in multiple datacenters.**</span></span> <span data-ttu-id="f2134-145">발생할 가능성이 거의 없지만 전체 데이터 센터는 같은 자연 재해 또는 인터넷 실패와 같은 이벤트를 통해 오프라인으로 전환하는 것도 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-145">Although extremely unlikely, it is possible for an entire datacenter to go offline through an event such as a natural disaster or Internet failure.</span></span> <span data-ttu-id="f2134-146">최대 가용성을 제공하기 위해 둘 이상의 데이터 센터에서 중요한 비즈니스 응용 프로그램을 호스팅해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-146">Vital business applications should be hosted in more than one datacenter to provide maximum availability.</span></span> <span data-ttu-id="f2134-147">이는 로컬 사용자에게 대기 시간을 줄여주고 응용 프로그램을 업데이트할 때 유연성에 대한 추가 기회를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-147">This can also reduce latency for local users, and provide additional opportunities for flexibility when updating applications.</span></span>
* <span data-ttu-id="f2134-148">**배포 및 유지 관리 작업을 자동화하고 테스트합니다.**</span><span class="sxs-lookup"><span data-stu-id="f2134-148">**Automate and test deployment and maintenance tasks.**</span></span> <span data-ttu-id="f2134-149">분산된 응용 프로그램은 함께 작동해야 하는 여러 부분으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-149">Distributed applications consist of multiple parts that must work together.</span></span> <span data-ttu-id="f2134-150">따라서 배포는 스크립트 및 배포 응용 프로그램과 같은 테스트되고 입증된 메커니즘을 사용하여 자동화되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-150">Deployment should therefore be automated, using tested and proven mechanisms such as scripts and deployment applications.</span></span> <span data-ttu-id="f2134-151">업데이트 및 구성의 유효성을 검사하고 배포 프로세스를 자동화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-151">These can update and validate configuration, and automate the deployment process.</span></span> <span data-ttu-id="f2134-152">또한 자동화된 방법은 응용 프로그램의 일부 또는 전체의 업데이트를 수행하는데 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-152">Automated techniques should also be used to perform updates of all or parts of applications.</span></span> <span data-ttu-id="f2134-153">오류 작동 중단 시간이 추가로 인해 에러가 일어나지 않도록 완벽하게 이러한 모든 프로세스를 테스트하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-153">It is vital to test all of these processes fully to ensure that errors do not cause additional downtime.</span></span> <span data-ttu-id="f2134-154">모든 배포 도구는 배포된 응용 프로그램을 보호하기 위해 적합한 보안 제한이 있어야 합니다. 배포 정책을 신중하게 정의 및 적용하고 사용자 개입의 필요성을 최소화합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-154">All deployment tools must have suitable security restrictions to protect the deployed application; define and enforce deployment policies carefully and minimize the need for human intervention.</span></span>
* <span data-ttu-id="f2134-155">**플랫폼의 스테이징 및 프로덕션 기능을 사용하는 것이 좋습니다** .</span><span class="sxs-lookup"><span data-stu-id="f2134-155">**Consider using staging and production features of the platform** where these are available.</span></span> <span data-ttu-id="f2134-156">예를 들어 Azure Cloud Services 스테이징 및 프로덕션 환경을 사용하여 가상 IP 주소 교체(VIP 교체)를 통해 응용 프로그램을 즉시 바꿀 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-156">For example, using Azure Cloud Services staging and production environments allows applications to be switched from one to another instantly through a virtual IP address swap (VIP Swap).</span></span> <span data-ttu-id="f2134-157">그러나 온-프레미스 준비 또는 응용 프로그램의 서로 다른 버전을 동시에 배포하고 사용자를 점진적으로 마이그레이션하려면 VIP 교체 작업을 사용하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-157">However, if you prefer to stage on-premises, or deploy different versions of the application concurrently and gradually migrate users, you may not be able to use a VIP Swap operation.</span></span>
* <span data-ttu-id="f2134-158">**재활용하지 않고 구성 변경 내용을 적용합니다** .</span><span class="sxs-lookup"><span data-stu-id="f2134-158">**Apply configuration changes without recycling** the instance when possible.</span></span> <span data-ttu-id="f2134-159">대부분의 경우 역할을 다시 시작하지 않고 Azure 응용 프로그램 또는 서비스에 대한 구성 설정을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-159">In many cases, the configuration settings for an Azure application or service can be changed without requiring the role to be restarted.</span></span> <span data-ttu-id="f2134-160">역할은 이벤트를 노출하여 구성 변경 내용을 검색하고 응용 프로그램 내에서 구성 요소에 적용하도록 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-160">Role expose events that can be handled to detect configuration changes and apply them to components within the application.</span></span> <span data-ttu-id="f2134-161">그러나 코어 플랫폼 설정을 일부 변경에는 다시 시작하는 역할이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-161">However, some changes to the core platform settings do require a role to be restarted.</span></span> <span data-ttu-id="f2134-162">구성 요소 및 서비스를 작성할 때 전체적으로 응용 프로그램을 다시 시작하지 않고도 구성 설정에 변경 사항을 적용하도록 설계하여 가용성을 최대화하고 가동 중지 시간을 최소화 합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-162">When building components and services, maximize availability and minimize downtime by designing them to accept changes to configuration settings without requiring the application as a whole to be restarted.</span></span>
* <span data-ttu-id="f2134-163">**업데이트하는 동안 가동 중지 시간없이 업그레이드 도메인을 사용합니다.**</span><span class="sxs-lookup"><span data-stu-id="f2134-163">**Use upgrade domains for zero downtime during updates.**</span></span> <span data-ttu-id="f2134-164">웹 및 작업자 역할과 같은 Azure 계산 단위는 업그레이드 도메인에 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-164">Azure compute units such as web and worker roles are allocated to upgrade domains.</span></span> <span data-ttu-id="f2134-165">업그레이드 도메인은 역할 인스턴스를 그룹화하여 역할 업데이트가 수행될 때 각 역할을 차례로 중지, 업데이트 및 다시 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-165">Upgrade domains group role instances together so that, when a rolling update takes place, each role in the upgrade domain is stopped, updated, and restarted in turn.</span></span> <span data-ttu-id="f2134-166">응용 프로그램 가용성에 미치는 영향을 최소화합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-166">This minimizes the impact on application availability.</span></span> <span data-ttu-id="f2134-167">서비스를 배포할 때 만들어야 하는 서비스용 업그레이드 도메인 개수를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-167">You can specify how many upgrade domains should be created for a service when the service is deployed.</span></span>
  
  > [!NOTE]
  > <span data-ttu-id="f2134-168">또한 역할은 오류 도메인에는 분산되고 각각이 서버 랙, 기능 및 냉각 프로비전 면에서 다른 오류 도메인에서 합리적으로 독립된 모든 역할 인스턴스에 영향을 주는 오류의 가능성을 최소화합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-168">Roles are also distributed across fault domains, each of which is reasonably independent from other fault domains in terms of server rack, power, and cooling provision, in order to minimize the chance of a failure affecting all role instances.</span></span> <span data-ttu-id="f2134-169">이 배포는 자동으로 발생하고 제어할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-169">This distribution occurs automatically, and you cannot control it.</span></span>
  > 
  > 
* <span data-ttu-id="f2134-170">**Azure 가상 머신에 대한 가용성 집합을 구성합니다.**</span><span class="sxs-lookup"><span data-stu-id="f2134-170">**Configure availability sets for Azure virtual machines.**</span></span> <span data-ttu-id="f2134-171">동일한 가용성 집합에서 둘 이상의 가상 머신을 배치하여 이러한 가상 머신을 동일한 장애 도메인에 배포하지 않도록 보장합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-171">Placing two or more virtual machines in the same availability set guarantees that these virtual machines will not be deployed to the same fault domain.</span></span> <span data-ttu-id="f2134-172">가용성을 최대화하려면 시스템에서 사용하는 각각의 중요한 가상 머신의 여러 인스턴스를 만들고 이러한 인스턴스를 동일한 가용성 집합에 배치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-172">To maximize availability, you should create multiple instances of each critical virtual machine used by your system and place these instances in the same availability set.</span></span> <span data-ttu-id="f2134-173">다른 용도로 사용되는 여러 가상 머신을 실행하는 경우 각 가상 머신에 대한 가용성 집합을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-173">If you are running multiple virtual machines that serve different purposes, create an availability set for each virtual machine.</span></span> <span data-ttu-id="f2134-174">각 가용성 집합에 각 가상 머신의 인스턴스를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-174">Add instances of each virtual machine to each availability set.</span></span> <span data-ttu-id="f2134-175">예를 들어 별도 가상 머신을 만들어 웹 서버 및 보고 서버로 작동하는 경우 웹 서버용 가용성 집합 및 보고 서버용의 다른 가용성 집합을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-175">For example, if you have created separate virtual machines to act as a web server and a reporting server, create an availability set for the web server and another availability set for the reporting server.</span></span> <span data-ttu-id="f2134-176">웹 서버 가상 머신의 인스턴스를 웹 서버 가용성 집합에 추가하고 보고 서버 가상 머신의 인스턴스를 보고 서버 가용성 집합에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-176">Add instances of the web server virtual machine to the web server availability set, and add instances of the reporting server virtual machine to the reporting server availability set.</span></span>

## <a name="data-management"></a><span data-ttu-id="f2134-177">데이터 관리</span><span class="sxs-lookup"><span data-stu-id="f2134-177">Data management</span></span>

* <span data-ttu-id="f2134-178">**Azure Storage의 지역 간 데이터 복제**</span><span class="sxs-lookup"><span data-stu-id="f2134-178">**Geo-replicate data in Azure Storage**.</span></span> <span data-ttu-id="f2134-179">Azure Storage의 데이터는 데이터 센터 내에서 자동으로 복제됩니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-179">Data in Azure Storage is automatically replicated within in a datacenter.</span></span> <span data-ttu-id="f2134-180">더 높은 가용성을 위해서는, 데이터를 보조 지역으로 복제하고 보조 위치에 있는 데이터에 대해 읽기 전용 액세스를 제공하는 RAGRS(읽기 액세스 지역 중복 저장소)를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-180">For even higher availability, use Read-access geo-redundant storage (-RAGRS), which replicates your data to a secondary region and provides read-only access to the data in the secondary location.</span></span> <span data-ttu-id="f2134-181">이 경우 전체 지역 가동 중단 또는 재해가 발생하더라도 데이터를 계속 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-181">The data is durable even in the case of a complete regional outage or a disaster.</span></span> <span data-ttu-id="f2134-182">자세한 내용은 [Azure Storage 복제](/azure/storage/storage-redundancy)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f2134-182">For more information, see [Azure Storage replication](/azure/storage/storage-redundancy).</span></span>
* <span data-ttu-id="f2134-183">**지역에서 데이터베이스 복제**.</span><span class="sxs-lookup"><span data-stu-id="f2134-183">**Geo-replicate databases**.</span></span> <span data-ttu-id="f2134-184">Azure SQL Database 및 Cosmos DB는 지역에서 복제 기능을 지원하여 다른 지역에서 보조 데이터베이스 복제본을 구성할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-184">Azure SQL Database and Cosmos DB both support geo-replication, which enables you to configure secondary database replicas in other regions.</span></span> <span data-ttu-id="f2134-185">데이터 센터 정전 또는 주 데이터베이스에 연결하지 못하는 경우 쿼리 및 장애 조치(failover)에 보조 데이터베이스를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-185">Secondary databases are available for querying and for failover in the case of a data center outage or the inability to connect to the primary database.</span></span> <span data-ttu-id="f2134-186">자세한 내용은 [장애 조치(Failover) 그룹 및 활성 지역 복제](/azure/sql-database/sql-database-geo-replication-overview)(SQL Database) 및 [Azure Cosmos DB로 데이터를 글로벌 배포하는 방법](/azure/cosmos-db/distribute-data-globally)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f2134-186">For more information, see [Failover groups and active geo-replication](/azure/sql-database/sql-database-geo-replication-overview) (SQL Database) and [How to distribute data globally with Azure Cosmos DB?](/azure/cosmos-db/distribute-data-globally).</span></span>
* <span data-ttu-id="f2134-187">**낙관적 동시성 및 결과적 일관성을 사용합니다** .</span><span class="sxs-lookup"><span data-stu-id="f2134-187">**Use optimistic concurrency and eventual consistency** where possible.</span></span> <span data-ttu-id="f2134-188">잠금(비관적 동시성)을 통해 리소스에 액세스를 차단하는 트랜잭션은 성능이 떨어지고 가용성이 상당히 줄어들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-188">Transactions that block access to resources through locking (pessimistic concurrency) can cause poor performance and considerably reduce availability.</span></span> <span data-ttu-id="f2134-189">이러한 문제는 특히 분산된 시스템에서 심각할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-189">These problems can become especially acute in distributed systems.</span></span> <span data-ttu-id="f2134-190">많은 경우 분할과 같이 신중한 설계 및 기법은 충돌하는 업데이트의 발생 가능성을 최소화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-190">In many cases, careful design and techniques such as partitioning can minimize the chances of conflicting updates occurring.</span></span> <span data-ttu-id="f2134-191">데이터를 복제하거나 업데이트된 저장소에서 읽으면 데이터는 결국 일관됩니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-191">Where data is replicated, or is read from a separately updated store, the data will only be eventually consistent.</span></span> <span data-ttu-id="f2134-192">하지만 즉각적인 일관성을 보장하려면 트랙잭션을 사용하는 가용성의 영향보다 장점이 일반적으로 보다 큰 가치가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-192">But the advantages usually far outweigh the impact on availability of using transactions to ensure immediate consistency.</span></span>
* <span data-ttu-id="f2134-193">**정기적인 백업 및 지정 시간 복원을 사용하고**복구 지점 목표(RPO)를 충족하도록 보장합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-193">**Use periodic backup and point-in-time restore**, and ensure it meets the Recovery Point Objective (RPO).</span></span> <span data-ttu-id="f2134-194">정기적으로 다른 위치에 보존되지 않은 데이터를 자동으로 백업하고 안정적으로 데이터와 응용 프로그램 자체에 모두 일어날 수 있는 실패를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-194">Regularly and automatically back up data that is not preserved elsewhere, and verify you can reliably restore both the data and the application itself should a failure occur.</span></span> <span data-ttu-id="f2134-195">데이터 복제는 실패, 오류 또는 악의적인 작업을 통해 발생하는 오류 및 불일치가 모든 매장에서 복제되기 때문에 백업 기능이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-195">Data replication is not a backup feature because errors and inconsistencies introduced through failure, error, or malicious operations will be replicated across all stores.</span></span> <span data-ttu-id="f2134-196">전송 중 및 저장소에 있는 데이터를 보호하려면 백업 프로세스가 안전해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-196">The backup process must be secure to protect the data in transit and in storage.</span></span> <span data-ttu-id="f2134-197">데이터베이스 또는 데이터 저장소의 부분은 일반적으로 트랜잭션 로그를 사용하여 이전 특정 시점으로 복구될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-197">Databases or parts of a data store can usually be recovered to a previous point in time by using transaction logs.</span></span> <span data-ttu-id="f2134-198">Microsoft Azure는 Azure SQL Database에 저장된 데이터에 대한 백업 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-198">Microsoft Azure provides a backup facility for data stored in Azure SQL Database.</span></span> <span data-ttu-id="f2134-199">데이터를 Azure blob 저장소에 백업 패키지를 내보내고 저장소에 대한 안전한 온-프레미스 위치에 다운로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-199">The data is exported to a backup package on Azure blob storage, and can be downloaded to a secure on-premises location for storage.</span></span>
* <span data-ttu-id="f2134-200">**Azure Redis Cache의 보조 복사본을 유지하는 고가용성 옵션을 사용하도록 설정합니다.**</span><span class="sxs-lookup"><span data-stu-id="f2134-200">**Enable the high availability option to maintain a secondary copy of an Azure Redis cache.**</span></span> <span data-ttu-id="f2134-201">Azure Redis Cache를 사용할 때 내용의 보조 복사본을 유지하기 위해 표준 옵션을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-201">When using Azure Redis Cache, choose the standard option to maintain a secondary copy of the contents.</span></span> <span data-ttu-id="f2134-202">자세한 내용은 [Azure Redis Cache에서 캐시 만들기](https://msdn.microsoft.com/library/dn690516.aspx)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f2134-202">For more information, see [Create a cache in Azure Redis Cache](https://msdn.microsoft.com/library/dn690516.aspx).</span></span>

## <a name="errors-and-failures"></a><span data-ttu-id="f2134-203">오류 및 실패</span><span class="sxs-lookup"><span data-stu-id="f2134-203">Errors and failures</span></span>
* <span data-ttu-id="f2134-204">**시간 제한의 개념을 소개합니다.**</span><span class="sxs-lookup"><span data-stu-id="f2134-204">**Introduce the concept of a timeout.**</span></span> <span data-ttu-id="f2134-205">서비스 및 리소스는 실패한 요청을 발생시켜 사용할 수 없게 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-205">Services and resources may become unavailable, causing requests to fail.</span></span> <span data-ttu-id="f2134-206">적용한 시간 제한이 각 서비스 또는 리소스 또한 액세스하는 클라이언트에 적절한지를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-206">Ensure that the timeouts you apply are appropriate for each service or resource as well as the client that is accessing them.</span></span> <span data-ttu-id="f2134-207">(일부 경우 클라이언트가 수행하는 컨텍스트 및 기타 작업에 따라 클라이언트의 특정 인스턴스에 대해 더 긴 시간 제한을 두는 것이 적절할 수 있습니다.) 매우 짧은 시간 제한 때문에 대기 시간이 상당한 서비스 및 리소스에 대한 과도한 다시 시도 작업이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-207">(In some cases, it may be appropriate to allow a longer timeout for a particular instance of a client, depending on the context and other actions that the client is performing.) Very short timeouts may cause excessive retry operations for services and resources that have considerable latency.</span></span> <span data-ttu-id="f2134-208">많은 수의 요청이 응답할 서비스 또는 리소스를 기다리며 큐에 대기 중인 경우 매우 긴 시간 제한이 차단을 발생시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-208">Very long timeouts can cause blocking if a large number of requests are queued, waiting for a service or resource to respond.</span></span>
* <span data-ttu-id="f2134-209">**일시적인 오류를 발생하는 실패한 작업을 다시 시도합니다.**</span><span class="sxs-lookup"><span data-stu-id="f2134-209">**Retry failed operations caused by transient faults.**</span></span> <span data-ttu-id="f2134-210">모든 서비스 및 리소스가 본질적으로 자동 연결 다시 시도를 지원하지 않으면 이에 액세스하려는 다시 시도 전략을 설계합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-210">Design a retry strategy for access to all services and resources where they do not inherently support automatic connection retry.</span></span> <span data-ttu-id="f2134-211">실패한 횟수가 증가하여 리소스의 오버 로드를 방지하고 큐에 대기 중인 요청을 정상적으로 복구하고 처리하도록 다시 시도 간에 지연이 증가하도록 하는 전략을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-211">Use a strategy that includes an increasing delay between retries as the number of failures increases, to prevent overloading of the resource and to allow it to gracefully recover and handle queued requests.</span></span> <span data-ttu-id="f2134-212">매우 짧은 지연을 동반한 지속적인 재시도는 문제를 악화시킬 가능성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-212">Continual retries with very short delays are likely to exacerbate the problem.</span></span>
* <span data-ttu-id="f2134-213">**연속 오류를 방지하기 위한 요청 전송을 중지합니다** .</span><span class="sxs-lookup"><span data-stu-id="f2134-213">**Stop sending requests to avoid cascading failures** when remote services are unavailable.</span></span> <span data-ttu-id="f2134-214">서비스의 전체 오류에 대한 연결의 손실 부분이 심각하면 일시적이거나 다른 오류가 정상으로 돌아가려면 예상보다 훨씬 더 긴 시간이 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-214">There may be situations in which transient or other faults, ranging in severity from a partial loss of connectivity to the complete failure of a service, take much longer than expected to return to normal.</span></span> <span data-ttu-id="f2134-215">또한 서비스를 과도하게 사용하면 메모리, 스레드 및 데이터베이스 연결과 같은 중요한 시스템 리소스를 점유하는 동안 시스템에서 한 부분의 실패가 연속 오류를 발생하고 다양한 작업이 차단되는 결과가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-215">Additionally, if a service is very busy, failure in one part of the system may lead to cascading failures, and result in many operations becoming blocked while holding onto critical system resources such as memory, threads, and database connections.</span></span> <span data-ttu-id="f2134-216">성공할 가능성이 없는 작업을 지속적으로 다시 시도하는 대신 응용 프로그램은 작업 실패를 빠르게 수락하고 이 실패를 정상적으로 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-216">Instead of continually retrying an operation that is unlikely to succeed, the application should quickly accept that the operation has failed, and gracefully handle this failure.</span></span> <span data-ttu-id="f2134-217">정의된 기간에서 특정 작업에 대한 요청을 거부하도록 회로 차단기 패턴을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-217">You can use the circuit breaker pattern to reject requests for specific operations for defined periods.</span></span> <span data-ttu-id="f2134-218">자세한 내용은 [회로 차단기 패턴](../patterns/circuit-breaker.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f2134-218">For more information, see [Circuit Breaker Pattern](../patterns/circuit-breaker.md).</span></span>
* <span data-ttu-id="f2134-219">**여러 구성 요소를 작성하거나 다시 대체하여** 오프라인이거나 사용할 수 없는 특정 서비스의 영향을 완화합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-219">**Compose or fall back to multiple components** to mitigate the impact of a specific service being offline or unavailable.</span></span> <span data-ttu-id="f2134-220">가능한 경우 작업 및 기존 연결에 영향을 주지 않고 여러 인스턴스를 이용하도록 응용 프로그램을 설계합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-220">Design applications to take advantage of multiple instances without affecting operation and existing connections where possible.</span></span> <span data-ttu-id="f2134-221">여러 인스턴스를 사용하고 이들 간에 요청을 분산하며 실패한 인스턴스에 요청을 보내는 것을 검색 및 방지하여 가용성을 극대화합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-221">Use multiple instances and distribute requests between them, and detect and avoid sending requests to failed instances, in order to maximize availability.</span></span>
* <span data-ttu-id="f2134-222">**다른 서비스 또는 워크플로를 대체** .</span><span class="sxs-lookup"><span data-stu-id="f2134-222">**Fall back to a different service or workflow** where possible.</span></span> <span data-ttu-id="f2134-223">예를 들어 SQL Database에 쓰기를 실패하면 Blob 저장소에 임시로 데이터를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-223">For example, if writing to SQL Database fails, temporarily store data in blob storage.</span></span> <span data-ttu-id="f2134-224">서비스를 사용할 수 있을 때 SQL Database에 Blob 저장소의 쓰기를 재생하는 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-224">Provide a facility to replay the writes in blob storage to SQL Database when the service becomes available.</span></span> <span data-ttu-id="f2134-225">일부에 구성 요소 또는 서비스가 실패한 경우에도 실패한 작업은 응용 프로그램으로 작업을 계속할 수 있는 대체 동작이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-225">In some cases, a failed operation may have an alternative action that allows the application to continue to work even when a component or service fails.</span></span> <span data-ttu-id="f2134-226">가능한 경우 기본 서비스가 오프라인일 때 오류를 검색하고 적합한 대체 기능을 제공할 수 있는 다른 서비스에 요청을 리디렉션하거나 코어 작업을 유지할 수 있는 기능 인스턴스를 백업 또는 축소합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-226">If possible, detect failures and redirect requests to other services that can offer a suitable alternative functionality, or to back up or reduced functionality instances that can maintain core operations while the primary service is offline.</span></span>

## <a name="monitoring-and-disaster-recovery"></a><span data-ttu-id="f2134-227">모니터링 및 재해 복구</span><span class="sxs-lookup"><span data-stu-id="f2134-227">Monitoring and disaster recovery</span></span>
* <span data-ttu-id="f2134-228">**예상되는 실패 및 실패 이벤트에 대한 풍부한 계측 기능을 제공** 하여 운영 담당자에게 상황을 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-228">**Provide rich instrumentation for likely failures and failure events** to report the situation to operations staff.</span></span> <span data-ttu-id="f2134-229">가능성이 있지만 아직 발생하지 않은 오류의 경우 운영 담당자가 원인을 확인하고 상황을 완화하며 사용할 수 있는 시스템이 남아 있는지 확인하도록 충분한 데이터를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-229">For failures that are likely but have not yet occurred, provide sufficient data to enable operations staff to determine the cause, mitigate the situation, and ensure that the system remains available.</span></span> <span data-ttu-id="f2134-230">이미 발생한 오류의 경우 응용 프로그램은 사용자에게 적합한 오류 메시지를 반환해야 하지만 기능이 축소된 상태라도 실행을 계속 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-230">For failures that have already occurred, the application should return an appropriate error message to the user but attempt to continue running, albeit with reduced functionality.</span></span> <span data-ttu-id="f2134-231">모든 경우 모니터링 시스템은 운영 담당자가 빠른 복구를 적용할 수 있도록 포괄적인 정보를 캡처해야 하고, 설계자가 필요로 하면 개발자가 다시 발생하는 상황을 방지하기 위해 시스템을 수정합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-231">In all cases, the monitoring system should capture comprehensive details to enable operations staff to effect a quick recovery, and if necessary, for designers and developers to modify the system to prevent the situation from arising again.</span></span>
* <span data-ttu-id="f2134-232">**검사 함수를 구현하여 시스템 상태를 모니터링합니다.**</span><span class="sxs-lookup"><span data-stu-id="f2134-232">**Monitor system health by implementing checking functions.**</span></span> <span data-ttu-id="f2134-233">실패할 때까지 눈에 띄지 않아도 시간이 지남에 따라 응용 프로그램의 상태 및 성능이 저하될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-233">The health and performance of an application can degrade over time, without being noticeable until it fails.</span></span> <span data-ttu-id="f2134-234">프로브를 구현하거나 응용 프로그램 외부에서 정기적으로 실행되는 함수를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-234">Implement probes or check functions that are executed regularly from outside the application.</span></span> <span data-ttu-id="f2134-235">이러한 검사는 전체적인 응용 프로그램, 응용 프로그램의 개별 부분, 응용 프로그램이 사용하는 개별 서비스 또는 개별 구성 요소에 대한 응답 시간 측정같이 간단할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-235">These checks can be as simple as measuring response time for the application as a whole, for individual parts of the application, for individual services that the application uses, or for individual components.</span></span> <span data-ttu-id="f2134-236">검사 함수가 올바른 결과를 생성하고 대기 시간을 측정하며 가용성을 확인하도록 보장하는 프로세스를 실행하고 시스템에서 정보를 추출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-236">Check functions can execute processes to ensure they produce valid results, measure latency and check availability, and extract information from the system.</span></span>
* <span data-ttu-id="f2134-237">**모든 장애 조치를 정기적으로 테스트하고 시스템을 대체하여** 사용 가능하며 예상대로 작동되도록 보장합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-237">**Regularly test all failover and fallback systems** to ensure they are available and operate as expected.</span></span> <span data-ttu-id="f2134-238">시스템 및 작업 변경 내용은 장애 조치에 영향을 주고 기능을 대체할 수 있지만 주 시스템이 실패하거나 과부하 상태일 때까지 영향이 검색되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-238">Changes to systems and operations may affect failover and fallback functions, but the impact may not be detected until the main system fails or becomes overloaded.</span></span> <span data-ttu-id="f2134-239">런타임 시 라이브 문제를 보충하기 위해 요구하기 전에 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-239">Test it before it is required to compensate for a live problem at runtime.</span></span>
* <span data-ttu-id="f2134-240">**모니터링 시스템을 테스트합니다.**</span><span class="sxs-lookup"><span data-stu-id="f2134-240">**Test the monitoring systems.**</span></span> <span data-ttu-id="f2134-241">자동화된 장애 조치(Failover) 및 대체 시스템과 대시보드를 사용한 시스템 상태 및 성능 수동 시각화는 모두 모니터링 및 계측 기능에 따라 정상적으로 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-241">Automated failover and fallback systems, and manual visualization of system health and performance by using dashboards, all depend on monitoring and instrumentation functioning correctly.</span></span> <span data-ttu-id="f2134-242">이러한 요소에 오류가 발생하고 중요한 정보를 누락되거나 부정확한 데이터가 보고된 경우 운영자는 시스템이 비정상 또는 실패임을 모를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-242">If these elements fail, miss critical information, or report inaccurate data, an operator might not realize that the system is unhealthy or failing.</span></span>
* <span data-ttu-id="f2134-243">**장기 실행 워크플로의 진행률을 추적하고** 실패 시 다시 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-243">**Track the progress of long-running workflows** and retry on failure.</span></span> <span data-ttu-id="f2134-244">장기 실행 워크플로는 종종 여러 단계로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-244">Long-running workflows are often composed of multiple steps.</span></span> <span data-ttu-id="f2134-245">각 단계가 독립적이도록 보장하고 다시 시도하여 전체 워크플로가 롤백하거나 여러 보충 트랜잭션을 실행해야 하는 가능성을 최소화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-245">Ensure that each step is independent and can be retried to minimize the chance that the entire workflow will need to be rolled back, or that multiple compensating transactions need to be executed.</span></span> <span data-ttu-id="f2134-246">[Scheduler 에이전트 감독자 패턴](https://msdn.microsoft.com/library/dn589780.aspx)과 같은 패턴을 구현하여 장기 실행 워크플로의 진행 상태를 모니터링하고 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-246">Monitor and manage the progress of long-running workflows by implementing a pattern such as [Scheduler Agent Supervisor Pattern](https://msdn.microsoft.com/library/dn589780.aspx).</span></span>
* <span data-ttu-id="f2134-247">**재해 복구 계획입니다.**</span><span class="sxs-lookup"><span data-stu-id="f2134-247">**Plan for disaster recovery.**</span></span> <span data-ttu-id="f2134-248">시스템 가용성에 영향을 줄 수 있는 모든 유형의 오류에서 복구하기 위해 수락되고 완전히 테스트된 계획을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-248">Create an accepted, fully-tested plan for recovery from any type of failure that may affect system availability.</span></span> <span data-ttu-id="f2134-249">업무에 중요한 모든 응용 프로그램에 대해 다중 사이트 재해 복구 아키텍처를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-249">Choose a multi-site disaster recovery architecture for any mission-critical applications.</span></span> <span data-ttu-id="f2134-250">자동화 및 테스트를 비롯한 재해 복구 계획의 구체적인 소유자를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-250">Identify a specific owner of the disaster recovery plan, including automation and testing.</span></span> <span data-ttu-id="f2134-251">계획이 잘 문서화되도록 하고, 가능한 한 많은 프로세스를 자동화합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-251">Ensure the plan is well-documented, and automate the process as much as possible.</span></span> <span data-ttu-id="f2134-252">모든 참조 및 트랜잭션 데이터에 대한 백업 전략을 수립하고 이러한 백업 복원을 정기적으로 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-252">Establish a backup strategy for all reference and transactional data, and test the restoration of these backups regularly.</span></span> <span data-ttu-id="f2134-253">교육 운영 담당자가 계획을 실행하고, 정기적인 재해 시뮬레이션을 수행하여 계획이 유효한지 확인하고 개선하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="f2134-253">Train operations staff to execute the plan, and perform regular disaster simulations to validate and improve the plan.</span></span>
