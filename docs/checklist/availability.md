---
title: Availability checklist
description: Checklist that provides guidance for availability concerns during design.
author: dragon119
ms.service: guidance
ms.topic: article
ms.date: 03/24/2017
ms.author: pnp
ms.custom: checklist

---
# 가용성 체크리스트
[!INCLUDE [header](../_includes/header.md)]

## 응용 프로그램 설계

* **단일 실패 지점을 사용하지 않습니다.** 모든 구성 요소, 서비스, 리소스, 계산 인스턴스는 다중 인스턴스로 하여 단일 실패 지점이 영향을 미치지 않도록 합니다. 여기에는 인증 메커니즘이 포함됩니다. 구성 가능한 응용 프로그램을 설계하여 다중 인스턴스를 사용하고, 자동으로 오류를 감지하여 플랫폼이 자동으로 수행하지 않는 정상 인스턴스로 요청을 리디렉션하도록 합니다.

* **서로 다른 서비스 수준 계약별로 작업을 분리합니다.** 서비스가 중요한 작업과 덜 중요한 작업으로 구성된 경우, 이를 별도로 관리하고 서비스 기능 및 인스턴스 수를 특정하여 사용 가능성 요구사항을 충족시킵니다.

* **서비스 종속성을 최소화하고 이해합니다.** 사용되는 여러 서비스 수를 가능한 최소화하고 시스템의 모든 기능과 서비스 종속성을 이해해야 합니다. 여기에는 이러한 종속성의 특성 그리고 전체 응용 프로그램에 미치는 오류 또는 성능 저하의 영향이 포함됩니다. Microsoft는 대부분의 서비스에 대해 최소 99.9% 가용성을 보장합니다. 단, 응용 프로그램에 필요한 모든 추가 서비스는 잠재적으로 시스템의 전체 가용성 SLA를 0.1% 감소시킵니다.

* **작업 및 메시지는 가능하면 멱등성(idempotent)을 가지도록(안전한 반복) 설계하여**, , 중복된 요청으로 인해 문제가 발생하지 않도록 합니다. 예를 들어, 어떤 서비스는 제작자 역할을 하는 시스템 다른 부분의 요청에 따라 보내진 메시지를 처리하는 소비자 역할을 할 수 있습니다. 그 소비자가 메시지를 처리한 후 처리를 인지하지 전에 오류가 발생하는 경우, 제작자는 반복 요청을 제출하고 이 요청을 소비자의 다른 인스턴스에서 처리하는 경우가 생깁니다. 그러므로, 소비자와 소비자가 수행하는 작업에 멱등성이 있어야 이전에 실행한 작업을 반복함으로써 유효하지 않은 결과가 되지 않습니다. 이 말은 중복 메시지를 탐지하거나, 충돌 관리에 최적의 접근법을 사용하여 일관성을 유지한다는 뜻도 될 수 있습니다.

* **중요 트랜잭션에 고가용성을 구현하는 메시지 브로커를 사용합니다.** 작업 초기화 또는 원격 서비스 액세스에 대한 대다수 시나리오는 메시지를 사용하여 응용 프로그램과 대상 서비스 간에 명령을 전달합니다. 최고 성능을 위해 응용 프로그램은 메시지를 전송한 다음 회신할 때까지 대기하지 않고 돌아가서 다른 요청을 처리할 수 있어야 합니다. 메시지 전송을 보증하기 위해, 메시지 시스템은 고가용성을 제공해야 합니다. Azure 서비스 버스 메시지 큐는 의미 체계를 한 번 이상 구현합니다. 이 말은 큐에 게시되는 각각의 메시지는 특정 상황에서 중복 복사본이 전송되더라도 손실되지 않는다는 뜻입니다. 메시지 처리가 멱등(이전 항목 참조)인 경우, 반복 전송은 문제되지 않습니다.

* **리소스 한도에 이르면 응용 프로그램의 성능이 정상적으로 저하되고 그로 인한 영향을 최소화하기 위해 적절한 작업을 수행하도록 설계합니다.** 어떤 경우, 응용 프로그램의 로드가 한 개 이상의 부품의 용량을 초과하여 가용성이 떨어지고 연결이 끊어질 수 있습니다. 크기 조정(scaling)으로  이러한 문제를 완화할 수 있으나, 리소스 가용성 또는 비용 등 다른 요소에 설정된 한계에 이를 수 있습니다. 이러한 경우 응용 프로그램의 성능이 정상적으로 저하되도록 설계합니다. 예를 들어, 전자 상거래 시스템에서 주문 처리 하위 시스템을 과도하게 사용하는 경우(또는 완전히 오류가 발생한 경우), 다른 기능(제품 카탈로그 검색 등)은 계속 수행하도록 하면서 하위 시스템을 일시적으로 사용하지 못할 수 있습니다. 고객이 계속 주문은 할 수 있지만 이후 주문 하위 시스템을 다시 사용할 수 있을 때 처리하도록 저장하는 등 오류가 발생한 하위 시스템에 대한 요청을 연기하는 것이 좋습니다.

* **빠른 버스트 이벤트를 정상적으로 처리합니다.** 대부분의 응용 프로그램은 시간마다 변하는 워크로드를 처리해야 합니다. 비즈니스 응용 프로그램에서 오전에 제일 먼저 최대 사용량이 되거나 전자 상거래 사이트에서 신제품이 출시되는 경우입니다. 자동 크기 조정으로 로드를 처리할 수 있으나, 추가 인스턴스가 온라인에 연결되어 요청을 처리하기까지 시간이 걸릴 수 있습니다. 급격하고 예기치 않은 작업 버스트가 응용 프로그램을 가득 채우지 않도록 합니다. 사용하는 서비스에 대한 요청을 큐에 넣고 큐의 용량이 거의 차면 정상적으로 기능을 저하시키도록 설계합니다. 비 버스트 상태에서는 큐를 수행하고 처리하지 않은 요청을 처리하기 위한 성능과 용량이 충분해야 합니다.  자세한 내용은 [큐 기반 로드 평준화 패턴(Queue-Based Load Leveling Pattern)](https://msdn.microsoft.com/library/dn589783.aspx)을 참조하십시오.

## 배포 및 유지관리

* **각 서비스에 대해 여러 역할 인스턴스를 배포합니다.** Microsoft는 사용자가 생성하고 배포하는 서비스에 대해 가용성을 보증하지만, 이러한 보증은 서비스에서 각 역할 당 2개 이상의 인스턴스를 배포해야만 유효합니다. 이렇게 함으로써 역할 하나를 사용할 수 없으면 다른 역할이 활성 상태를 유지할 수 있습니다. 이는 클라이언트 작업을 방해하지 않고 라이브 시스템에 업데이트를 배포해야 하는 경우 특히 중요합니다. 다른 인스턴스가 온라인 상태를 유지하는 동안 일부 인스턴스를 개별적으로 종료하여 업그레이드할 수 있기 때문입니다. 

* **여러 데이터센터에 응용 프로그램을 호스트합니다.** 그럴 가능성은 거의 없지만, 자연 재해나 인터넷 고장 등의 사건으로 인해 전체 데이터센터가 오프라인 상태가 될 수 있습니다.  중요한 비즈니스 응용 프로그램은 한 개 이상의 데이터센터에 호스팅하여 가용성을 최대화해야 합니다. 그럴 경우 로컬 사용자의 대기 시간을 줄이고, 응용 프로그램 업데이트의 유연성을 향상시킬 수도 있습니다.

* **배포 및 유지관리 작업을 자동화하고 테스트합니다.** 배포된 응용 프로그램은 공동으로 작업해야 하는 여러 부분으로 구성됩니다. 그러므로 스크립트 및 배포 응용 프로그램과 같이 테스트를 거쳐 검증된 메커니즘을 사용해 자동으로 배포해야 합니다. 이러한 응용 프로그램은 구성을 업데이트하고 확인며, 배포 프로세스를 자동화할 수 있습니다. 응용 프로그램 전체나 일부 업데이트를 수행할 때도 자동화 기술을 사용합니다. 이 모든 프로세스를 완전히 테스트하여 오류로 인해 더 이상의 다운타임이 발생하지 않도록 해야 합니다. 모든 배포 도구는 배포되는 응용 프로그램을 보호하기에 적절한 보안 제한이 있어야 합니다. 배포 정책을 신중하게 정의하고 적용하여 사용자의 개입을 최소화합니다.

* **가능하면 플랫폼의 스테이징 및 프로덕션 기능을 사용합니다.** 예를 들어, Azure 클라우드 서비스 스테이징 및 프로덕션 환경을 사용하면 가상 IP 주소 교환(VIP 교환)을 통해 응용 프로그램을 즉시 서로 바꿀 수 있습니다. 그러나, 온프레미스 스테이징을 선호하거나 다양한 버전의 응용 프로그램을 동시에 배포하여 사용자를 점차적으로 마이그레이션하려는 경우, VIP 교환 작업을 사용하지 못할 수 있습니다. 

* **가능하면 인스턴스 재순환 없이 구성 변경 내용을 적용합니다.** 대부분의 경우, Azure 응용 프로그램 또는 서비스의 구성 설정은 역할을 다시 시작하지 않고도 변경할 수 있습니다.  역할 표시 이벤트를 처리하여 구성 변경 내용을 감지하고 응용 프로그램 내에 있는 구성 요소에 이를 적용할 수 있습니다. 그러나, 핵심 플랫폼 설정의 일부 변경 내용은 역할을 다시 시작해야 합니다.  구성 요소 및 서비스를 구성할 때는, 응용 프로그램 전체를 다시 시작하지 않고도 구성 설정에 변경 내용을 적용하도록 설계함으로써 가용성을 최대화하고 다운타임을 최소화합니다.

* **업그레이드 도메인을 사용해 업데이트 중 제로 다운타임을 구현합니다.** 웹 및 작업자 역할 등 Azure 계산 단위가 업그레이드 도메인에 할당됩니다. 업그레이드 도메인은 역할 인스턴스를 그룹화하여 롤링 업데이트를 수행할 때 업그레이드 도메인의 각 역할이 중지되고 업데이트된 후 다시 시작됩니다. 이는 응용 프로그램 가용성에 미치는 영향을 최소화합니다. 서비스를 배포할 때 해당 서비스에 대한 업그레이드 도메인을 얼마나 생성해야 하는지 지정할 수 있습니다.
  
  > [!참고]
  > 역할은 오류 도메인에도 배포되며, 오류가 전체 역할 인스턴스에 영향을 줄 가능성을 최소화하기 위해 각 역할은 서비스 랙, 전원, 냉각 설비에 있어서 기타 오류 도메인과는 충분한 독립성을 유지합니다. 이 배포는 자동적으로 발생하기 때문에 사용자가 제어할 수 없습니다.
  > 
  > 
* **Azure 가상 컴퓨터에 대한 가용성 집합을 구성합니다.** 같은 가용성 집합에 두 개 이상의 가상 컴퓨터를 설치하면, 이 가상 컴퓨터들이 동일한 오류 도메인에 배포되지 않게 할 수 있습니다. 가용성 극대화를 위해, 시스템에서 사용하는 각각의 중요 가상 컴퓨터의 인스턴스를 여러 개 생성하여 동일한 가용성 집합에 넣습니다. 서로 다른 용도의 가상 컴퓨터를 여러 개 실행 중인 경우, 각 가상 컴퓨터마다 가용성 집합을 한 개씩 만듭니다. 가용성 집합마다 한 가용성 컴퓨터의 인스턴스를 추가합니다. 예를 들어, 웹 서버와 보고 서버에 서로 다른 가상 컴퓨터를 생성했다면, 웹 서버에 가용성 집합 한 개, 보고 서버에 또 다른 가용성 집합 한 개를 만듭니다. 웹 서버 가상 컴퓨터의 인스턴스를 웹 서버 가용성 집합에 추가하고, 보고 서버 가상 컴퓨터의 인스턴스를 보고 서버 가용성 집합에 추가합니다.

## 데이터 관리

* **로컬 중복 및 위치 중복을 통해 데이터 복제를 활용합니다.** Azure 저장소의 데이터는 자동으로 복제되어 인프라 오류가 발생하는 경우 손실을 방지하며, 이러한 복제의 일부는 설정할 수 있습니다. 예를 들어, 읽기 전용 데이터 복사본은 한 개 이상의 지리적 위치에서 복제할 수 있습니다(읽기-액세스 전역 중복 저장소 또는 RA-GRS). RA-GRS 사용에는 추가 요금이 부과될 수 있습니다. 자세한 내용은 [Azure 저장소 가격(Azure Storage Pricing)](https://azure.microsoft.com/pricing/details/storage/)을 참조하십시오.

* 가능하면 **낙관적 동시성과 최종 일관성을 사용**합니다. 잠금(비관적 동시성)을 통해 리소스에 대한 액세스를 차단하는 트랜잭션은 성능을 저하시키고 가용성을 현저하게 감소시킬 수 있습니다. 이러한 문제는 특히 분산 시스템에서 심각해질 수 있습니다. 대부분의 경우, 신중한 설계와 분할 등의 기술로 업데이트 충돌 발생을 최소화할 수 있습니다. 데이터를 복제하거나 별도로 업데이트된 저장소에서 읽어오는 경우, 데이터는 최종 상태에서만 일관성을 가집니다. 그러나 대개는 즉시적 일관성을 보장하기 위해 트랜잭션을 사용할 때 가용성에 미치는 영향보다 장점이 훨씬 많습니다.

* **주기적 백업과 특정 시점 복원을 사용하고**,복구 지점 목표(Recovery Point Objective, RPO)를 지키도록 합니다. 별도로 보존되지 않는 데이터를 정기적으로 자동 백업 데이터하고, 오류가 발생하는 경우 데이터와 응용 프로그램을 안정적으로 자체 복원할 수 있는지 확인합니다. 오류 및 고장, 오류 또는 악성 작업으로 인한 불일치는 모든 저장소에서 복제되기 때문에 데이터 복제는 백업 기능이 아닙니다.  백업 프로세스는 전송 중인 데이터와 저장소에 있는 데이터를 보호할 수 있도록 안전해야 합니다.  데이터베이스 또는 데이터 저장소의 부분은 트랜잭션 로그를 사용해 이전 시점으로 복구할 수 있습니다. Microsoft Azure는 Azure SQL 데이터베이스에 저장된 데이터를 위해 백업 장치를 제공합니다. 데이터는 Azure blob 저장소의 백업 패키지에 내보내고, 안전한 온프레미스 위치에 다운로드하여 저장합니다.

* **고가용성 옵션을 사용해 Azure Redis Cache의 보조 복사본을 유지 관리합니다.** Azure Redis Cache를 사용할 때는, 표준 옵션을 선택하여 콘텐츠의 보조 복사본을 유지 관리합니다. 자세한 내용은 [Azure Redis Cache에 캐시 만들기(Create a cache in Azure Redis Cache)](https://msdn.microsoft.com/library/dn690516.aspx)를 참조하십시오.

## 오류 및 실패

* **시간 제한 개념을 적용합니다.** 서비스와 리소스를 사용할 수 없게 되면서 요청이 실패할 수 있습니다. 적용할 시간 제한이 각 서비스 또는 리소스, 그리고 그에 액세스하는 클라이언트에 적절한지 확인합니다. (어떤 경우 상황 및 클라이언트가 수행하는 기타 작업에 따라 클라이언트의 특정 인스턴스에 대해 시간 제한을 더 연장하는 것이 좋을 수 있습니다.) 시간 제한이 너무 짧으면  서비스 및 리소스에 대한 재시도 작업이 과도해 대기 시간이 길어질 수 있습니다. 시간 제한이 너무 길면 큐에서 너무 많은 요청이 응답할 서비스나 리소스를 기다리는 경우 차단할 수 있습니다.

* **일시적 오류로 인해 실패한 작업을 재시도합니다.** 기본적으로 자동 연결 재시도를 지원하지 않는 경우, 모든 서비스 및 리소스에 대해 액세스 재시도 전략을 설계합니다. 실패 횟수가 늘어나면 재시도 사이에 증가하는 지연을 포함하는 전략을 사용하여, 리소스가 오버로드되는 것을 방지하고 정상적으로 복구되어 대기 중인 요청을 처리할 수 있도록 합니다. 지연이 아주 짧은 지속적 재시도는 문제를 악화시킬 가능성이 있습니다.

* **원격 서비스를 사용할 수 없을 때는 요청 전송을 중단하여 연속 실패를 방지합니다.** 부분적 연결 손실에서 서비스의 완전한 실패까지 다양한 심각도의 일시적 또는 기타 오류가 정상 상태가 되는 데 예상보다 오래 걸리는 상황도 있습니다. 또한, 서비스가 많은 작업을 수행 중인 경우, 시스템 한 부분의 실패로 인해 연속적인 실패가 발생하여 메모리, 스레드, 데이터베이스 연결과 같이 중요한 시스템 리소스를 보류하면서 여러 작업이 차단될 수 있습니다. 성공할 가능성이 낮은 작업을 계속 재시도하는 대신, 응용 프로그램에서 작업 실패를 신속하게 수락하고 적절하게 실패를 처리해야 합니다.  회로 차단기 패턴을 사용해 지정된 시간 동안 특정 작업에 대한 요청을 거부할 수 있습니다.  자세한 내용은 [회로 차단기 패턴(Circuit Breaker Pattern)](https://msdn.microsoft.com/library/dn589784.aspx)을 참조하십시오.

* **다중 구성 요소를 작성하거나 대체하여 오프라인되거나 사용할 수 없는 특정 서비스의 영향을 완화합니다.** 응용 프로그램이 작업 및 기존 연결에 최대한 영향을 주지 않고 여러 인스턴스를 활용할 수 있도록 설계합니다. 가용성을 최대화하기 위해서는, 여러 인스턴스를 사용해 인스턴스 간에 요청을 배분하고, 오류 인스턴스로 보내는 요청을 감지하여 전송을 방지합니다.

* **가능하면 다른 서비스 또는 워크플로로 대체합니다.** 예를 들어, SQL 데이터베이스 쓰기가 실패하는 경우, 데이터를 blob 저장소에 임시로 저장합니다. 서비스 사용이 가능해 지면, blob 저장소의 쓰기를 재생하는 장치를 SQL 데이터베이스에 제공합니다. 실패한 작업에 대안 작업이 있어 구성 요소나 서비스가 실패했을 때도 응용 프로그램이 계속 작업할 수 있는 경우도 있습니다. 가능하면, 실패를 감지해 적절한 대안 기능이 있는 다른 서비스로 요청을 리디렉션하거나, 기본 서비스가 오프라인일 때 핵심 작업을 유지할 수 있는 백업 또는 기능 제한 인스턴스로 리디렉션합니다.

## 모니터링 및 재해 복구

* **실패할 가능성이 있는 이벤트 및 실패 이벤트에 대한 풍부한 계측을 제공하여 운영 스태프에게 상황을 보고합니다.** 가능성이 있지만 아직 발생하지 않은 실패의 경우, 충분한 데이터를 제공하여 운영 스태프가 원인을 알아내고, 상태를 완화하여 시스템을 계속 사용할 수 있도록 합니다. 이미 실패한 경우, 응용 프로그램은 사용자에게 적절한 오류 메시지를 반환하며, 제한된 기능으로도 계속 실행을 시도해야 합니다.  모든 경우에 모니터링 시스템은 포괄적 상세 정보를 캡처하여 운영 스태프가 빠르게 복구할 수 있도록 하며, 필요한 경우 설계자 및 개발자가 시스템을 변경하여 재발 상황을 방지하도록 해야 합니다.

* **검사 기능을 구현하여 시스템 상태를 모니터링합니다.** 응용 프로그램의 상태 및 성능은 시간이 흐르면서 저하되어, 실패할 때까지는 눈에 띄지 않을 수 있습니다. 응용 프로그램 외부에서 정기적으로 실행되는 프로브나 검사 기능을 구현합니다.  이러한 검사는 응용 프로그램 전체 또는 응용 프로그램의 개별 부품, 응용 프로그램에서 사용하는 개별 서비스, 개별 구성 요소에 대해 응답 시간을 측정하는 것처럼 간단할 수도 있습니다. 검사 기능은 유효한 결과가 나오는지 확인하고, 대기 시간을 측정해 가용성을 확인하며, 시스템에서 정보를 추출하는 프로세스를 실행할 수 있습니다.     

* **모든 장애 조치 및 대체 시스템을 정기적으로 테스트하여** 사용 가능성과 예상대로 작동하는지 확인합니다. 시스템 및 운영 변경 내용은 장애 조치(failover) 및 대체(fallback) 기능에 영향을 줄 수 있지만, 그 영향은 주 시스템에 오류나 오버로드가 발생할 때까지 감지되지 않을 수 있습니다. 실행 중 실시간 문제를 해결하지 않도록 사전에 테스트합니다.

* **모니터링 시스템을 테스트합니다.** 자동화된 장애 조치 및 대체 시스템, 그리고 대시보드를 사용한 시스템 상태 및 성능의 수동 시각화는 모두 정확한 모니터링 및 계측 기능에 좌우됩니다. 이러한 요소가 실패하거나, 중요 정보를 놓치거나, 정확하지 않은 데이터를 보고하는 경우, 운영자가 시스템의 비정상 및 오류를 인식하지 못할 수 있습니다.

* **장기 실행 워크플로의 진행을 추적하고 실패 시 재시도합니다.** 장기 실행 워크플로는 여러 단계로 구성된 경우가 많습니다. 각 단계를 독립적이고 재시도할 수 있도록 하여, 전체 워크플로를 롤백해야 하거나 여러 보상 트랜잭션을 실행해야 하는 경우를 최소화합니다. [스케줄러 에이전트 감독자(Scheduler Agent Supervisor) 패턴](https://msdn.microsoft.com/library/dn589780.aspx) 등 패턴을 구현하여 장기 실행 워크플로의 진행을 모니터링하고 관리합니다.

* **재해 복구 계획을 세웁니다.** 주 시스템을 부분 또는 전체적으로 사용할 수 없도록 만드는 모든 유형의 오류로부터 복구하기 위해 문서화 및 승인되어 완전히 테스트한 계획이 있어야 합니다.  정기적으로 절차를 테스트하여 모든 운영 스태프가 프로세스를 숙지하도록 합니다.
