---
title: 가용성 검사 목록
description: 설계하는 동안 가용성 문제에 대한 지침을 제공하는 검사 목록입니다.
author: dragon119
ms.date: 01/10/2018
ms.custom: checklist
ms.openlocfilehash: 324d8200d822eb1a7dce95ba4b2a7f29b00fb291
ms.sourcegitcommit: 441185360db49cfb3cf39527b68f318d17d4cb3d
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/19/2018
ms.locfileid: "27973113"
---
# <a name="availability-checklist"></a>가용성 검사 목록

가용성은 시스템의 기능 및 활성화 된 시간의 비율을 말하며 [소프트웨어 품질 핵심 요소](../guide/pillars.md) 중 하나입니다. 이 검사 목록을 사용하여 가용성 관점에서 응용 프로그램 아키텍처를 검토 합니다. 

## <a name="application-design"></a>응용 프로그램 설계

**모든 단일 지점 장애를 방지합니다.** 모든 구성 요소, 서비스, 리소스 및 계산 인스턴스는 여러 인스턴스로 배포하여 단일 실패 지점이 가용성에 영향을 주지 않도록 해야 합니다. 여기에 인증 메커니즘을 포함합니다. 여러 인스턴스를 사용한 구성이 가능하도록 응용 프로그램을 설계하고 플랫폼이 자동으로 이를 수행하지 않는 곳에서 자동으로 오류를 검색하며 실패하지 않은 인스턴스에 요청을 리디렉션합니다.

**서비스 수준 목적별로 워크로드를 분해합니다.** 서비스가 중요하고 덜 중요한 워크로드로 구성되면 다르게 관리하도록 하고 해당 가용성 요구 사항에 맞게 서비스 기능 및 인스턴스 수를 지정합니다.

**서비스 종속성을 최소화하고 이해합니다.** 사용 가능한 경우 다른 서비스의 수를 최소화하고 모든 시스템에 존재하는 기능 및 서비스 종속성을 이해합니다. 이는 이러한 종속성의 특성 및 전체 응용 프로그램에서 각각의 실패 또는 성능 저하의 영향을 포함합니다. [복원력 요구 사항 정의](../resiliency/index.md#defining-your-resiliency-requirements)를 참조하세요.

**사용 가능한 경우 작업 및 메시지가 idempotent가 되게 설계합니다**. 작업을 수차례 반복해도 동일한 결과를 내놓는다면 idempotent 작업입니다. Idempotency는 중복된 요청이 반복돼도 문제를 일으키지 않게 합니다. 소비자와 소비자가 수행하는 작업은 idempotent하므로 이전에 실행된 작업을 반복하는 것이 잘못된 결과를 렌더링하지 않습니다. 이는 충돌 처리에 대해 낙관적 접근법을 사용하여 중복된 메시지를 감지 또는 일관성 보장을 의미합니다.

**중요한 트랜잭션에 대한 고가용성을 구현하는 메시지 브로커를 사용합니다.** 많은 클라우드 응용 프로그램은 메시징 기능을 사용해 비동기적으로 수행되는 작업을 시작합니다. 메시지 배달을 보장하려면 메시징 시스템이 고가용성을 제공해야 합니다. [Azure Service Bus Messaging](/azure/service-bus-messaging)은 *한 번 이상* 의미 체계를 구현합니다. 즉 특정 상황에서 중복된 복사본을 배달할 수 있지만 큐에 게시된 메시지가 손실되지 않음을 의미합니다. 메시지 처리가 멱등 상태이면(이전 항목 참조) 반복된 배달이 문제가 아니어야 합니다.

**응용 프로그램이 무리없이 성능이 저하되도록 설계합니다.** 응용 프로그램에서 부하가 하나 이상의 부분 용량을 초과하여 가용성을 감소시키고 연결이 실패할 수 있습니다. 크기 조정은 이를 완화하는데 도움이 되지만 리소스 가용성 또는 비용 같은 다른 요인에 의해 제한에 도달할 수 있습니다. 응용 프로그램이 리소스 제한에 도달한 경우 해당 사용자에게 충격을 최소화할 수 있는 조치를 해야 합니다. 예를 들어, 전자 상거래 시스템에서 주문 처리 하위 시스템이 부담을 받거나 실패하면 다른 기능을 계속 허용하는 동안 임시로 사용하지 않을 수 있습니다(예: 제품 카탈로그 찾아보기). 예를 들어 주문 하위 시스템을 다시 사용할 수 있는 경우 주문을 제출할 수 있지만 나중에 처리하기 위해 저장하는 것처럼 결함이 있는 하위 시스템에 요청을 연기하는 것이 적절할 수 있습니다.

**빠른 버스트 이벤트를 정상적으로 처리 합니다.** 대부분 응용 프로그램은 시간에 따라 변화하는 워크로드를 처리해야 합니다. 자동 크기 조정은 부하를 처리를 도울 수 있지만 추가 인스턴스를 온라인 상태로 전환하고 요청을 처리하는 데 약간의 시간이 걸릴 수 있습니다. 응용 프로그램이 사용하는 서비스에 대한 큐 요청에 맞고 큐가 전체 용량에 가까운 경우 정상적으로 저하되도록 설계하여 응용 프로그램에 부담을 주는 갑작스럽고 예상하지 않은 활동의 버스트를 방지합니다. 버스트하지 않은 조건에서 사용 가능한 충분한 성능 및 용량이 있는지 확인하여 큐를 비우고 처리되지 않은 요청을 처리합니다. 자세한 내용은 [큐 기반 부하 평준화 패턴](https://msdn.microsoft.com/library/dn589783.aspx)을 참조하십시오.

## <a name="deployment-and-maintenance"></a>배포 및 유지 관리

**서비스의 여러 인스턴스를 배포합니다.** 응용 프로그램이 서비스의 단일 인스턴스에 종속된 경우 단일 실패 지점이 생깁니다. 여러 인스턴스를 프로비전하면 복원력 및 확장성이 모두 개선됩니다. [Azure App Service](/azure/app-service/app-service-value-prop-what-is/)의 경우 여러 인스턴스를 제공하는 [App Service 계획](/azure/app-service/azure-web-sites-web-hosting-plans-in-depth-overview/)을 선택합니다. Azure Cloud Services의 경우 각각의 역할을 [여러 인스턴스](/azure/cloud-services/cloud-services-choose-me/#scaling-and-management)를 사용하도록 구성합니다. [Azure Virtual Machines(VM)](/azure/virtual-machines/virtual-machines-windows-about/?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json)의 경우, VM 아키텍처가 둘 이상의 VM을 포함하는지 그리고 각각의 VM이 [가용성 집합][availability-sets]에 포함되는지 확인합니다.

**여러 지역에 걸쳐 응용 프로그램을 배포하는 것을 고려합니다.** 응용 프로그램이 단일 지역에 배포되면 전체 지역이 사용할 수 없게 되는 드문 경우에 응용 프로그램도 사용할 수 없습니다. 이러한 상황이 응용 프로그램의 SLA의 조항에 따라 허용되지 않을 수 있습니다. 그러한 경우 응용 프로그램 및 해당 서비스를 여러 지역에 걸쳐 배포하는 것을 고려합니다.

**배포 및 유지 관리 작업을 자동화하고 테스트합니다.** 분산된 응용 프로그램은 함께 작동해야 하는 여러 부분으로 구성됩니다. 배포는 스크립트처럼 테스트되고 입증된 메커니즘을 사용해 자동화되어야 합니다. 업데이트 및 구성의 유효성을 검사하고 배포 프로세스를 자동화할 수 있습니다. [Azure Resource Manager 템플릿](/azure/azure-resource-manager/resource-group-authoring-templates)을 사용하여 리소스를 프로비전합니다. 또한 자동화 기술을 사용해 응용 프로그램 업데이트를 수행합니다. 오류 작동 중단 시간이 추가로 인해 에러가 일어나지 않도록 완벽하게 이러한 모든 프로세스를 테스트하는 것이 중요합니다. 모든 배포 도구는 배포된 응용 프로그램을 보호하기 위해 적합한 보안 제한이 있어야 합니다. 배포 정책을 신중하게 정의 및 적용하고 사용자 개입의 필요성을 최소화합니다.

**해당 플랫폼의 준비 및 생산 기능을 사용합니다.**. 예를 들어 Azure App Service는 생산으로 교체하기 전에 배포에 사용할 수 있는 [배포 슬롯](/azure/app-service/web-sites-staged-publishing)을 지원합니다. Azure Service Fabric은 응용 프로그램 서비스에 대한 [롤링 업그레이드](/azure/service-fabric/service-fabric-application-upgrade)를 지원합니다.

**가용성 집합에 모든 가상 머신(VM)을 배치합니다.** 가용성을 최대화하려면 각 VM 역할의 여러 인스턴스를 만들고 이러한 인스턴스를 동일한 가용성 집합에 배치합니다. 다양한 응용 프로그램 계층처럼 다양한 역할을 수행하는 여러 VM이 있는 경우 각 VM 역할에 맞는 가용성 집합을 만듭니다. 예를 들어, 웹 계층용 가용성 집합과 데이터 계층용 가용성 집합을 만듭니다.

## <a name="data-management"></a>데이터 관리

**Azure Storage의 지역 간 데이터 복제** Azure Storage의 데이터는 데이터 센터 내에서 자동으로 복제됩니다. 더 높은 가용성을 위해서는, 데이터를 보조 지역으로 복제하고 보조 위치에 있는 데이터에 대해 읽기 전용 액세스를 제공하는 RAGRS(읽기 액세스 지역 중복 저장소)를 사용합니다. 이 경우 전체 지역 가동 중단 또는 재해가 발생하더라도 데이터를 계속 사용할 수 있습니다. 자세한 내용은 [Azure Storage 복제](/azure/storage/storage-redundancy)를 참조하세요.

**지역에서 데이터베이스 복제**. Azure SQL Database 및 Cosmos DB는 지역에서 복제 기능을 지원하여 다른 지역에서 보조 데이터베이스 복제본을 구성할 수 있도록 합니다. 데이터 센터 정전 또는 주 데이터베이스에 연결하지 못하는 경우 쿼리 및 장애 조치(failover)에 보조 데이터베이스를 사용할 수 있습니다. 자세한 내용은 [장애 조치(Failover) 그룹 및 활성 지역 복제](/azure/sql-database/sql-database-geo-replication-overview)(SQL Database) 및 [Azure Cosmos DB로 데이터를 글로벌 배포하는 방법](/azure/cosmos-db/distribute-data-globally)을 참조하세요.

**낙관적 동시성 및 결과적 일관성을 사용합니다**. 잠금(비관적 동시성)을 통해 리소스에 액세스를 차단하는 트랜잭션은 성능이 떨어지고 가용성이 상당히 줄어들 수 있습니다. 이러한 문제는 특히 분산된 시스템에서 심각할 수 있습니다. 많은 경우 분할과 같이 신중한 설계 및 기법은 충돌하는 업데이트의 발생 가능성을 최소화할 수 있습니다. 데이터를 복제하거나 업데이트된 저장소에서 읽으면 데이터는 결국 일관됩니다. 하지만 즉각적인 일관성을 보장하려면 트랙잭션을 사용하는 가용성의 영향보다 장점이 일반적으로 보다 큰 가치가 있습니다.

**주기적인 백업 및 지정 시간 복원을 사용합니다**. 정기적으로 다른 위치에 보존되지 않은 데이터를 자동으로 백업하고 안정적으로 데이터와 응용 프로그램 자체에 모두 일어날 수 있는 실패를 확인합니다. 백업이 RPO(복구 지점 목표)를 충족하는지 확인합니다. 인간적 오류나 악의적인 작업으로 모든 복제본의 데이터가 손상될 수 있기 때문에, 데이터 복제는 백업 기능이 아닙니다. 전송 중 및 저장소에 있는 데이터를 보호하려면 백업 프로세스가 안전해야 합니다. 데이터베이스 또는 데이터 저장소의 부분은 일반적으로 트랜잭션 로그를 사용하여 이전 특정 시점으로 복구될 수 있습니다. 자세한 내용은 [데이터 손상 또는 우발적 삭제로부터 복구](../resiliency/recovery-data-corruption.md)를 참조하세요

## <a name="errors-and-failures"></a>오류 및 실패

**요청 시간 제한 구성.** 서비스 및 리소스는 실패한 요청을 발생시켜 사용할 수 없게 될 수 있습니다. 적용한 시간 제한이 각 서비스 또는 리소스 또한 액세스하는 클라이언트에 적절한지를 확인합니다. 경우에 따라, 클라이언트가 수행하는 컨텍스트 및 기타 작업에 따라 클라이언트의 특정 인스턴스에 대해 더 긴 시간 제한을 허용할 수도 있습니다. 매우 짧은 시간 제한 때문에 대기 시간이 상당한 서비스 및 리소스에 대한 과도한 다시 시도 작업이 발생할 수 있습니다. 많은 수의 요청이 응답할 서비스 또는 리소스를 기다리며 큐에 대기 중인 경우 매우 긴 시간 제한이 차단을 발생시킬 수 있습니다.

**일시적인 오류를 발생하는 실패한 작업을 다시 시도합니다.** 모든 서비스 및 리소스가 본질적으로 자동 연결 다시 시도를 지원하지 않으면 이에 액세스하려는 다시 시도 전략을 설계합니다. 실패한 횟수가 증가하여 리소스의 오버 로드를 방지하고 큐에 대기 중인 요청을 정상적으로 복구하고 처리하도록 다시 시도 간에 지연이 증가하도록 하는 전략을 사용합니다. 매우 짧은 지연을 동반한 지속적인 재시도는 문제를 악화시킬 가능성이 있습니다. 자세한 내용은 [특정 서비스에 대한 다시 시도 지침](../best-practices/retry-service-specific.md)을 참조하세요.

**연속 장애를 방지하기 위해 회로를 차단합니다.** 서비스의 전체 오류에 대한 연결의 손실 부분이 심각하면 일시적이거나 다른 오류가 정상으로 돌아가려면 예상보다 훨씬 더 긴 시간이 걸릴 수 있습니다. 또한 서비스를 과도하게 사용하면 메모리, 스레드 및 데이터베이스 연결과 같은 중요한 시스템 리소스를 점유하는 동안 시스템에서 한 부분의 실패가 연속 오류를 발생하고 다양한 작업이 차단되는 결과가 발생할 수 있습니다. 성공할 가능성이 없는 작업을 지속적으로 다시 시도하는 대신 응용 프로그램은 작업 실패를 빠르게 수락하고 이 실패를 정상적으로 처리해야 합니다. 정의된 기간에서 특정 작업에 대한 요청을 거부하도록 회로 차단기 패턴을 사용합니다. 자세한 내용은 [회로 차단기 패턴](../patterns/circuit-breaker.md)을 참조하세요.

**여러 구성 요소를 구성하거나 대체합니다.** 가능한 경우 작업 및 기존 연결에 영향을 주지 않고 여러 인스턴스를 이용하도록 응용 프로그램을 설계합니다. 여러 인스턴스를 사용하고 이들 간에 요청을 분산하며 실패한 인스턴스에 요청을 보내는 것을 검색 및 방지하여 가용성을 극대화합니다.

**다른 서비스 또는 워크플로를 대체합니다.** 예를 들어 SQL Database에 쓰기를 실패하면 Blob 저장소에 임시로 데이터를 저장합니다. 서비스를 사용할 수 있을 때 SQL Database에 쓰기를 재생하는 방법을 제공합니다. 일부에 구성 요소 또는 서비스가 실패한 경우에도 실패한 작업은 응용 프로그램으로 작업을 계속할 수 있는 대체 동작이 있을 수 있습니다. 가능한 경우 기본 서비스가 오프라인일 때 오류를 검색하고 적합한 대체 기능을 제공할 수 있는 다른 서비스에 요청을 리디렉션하거나 코어 작업을 유지할 수 있는 기능 인스턴스를 백업 또는 축소합니다.

## <a name="monitoring-and-disaster-recovery"></a>모니터링 및 재해 복구

**예상되는 실패 및 실패 이벤트에 대한 풍부한 계측 기능을 제공** 하여 운영 담당자에게 상황을 보고합니다. 가능성이 있지만 아직 발생하지 않은 오류의 경우 운영 담당자가 원인을 확인하고 상황을 완화하며 사용할 수 있는 시스템이 남아 있는지 확인하도록 충분한 데이터를 제공합니다. 이미 발생한 오류의 경우 응용 프로그램은 사용자에게 적합한 오류 메시지를 반환해야 하지만 기능이 축소된 상태라도 실행을 계속 시도합니다. 모든 경우 모니터링 시스템은 운영 담당자가 빠른 복구를 적용할 수 있도록 포괄적인 정보를 캡처해야 하고, 설계자가 필요로 하면 개발자가 다시 발생하는 상황을 방지하기 위해 시스템을 수정합니다.

**검사 함수를 구현하여 시스템 상태를 모니터링합니다.** 실패할 때까지 눈에 띄지 않아도 시간이 지남에 따라 응용 프로그램의 상태 및 성능이 저하될 수 있습니다. 프로브를 구현하거나 응용 프로그램 외부에서 정기적으로 실행되는 함수를 확인합니다. 이러한 검사는 전체적인 응용 프로그램, 응용 프로그램의 개별 부분, 응용 프로그램이 사용하는 개별 서비스 또는 개별 구성 요소에 대한 응답 시간 측정같이 간단할 수 있습니다. 검사 함수가 올바른 결과를 생성하고 대기 시간을 측정하며 가용성을 확인하도록 보장하는 프로세스를 실행하고 시스템에서 정보를 추출할 수 있습니다.

**모든 장애 조치(failover) 및 대체(fallback) 시스템을 정기적으로 테스트 합니다.** 시스템 및 작업 변경 내용은 장애 조치에 영향을 주고 기능을 대체할 수 있지만 주 시스템이 실패하거나 과부하 상태일 때까지 영향이 검색되지 않을 수 있습니다. 런타임 시 라이브 문제를 보충하기 위해 요구하기 전에 테스트합니다.

**모니터링 시스템을 테스트합니다.** 자동화된 장애 조치(Failover) 및 대체 시스템과 대시보드를 사용한 시스템 상태 및 성능 수동 시각화는 모두 모니터링 및 계측 기능에 따라 정상적으로 다릅니다. 이러한 요소에 오류가 발생하고 중요한 정보를 누락되거나 부정확한 데이터가 보고된 경우 운영자는 시스템이 비정상 또는 실패임을 모를 수 있습니다.

**장기 실행 워크플로의 진행률을 추적하고 실패 시 다시 시도하십시오.** 장기 실행 워크플로는 종종 여러 단계로 구성됩니다. 각 단계가 독립적이도록 보장하고 다시 시도하여 전체 워크플로가 롤백하거나 여러 보충 트랜잭션을 실행해야 하는 가능성을 최소화할 수 있습니다. [Scheduler 에이전트 감독자 패턴](../patterns/scheduler-agent-supervisor.md)과 같은 패턴을 구현하여 장기 실행 워크플로의 진행 상태를 모니터링하고 관리합니다.

**재해 복구 계획입니다.** 시스템 가용성에 영향을 줄 수 있는 모든 유형의 오류에서 복구하기 위해 수락되고 완전히 테스트된 계획을 만듭니다. 업무에 중요한 모든 응용 프로그램에 대해 다중 사이트 재해 복구 아키텍처를 선택합니다. 자동화 및 테스트를 비롯한 재해 복구 계획의 구체적인 소유자를 식별합니다. 계획이 잘 문서화되도록 하고, 가능한 한 많은 프로세스를 자동화합니다. 모든 참조 및 트랜잭션 데이터에 대한 백업 전략을 수립하고 이러한 백업 복원을 정기적으로 테스트합니다. 교육 운영 담당자가 계획을 실행하고, 정기적인 재해 시뮬레이션을 수행하여 계획이 유효한지 확인하고 개선하도록 합니다.

<!-- links -->
[availability-sets]:/azure/virtual-machines/virtual-machines-windows-manage-availability/
