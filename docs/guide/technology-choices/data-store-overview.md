---
title: 적절한 데이터 저장소 선택
titleSuffix: Azure Application Architecture Guide
description: Azure의 데이터 저장소 선택 개요
author: MikeWasson
ms.date: 06/01/2018
ms.topic: guide
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: seojan19
ms.openlocfilehash: 91a551025ae697d5828fc1e398b204d2901d17f6
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/20/2019
ms.locfileid: "58242024"
---
# <a name="choose-the-right-data-store"></a><span data-ttu-id="4de14-103">적절한 데이터 저장소 선택</span><span class="sxs-lookup"><span data-stu-id="4de14-103">Choose the right data store</span></span>

<span data-ttu-id="4de14-104">최신 비즈니스 시스템은 점점 더 많은 양의 데이터를 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-104">Modern business systems manage increasingly large volumes of data.</span></span> <span data-ttu-id="4de14-105">데이터는 외부 서비스에서 수집되거나 시스템 자체에서 생성되거나 사용자가 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-105">Data may be ingested from external services, generated by the system itself, or created by users.</span></span> <span data-ttu-id="4de14-106">이러한 데이터 집합은 매우 다양한 특성 및 처리 요구 사항이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-106">These data sets may have extremely varied characteristics and processing requirements.</span></span> <span data-ttu-id="4de14-107">기업에서는 데이터를 사용하여 추세를 평가하고, 비즈니스 프로세스를 트리거하며, 해당 작업을 감사하고, 고객 행동을 분석하는 등의 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-107">Businesses use data to assess trends, trigger business processes, audit their operations, analyze customer behavior, and many other things.</span></span>

<span data-ttu-id="4de14-108">그러므로 단일 데이터 저장소가 일반적으로 모든 경우에 최선의 방법이 될 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-108">This heterogeneity means that a single data store is usually not the best approach.</span></span> <span data-ttu-id="4de14-109">대신 서로 다른 유형의 데이터를 서로 다른 데이터 저장소에 저장하는 것이 좋습니다. 각 데이터 저장소는 특정 워크로드 또는 사용 패턴에 중점을 둡니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-109">Instead, it's often better to store different types of data in different data stores, each focused towards a specific workload or usage pattern.</span></span> <span data-ttu-id="4de14-110">*polyglot 지속성*이라는 용어는 데이터 저장소 기술을 혼합하여 사용하는 솔루션을 설명하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-110">The term *polyglot persistence* is used to describe solutions that use a mix of data store technologies.</span></span>

<span data-ttu-id="4de14-111">요구 사항에 적합한 데이터 저장소를 선택하는 것이 디자인 결정의 핵심입니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-111">Selecting the right data store for your requirements is a key design decision.</span></span> <span data-ttu-id="4de14-112">SQL과 NoSQL 데이터베이스 중에서 선택할 수 있는 구현에는 문자 그대로 수백 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-112">There are literally hundreds of implementations to choose from among SQL and NoSQL databases.</span></span> <span data-ttu-id="4de14-113">데이터 저장소는 데이터 구조화 방법과 지원하는 작업 유형에 따라 분류됩니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-113">Data stores are often categorized by how they structure data and the types of operations they support.</span></span> <span data-ttu-id="4de14-114">이 문서에서는 가장 일반적인 여러 저장소 모델에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-114">This article describes several of the most common storage models.</span></span> <span data-ttu-id="4de14-115">특정 데이터 저장소 기술에서 여러 저장소 모델을 지원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-115">Note that a particular data store technology may support multiple storage models.</span></span> <span data-ttu-id="4de14-116">예를 들어 RDBMS(관계형 데이터베이스 관리 시스템)는 키/값 또는 그래프 저장을 지원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-116">For example, a relational database management systems (RDBMS) may also support key/value or graph storage.</span></span> <span data-ttu-id="4de14-117">사실, 단일 데이터베이스 시스템이 여러 모델을 지원하는 소위 *다중 모델* 지원이 일반적인 추세입니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-117">In fact, there is a general trend for so-called *multimodel* support, where a single database system supports several models.</span></span> <span data-ttu-id="4de14-118">그러나 다양한 모델을 개략적으로 이해하는 것은 여전히 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-118">But it's still useful to understand the different models at a high level.</span></span>

<span data-ttu-id="4de14-119">특정 범주의 모든 데이터 저장소가 동일한 기능을 제공하는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-119">Not all data stores in a given category provide the same feature-set.</span></span> <span data-ttu-id="4de14-120">대부분의 데이터 저장소는 데이터를 쿼리하고 처리하기 위한 서버 쪽 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-120">Most data stores provide server-side functionality to query and process data.</span></span> <span data-ttu-id="4de14-121">경우에 따라 이 기능은 데이터 저장소 엔진에 기본 제공되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-121">Sometimes this functionality is built into the data storage engine.</span></span> <span data-ttu-id="4de14-122">또는 데이터 저장 및 처리 기능이 분리되어 처리 및 분석을 위한 몇 가지 옵션이 있을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-122">In other cases, the data storage and processing capabilities are separated, and there may be several options for processing and analysis.</span></span> <span data-ttu-id="4de14-123">또한 데이터 저장소는 다양한 프로그래밍 및 관리 인터페이스를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-123">Data stores also support different programmatic and management interfaces.</span></span>

<span data-ttu-id="4de14-124">일반적으로 요구 사항에 가장 적합한 저장소 모델을 고려하여 시작해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-124">Generally, you should start by considering which storage model is best suited for your requirements.</span></span> <span data-ttu-id="4de14-125">그런 다음 기능 집합, 비용 및 관리 용이성과 같은 요소를 기반으로 해당 범주 내의 특정 데이터 저장소를 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-125">Then consider a particular data store within that category, based on factors such as feature set, cost, and ease of management.</span></span>

## <a name="relational-database-management-systems"></a><span data-ttu-id="4de14-126">관계형 데이터베이스 관리 시스템</span><span class="sxs-lookup"><span data-stu-id="4de14-126">Relational database management systems</span></span>

<span data-ttu-id="4de14-127">관계형 데이터베이스는 행과 열이 있는 일련의 2차원 테이블로 데이터를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-127">Relational databases organize data as a series of two-dimensional tables with rows and columns.</span></span> <span data-ttu-id="4de14-128">각 테이블에는 고유한 열이 있으며 테이블의 모든 행에는 동일한 열 집합이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-128">Each table has its own columns, and every row in a table has the same set of columns.</span></span> <span data-ttu-id="4de14-129">이 모델은 수학에 기반을 두고 있으며 대부분의 공급업체는 데이터 검색 및 관리를 위해 SQL(구조적 쿼리 언어) 언어를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-129">This model is mathematically based, and most vendors provide a dialect of the Structured Query Language (SQL) for retrieving and managing data.</span></span> <span data-ttu-id="4de14-130">RDBMS는 일반적으로 정보 업데이트를 위해 ACID(원자성, 일관성, 격리, 영속성) 모델을 준수하는 트랜잭션 방식으로 일관된 메커니즘을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-130">An RDBMS typically implements a transactionally consistent mechanism that conforms to the ACID (Atomic, Consistent, Isolated, Durable) model for updating information.</span></span>

<span data-ttu-id="4de14-131">RDBMS는 일반적으로 데이터 구조가 미리 정의되고 모든 읽기 또는 쓰기 작업이 스키마를 사용해야 하는 스키마 온 라이트(schema-on-write) 모델을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-131">An RDBMS typically supports a schema-on-write model, where the data structure is defined ahead of time, and all read or write operations must use the schema.</span></span> <span data-ttu-id="4de14-132">이 모델은 대부분의 NoSQL 데이터 저장소, 특히 키/값 유형과 대조됩니다. 스키마 온 리드(schema-on-read) 모델은 클라이언트가 데이터베이스에서 가져오는 데이터에 자체 해석 스키마를 부과하고, 쓰여지는 데이터 형식에 대해 제약 없는 것으로 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-132">This is in contrast to most NoSQL data stores, particularly key/value types, where the schema-on-read model assumes that the client will be imposing its own interpretive schema on data coming out of the database, and is agnostic to the data format being written.</span></span>

<span data-ttu-id="4de14-133">RDBMS는 강력한 일관성 보장이 중요한 경우 매우 유용합니다. 모든 변경 사항은 원자성이며 트랜잭션은 항상 데이터를 일관된 상태로 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-133">An RDBMS is very useful when strong consistency guarantees are important &mdash; where all changes are atomic, and transactions always leave the data in a consistent state.</span></span> <span data-ttu-id="4de14-134">그러나 기본 구조는 저장소를 분산하고 여러 컴퓨터에서 처리하여 확장하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-134">However, the underlying structures do not lend themselves to scaling out by distributing storage and processing across machines.</span></span> <span data-ttu-id="4de14-135">또한 RDBMS에 저장되는 정보는 정규화 프로세스를 수행하여 관계형 구조로 구성되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-135">Also, information stored in an RDBMS, must be put into a relational structure by following the normalization process.</span></span> <span data-ttu-id="4de14-136">이 프로세스는 이해하기 쉽지만 논리적 엔터티를 별도의 테이블 행으로 디스어셈블한 다음 쿼리를 실행할 때 데이터를 다시 어셈블해야 하므로 비효율적일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-136">While this process is well understood, it can lead to inefficiencies, because of the need to disassemble logical entities into rows in separate tables, and then reassemble the data when running queries.</span></span>

<span data-ttu-id="4de14-137">관련 Azure 서비스:</span><span class="sxs-lookup"><span data-stu-id="4de14-137">Relevant Azure service:</span></span>

- <span data-ttu-id="4de14-138">[Azure SQL Database][sql-db]</span><span class="sxs-lookup"><span data-stu-id="4de14-138">[Azure SQL Database][sql-db]</span></span>
- <span data-ttu-id="4de14-139">[Azure Database for MySQL][mysql]</span><span class="sxs-lookup"><span data-stu-id="4de14-139">[Azure Database for MySQL][mysql]</span></span>
- <span data-ttu-id="4de14-140">[Azure Database for PostgreSQL][postgres]</span><span class="sxs-lookup"><span data-stu-id="4de14-140">[Azure Database for PostgreSQL][postgres]</span></span>

## <a name="keyvalue-stores"></a><span data-ttu-id="4de14-141">키/값 저장소</span><span class="sxs-lookup"><span data-stu-id="4de14-141">Key/value stores</span></span>

<span data-ttu-id="4de14-142">키/값 저장소는 기본적으로 큰 해시 테이블입니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-142">A key/value store is essentially a large hash table.</span></span> <span data-ttu-id="4de14-143">각 데이터 값을 고유한 키와 연결하고 키/값 저장소는 이 키를 사용하여 적절한 해시 알고리즘을 통해 데이터를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-143">You associate each data value with a unique key, and the key/value store uses this key to store the data by using an appropriate hashing function.</span></span> <span data-ttu-id="4de14-144">해시 알고리즘은 데이터 저장소 전반에 해시 키가 균등하게 분산되도록 하기 위해 선택됩니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-144">The hashing function is selected to provide an even distribution of hashed keys across the data storage.</span></span>

<span data-ttu-id="4de14-145">대부분의 키/값 저장소는 간단한 쿼리, 삽입 및 삭제 작업만 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-145">Most key/value stores only support simple query, insert, and delete operations.</span></span> <span data-ttu-id="4de14-146">값을 수정(부분적으로 또는 완전히)하려면 애플리케이션이 전체 값에 대해 기존 데이터를 덮어써야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-146">To modify a value (either partially or completely), an application must overwrite the existing data for the entire value.</span></span> <span data-ttu-id="4de14-147">대부분의 구현에서 단일 값 읽기 또는 쓰기는 원자성 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-147">In most implementations, reading or writing a single value is an atomic operation.</span></span> <span data-ttu-id="4de14-148">값이 클 경우 쓸 때 약간의 시간이 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-148">If the value is large, writing may take some time.</span></span>

<span data-ttu-id="4de14-149">애플리케이션은 임의의 데이터를 값 집합으로 저장할 수 있지만 일부 키/값 저장소는 값의 최대 크기를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-149">An application can store arbitrary data as a set of values, although some key/value stores impose limits on the maximum size of values.</span></span> <span data-ttu-id="4de14-150">저장된 값은 저장소 시스템 소프트웨어에 불투명합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-150">The stored values are opaque to the storage system software.</span></span> <span data-ttu-id="4de14-151">모든 스키마 정보는 애플리케이션에서 제공하고 해석해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-151">Any schema information must be provided and interpreted by the application.</span></span> <span data-ttu-id="4de14-152">본질적으로 값은 BLOB이며 키/값 저장소는 키로 값을 검색하거나 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-152">Essentially, values are blobs and the key/value store simply retrieves or stores the value by key.</span></span>

![키-값 저장소의 다이어그램](./images/key-value.png)

<span data-ttu-id="4de14-154">키/값 저장소는 간단한 조회를 수행하는 애플리케이션에 대해 매우 최적화되어 있지만 다른 키/값 저장소에서 데이터를 쿼리해야 하는 시스템에는 적합하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-154">Key/value stores are highly optimized for applications performing simple lookups, but are less suitable for systems that need to query data across different key/value stores.</span></span> <span data-ttu-id="4de14-155">키/값 저장소는 키에 따라서만 조회를 수행하는 것이 아니라 값별 쿼리가 중요한 시나리오에 대해서도 최적화되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-155">Key/value stores are also not optimized for scenarios where querying by value is important, rather than performing lookups based only on keys.</span></span> <span data-ttu-id="4de14-156">예를 들어, 관계형 데이터베이스의 경우 WHERE 절을 사용하여 레코드를 찾을 수 있지만 키/값 저장소에는 일반적으로 값에 대해 이러한 유형의 조회 기능이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-156">For example, with a relational database, you can find a record by using a WHERE clause, but key/values stores usually do not have this type of lookup capability for values.</span></span>

<span data-ttu-id="4de14-157">단일 키/값 저장소는 별도의 컴퓨터에 있는 여러 노드에 데이터를 쉽게 배포할 수 있으므로 확장성이 매우 뛰어납니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-157">A single key/value store can be extremely scalable, as the data store can easily distribute data across multiple nodes on separate machines.</span></span>

<span data-ttu-id="4de14-158">관련 Azure 서비스:</span><span class="sxs-lookup"><span data-stu-id="4de14-158">Relevant Azure services:</span></span>

- <span data-ttu-id="4de14-159">[Cosmos DB][cosmosdb]</span><span class="sxs-lookup"><span data-stu-id="4de14-159">[Cosmos DB][cosmosdb]</span></span>
- <span data-ttu-id="4de14-160">[Azure Redis Cache][redis-cache]</span><span class="sxs-lookup"><span data-stu-id="4de14-160">[Azure Redis Cache][redis-cache]</span></span>

## <a name="document-databases"></a><span data-ttu-id="4de14-161">문서 데이터베이스</span><span class="sxs-lookup"><span data-stu-id="4de14-161">Document databases</span></span>

<span data-ttu-id="4de14-162">문서 데이터베이스는 개념적으로 키/값 저장소와 비슷하지만 명명된 필드 및 데이터의 모음(문서)을 저장하며 각각 간단한 스칼라 항목이나 목록 및 하위 모음과 같은 복합 요소가 될 수 있다는 점이 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-162">A document database is conceptually similar to a key/value store, except that it stores a collection of named fields and data (known as documents), each of which could be simple scalar items or compound elements such as lists and child collections.</span></span> <span data-ttu-id="4de14-163">문서 필드의 데이터는 XML, YAML, JSON, BSON을 비롯한 다양한 방법으로 인코딩되거나 일반 텍스트로 저장될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-163">The data in the fields of a document can be encoded in a variety of ways, including XML, YAML, JSON, BSON,or even stored as plain text.</span></span> <span data-ttu-id="4de14-164">키/값 저장소와 달리 문서의 필드는 저장소 관리 시스템에 표시되므로 애플리케이션에서 이러한 필드의 값을 사용하여 데이터를 쿼리하고 필터링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-164">Unlike key/value stores, the fields in documents are exposed to the storage management system, enabling an application to query and filter data by using the values in these fields.</span></span>

<span data-ttu-id="4de14-165">일반적으로 문서에는 엔터티의 전체 데이터가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-165">Typically, a document contains the entire data for an entity.</span></span> <span data-ttu-id="4de14-166">엔터티를 구성하는 항목은 애플리케이션에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-166">What items constitute an entity are application specific.</span></span> <span data-ttu-id="4de14-167">예를 들어, 엔터티에는 고객의 세부 정보, 주문 또는 이 두 정보의 조합을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-167">For example, an entity could contain the details of a customer, an order, or a combination of both.</span></span> <span data-ttu-id="4de14-168">RDBMS의 여러 관계형 테이블에 분산된 정보가 단일 문서에 포함될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-168">A single document may contain information that would be spread across several relational tables in an RDBMS.</span></span>

<span data-ttu-id="4de14-169">문서 저장소의 모든 문서가 동일한 구조를 가질 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-169">A document store does not require that all documents have the same structure.</span></span> <span data-ttu-id="4de14-170">이 자유 형식 접근 방식은 많은 유연성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-170">This free-form approach provides a great deal of flexibility.</span></span> <span data-ttu-id="4de14-171">비즈니스 요구 사항이 변경될 경우 애플리케이션은 문서에 다른 데이터를 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-171">Applications can store different data in documents as business requirements change.</span></span>

![문서 저장소의 다이어그램](./images/document.png)

<span data-ttu-id="4de14-173">애플리케이션은 문서 키를 사용하여 문서를 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-173">The application can retrieve documents by using the document key.</span></span> <span data-ttu-id="4de14-174">문서 키란 데이터를 균등하게 분산하는 데 사용되는 문서의 고유 식별자로서 종종 해시됩니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-174">This is a unique identifier for the document, which is often hashed, to help distribute data evenly.</span></span> <span data-ttu-id="4de14-175">일부 문서 데이터베이스는 자동으로 문서 키를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-175">Some document databases create the document key automatically.</span></span> <span data-ttu-id="4de14-176">다른 문서 데이터베이스에서는 키로 사용할 문서의 특성을 사용자가 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-176">Others enable you to specify an attribute of the document to use as the key.</span></span> <span data-ttu-id="4de14-177">애플리케이션은 하나 이상의 필드 값을 기반으로 문서를 쿼리할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-177">The application can also query documents based on the value of one or more fields.</span></span> <span data-ttu-id="4de14-178">일부 문서 데이터베이스는 하나 이상의 인덱싱된 필드를 기반으로 문서를 빠르게 조회할 수 있도록 인덱싱을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-178">Some document databases support indexing to facilitate fast lookup of documents based on one or more indexed fields.</span></span>

<span data-ttu-id="4de14-179">많은 문서 데이터베이스에서는 애플리케이션에서 전체 문서를 다시 작성하지 않고도 문서의 특정 필드 값을 수정할 수 있는 내부 업데이트를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-179">Many document databases support in-place updates, enabling an application to modify the values of specific fields in a document without rewriting the entire document.</span></span> <span data-ttu-id="4de14-180">단일 문서의 여러 필드에 대한 읽기 및 쓰기 작업은 일반적으로 원자성입니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-180">Read and write operations over multiple fields in a single document are usually atomic.</span></span>

<span data-ttu-id="4de14-181">관련 Azure 서비스: [Cosmos DB][cosmosdb]</span><span class="sxs-lookup"><span data-stu-id="4de14-181">Relevant Azure service: [Cosmos DB][cosmosdb]</span></span>

## <a name="graph-databases"></a><span data-ttu-id="4de14-182">그래프 데이터베이스</span><span class="sxs-lookup"><span data-stu-id="4de14-182">Graph databases</span></span>

<span data-ttu-id="4de14-183">그래프 데이터베이스는 노드와 에지, 두 가지 유형의 정보를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-183">A graph database stores two types of information, nodes and edges.</span></span> <span data-ttu-id="4de14-184">노드는 엔터티로 생각할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-184">You can think of nodes as entities.</span></span> <span data-ttu-id="4de14-185">에지는 노드 간의 관계를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-185">Edges which specify the relationships between nodes.</span></span> <span data-ttu-id="4de14-186">노드와 에지 모두 테이블의 열과 마찬가지로 해당 노드 또는 에지에 대한 정보를 제공하는 속성을 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-186">Both nodes and edges can have properties that provide information about that node or edge, similar to columns in a table.</span></span> <span data-ttu-id="4de14-187">에지는 또한 관계의 특성을 나타내는 방향을 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-187">Edges can also have a direction indicating the nature of the relationship.</span></span>

<span data-ttu-id="4de14-188">그래프 데이터베이스의 목적은 애플리케이션이 노드와 에지의 네트워크를 트래버스하는 쿼리를 효율적으로 수행하고 엔터티 간의 관계를 분석할 수 있게 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-188">The purpose of a graph database is to allow an application to efficiently perform queries that traverse the network of nodes and edges, and to analyze the relationships between entities.</span></span> <span data-ttu-id="4de14-189">다음 다이어그램은 그래프로 구성된 조직의 인사 데이터베이스를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-189">The following diagram shows an organization's personnel database structured as a graph.</span></span> <span data-ttu-id="4de14-190">엔터티는 직원 및 부서이며, 에지는 보고 관계 및 직원이 근무하는 부서를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-190">The entities are employees and departments, and the edges indicate reporting relationships and the department in which employees work.</span></span> <span data-ttu-id="4de14-191">이 그래프에서 에지의 화살표는 관계 방향을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-191">In this graph, the arrows on the edges show the direction of the relationships.</span></span>

![문서 데이터베이스의 다이어그램](./images/graph.png)

<span data-ttu-id="4de14-193">이 구조를 통해 "Sarah에게 직접 또는 간접적으로 보고하는 모든 직원 찾기" 또는 "John과 같은 부서에서 근무하는 직원"과 같은 쿼리를 간단하게 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-193">This structure makes it straightforward to perform queries such as "Find all employees who report directly or indirectly to Sarah" or "Who works in the same department as John?"</span></span> <span data-ttu-id="4de14-194">엔터티와 관계가 많은 대형 그래프의 경우 매우 복잡한 분석을 매우 신속하게 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-194">For large graphs with lots of entities and relationships, you can perform very complex analyses very quickly.</span></span> <span data-ttu-id="4de14-195">많은 그래프 데이터베이스는 관계 네트워크를 효율적으로 트래버스하는 데 사용할 수 있는 쿼리 언어를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-195">Many graph databases provide a query language that you can use to traverse a network of relationships efficiently.</span></span>

<span data-ttu-id="4de14-196">관련 Azure 서비스: [Cosmos DB][cosmosdb]</span><span class="sxs-lookup"><span data-stu-id="4de14-196">Relevant Azure service: [Cosmos DB][cosmosdb]</span></span>

## <a name="column-family-databases"></a><span data-ttu-id="4de14-197">열 패밀리 데이터베이스</span><span class="sxs-lookup"><span data-stu-id="4de14-197">Column-family databases</span></span>

<span data-ttu-id="4de14-198">열 패밀리 데이터베이스는 데이터를 행과 열로 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-198">A column-family database organizes data into rows and columns.</span></span> <span data-ttu-id="4de14-199">가장 간단한 형태인 열 패밀리 데이터베이스는 적어도 개념적으로 관계형 데이터베이스와 매우 유사하게 보일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-199">In its simplest form, a column-family database can appear very similar to a relational database, at least conceptually.</span></span> <span data-ttu-id="4de14-200">열 패밀리 데이터베이스의 이점은 스파스 데이터를 구조화하기 위한 비정규화된 접근법에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-200">The real power of a column-family database lies in its denormalized approach to structuring sparse data.</span></span>

<span data-ttu-id="4de14-201">열 패밀리 데이터베이스는 행과 열이 있는 표 형식 데이터로 생각할 수 있지만 열은 *열 패밀리*라는 그룹으로 나뉩니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-201">You can think of a column-family database as holding tabular data with rows and columns, but the columns are divided into groups known as *column families*.</span></span> <span data-ttu-id="4de14-202">각 열 패밀리는 논리적으로 관련되어 있고 일반적으로 하나의 단위로 검색되거나 조작되는 열 집합을 보유합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-202">Each column family holds a set of columns that are logically related together and are typically retrieved or manipulated as a unit.</span></span> <span data-ttu-id="4de14-203">개별적으로 액세스되는 다른 데이터는 별도의 열 패밀리에 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-203">Other data that is accessed separately can be stored in separate column families.</span></span> <span data-ttu-id="4de14-204">열 패밀리 내에서 새 열을 동적으로 추가할 수 있고 행은 스파스될 수 있습니다. 즉, 행은 모든 열에 대해 값을 가질 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-204">Within a column family, new columns can be added dynamically, and rows can be sparse (that is, a row doesn't need to have a value for every column).</span></span>

<span data-ttu-id="4de14-205">다음 다이어그램은 `Identity` 및 `Contact Info`의 두 열 패밀리가 있는 예를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-205">The following diagram shows an example with two column families, `Identity` and `Contact Info`.</span></span> <span data-ttu-id="4de14-206">단일 엔터티의 데이터에는 각 열 패밀리에서 동일한 행 키가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-206">The data for a single entity has the same row key in each column-family.</span></span> <span data-ttu-id="4de14-207">열 패밀리의 특정 개체에 대한 행이 동적으로 달라질 수 있는 이 구조는 열 패밀리 접근 방식의 중요한 이점이므로 이 데이터 저장소 형식은 구조화된 휘발성 데이터를 저장하는 데 매우 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-207">This structure, where the rows for any given object in a column family can vary dynamically, is an important benefit of the column-family approach, making this form of data store highly suited for storing structured, volatile data.</span></span>

![열 패밀리 데이터베이스의 다이어그램](./images/column-family.png)

<span data-ttu-id="4de14-209">키/값 저장소 또는 문서 데이터베이스와 달리 대부분의 열 패밀리 데이터베이스는 해시를 계산하지 않고 키 순서로 데이터를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-209">Unlike a key/value store or a document database, most column-family databases store data in key order, rather than by computing a hash.</span></span> <span data-ttu-id="4de14-210">많은 구현을 통해 열 패밀리의 특정 열에 대한 인덱스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-210">Many implementations allow you to create indexes over specific columns in a column-family.</span></span> <span data-ttu-id="4de14-211">인덱스를 사용하면 행 키가 아닌 열 값으로 데이터를 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-211">Indexes let you retrieve data by columns value, rather than row key.</span></span>

<span data-ttu-id="4de14-212">행에 대한 읽기 및 쓰기 작업은 일반적으로 단일 열 패밀리에 대해 원자성이지만 일부 구현은 여러 열 패밀리에 걸쳐 전체 행에 원자성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-212">Read and write operations for a row are usually atomic with a single column-family, although some implementations provide atomicity across the entire row, spanning multiple column-families.</span></span>

<span data-ttu-id="4de14-213">관련 Azure 서비스: [HDInsight의 HBase][hbase]</span><span class="sxs-lookup"><span data-stu-id="4de14-213">Relevant Azure service: [HBase in HDInsight][hbase]</span></span>

## <a name="data-analytics"></a><span data-ttu-id="4de14-214">데이터 분석</span><span class="sxs-lookup"><span data-stu-id="4de14-214">Data analytics</span></span>

<span data-ttu-id="4de14-215">데이터 분석 저장소는 데이터 수집, 저장 및 분석을 위한 대규모 병렬 솔루션을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-215">Data analytics stores provide massively parallel solutions for ingesting, storing, and analyzing data.</span></span> <span data-ttu-id="4de14-216">이 데이터는 공유 안 함(share-nothing) 아키텍처를 사용하여 여러 서버에 분산되어 확장성을 최대화하고 종속성을 최소화합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-216">This data is distributed across multiple servers using a share-nothing architecture to maximize scalability and minimize dependencies.</span></span> <span data-ttu-id="4de14-217">데이터는 정적일 가능성이 낮기 때문에 이러한 저장소는 여러 스트림에서 다양한 형식으로 도착하는 대량의 정보를 처리하면서 새로운 쿼리를 계속 처리할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-217">The data is unlikely to be static, so these stores must be able to handle large quantities of information, arriving in a variety of formats from multiple streams, while continuing to process new queries.</span></span>

<span data-ttu-id="4de14-218">관련 Azure 서비스:</span><span class="sxs-lookup"><span data-stu-id="4de14-218">Relevant Azure services:</span></span>

- <span data-ttu-id="4de14-219">[SQL Data Warehouse][sql-dw]</span><span class="sxs-lookup"><span data-stu-id="4de14-219">[SQL Data Warehouse][sql-dw]</span></span>
- <span data-ttu-id="4de14-220">[Azure Data Lake][data-lake]</span><span class="sxs-lookup"><span data-stu-id="4de14-220">[Azure Data Lake][data-lake]</span></span>

## <a name="search-engine-databases"></a><span data-ttu-id="4de14-221">검색 엔진 데이터베이스</span><span class="sxs-lookup"><span data-stu-id="4de14-221">Search Engine Databases</span></span>  

<span data-ttu-id="4de14-222">검색 엔진 데이터베이스는 외부 데이터 저장소 및 서비스에 보관된 정보를 검색하는 기능을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-222">A search engine database supports the ability to search for information held in external data stores and services.</span></span> <span data-ttu-id="4de14-223">검색 엔진 데이터베이스를 사용하면 대용량 데이터를 인덱싱하고 이러한 인덱스에 거의 실시간으로 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-223">A search engine database can be used to index massive volumes of data and provide near real-time access to these indexes.</span></span> <span data-ttu-id="4de14-224">검색 엔진 데이터베이스는 일반적으로 웹과 동의어로 간주되지만 많은 대규모 시스템에서 이를 사용하여 자체 데이터베이스 위에 구조화된 임시 검색 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-224">Although search engine databases are commonly thought of as being synonymous with the web, many large-scale systems use them to provide structured and ad-hoc search capabilities on top of their own databases.</span></span>

<span data-ttu-id="4de14-225">검색 엔진 데이터베이스의 주요 특징은 정보를 매우 신속하게 저장 및 인덱싱하고 검색 요청에 대해 빠른 응답 시간을 제공할 수 있다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-225">The key characteristics of a search engine database are the ability to store and index information very quickly, and provide fast response times for search requests.</span></span> <span data-ttu-id="4de14-226">인덱스는 다차원적일 수 있으며 많은 양의 텍스트 데이터에서 자유 텍스트 검색을 지원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-226">Indexes can be multi-dimensional and may support free-text searches across large volumes of text data.</span></span> <span data-ttu-id="4de14-227">인덱싱은 검색 엔진 데이터베이스에 의해 트리거되는 끌어오기 모델을 사용하거나 외부 애플리케이션 코드에 의해 시작되는 밀어넣기 모델을 사용하여 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-227">Indexing can be performed using a pull model, triggered by the search engine database, or using a push model, initiated by external application code.</span></span>

<span data-ttu-id="4de14-228">검색은 정확한 항목 또는 유사 항목을 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-228">Searching can be exact or fuzzy.</span></span> <span data-ttu-id="4de14-229">유사 항목 검색은 용어 집합과 일치하는 문서를 찾고 일치하는 정도를 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-229">A fuzzy search finds documents that match a set of terms and calculates how closely they match.</span></span> <span data-ttu-id="4de14-230">일부 검색 엔진은 동의어, 장르 확장(예: `dogs` 및 `pets` 일치) 및 형태소 분석(동일한 어근일 경우 일치하는 단어로 판단)을 기반으로 일치 항목을 반환할 수 있는 언어 분석도 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-230">Some search engines also support linguistic analysis that can return matches based on synonyms, genre expansions (for example, matching `dogs` to `pets`), and stemming (matching words with the same root).</span></span>

<span data-ttu-id="4de14-231">관련 Azure 서비스: [Azure Search][search]</span><span class="sxs-lookup"><span data-stu-id="4de14-231">Relevant Azure service: [Azure Search][search]</span></span>

## <a name="time-series-databases"></a><span data-ttu-id="4de14-232">시계열 데이터베이스</span><span class="sxs-lookup"><span data-stu-id="4de14-232">Time Series Databases</span></span>

<span data-ttu-id="4de14-233">시계열 데이터는 시간별로 구성된 값 집합이며 시계열 데이터베이스는 이러한 유형의 데이터에 대해 최적화된 데이터베이스입니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-233">Time series data is a set of values organized by time, and a time series database is a database that is optimized for this type of data.</span></span> <span data-ttu-id="4de14-234">시계열 데이터베이스는 대개 여러 소스에서 대량의 데이터를 실시간으로 수집하기 때문에 매우 많은 쓰기를 지원해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-234">Time series databases must support a very high number of writes, as they typically collect large amounts of data in real time from a large number of sources.</span></span> <span data-ttu-id="4de14-235">업데이트는 거의 발생하지 않으며 삭제는 종종 대량 작업으로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-235">Updates are rare, and deletes are often done as bulk operations.</span></span> <span data-ttu-id="4de14-236">시계열 데이터베이스에 기록된 레코드는 일반적으로 작지만 레코드 수가 많아 전체 데이터 크기가 빠르게 커지는 경우가 종종 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-236">Although the records written to a time-series database are generally small,  there are often a large number of records, and total data size can grow rapidly.</span></span>

<span data-ttu-id="4de14-237">시계열 데이터베이스는 원격 분석 데이터를 저장하는 데 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-237">Time series databases are good for storing telemetry data.</span></span> <span data-ttu-id="4de14-238">시나리오에는 IoT 센서 또는 애플리케이션/시스템 카운터가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-238">Scenarios include IoT sensors or application/system counters.</span></span>

<span data-ttu-id="4de14-239">관련 Azure 서비스: [Time Series Insights][time-series]</span><span class="sxs-lookup"><span data-stu-id="4de14-239">Relevant Azure service: [Time Series Insights][time-series]</span></span>

## <a name="object-storage"></a><span data-ttu-id="4de14-240">개체 저장소</span><span class="sxs-lookup"><span data-stu-id="4de14-240">Object storage</span></span>  

<span data-ttu-id="4de14-241">개체 스토리지는 대형 이진 개체(이미지, 파일, 비디오 및 오디오 스트림, 대형 애플리케이션 데이터 개체 및 문서, 가상 머신 디스크 이미지)를 저장하고 검색하는 데 최적화되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-241">Object storage is optimized for storing and retrieving large binary objects (images, files, video and audio streams, large application data objects and documents, virtual machine disk images).</span></span> <span data-ttu-id="4de14-242">이러한 저장소 유형의 개체는 저장된 데이터, 일부 메타데이터 및 개체에 액세스하기 위한 고유한 ID로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-242">Objects in these store types are composed of the stored data, some metadata, and a unique ID for accessing the object.</span></span> <span data-ttu-id="4de14-243">개체 저장소를 사용하면 매우 많은 양의 구조화되지 않은 데이터를 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-243">Object stores enables the management of extremely large amounts of unstructured data.</span></span>

<span data-ttu-id="4de14-244">관련 Azure 서비스: [Blob Storage][blob]</span><span class="sxs-lookup"><span data-stu-id="4de14-244">Relevant Azure service: [Blob Storage][blob]</span></span>

## <a name="shared-files"></a><span data-ttu-id="4de14-245">공유 파일</span><span class="sxs-lookup"><span data-stu-id="4de14-245">Shared files</span></span>

<span data-ttu-id="4de14-246">때로는 간단한 플랫 파일을 사용하는 것이 정보를 저장하고 검색하는 가장 효과적인 방법이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-246">Sometimes, using simple flat files can be the most effective means of storing and retrieving information.</span></span> <span data-ttu-id="4de14-247">파일 공유를 사용하면 네트워크를 통해 파일에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-247">Using file shares enables files to be accessed across a network.</span></span> <span data-ttu-id="4de14-248">적절한 보안 및 동시 액세스 제어 메커니즘이 제공되면 이러한 방식으로 데이터를 공유하여, 분산 서비스를 통해 단순 읽기 및 쓰기 요청과 같은 기본, 저수준 작업을 수행하기 위한 확장성이 뛰어난 데이터 액세스를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4de14-248">Given appropriate security and concurrent access control mechanisms, sharing data in this way can enable distributed services to provide highly scalable data access for performing basic, low-level operations such as simple read and write requests.</span></span>

<span data-ttu-id="4de14-249">관련 Azure 서비스: [File Storage][file-storage]</span><span class="sxs-lookup"><span data-stu-id="4de14-249">Relevant Azure service: [File Storage][file-storage]</span></span>

<!-- links -->

[blob]: https://azure.microsoft.com/services/storage/blobs/
[cosmosdb]: https://azure.microsoft.com/services/cosmos-db/
[data-lake]: https://azure.microsoft.com/solutions/data-lake/
[file-storage]: https://azure.microsoft.com/services/storage/files/
[hbase]: /azure/hdinsight/hdinsight-hbase-overview
[mysql]: https://azure.microsoft.com/services/mysql/
[postgres]: https://azure.microsoft.com/services/postgresql/
[redis-cache]: https://azure.microsoft.com/services/cache/
[search]: https://azure.microsoft.com/services/search/
[sql-db]: https://azure.microsoft.com/services/sql-database
[sql-dw]: https://azure.microsoft.com/services/sql-data-warehouse/
[time-series]: https://azure.microsoft.com/services/time-series-insights/
