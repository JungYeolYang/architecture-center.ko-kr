---
title: 이벤트 기반 아키텍처 스타일
description: Azure에서 이벤트 기반 아키텍처와 IoT 아키텍처의 혜택, 과제 및 모범 사례를 설명합니다.
author: MikeWasson
ms.date: 08/30/2018
ms.openlocfilehash: 67e823d72f1f66669a052f7ae05c13adc7e5c463
ms.sourcegitcommit: ae8a1de6f4af7a89a66a8339879843d945201f85
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/31/2018
ms.locfileid: "43326111"
---
# <a name="event-driven-architecture-style"></a>이벤트 기반 아키텍처 스타일

이벤트 기반 아키텍처는 이벤트 스트림을 생성하는 **이벤트 생산자**와 이벤트를 수신 대기하는 **이벤트 소비자**로 구성됩니다. 

![](./images/event-driven.svg)

이벤트는 거의 실시간으로 전달되므로 이벤트가 발생하는 즉시 소비자가 이벤트에 응답할 수 있습니다. 생산자와 소비자가 분리되므로 생산자는 수신 대기 중인 소비자를 알 수 없습니다. 소비자도 서로 분리되며 각 소비자에게 모든 이벤트가 표시됩니다. 이는 소비자가 큐에서 메시지를 끌어오고 오류가 없다고 가정할 경우 메시지가 한 번만 처리되는 [경쟁 소비자][competing-consumers] 패턴과 다릅니다. IoT와 같은 일부 시스템에서는 매우 높은 볼륨으로 이벤트를 수집해야 합니다.

이벤트 기반 아키텍처는 게시자/구독자 모델 또는 이벤트 스트림 모델을 사용할 수 있습니다. 

- **게시자/구독자**: 메시징 인프라에서 구독을 추적합니다. 이벤트가 게시되면 각 구독자에게 이벤트를 보냅니다. 이벤트를 받은 후에는 재생할 수 없으며 새 구독자에게 이벤트가 표시되지 않습니다. 

- **이벤트 스트리밍**: 이벤트가 로그에 기록됩니다. 이벤트가 파티션 내에 엄격하게 정렬되며 지속 가능합니다. 클라이언트는 스트림을 구독하지 않고, 대신 스트림의 일부에서 읽을 수 있습니다. 클라이언트가 스트림에서 해당 위치를 진행해야 합니다. 즉, 클라이언트가 언제든지 연결하고 이벤트를 재생할 수 있습니다.

소비자 측면에서 다음과 같은 몇 가지 일반적인 변형이 있습니다.

- **단순 이벤트 처리**. 이벤트가 즉시 소비자에서 작업을 트리거합니다. 예를 들어 서비스 버스 토픽에 메시지를 게시할 때마다 함수가 실행되도록 서비스 버스 트리거와 함께 Azure Functions를 사용할 수 있습니다.

- **복합 이벤트 처리**. 소비자가 Azure Stream Analytics 또는 Apache Storm과 같은 기술을 사용하여 이벤트 데이터에서 패턴을 찾으면서 일련의 이벤트를 처리합니다. 예를 들어 포함된 디바이스에서 일정 기간 동안 읽은 값을 집계하고 이동 평균이 특정 임계값을 초과하면 알림을 생성할 수 있습니다. 

- **이벤트 스트림 처리**. Azure IoT Hub 또는 Apache Kafka와 같은 데이터 스트리밍 플랫폼을 파이프라인으로 사용하여 이벤트를 수집하고 스트림 프로세서에 공급합니다. 스트림 프로세서는 스트림을 처리하거나 변환합니다. 응용 프로그램의 각 하위 시스템에 사용되는 여러 스트림 프로세서가 있을 수 있습니다. 이 접근 방법은 IoT 워크로드에 적합합니다.

이벤트의 소스가 IoT 솔루션의 물리적 디바이스와 같이 시스템 외부에 있을 수도 있습니다. 이 경우 시스템이 데이터 원본에 필요한 볼륨 및 처리량으로 데이터를 수집할 수 있어야 합니다.

위의 논리 다이어그램에서 각 소비자 유형은 단일 상자로 표시됩니다. 실제로는 소비자가 시스템의 단일 실패 지점이 되지 않도록 한 소비자의 여러 인스턴스가 있는 것이 일반적입니다. 이벤트의 볼륨 및 빈도를 처리하기 위해 여러 인스턴스가 필요할 수도 있습니다. 또한 단일 소비자가 여러 스레드의 이벤트를 처리할 수 있습니다. 이벤트가 순서대로 처리되어야 하거나 정확히 한 번 처리되어야 하는 경우 이것이 문제가 될 수 있습니다. [조정 최소화][minimize-coordination]를 참조하세요. 

## <a name="when-to-use-this-architecture"></a>이 아키텍처를 사용하는 경우

- 여러 하위 시스템이 동일한 이벤트를 처리해야 하는 경우. 
- 최소 시간 지연의 실시간 처리.
- 패턴 일치 또는 일정 기간의 집계와 같은 복합 이벤트 처리.
- 높은 볼륨 및 높은 데이터 개발속도(예: IoT).

## <a name="benefits"></a>이점

- 생산자와 소비자가 분리됩니다.
- 지점 간 통합이 없습니다. 시스템에 새 소비자를 쉽게 추가할 수 있습니다.
- 이벤트가 도착하는 즉시 소비자가 이벤트에 응답할 수 있습니다. 
- 확장성이 있고 배포 가능합니다. 
- 하위 시스템에서 이벤트 스트림을 독립적으로 확인할 수 있습니다.

## <a name="challenges"></a>과제

- 배달 보장. 일부 시스템, 특히 IoT 시나리오에서는 이벤트가 배달되도록 보장하는 것이 중요합니다.
- 이벤트를 순서대로 또는 한 번만 처리. 복원 및 확장성을 위해 일반적으로 각 소비자 유형이 여러 인스턴스에서 실행됩니다. 이벤트가 소비자 유형 내에서 순서대로 처리되어야 하거나 처리 논리가 비멱등적인 경우 이것이 문제가 될 수 있습니다.

 <!-- links -->

[competing-consumers]: ../../patterns/competing-consumers.md
[minimize-coordination]: ../design-principles/minimize-coordination.md


