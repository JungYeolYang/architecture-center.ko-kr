---
title: 조정 최소화
description: 확장성을 위해 응용 프로그램 서비스 간의 조정 최소화
author: MikeWasson
ms.date: 08/30/2018
ms.openlocfilehash: 0e0aa34f851ee743a0c4bebc6d9ca63d7f3ae203
ms.sourcegitcommit: ae8a1de6f4af7a89a66a8339879843d945201f85
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/31/2018
ms.locfileid: "43326217"
---
# <a name="minimize-coordination"></a><span data-ttu-id="b50af-103">조정 최소화</span><span class="sxs-lookup"><span data-stu-id="b50af-103">Minimize coordination</span></span> 

## <a name="minimize-coordination-between-application-services-to-achieve-scalability"></a><span data-ttu-id="b50af-104">확장성을 위해 응용 프로그램 서비스 간의 조정 최소화</span><span class="sxs-lookup"><span data-stu-id="b50af-104">Minimize coordination between application services to achieve scalability</span></span>

<span data-ttu-id="b50af-105">대부분의 클라우드 응용 프로그램은 웹 프런트 엔드, 데이터베이스, 비즈니스 프로세스, 보고 및 분석 등 여러 응용 프로그램 서비스로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-105">Most cloud applications consist of multiple application services &mdash; web front ends, databases, business processes, reporting and analysis, and so on.</span></span> <span data-ttu-id="b50af-106">확장성 및 안정성을 얻으려면 이러한 각 서비스가 여러 인스턴스에서 실행되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-106">To achieve scalability and reliability, each of those services should run on multiple instances.</span></span> 

<span data-ttu-id="b50af-107">두 인스턴스가 일부 공유 상태에 영향을 주는 작업을 동시에 수행하려고 하면 어떻게 될까요?</span><span class="sxs-lookup"><span data-stu-id="b50af-107">What happens when two instances try to perform concurrent operations that affect some shared state?</span></span> <span data-ttu-id="b50af-108">ACID 보장 유지 등을 위해 노드 간에 조정이 필요한 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-108">In some cases, there must be coordination across nodes, for example to preserve ACID guarantees.</span></span> <span data-ttu-id="b50af-109">이 다이어그램에서 `Node2`는 `Node1`에서 데이터베이스 잠금을 해제할 때까지 대기 중입니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-109">In this diagram, `Node2` is waiting for `Node1` to release a database lock:</span></span>

![](./images/database-lock.svg)

<span data-ttu-id="b50af-110">조정은 수평적 확장의 혜택을 제한하고 병목 상태를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-110">Coordination limits the benefits of horizontal scale and creates bottlenecks.</span></span> <span data-ttu-id="b50af-111">이 예제에서는 응용 프로그램을 확장하고 인스턴스를 추가함에 따라 잠금 경합이 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-111">In this example, as you scale out the application and add more instances, you'll see increased lock contention.</span></span> <span data-ttu-id="b50af-112">최악의 경우 프론트 엔드 인스턴스가 잠금을 기다리는 데 대부분의 시간을 허비합니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-112">In the worst case, the front-end instances will spend most of their time waiting on locks.</span></span>

<span data-ttu-id="b50af-113">"정확히 한 번" 의미 체계도 조정이 자주 발생하는 원인 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-113">"Exactly once" semantics are another frequent source of coordination.</span></span> <span data-ttu-id="b50af-114">예를 들어 주문이 정확히 한 번 처리되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-114">For example, an order must be processed exactly once.</span></span> <span data-ttu-id="b50af-115">두 명의 작업자가 새 주문을 수신 대기 중입니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-115">Two workers are listening for new orders.</span></span> <span data-ttu-id="b50af-116">`Worker1`이 처리를 위해 주문을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-116">`Worker1` picks up an order for processing.</span></span> <span data-ttu-id="b50af-117">응용 프로그램에서 `Worker2`가 작업을 중복하지 않고, `Worker1` 작동이 중단될 경우 주문이 삭제되지 않도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-117">The application must ensure that `Worker2` doesn't duplicate the work, but also if `Worker1` crashes, the order isn't dropped.</span></span>

![](./images/coordination.svg)

<span data-ttu-id="b50af-118">[Scheduler 에이전트 감독자][sas-pattern] 등의 패턴을 사용하여 작업자 간에 조정할 수 있지만, 이 경우 작업을 분할하는 것이 더 나을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-118">You can use a pattern such as [Scheduler Agent Supervisor][sas-pattern] to coordinate between the workers, but in this case a better approach might be to partition the work.</span></span> <span data-ttu-id="b50af-119">각 작업자에게 특정 범위의 주문(가령, 청구 지역별)이 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-119">Each worker is assigned a certain range of orders (say, by billing region).</span></span> <span data-ttu-id="b50af-120">작업자 작동이 중단될 경우 새 인스턴스에서 이전 인스턴스가 중단된 지점을 선택하지만 여러 인스턴스가 경합하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-120">If a worker crashes, a new instance picks up where the previous instance left off, but multiple instances aren't contending.</span></span>

## <a name="recommendations"></a><span data-ttu-id="b50af-121">권장 사항</span><span class="sxs-lookup"><span data-stu-id="b50af-121">Recommendations</span></span>

<span data-ttu-id="b50af-122">**결과적 일관성 보장**.</span><span class="sxs-lookup"><span data-stu-id="b50af-122">**Embrace eventual consistency**.</span></span> <span data-ttu-id="b50af-123">데이터가 분산된 경우 강력한 일관성 보장을 적용하려면 조정이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-123">When data is distributed, it takes coordination to enforce strong consistency guarantees.</span></span> <span data-ttu-id="b50af-124">예를 들어 한 작업에서 두 데이터베이스를 업데이트한다고 가정할 경우,</span><span class="sxs-lookup"><span data-stu-id="b50af-124">For example, suppose an operation updates two databases.</span></span> <span data-ttu-id="b50af-125">이 작업을 단일 트랜잭션 범위에 넣는 대신 시스템이 실패 후 논리적으로 롤백하기 위해 [보상 트랜잭션][compensating-transaction] 패턴을 사용하여 결과적 일관성을 수용할 수 있다면 더 나을 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-125">Instead of putting it into a single transaction scope, it's better if the system can accommodate eventual consistency, perhaps by using the [Compensating Transaction][compensating-transaction] pattern to logically roll back after a failure.</span></span>

<span data-ttu-id="b50af-126">**도메인 이벤트를 사용하여 상태 동기화**.</span><span class="sxs-lookup"><span data-stu-id="b50af-126">**Use domain events to synchronize state**.</span></span> <span data-ttu-id="b50af-127">[도메인 이벤트][domain-event]는 도메인 내에서 중요한 사항이 발생할 때 기록되는 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-127">A [domain event][domain-event] is an event that records when something happens that has significance within the domain.</span></span> <span data-ttu-id="b50af-128">글로벌 트랜잭션을 사용하여 여러 서비스 간에 조정하는 대신 관심 있는 서비스가 이벤트를 수신 대기할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-128">Interested services can listen for the event, rather than using a global transaction to coordinate across multiple services.</span></span> <span data-ttu-id="b50af-129">이 접근 방법을 사용할 경우 시스템이 결과적 일관성(이전 항목 참조)을 허용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-129">If this approach is used, the system must tolerate eventual consistency (see previous item).</span></span> 

<span data-ttu-id="b50af-130">**CQRS, 이벤트 소싱 등의 패턴 고려**.</span><span class="sxs-lookup"><span data-stu-id="b50af-130">**Consider patterns such as CQRS and event sourcing**.</span></span> <span data-ttu-id="b50af-131">이러한 두 패턴은 읽기 워크로드와 쓰기 워크로드 간의 경합을 줄이는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-131">These two patterns can help to reduce contention between read workloads and write workloads.</span></span> 

- <span data-ttu-id="b50af-132">[CQRS 패턴][cqrs-pattern]은 읽기 작업과 쓰기 작업을 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-132">The [CQRS pattern][cqrs-pattern] separates read operations from write operations.</span></span> <span data-ttu-id="b50af-133">일부 구현에서는 데이터 읽기와 데이터 쓰기가 물리적으로 분리됩니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-133">In some implementations, the read data is physically separated from the write data.</span></span> 

- <span data-ttu-id="b50af-134">[이벤트 소싱 패턴][event-sourcing]에서는 상태 변경이 추가 전용 데이터 저장소에 일련의 이벤트로 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-134">In the [Event Sourcing pattern][event-sourcing], state changes are recorded as a series of events to an append-only data store.</span></span> <span data-ttu-id="b50af-135">스트림에 이벤트 추가가 최소 잠금이 필요한 원자성 작업이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-135">Appending an event to the stream is an atomic operation, requiring minimal locking.</span></span> 

<span data-ttu-id="b50af-136">이러한 두 패턴은 서로 보완됩니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-136">These two patterns complement each other.</span></span> <span data-ttu-id="b50af-137">CQRS의 쓰기 전용 저장소가 이벤트 소싱을 사용하는 경우 읽기 전용 저장소는 동일한 이벤트를 수신 대기하여 쿼리에 최적화된 현재 상태의 읽기 가능 스냅숏을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-137">If the write-only store in CQRS uses event sourcing, the read-only store can listen for the same events to create a readable snapshot of the current state, optimized for queries.</span></span> <span data-ttu-id="b50af-138">그러나 CQRS 또는 이벤트 소싱을 채택하기 전에 이 접근 방법의 과제를 알고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-138">Before adopting CQRS or event sourcing, however, be aware of the challenges of this approach.</span></span> <span data-ttu-id="b50af-139">자세한 내용은 [CQRS 아키텍처 스타일][cqrs-style]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b50af-139">For more information, see [CQRS architecture style][cqrs-style].</span></span>

<span data-ttu-id="b50af-140">**데이터 분할**.</span><span class="sxs-lookup"><span data-stu-id="b50af-140">**Partition data**.</span></span>  <span data-ttu-id="b50af-141">여러 응용 프로그램 서비스에서 공유되는 하나의 데이터 스키마에 데이터를 모두 넣지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-141">Avoid putting all of your data into one data schema that is shared across many application services.</span></span> <span data-ttu-id="b50af-142">마이크로 서비스 아키텍처는 각 서비스가 자체 데이터 저장소를 담당하도록 하여 이 원칙을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-142">A microservices architecture enforces this principle by making each service responsible for its own data store.</span></span> <span data-ttu-id="b50af-143">단일 데이터베이스 내에서 데이터를 분할된 데이터베이스로 분할하면 특정 분할된 데이터베이스에 쓰는 서비스가 다른 분할된 데이터베이스에 쓰는 서비스에 영향을 주지 않으므로 동시성이 향상될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-143">Within a single database, partitioning the data into shards can improve concurrency, because a service writing to one shard does not affect a service writing to a different shard.</span></span>

<span data-ttu-id="b50af-144">**멱등적 작업 디자인**.</span><span class="sxs-lookup"><span data-stu-id="b50af-144">**Design idempotent operations**.</span></span> <span data-ttu-id="b50af-145">가능할 경우 작업을 멱등적으로 디자인합니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-145">When possible, design operations to be idempotent.</span></span> <span data-ttu-id="b50af-146">이렇게 하면 최소 한 번 의미 체계를 사용하여 작업을 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-146">That way, they can be handled using at-least-once semantics.</span></span> <span data-ttu-id="b50af-147">예를 들어 작업 항목을 큐에 넣을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-147">For example, you can put work items on a queue.</span></span> <span data-ttu-id="b50af-148">작업 도중 작업자 작동이 중단될 경우 다른 작업자가 작업 항목을 선택하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-148">If a worker crashes in the middle of an operation, another worker simply picks up the work item.</span></span>

<span data-ttu-id="b50af-149">**비동기 병렬 처리 사용**.</span><span class="sxs-lookup"><span data-stu-id="b50af-149">**Use asynchronous parallel processing**.</span></span> <span data-ttu-id="b50af-150">작업에 비동기적으로 수행되는 여러 단계가 필요한 경우(예: 원격 서비스 호출) 병렬로 호출한 다음 결과를 집계할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-150">If an operation requires multiple steps that are performed asynchronously (such as remote service calls), you might be able to call them in parallel, and then aggregate the results.</span></span> <span data-ttu-id="b50af-151">이 접근 방법에서는 각 단계가 이전 단계의 결과에 따라 달라지지 않는다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-151">This approach assumes that each step does not depend on the results of the previous step.</span></span>   

<span data-ttu-id="b50af-152">**가능한 경우 낙관적 동시성 사용**.</span><span class="sxs-lookup"><span data-stu-id="b50af-152">**Use optimistic concurrency when possible**.</span></span> <span data-ttu-id="b50af-153">비관적 동시성 제어는 데이터베이스 잠금을 사용하여 충돌을 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-153">Pessimistic concurrency control uses database locks to prevent conflicts.</span></span> <span data-ttu-id="b50af-154">이로 인해 성능이 저하되고 가용성이 감소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-154">This can cause poor performance and reduce availability.</span></span> <span data-ttu-id="b50af-155">낙관적 동시성 제어를 사용하여 각 트랜잭션이 데이터 복사본 또는 스냅숏을 수정합니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-155">With optimistic concurrency control, each transaction modifies a copy or snapshot of the data.</span></span> <span data-ttu-id="b50af-156">트랜잭션이 커밋되면 데이터베이스 엔진이 트랜잭션의 유효성을 검사하고 데이터베이스 일관성에 영향을 주는 트랜잭션을 거부합니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-156">When the transaction is committed, the database engine validates the transaction and rejects any transactions that would affect database consistency.</span></span> 

<span data-ttu-id="b50af-157">Azure SQL Database 및 SQL Server는 [스냅숏 격리][sql-snapshot-isolation]를 통해 낙관적 동시성을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-157">Azure SQL Database and SQL Server support optimistic concurrency through [snapshot isolation][sql-snapshot-isolation].</span></span> <span data-ttu-id="b50af-158">[Azure Cosmos DB][cosmosdb-faq] 및 [Azure Storage][storage-concurrency]를 비롯한 일부 Azure Storage 서비스는 Etags를 사용하여 낙관적 동시성을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-158">Some Azure storage services support optimistic concurrency through the use of Etags, including [Azure Cosmos DB][cosmosdb-faq] and [Azure Storage][storage-concurrency].</span></span>

<span data-ttu-id="b50af-159">**MapReduce 또는 기타 병렬 분산 알고리즘 고려**.</span><span class="sxs-lookup"><span data-stu-id="b50af-159">**Consider MapReduce or other parallel, distributed algorithms**.</span></span> <span data-ttu-id="b50af-160">수행할 작업 유형과 데이터에 따라 병렬로 작동하는 여러 노드에서 수행할 수 있는 독립 태스크로 작업을 분할할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-160">Depending on the data and type of work to be performed, you may be able to split the work into independent tasks that can be performed by multiple nodes working in parallel.</span></span> <span data-ttu-id="b50af-161">[큰 계산 아키텍처 스타일][big-compute]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b50af-161">See [Big compute architecture style][big-compute].</span></span>

<span data-ttu-id="b50af-162">**조정을 위해 리더 선택 사용**.</span><span class="sxs-lookup"><span data-stu-id="b50af-162">**Use leader election for coordination**.</span></span> <span data-ttu-id="b50af-163">작업을 조정해야 하는 경우 코디네이터가 응용 프로그램의 단일 실패 지점이 되지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-163">In cases where you need to coordinate operations, make sure the coordinator does not become a single point of failure in the application.</span></span> <span data-ttu-id="b50af-164">[리더 선택 패턴][leader-election]을 사용하면 언제든지 한 인스턴스가 리더가 되어 코디네이터 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-164">Using the [Leader Election pattern][leader-election], one instance is the leader at any time, and acts as the coordinator.</span></span> <span data-ttu-id="b50af-165">리더가 실패하면 새 인스턴스가 리더로 선택됩니다.</span><span class="sxs-lookup"><span data-stu-id="b50af-165">If the leader fails, a new instance is elected to be the leader.</span></span> 
 

<!-- links -->

[big-compute]: ../architecture-styles/big-compute.md
[compensating-transaction]: ../../patterns/compensating-transaction.md
[cqrs-style]: ../architecture-styles/cqrs.md
[cqrs-pattern]: ../../patterns/cqrs.md
[cosmosdb-faq]: /azure/cosmos-db/faq
[domain-event]: https://martinfowler.com/eaaDev/DomainEvent.html
[event-sourcing]: ../../patterns/event-sourcing.md
[leader-election]: ../../patterns/leader-election.md
[sas-pattern]: ../../patterns/scheduler-agent-supervisor.md
[sql-snapshot-isolation]: /sql/t-sql/statements/set-transaction-isolation-level-transact-sql
[storage-concurrency]: https://azure.microsoft.com/blog/managing-concurrency-in-microsoft-azure-storage-2/