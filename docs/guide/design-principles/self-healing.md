---
title: 자체 복구를 위한 디자인
titleSuffix: Azure Application Architecture Guide
description: 복원 애플리케이션은 수동 개입 없이 오류를 복구할 수 있습니다.
author: MikeWasson
ms.date: 08/30/2018
ms.topic: guide
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: seojan19
ms.openlocfilehash: 5e5af0be41fa892e490d556ef4286d5367144fd9
ms.sourcegitcommit: 1b50810208354577b00e89e5c031b774b02736e2
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/23/2019
ms.locfileid: "54483941"
---
# <a name="design-for-self-healing"></a><span data-ttu-id="84a0c-103">자체 복구를 위한 디자인</span><span class="sxs-lookup"><span data-stu-id="84a0c-103">Design for self healing</span></span>

## <a name="design-your-application-to-be-self-healing-when-failures-occur"></a><span data-ttu-id="84a0c-104">오류가 발생하면 자체 복구되도록 애플리케이션 디자인</span><span class="sxs-lookup"><span data-stu-id="84a0c-104">Design your application to be self healing when failures occur</span></span>

<span data-ttu-id="84a0c-105">분산 시스템에서는 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-105">In a distributed system, failures happen.</span></span> <span data-ttu-id="84a0c-106">하드웨어 고장이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-106">Hardware can fail.</span></span> <span data-ttu-id="84a0c-107">일시적인 네트워크 오류가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-107">The network can have transient failures.</span></span> <span data-ttu-id="84a0c-108">매우 드물게 서비스 또는 지역 전체가 중단될 수도 있지만 그렇다 하더라도 계획된 중단이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-108">Rarely, an entire service or region may experience a disruption, but even those must be planned for.</span></span>

<span data-ttu-id="84a0c-109">따라서 오류가 발생하면 자체 복구되도록 애플리케이션을 디자인합니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-109">Therefore, design an application to be self healing when failures occur.</span></span> <span data-ttu-id="84a0c-110">이를 위해서는 세 가지 방법이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-110">This requires a three-pronged approach:</span></span>

- <span data-ttu-id="84a0c-111">오류 검색</span><span class="sxs-lookup"><span data-stu-id="84a0c-111">Detect failures.</span></span>
- <span data-ttu-id="84a0c-112">오류에 대한 적절한 응답</span><span class="sxs-lookup"><span data-stu-id="84a0c-112">Respond to failures gracefully.</span></span>
- <span data-ttu-id="84a0c-113">운영 정보를 얻기 위해 실패 기록 및 모니터링</span><span class="sxs-lookup"><span data-stu-id="84a0c-113">Log and monitor failures, to give operational insight.</span></span>

<span data-ttu-id="84a0c-114">특정 유형의 실패에 대응하는 방법은 애플리케이션의 가용성 요구 사항에 따라 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-114">How you respond to a particular type of failure may depend on your application's availability requirements.</span></span> <span data-ttu-id="84a0c-115">예를 들어, 매우 높은 가용성이 필요한 경우 지역 가동 중단 중 자동으로 보조 지역으로 장애 조치(failover)되도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-115">For example, if you require very high availability, you might automatically fail over to a secondary region during a regional outage.</span></span> <span data-ttu-id="84a0c-116">그러나 이 경우 단일 지역 배포보다 비용이 많이 듭니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-116">However, that will incur a higher cost than a single-region deployment.</span></span>

<span data-ttu-id="84a0c-117">또한 일반적으로 지역 가동 중단과 같이 발생 빈도가 적은 대규모 이벤트는 고려하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="84a0c-117">Also, don't just consider big events like regional outages, which are generally rare.</span></span> <span data-ttu-id="84a0c-118">네트워크 연결 실패 또는 데이터베이스 연결 실패와 같이 단시간 발생하는 로컬 오류를 처리하는 데 많은 노력을 기울여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-118">You should focus as much, if not more, on handling local, short-lived failures, such as network connectivity failures or failed database connections.</span></span>

## <a name="recommendations"></a><span data-ttu-id="84a0c-119">권장 사항</span><span class="sxs-lookup"><span data-stu-id="84a0c-119">Recommendations</span></span>

<span data-ttu-id="84a0c-120">**실패한 작업 다시 시도**.</span><span class="sxs-lookup"><span data-stu-id="84a0c-120">**Retry failed operations**.</span></span> <span data-ttu-id="84a0c-121">서비스 사용량이 많을 때 일시적인 네트워크 연결 해제, 데이터베이스 연결 끊김 또는 시간 제한으로 인해 일시적 오류가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-121">Transient failures may occur due to momentary loss of network connectivity, a dropped database connection, or a timeout when a service is busy.</span></span> <span data-ttu-id="84a0c-122">애플리케이션에 재시도 논리를 작성하여 일시적인 오류를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-122">Build retry logic into your application to handle transient failures.</span></span> <span data-ttu-id="84a0c-123">많은 Azure 서비스의 경우 클라이언트 SDK는 자동 재시도를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-123">For many Azure services, the client SDK implements automatic retries.</span></span> <span data-ttu-id="84a0c-124">자세한 내용은 [일시적인 오류 처리][transient-fault-handling] 및 [재시도 패턴][retry]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="84a0c-124">For more information, see [Transient fault handling][transient-fault-handling] and the [Retry pattern][retry].</span></span>

<span data-ttu-id="84a0c-125">**실패한 원격 서비스 보호(회로 차단기)**.</span><span class="sxs-lookup"><span data-stu-id="84a0c-125">**Protect failing remote services (Circuit Breaker)**.</span></span> <span data-ttu-id="84a0c-126">일시적인 오류가 발생하면 다시 시도해 보는 것이 좋지만 오류가 지속되면 많은 호출자에 대한 서비스가 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-126">It's good to retry after a transient failure, but if the failure persists, you can end up with too many callers hammering a failing service.</span></span> <span data-ttu-id="84a0c-127">요청이 다시 실행될 때 연속 실패가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-127">This can lead to cascading failures, as requests back up.</span></span> <span data-ttu-id="84a0c-128">작업이 실패할 것 같으면 [회로 차단기 패턴][circuit-breaker]을 사용하여(원격 호출을 사용하지 않고) 페일 패스트합니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-128">Use the [Circuit Breaker pattern][circuit-breaker] to fail fast (without making the remote call) when an operation is likely to fail.</span></span>

<span data-ttu-id="84a0c-129">**중요한 리소스 격리(격벽)**.</span><span class="sxs-lookup"><span data-stu-id="84a0c-129">**Isolate critical resources (Bulkhead)**.</span></span> <span data-ttu-id="84a0c-130">하나의 하위 시스템에서 발생한 오류가 다른 시스템으로 전이될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-130">Failures in one subsystem can sometimes cascade.</span></span> <span data-ttu-id="84a0c-131">오류가 스레드 또는 소켓 같은 리소스를 적시에 놓아주지 않으면 리소스가 고갈되어 이와 같은 상황이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-131">This can happen if a failure causes some resources, such as threads or sockets, not to get freed in a timely manner, leading to resource exhaustion.</span></span> <span data-ttu-id="84a0c-132">이 상황을 방지하려면 한 파티션의 오류 때문에 전체 시스템이 중단되는 일이 없도록 시스템을 격리된 그룹으로 분할합니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-132">To avoid this, partition a system into isolated groups, so that a failure in one partition does not bring down the entire system.</span></span>

<span data-ttu-id="84a0c-133">**부하 평준화 수행**.</span><span class="sxs-lookup"><span data-stu-id="84a0c-133">**Perform load leveling**.</span></span> <span data-ttu-id="84a0c-134">백 엔드의 서비스가 감당할 수 없을 정도로 애플리케이션의 트래픽이 갑자기 치솟을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-134">Applications may experience sudden spikes in traffic that can overwhelm services on the backend.</span></span> <span data-ttu-id="84a0c-135">이를 방지하려면 [큐 기반 부하 평준화 패턴][load-level]을 사용하여 작업 항목을 비동기적으로 실행하도록 큐에 넣습니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-135">To avoid this, use the [Queue-Based Load Leveling pattern][load-level] to queue work items to run asynchronously.</span></span> <span data-ttu-id="84a0c-136">큐는 피크 부하를 매끄럽게 하는 버퍼 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-136">The queue acts as a buffer that smooths out peaks in the load.</span></span>

<span data-ttu-id="84a0c-137">**장애 조치(failover)**.</span><span class="sxs-lookup"><span data-stu-id="84a0c-137">**Fail over**.</span></span> <span data-ttu-id="84a0c-138">인스턴스에 연결할 수 없으면 다른 인스턴스로 장애 조치(failover)합니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-138">If an instance can't be reached, fail over to another instance.</span></span> <span data-ttu-id="84a0c-139">웹 서버와 같이 상태 비저장 항목의 경우 부하 분산 장치 또는 Traffic Manager 뒤에 여러 인스턴스를 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-139">For things that are stateless, like a web server, put several instances behind a load balancer or traffic manager.</span></span> <span data-ttu-id="84a0c-140">데이터베이스와 같이 상태 저장 항목의 경우 복제본을 사용하여 장애 조치(failover)합니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-140">For things that store state, like a database, use replicas and fail over.</span></span> <span data-ttu-id="84a0c-141">데이터 저장소 및 복제 방법에 따라 애플리케이션에서 최종 일관성을 처리해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-141">Depending on the data store and how it replicates, this may require the application to deal with eventual consistency.</span></span>

<span data-ttu-id="84a0c-142">**실패한 트랜잭션 보정**.</span><span class="sxs-lookup"><span data-stu-id="84a0c-142">**Compensate failed transactions**.</span></span> <span data-ttu-id="84a0c-143">일반적으로 분산 트랜잭션은 서비스와 자원 간의 조정이 필요하므로 사용하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-143">In general, avoid distributed transactions, as they require coordination across services and resources.</span></span> <span data-ttu-id="84a0c-144">대신 작은 개별 트랜잭션에서 작업을 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-144">Instead, compose an operation from smaller individual transactions.</span></span> <span data-ttu-id="84a0c-145">작업이 중간에 실패하면 [트랜잭션 보정][compensating-transactions]을 사용하여 이미 완료된 단계를 실행 취소합니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-145">If the operation fails midway through, use [Compensating Transactions][compensating-transactions] to undo any step that already completed.</span></span>

<span data-ttu-id="84a0c-146">**장기 실행 트랜잭션의 검사점**.</span><span class="sxs-lookup"><span data-stu-id="84a0c-146">**Checkpoint long-running transactions**.</span></span> <span data-ttu-id="84a0c-147">검사점은 장기 실행 작업이 실패할 경우 복원 지점을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-147">Checkpoints can provide resiliency if a long-running operation fails.</span></span> <span data-ttu-id="84a0c-148">작업이 다시 시작되면(예: 다른 VM에서 작업을 시작한 경우) 마지막 검사점에서 작업을 다시 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-148">When the operation restarts (for example, it is picked up by another VM), it can be resumed from the last checkpoint.</span></span>

<span data-ttu-id="84a0c-149">**정상적으로 성능 저하**.</span><span class="sxs-lookup"><span data-stu-id="84a0c-149">**Degrade gracefully**.</span></span> <span data-ttu-id="84a0c-150">경우에 따라 문제를 해결할 수 없지만 여전히 유용한 축소된 기능을 제공할 수는 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-150">Sometimes you can't work around a problem, but you can provide reduced functionality that is still useful.</span></span> <span data-ttu-id="84a0c-151">책 카탈로그를 표시하는 애플리케이션을 생각해 보세요.</span><span class="sxs-lookup"><span data-stu-id="84a0c-151">Consider an application that shows a catalog of books.</span></span> <span data-ttu-id="84a0c-152">이 애플리케이션은 표지의 썸네일 이미지를 검색할 수 없으면 자리 표시자 이미지를 표시할 것입니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-152">If the application can't retrieve the thumbnail image for the cover, it might show a placeholder image.</span></span> <span data-ttu-id="84a0c-153">전체 하위 시스템은 애플리케이션에 중요하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-153">Entire subsystems might be noncritical for the application.</span></span> <span data-ttu-id="84a0c-154">예를 들어, 전자상거래 사이트에서 제품 권장 사항을 보여 주는 것은 주문 처리보다 덜 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-154">For example, in an e-commerce site, showing product recommendations is probably less critical than processing orders.</span></span>

<span data-ttu-id="84a0c-155">**클라이언트 제한**.</span><span class="sxs-lookup"><span data-stu-id="84a0c-155">**Throttle clients**.</span></span> <span data-ttu-id="84a0c-156">때로는 소수의 사용자가 과도한 로드를 생성하여 다른 사용자의 애플리케이션 가용성에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-156">Sometimes a small number of users create excessive load, which can reduce your application's availability for other users.</span></span> <span data-ttu-id="84a0c-157">이 경우 특정 시간 동안 클라이언트를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-157">In this situation, throttle the client for a certain period of time.</span></span> <span data-ttu-id="84a0c-158">[제한 패턴][throttle]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="84a0c-158">See the [Throttling pattern][throttle].</span></span>

<span data-ttu-id="84a0c-159">**불량 작업자 차단**.</span><span class="sxs-lookup"><span data-stu-id="84a0c-159">**Block bad actors**.</span></span> <span data-ttu-id="84a0c-160">클라이언트를 제한한다고 해서 해당 클라이언트의 작업이 악의적이라는 것을 의미하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-160">Just because you throttle a client, it doesn't mean client was acting maliciously.</span></span> <span data-ttu-id="84a0c-161">단지 해당 클라이언트가 서비스 할당량을 초과했다는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-161">It just means the client exceeded their service quota.</span></span> <span data-ttu-id="84a0c-162">그러나 클라이언트가 지속적으로 할당량을 초과하거나 잘못 작동하면 해당 클라이언트를 차단할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-162">But if a client consistently exceeds their quota or otherwise behaves badly, you might block them.</span></span> <span data-ttu-id="84a0c-163">사용자가 차단 해제를 요청할 수 있도록 대역 외 프로세스를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-163">Define an out-of-band process for user to request getting unblocked.</span></span>

<span data-ttu-id="84a0c-164">**리더 선택 사용**.</span><span class="sxs-lookup"><span data-stu-id="84a0c-164">**Use leader election**.</span></span> <span data-ttu-id="84a0c-165">작업을 조정해야 할 경우 [리더 선택][leader-election]을 사용하여 코디네이터를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-165">When you need to coordinate a task, use [Leader Election][leader-election] to select a coordinator.</span></span> <span data-ttu-id="84a0c-166">이 경우 코디네이터는 단일 실패 지점이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-166">That way, the coordinator is not a single point of failure.</span></span> <span data-ttu-id="84a0c-167">한 코디네이터가 실패하면 새 코디네이터가 선택됩니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-167">If the coordinator fails, a new one is selected.</span></span> <span data-ttu-id="84a0c-168">리더 선택 알고리즘을 처음부터 구현하는 대신 Zookeeper와 같은 상업용 솔루션을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-168">Rather than implement a leader election algorithm from scratch, consider an off-the-shelf solution such as Zookeeper.</span></span>

<span data-ttu-id="84a0c-169">**오류 주입으로 테스트**.</span><span class="sxs-lookup"><span data-stu-id="84a0c-169">**Test with fault injection**.</span></span> <span data-ttu-id="84a0c-170">성공 경로는 대부분 올바르게 테스트되지만 실패 경로는 그렇지 않은 경우가 많이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-170">All too often, the success path is well tested but not the failure path.</span></span> <span data-ttu-id="84a0c-171">시스템은 실패 경로가 실행되기 전에 오랜 시간 동안 프로덕션 환경에서 작동되었을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-171">A system could run in production for a long time before a failure path is exercised.</span></span> <span data-ttu-id="84a0c-172">오류 주입을 통해 실제 오류를 트리거하거나 시뮬레이트하여 오류 시 시스템 복원력을 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-172">Use fault injection to test the resiliency of the system to failures, either by triggering actual failures or by simulating them.</span></span>

<span data-ttu-id="84a0c-173">**비정상 상황 엔지니어링 사용**.</span><span class="sxs-lookup"><span data-stu-id="84a0c-173">**Embrace chaos engineering**.</span></span> <span data-ttu-id="84a0c-174">비정상 상황 엔지니어링은 실패 또는 비정상 상황을 무작위로 프로덕션 인스턴스에 주입하여 오류 주입의 개념을 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="84a0c-174">Chaos engineering extends the notion of fault injection, by randomly injecting failures or abnormal conditions into production instances.</span></span>

<span data-ttu-id="84a0c-175">애플리케이션 자동 복구를 위한 구조화된 접근 방식은 [Azure용 복원 애플리케이션 디자인][resiliency-overview]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="84a0c-175">For a structured approach to making your applications self healing, see [Design resilient applications for Azure][resiliency-overview].</span></span>

<!-- links -->

[circuit-breaker]: ../../patterns/circuit-breaker.md
[compensating-transactions]: ../../patterns/compensating-transaction.md
[leader-election]: ../../patterns/leader-election.md
[load-level]: ../../patterns/queue-based-load-leveling.md
[resiliency-overview]: ../../resiliency/index.md
[retry]: ../../patterns/retry.md
[throttle]: ../../patterns/throttling.md
[transient-fault-handling]: ../../best-practices/transient-faults.md
