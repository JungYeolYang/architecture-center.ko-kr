---
title: Azure용 복원 애플리케이션 디자인
description: Azure에서 고가용성 및 재해 복구를 제공하는 복원 애플리케이션을 빌드하는 방법을 설명합니다.
author: MikeWasson
ms.date: 12/18/2018
ms.topic: article
ms.service: architecture-center
ms.subservice: cloud-design-principles
ms.custom: resiliency
ms.openlocfilehash: ba3637ce90b793425b1238ee0d99d36a936da6ca
ms.sourcegitcommit: 1b50810208354577b00e89e5c031b774b02736e2
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/23/2019
ms.locfileid: "54488599"
---
# <a name="designing-resilient-applications-for-azure"></a><span data-ttu-id="3af76-103">Azure용 복원 애플리케이션 디자인</span><span class="sxs-lookup"><span data-stu-id="3af76-103">Designing resilient applications for Azure</span></span>

<span data-ttu-id="3af76-104">분산 시스템에서는 오류가 발생하기 마련입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-104">In a distributed system, failures will happen.</span></span> <span data-ttu-id="3af76-105">하드웨어 고장이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-105">Hardware can fail.</span></span> <span data-ttu-id="3af76-106">일시적인 네트워크 오류가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-106">The network can have transient failures.</span></span> <span data-ttu-id="3af76-107">매우 드물게 서비스 또는 지역 전체가 중단될 수도 있지만 그렇다 하더라도 계획된 중단이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-107">Rarely, an entire service or region may experience a disruption, but even those must be planned for.</span></span>

<span data-ttu-id="3af76-108">클라우드에서 신뢰할 수 있는 애플리케이션을 빌드하는 것은 엔터프라이즈 환경에서 신뢰할 수 있는 애플리케이션을 빌드하는 것과 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-108">Building a reliable application in the cloud is different than building a reliable application in an enterprise setting.</span></span> <span data-ttu-id="3af76-109">기존에는 규모 확장을 위해 고성능 하드웨어를 구입해야 했지만, 클라우드 환경에서는 강화 대신 규모 확장을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-109">While historically you may have purchased higher-end hardware to scale up, in a cloud environment you must scale out instead of scaling up.</span></span> <span data-ttu-id="3af76-110">클라우드 환경의 비용은 상용 하드웨어를 사용하는 내내 낮은 수준으로 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-110">Costs for cloud environments are kept low through the use of commodity hardware.</span></span> <span data-ttu-id="3af76-111">목표는 모든 장애를 막는 것이 아니라 시스템 내에서 발생하는 장애의 영향을 최소화하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-111">Instead of trying to prevent failures altogether, the goal is to minimize the effects of a failure within the system.</span></span>

<span data-ttu-id="3af76-112">이 문서에서는 Microsoft Azure에서 복원 애플리케이션을 빌드하는 방법에 대한 개요를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-112">This article provides an overview of how to build resilient applications in Microsoft Azure.</span></span> <span data-ttu-id="3af76-113">먼저 *복원력*이라는 용어의 정의와 관련 개념부터 시작하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-113">It starts with a definition of the term *resiliency* and related concepts.</span></span> <span data-ttu-id="3af76-114">그런 다음, 디자인 및 구현부터 배포 및 운영에 이르는 애플리케이션의 전체 수명에 걸쳐 구조화된 방법을 사용하여 복원력을 달성하는 프로세스를 설명하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-114">Then it describes a process for achieving resiliency, using a structured approach over the lifetime of an application, from design and implementation to deployment and operations.</span></span>

<!-- markdownlint-disable MD026 -->

## <a name="what-is-resiliency"></a><span data-ttu-id="3af76-115">복원력이란?</span><span class="sxs-lookup"><span data-stu-id="3af76-115">What is resiliency?</span></span>

<!-- markdownlint-enable MD026 -->

<span data-ttu-id="3af76-116">**복원력**은 오류를 복구하여 계속 작동하는 시스템 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-116">**Resiliency** is the ability of a system to recover from failures and continue to function.</span></span> <span data-ttu-id="3af76-117">오류 *방지*가 아니라 가동 중지 또는 데이터 손실을 방지하는 방법으로 오류에 *대응*하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-117">It's not about *avoiding* failures, but *responding* to failures in a way that avoids downtime or data loss.</span></span> <span data-ttu-id="3af76-118">복원력의 목표는 오류가 발생한 후 애플리케이션을 완전히 작동하는 상태로 되돌리기 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-118">The goal of resiliency is to return the application to a fully functioning state following a failure.</span></span>

<span data-ttu-id="3af76-119">복원력의 두 가지 중요한 측면은 고가용성과 재해 복구입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-119">Two important aspects of resiliency are high availability and disaster recovery.</span></span>

- <span data-ttu-id="3af76-120">**HA(고가용성)** 은 애플리케이션이 심각한 가동 중지 없이 정상 상태로 계속 실행되는 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-120">**High availability** (HA) is the ability of the application to continue running in a healthy state, without significant downtime.</span></span> <span data-ttu-id="3af76-121">"정상 상태"는 애플리케이션에서 응답하고 사용자가 애플리케이션에 연결하여 애플리케이션과 상호 작용할 수 있음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-121">By "healthy state," we mean the application is responsive, and users can connect to the application and interact with it.</span></span>  
- <span data-ttu-id="3af76-122">**DR(재해 복구)** 은 드물지만 중요한 사고, 즉 전체 지역에 영향을 주는 서비스 중단과 같이 일시적이지 않은 대규모 장애로부터 복구할 수 있는 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-122">**Disaster recovery** (DR) is the ability to recover from rare but major incidents: non-transient, wide-scale failures, such as service disruption that affects an entire region.</span></span> <span data-ttu-id="3af76-123">재해 복구에는 데이터 백업 및 보관이 포함되며, 백업에서 데이터베이스를 복원하는 것과 같은 수동 작업이 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-123">Disaster recovery includes data backup and archiving, and may include manual intervention, such as restoring a database from backup.</span></span>

<span data-ttu-id="3af76-124">HA와 DR을 구분하는 방법 중 하나로, DR은 오류의 영향이 HA 디자인의 오류 처리 능력을 초과할 때 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-124">One way to think about HA versus DR is that DR starts when the impact of a fault exceeds the ability of the HA design to handle it.</span></span>  

<span data-ttu-id="3af76-125">복원력을 디자인할 때 가용성 요구 사항을 이해해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-125">When you design resiliency, you must understand your availability requirements.</span></span> <span data-ttu-id="3af76-126">허용되는 가동 중지 시간이 얼마나 됩니까?</span><span class="sxs-lookup"><span data-stu-id="3af76-126">How much downtime is acceptable?</span></span> <span data-ttu-id="3af76-127">이것은 비용 함수의 일종입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-127">This is partly a function of cost.</span></span> <span data-ttu-id="3af76-128">가동 중지로 인한 잠재적 비용이 얼마나 발생할까요?</span><span class="sxs-lookup"><span data-stu-id="3af76-128">How much will potential downtime cost your business?</span></span> <span data-ttu-id="3af76-129">고가용성 애플리케이션을 만들려면 얼마를 투자해야 할까요?</span><span class="sxs-lookup"><span data-stu-id="3af76-129">How much should you invest in making the application highly available?</span></span> <span data-ttu-id="3af76-130">애플리케이션을 사용할 수 있다는 것이 무슨 뜻인지도 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-130">You also have to define what it means for the application to be available.</span></span> <span data-ttu-id="3af76-131">예를 들어 고객이 주문을 제출할 수 있지만 시스템이 일반적인 시간 내에 처리할 수 없으면 애플리케이션 "가동 중지"입니까?</span><span class="sxs-lookup"><span data-stu-id="3af76-131">For example, is the application "down" if a customer can submit an order but the system cannot process it within the normal timeframe?</span></span> <span data-ttu-id="3af76-132">특정 유형의 정전이 발생할 확률, 그리고 완화 전략이 비용 효율적인지 여부도 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-132">Also consider the probability of a particular type of outage occurring, and whether a mitigation strategy is cost-effective.</span></span>

<span data-ttu-id="3af76-133">또 다른 일반적인 용어로 **BC(비즈니스 연속성)** 가 사용되고 있는데, 자연 재해나 서비스 중단 같은 악조건이 발생하는 동안 그리고 발생 후에 필수 비즈니스 기능을 수행하는 기능을 말합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-133">Another common term is **business continuity** (BC), which is the ability to perform essential business functions during and after adverse conditions, such as a natural disaster or a downed service.</span></span> <span data-ttu-id="3af76-134">물리적 시설, 사람, 통신, 운송, IT를 포함한 기업의 전체 운영이 BC 범위에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-134">BC covers the entire operation of the business, including physical facilities, people, communications, transportation, and IT.</span></span> <span data-ttu-id="3af76-135">이 문서에서는 클라우드 애플리케이션을 집중적으로 다루지만, 전체적인 BC 요구 사항에 맞춰서 복원력 계획을 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-135">This article focuses on cloud applications, but resilience planning must be done in the context of overall BC requirements.</span></span>

<span data-ttu-id="3af76-136">**데이터 백업**은 DR의 중요한 부분입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-136">**Data backup** is a critical part of DR.</span></span> <span data-ttu-id="3af76-137">애플리케이션의 상태 비저장 구성 요소가 실패하면 언제든지 다시 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-137">If the stateless components of an application fail, you can always redeploy them.</span></span> <span data-ttu-id="3af76-138">하지만 데이터가 손실되면 시스템은 안정적인 상태로 돌아갈 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-138">But if data is lost, the system can't return to a stable state.</span></span> <span data-ttu-id="3af76-139">이상적으로 지역 수준의 재해 발생 시 다른 지역에 데이터를 백업해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-139">Data must be backed up, ideally in a different region in case of a region-wide disaster.</span></span>

<span data-ttu-id="3af76-140">백업은 *데이터 복제*와 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-140">Backup is distinct from *data replication*.</span></span> <span data-ttu-id="3af76-141">시스템이 복제본을 신속하게 장애 조치할 수 있도록 데이터 복제는 근실시간으로 데이터를 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-141">Data replication involves copying data in near-real-time, so that the system can fail over quickly to a replica.</span></span> <span data-ttu-id="3af76-142">많은 데이터베이스 시스템은 복제를 지원합니다. 예를 들어 SQL Server는 SQL Server Always On 가용성 그룹을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-142">Many databases systems support replication; for example, SQL Server supports SQL Server Always On Availability Groups.</span></span> <span data-ttu-id="3af76-143">데이터의 복제본을 항상 준비함으로써 데이터 복제가 가동 중단으로부터 복구하는 데 걸리는 시간을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-143">Data replication can reduce how long it takes to recover from an outage, by ensuring that a replica of the data is always standing by.</span></span> <span data-ttu-id="3af76-144">그러나 데이터 복제는 사용자 오류로부터 보호될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-144">However, data replication won't protect against human error.</span></span> <span data-ttu-id="3af76-145">사용자 오류로 인해 데이터가 손상되면 손상된 데이터가 바로 복제본에 복사됩니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-145">If data gets corrupted because of human error, the corrupted data just gets copied to the replicas.</span></span> <span data-ttu-id="3af76-146">따라서 장기 백업을 DR 전략에 포함해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-146">Therefore, you still need to include long-term backup in your DR strategy.</span></span>

## <a name="process-to-achieve-resiliency"></a><span data-ttu-id="3af76-147">복원력을 구현하기 위한 프로세스</span><span class="sxs-lookup"><span data-stu-id="3af76-147">Process to achieve resiliency</span></span>

<span data-ttu-id="3af76-148">복원력은 추가 기능이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-148">Resiliency is not an add-on.</span></span> <span data-ttu-id="3af76-149">시스템적으로 설계하여 운영 방식 속에 담아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-149">It must be designed into the system and put into operational practice.</span></span> <span data-ttu-id="3af76-150">다음은 일반적인 모델입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-150">Here is a general model to follow:</span></span>

1. <span data-ttu-id="3af76-151">**정의** - 비즈니스 요구에 따라 가용성 요구 사항을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-151">**Define** your availability requirements, based on business needs.</span></span>
2. <span data-ttu-id="3af76-152">**디자인** - 복원력 있는 애플리케이션을 디자인합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-152">**Design** the application for resiliency.</span></span> <span data-ttu-id="3af76-153">검증된 사례를 따르는 아키텍처로 시작한 후 해당 아키텍처에서 발생 가능한 오류를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-153">Start with an architecture that follows proven practices, and then identify the possible failure points in that architecture.</span></span>
3. <span data-ttu-id="3af76-154">**구현** - 오류를 감지하고 복구할 전략을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-154">**Implement** strategies to detect and recover from failures.</span></span>
4. <span data-ttu-id="3af76-155">**테스트** - 오류를 시뮬레이션하고 강제 장애 조치(failover)를 트리거하여 구현된 전략을 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-155">**Test** the implementation by simulating faults and triggering forced failovers.</span></span>
5. <span data-ttu-id="3af76-156">**배포** - 안정적이고 반복 가능한 프로세스를 사용하여 프로덕션 환경에 애플리케이션을 배포합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-156">**Deploy** the application into production using a reliable, repeatable process.</span></span>
6. <span data-ttu-id="3af76-157">**모니터링** - 애플리케이션을 모니터링하여 오류를 감지합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-157">**Monitor** the application to detect failures.</span></span> <span data-ttu-id="3af76-158">시스템을 모니터링하여 애플리케이션 상태를 측정하고 필요할 때 사고에 대응할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-158">By monitoring the system, you can gauge the health of the application and respond to incidents if necessary.</span></span>
7. <span data-ttu-id="3af76-159">**대응** - 수동 개입이 필요한 실패가 있는 경우 적절하게 대응합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-159">**Respond** if there are failure that require manual interventions.</span></span>

<span data-ttu-id="3af76-160">이 문서의 나머지 부분에서는 이러한 각 단계를 좀 더 자세히 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-160">In the remainder of this article, we discuss each of these steps in more detail.</span></span>

## <a name="define-your-availability-requirements"></a><span data-ttu-id="3af76-161">가용성 요구 사항 정의</span><span class="sxs-lookup"><span data-stu-id="3af76-161">Define your availability requirements</span></span>

<span data-ttu-id="3af76-162">복원력 계획은 비즈니스 요구 사항으로 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-162">Resiliency planning starts with business requirements.</span></span> <span data-ttu-id="3af76-163">다음과 같은 몇 가지 용어를 통해 복원력에 대해 생각해볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-163">Here are some approaches for thinking about resiliency in those terms.</span></span>

### <a name="decompose-by-workload"></a><span data-ttu-id="3af76-164">워크로드별로 분해</span><span class="sxs-lookup"><span data-stu-id="3af76-164">Decompose by workload</span></span>

<span data-ttu-id="3af76-165">많은 클라우드 솔루션이 여러 애플리케이션 워크로드로 구성되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-165">Many cloud solutions consist of multiple application workloads.</span></span> <span data-ttu-id="3af76-166">여기서 "워크로드"라는 용어는 별개의 기능 또는 계산 작업을 의미하며, 비즈니스 논리와 데이터 저장소 요구 사항의 측면에서 다른 작업과 논리적으로 분리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-166">The term "workload" in this context means a discrete capability or computing task, which can be logically separated from other tasks, in terms of business logic and data storage requirements.</span></span> <span data-ttu-id="3af76-167">예를 들어 전자 상거래 앱에는 다음과 같은 워크로드가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-167">For example, an e-commerce app might include the following workloads:</span></span>

- <span data-ttu-id="3af76-168">제품 카탈로그를 찾아보고 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-168">Browse and search a product catalog.</span></span>
- <span data-ttu-id="3af76-169">주문을 작성하고 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-169">Create and track orders.</span></span>
- <span data-ttu-id="3af76-170">추천 제품을 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-170">View recommendations.</span></span>

<span data-ttu-id="3af76-171">이러한 워크로드마다 가용성, 확장성, 데이터 일관성 및 재해 복구에 대한 요구 사항이 서로 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-171">These workloads might have different requirements for availability, scalability, data consistency, and disaster recovery.</span></span> <span data-ttu-id="3af76-172">비용과 위험 간의 적절한 균형을 맞추기 위해 내려야 하는 비즈니스 의사 결정이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-172">There are business decisions to be made in terms of balancing cost versus risk.</span></span>

<span data-ttu-id="3af76-173">사용 패턴도 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-173">Also consider usage patterns.</span></span> <span data-ttu-id="3af76-174">시스템이 반드시 작동해야 하는 특정 중요 시간대가 있습니까?</span><span class="sxs-lookup"><span data-stu-id="3af76-174">Are there certain critical periods when the system must be available?</span></span> <span data-ttu-id="3af76-175">예를 들어 세금 신고 서비스는 신고 마감 직전에는 절대 중지되면 안 되고, 비디오 스트리밍 서비스는 대형 스포츠 행사가 진행되는 내내 작동해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-175">For example, a tax-filing service can't go down right before the filing deadline, a video streaming service must stay up during a big sports event, and so on.</span></span> <span data-ttu-id="3af76-176">이처럼 중요한 기간에는 여러 지역에 걸쳐 이중으로 배포하면 한 지역에서 오류가 발생하더라도 애플리케이션을 장애 조치(failover)할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-176">During the critical periods, you might have redundant deployments across several regions, so the application could fail over if one region failed.</span></span> <span data-ttu-id="3af76-177">그러나 다중 지역 배포는 더 많은 비용이 들기 때문에 덜 중요한 시간에는 한 지역에서만 애플리케이션을 실행할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-177">However, a multi-region deployment is potentially more expensive, so during less critical times, you might run the application in a single region.</span></span> <span data-ttu-id="3af76-178">경우에 따라 사용량 기반 청구 방식의 최신 서버리스 기술을 사용하면 사용률이 낮은 컴퓨팅 리소스 비용이 청구되지 않으므로 비용을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-178">In some cases, the additional expense can be mitigated by using modern serverless techniques, which use consumption-based billing, so you are not charged for under-utilitzed compute resources.</span></span>

### <a name="rto-and-rpo"></a><span data-ttu-id="3af76-179">RTO 및 RPO</span><span class="sxs-lookup"><span data-stu-id="3af76-179">RTO and RPO</span></span>

<span data-ttu-id="3af76-180">재해 복구와 관련하여 고려해야 할 두 가지 중요한 메트릭은 복구 시간 목표 및 복구 지점 목표입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-180">Two important metrics to consider are the recovery time objective and recovery point objective, as they pertain to disaster recovery.</span></span>

- <span data-ttu-id="3af76-181">**RTO(복구 시간 목표)** 는 사고 발생 후 애플리케이션 중단이 허용되는 최대 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-181">**Recovery time objective** (RTO) is the maximum acceptable time that an application can be unavailable after an incident.</span></span> <span data-ttu-id="3af76-182">RTO가 90분이면 재해가 시작된 시점부터 90분 이내에 애플리케이션을 실행 상태로 복원할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-182">If your RTO is 90 minutes, you must be able to restore the application to a running state within 90 minutes from the start of a disaster.</span></span> <span data-ttu-id="3af76-183">RTO가 매우 낮은 경우 지역 단위 정전에 대비하여 보조 지역 배포에서 항상 대기 중인 활성/수동 구성을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-183">If you have a very low RTO, you might keep a second regional deployment continually running an active/passive configuration on standby, to protect against a regional outage.</span></span> <span data-ttu-id="3af76-184">경우에 따라 활성/활성 구성을 배포하여 더욱 낮은 RTO를 달성할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-184">In some cases you might deploy an active/active configuration to achieve even lower RTO.</span></span>

- <span data-ttu-id="3af76-185">**RPO(복구 지점 목표)** 는 재해 발생 시 허용되는 최대 데이터 손실 기간입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-185">**Recovery point objective** (RPO) is the maximum duration of data loss that is acceptable during a disaster.</span></span> <span data-ttu-id="3af76-186">예를 들어 다른 데이터베이스에 데이터를 복제하지 않고 단일 데이터베이스에만 데이터를 저장하며 매시간 백업을 수행하는 경우 최대 1시간 분량의 데이터가 손실될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-186">For example, if you store data in a single database, with no replication to other databases, and perform hourly backups, you could lose up to an hour of data.</span></span>

<span data-ttu-id="3af76-187">RTO 및 RPO는 시스템의 비기능적 요구 사항이며 비즈니스 요구 사항에 따라 결정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-187">RTO and RPO are non-functional requirements of a system, and should be dictated by business requirements.</span></span> <span data-ttu-id="3af76-188">이러한 가치를 측정하려면 위험 평가를 수행하고 가동 중지 시간 또는 데이터 손실의 비용을 정확하게 이해하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-188">To derive these values, it's a good idea to conduct a risk assessment, and clearly understanding the cost of downtime or data loss.</span></span>

### <a name="mttr-and-mtbf"></a><span data-ttu-id="3af76-189">MTTR 및 MTBF</span><span class="sxs-lookup"><span data-stu-id="3af76-189">MTTR and MTBF</span></span>

<span data-ttu-id="3af76-190">가용성을 측정하는 또 다른 두 가지 일반적인 방법은 MTTR(평균 복구 시간) 및 MTBF(평균 고장 간격)입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-190">Two other common measures of availability are mean time to recover (MTTR) and mean time between failures (MTBF).</span></span> <span data-ttu-id="3af76-191">두 측정 방법은 일반적으로 서비스 공급 기업에서 클라우드 서비스에 중복성을 추가할 위치와 고객에게 제공할 SLA를 결정하기 위해 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-191">These measures are usually used internally by service providers to determine where to add redundancy to cloud services, and which SLAs to provide to customers.</span></span>

<span data-ttu-id="3af76-192">**MTTR(평균 복구 시간)** 은 장애 발생 후 구성 요소를 복원하는 데 걸리는 평균 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-192">**Mean time to recover** (MTTR) is the average time that it takes to restore a component after a failure.</span></span> <span data-ttu-id="3af76-193">MTTR은 구성 요소에 대한 실증적 팩트입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-193">MTTR is an empirical fact about a component.</span></span> <span data-ttu-id="3af76-194">각 구성 요소의 MTTR에 따라 전체 애플리케이션의 MTTR를 예측할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-194">Based on the MTTR of each component, you can estimate the MTTR of an entire application.</span></span> <span data-ttu-id="3af76-195">MTTR이 낮은 여러 구성 요소를 사용하여 애플리케이션을 빌드하면 전체 MTTR이 낮은, 즉, 신속하게 장애를 복구하는 애플리케이션을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-195">Building applications from multiple components with low MTTR values results in an application with a low overall MTTR &mdash; one that recovers quickly from failures.</span></span>

<span data-ttu-id="3af76-196">**MTBF(평균 고장 간격)** 는 합리적인 수준에서 구성 요소에 기대할 수 있는 무고장 실행 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-196">**Mean time between failures** (MTBF) is the runtime that a component can reasonably expect to last between outages.</span></span> <span data-ttu-id="3af76-197">이 메트릭은 서비스를 사용할 수 없게 되는 빈도를 계산하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-197">This metric can help you to calculate how frequently a service will become unavailable.</span></span> <span data-ttu-id="3af76-198">안정성이 부족한 구성 요소는 MTBF가 낮고, 결국 해당 구성 요소의 SLA가 낮아집니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-198">An unreliable component has a low MTBF, resulting in a low SLA number for that component.</span></span> <span data-ttu-id="3af76-199">그러나 구성 요소의 여러 인스턴스를 배포하고 이들 간에 장애 조치(failover)를 구현하면 MTBF가 낮은 문제를 완화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-199">However, a low MTBF can be mitigated by deploying multiple instances of the component and implementing failover between them.</span></span>

> [!NOTE]
> <span data-ttu-id="3af76-200">고가용성 설정에서 구성 요소의 MTTR 값이 시스템의 RTO를 초과하는 경우 시스템 오류 시 허용할 수 없는 수준의 업무 중단이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-200">If ANY of the MTTR values of components in a high-availability setup exceed the RTO of the system, then a failure in the system will cause an unacceptable business disruption.</span></span> <span data-ttu-id="3af76-201">정의된 RTO 내에서 시스템을 복원할 수 없을 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-201">It won't be possible to restore the system within the defined RTO.</span></span>

### <a name="slas"></a><span data-ttu-id="3af76-202">SLA</span><span class="sxs-lookup"><span data-stu-id="3af76-202">SLAs</span></span>

<span data-ttu-id="3af76-203">Azure에서 [Service Level Agreement(서비스 수준 약정)][sla]는 작동 시간 및 연결에 대한 Microsoft의 정책을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-203">In Azure, the [Service Level Agreement][sla] (SLA) describes Microsoft’s commitments for uptime and connectivity.</span></span> <span data-ttu-id="3af76-204">특정 서비스의 SLA가 99.9%라는 것은 시간의 99.9% 동안 서비스를 사용할 수 있다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-204">If the SLA for a particular service is 99.9%, it means you should expect the service to be available 99.9% of the time.</span></span>

> [!NOTE]
> <span data-ttu-id="3af76-205">Azure SLA에는 각 서비스의 "가용성"에 대한 구체적인 정의와 함께 SLA가 충족되지 않은 경우 서비스 크레딧을 제공하는 조항도 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-205">The Azure SLA also includes provisions for obtaining a service credit if the SLA is not met, along with specific definitions of "availability" for each service.</span></span> <span data-ttu-id="3af76-206">SLA의 이러한 측면은 적용 정책의 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-206">That aspect of the SLA acts as an enforcement policy.</span></span>

<span data-ttu-id="3af76-207">개발자는 솔루션의 각 워크로드에 대한 고유의 목표 SLA를 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-207">You should define your own target SLAs for each workload in your solution.</span></span> <span data-ttu-id="3af76-208">SLA를 사용하면 아키텍처가 비즈니스 요구 사항을 충족하는지 평가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-208">An SLA makes it possible to evaluate whether the architecture meets the business requirements.</span></span> <span data-ttu-id="3af76-209">예를 들어 어떤 워크로드가 99.99% 작동 시간을 요구하지만 SLA 99.9% 서비스를 사용하는 경우 해당 서비스는 시스템에서 단일 오류 지점이 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-209">For example, if a workload requires 99.99% uptime, but depends on a service with a 99.9% SLA, that service cannot be a single-point of failure in the system.</span></span> <span data-ttu-id="3af76-210">한 가지 해결책은 서비스 오류를 대비하여 대체 경로를 만들거나, 다른 조치를 수행하여 해당 서비스의 오류를 복구하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-210">One remedy is to have a fallback path in case the service fails, or take other measures to recover from a failure in that service.</span></span>

<span data-ttu-id="3af76-211">다음 표는 다양한 SLA 수준의 잠재적인 누적 가동 중지 시간을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-211">The following table shows the potential cumulative downtime for various SLA levels.</span></span>

| <span data-ttu-id="3af76-212">SLA</span><span class="sxs-lookup"><span data-stu-id="3af76-212">SLA</span></span> | <span data-ttu-id="3af76-213">주간 가동 중지 시간</span><span class="sxs-lookup"><span data-stu-id="3af76-213">Downtime per week</span></span> | <span data-ttu-id="3af76-214">월간 가동 중지 시간</span><span class="sxs-lookup"><span data-stu-id="3af76-214">Downtime per month</span></span> | <span data-ttu-id="3af76-215">연간 가동 중지 시간</span><span class="sxs-lookup"><span data-stu-id="3af76-215">Downtime per year</span></span> |
| --- | --- | --- | --- |
| <span data-ttu-id="3af76-216">99%</span><span class="sxs-lookup"><span data-stu-id="3af76-216">99%</span></span> |<span data-ttu-id="3af76-217">1.68시간</span><span class="sxs-lookup"><span data-stu-id="3af76-217">1.68 hours</span></span> |<span data-ttu-id="3af76-218">7.2시간</span><span class="sxs-lookup"><span data-stu-id="3af76-218">7.2 hours</span></span> |<span data-ttu-id="3af76-219">3.65일</span><span class="sxs-lookup"><span data-stu-id="3af76-219">3.65 days</span></span> |
| <span data-ttu-id="3af76-220">99.9%</span><span class="sxs-lookup"><span data-stu-id="3af76-220">99.9%</span></span> |<span data-ttu-id="3af76-221">10.1분</span><span class="sxs-lookup"><span data-stu-id="3af76-221">10.1 minutes</span></span> |<span data-ttu-id="3af76-222">43.2분</span><span class="sxs-lookup"><span data-stu-id="3af76-222">43.2 minutes</span></span> |<span data-ttu-id="3af76-223">8.76시간</span><span class="sxs-lookup"><span data-stu-id="3af76-223">8.76 hours</span></span> |
| <span data-ttu-id="3af76-224">99.95%</span><span class="sxs-lookup"><span data-stu-id="3af76-224">99.95%</span></span> |<span data-ttu-id="3af76-225">5분</span><span class="sxs-lookup"><span data-stu-id="3af76-225">5 minutes</span></span> |<span data-ttu-id="3af76-226">21.6분</span><span class="sxs-lookup"><span data-stu-id="3af76-226">21.6 minutes</span></span> |<span data-ttu-id="3af76-227">4.38시간</span><span class="sxs-lookup"><span data-stu-id="3af76-227">4.38 hours</span></span> |
| <span data-ttu-id="3af76-228">99.99%</span><span class="sxs-lookup"><span data-stu-id="3af76-228">99.99%</span></span> |<span data-ttu-id="3af76-229">1.01분</span><span class="sxs-lookup"><span data-stu-id="3af76-229">1.01 minutes</span></span> |<span data-ttu-id="3af76-230">4.32분</span><span class="sxs-lookup"><span data-stu-id="3af76-230">4.32 minutes</span></span> |<span data-ttu-id="3af76-231">52.56분</span><span class="sxs-lookup"><span data-stu-id="3af76-231">52.56 minutes</span></span> |
| <span data-ttu-id="3af76-232">99.999%</span><span class="sxs-lookup"><span data-stu-id="3af76-232">99.999%</span></span> |<span data-ttu-id="3af76-233">6초</span><span class="sxs-lookup"><span data-stu-id="3af76-233">6 seconds</span></span> |<span data-ttu-id="3af76-234">25.9초</span><span class="sxs-lookup"><span data-stu-id="3af76-234">25.9 seconds</span></span> |<span data-ttu-id="3af76-235">5.26분</span><span class="sxs-lookup"><span data-stu-id="3af76-235">5.26 minutes</span></span> |

<span data-ttu-id="3af76-236">다른 요소가 전부 동일하다면 당연히 가용성이 높을수록 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-236">Of course, higher availability is better, everything else being equal.</span></span> <span data-ttu-id="3af76-237">그러나 9의 수를 늘리려면 그에 따른 비용과 복잡성도 함께 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-237">But as you strive for more 9s, the cost and complexity to achieve that level of availability grows.</span></span> <span data-ttu-id="3af76-238">작동 시간이 99.99%이면 총 월간 가동 중지 시간이 약 5분입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-238">An uptime of 99.99% translates to about 5 minutes of total downtime per month.</span></span> <span data-ttu-id="3af76-239">99.999%를 달성하기 위해 추가적인 복잡성과 비용을 감수할 가치가 있습니까?</span><span class="sxs-lookup"><span data-stu-id="3af76-239">Is it worth the additional complexity and cost to reach five 9s?</span></span> <span data-ttu-id="3af76-240">대답은 비즈니스 요구 사항에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-240">The answer depends on the business requirements.</span></span>

<span data-ttu-id="3af76-241">다음은 SLA를 정의할 때 고려해야 할 다른 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-241">Here are some other considerations when defining an SLA:</span></span>

- <span data-ttu-id="3af76-242">4개의 9(99.99%)를 달성하려면 아마도 수동 개입에 의존한 오류 복구로는 불가능할 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-242">To achieve four 9's (99.99%), you probably can't rely on manual intervention to recover from failures.</span></span> <span data-ttu-id="3af76-243">애플리케이션이 자체적으로 진단하고 자체적으로 복구해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-243">The application must be self-diagnosing and self-healing.</span></span>
- <span data-ttu-id="3af76-244">9의 수가 4개를 넘어가면 SLA를 충족할 만큼 신속하게 가동 중단을 감지하기가 쉽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-244">Beyond four 9's, it is challenging to detect outages quickly enough to meet the SLA.</span></span>
- <span data-ttu-id="3af76-245">SLA가 측정되는 시간을 생각해 보세요.</span><span class="sxs-lookup"><span data-stu-id="3af76-245">Think about the time window that your SLA is measured against.</span></span> <span data-ttu-id="3af76-246">시간이 짧을수록 허용 오차도 작습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-246">The smaller the window, the tighter the tolerances.</span></span> <span data-ttu-id="3af76-247">SLA를 시간별 또는 일별 작동 시간으로 정의할 수가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-247">It probably doesn't make sense to define your SLA in terms of hourly or daily uptime.</span></span>
- <span data-ttu-id="3af76-248">MTBF 및 MTTR 측정값을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-248">Consider the MTBF and MTTR measurements.</span></span> <span data-ttu-id="3af76-249">SLA가 낮을수록 서비스가 중단되는 횟수가 줄어들 수 있으며, 서비스를 더 빠르게 복구해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-249">The lower your SLA, the less frequently the service can go down, and the quicker the service must recover.</span></span>

### <a name="composite-slas"></a><span data-ttu-id="3af76-250">복합 SLA</span><span class="sxs-lookup"><span data-stu-id="3af76-250">Composite SLAs</span></span>

<span data-ttu-id="3af76-251">Azure SQL Database에 쓰는 App Service 웹앱을 고려해 보세요.</span><span class="sxs-lookup"><span data-stu-id="3af76-251">Consider an App Service web app that writes to Azure SQL Database.</span></span> <span data-ttu-id="3af76-252">이 문서가 작성된 시점에 이러한 Azure 서비스의 SLA는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-252">At the time of this writing, these Azure services have the following SLAs:</span></span>

- <span data-ttu-id="3af76-253">App Service Web Apps = 99.95%</span><span class="sxs-lookup"><span data-stu-id="3af76-253">App Service Web Apps = 99.95%</span></span>
- <span data-ttu-id="3af76-254">SQL Database = 99.99%</span><span class="sxs-lookup"><span data-stu-id="3af76-254">SQL Database = 99.99%</span></span>

![복합 SLA](./images/sla1.png)

<span data-ttu-id="3af76-256">이 애플리케이션에 기대하는 최대 가동 중지 시간이 얼마입니까?</span><span class="sxs-lookup"><span data-stu-id="3af76-256">What is the maximum downtime you would expect for this application?</span></span> <span data-ttu-id="3af76-257">서비스 중 하나가 중단되면 전체 애플리케이션이 중단됩니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-257">If either service fails, the whole application fails.</span></span> <span data-ttu-id="3af76-258">일반적으로 각 서비스가 중단될 확률은 독립적이므로 이 애플리케이션의 복합 SLA는 99.95% &times; 99.99% = 99.94%입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-258">In general, the probability of each service failing is independent, so the composite SLA for this application is 99.95% &times; 99.99% = 99.94%.</span></span> <span data-ttu-id="3af76-259">개별 SLA보다 낮은데, 별로 놀랄 일은 아닙니다. 여러 서비스를 사용하는 애플리케이션은 잠재적 오류 지점이 더 많기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-259">That's lower than the individual SLAs, which isn't surprising, because an application that relies on multiple services has more potential failure points.</span></span>

<span data-ttu-id="3af76-260">반면, 독립적인 대체 경로를 만들어서 복합 SLA를 높일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-260">On the other hand, you can improve the composite SLA by creating independent fallback paths.</span></span> <span data-ttu-id="3af76-261">예를 들어 SQL Database를 사용할 수 없으면 트랜잭션을 큐에 배치하여 나중에 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-261">For example, if SQL Database is unavailable, put transactions into a queue, to be processed later.</span></span>

![복합 SLA](./images/sla2.png)

<span data-ttu-id="3af76-263">이 디자인에서는 애플리케이션이 데이터베이스에 연결할 수 없는 경우에도 계속 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-263">With this design, the application is still available even if it can't connect to the database.</span></span> <span data-ttu-id="3af76-264">그러나 데이터베이스와 큐가 동시에 중단되면 응용 프로그램도 중단됩니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-264">However, it fails if the database and the queue both fail at the same time.</span></span> <span data-ttu-id="3af76-265">예상되는 동시 중단 시간 비율은 0.0001 &times; 0.001이므로 이 복합 경로의 복합 SLA는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-265">The expected percentage of time for a simultaneous failure is 0.0001 &times; 0.001, so the composite SLA for this combined path is:</span></span>  

- <span data-ttu-id="3af76-266">데이터베이스 또는 큐 = 1.0 &minus; (0.0001 &times; 0.001) = 99.99999%</span><span class="sxs-lookup"><span data-stu-id="3af76-266">Database OR queue = 1.0 &minus; (0.0001 &times; 0.001) = 99.99999%</span></span>

<span data-ttu-id="3af76-267">총 복합 SLA는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-267">The total composite SLA is:</span></span>

- <span data-ttu-id="3af76-268">웹앱 및 (데이터베이스 또는 큐) = 99.95% &times; 99.99999% = ~99.95%</span><span class="sxs-lookup"><span data-stu-id="3af76-268">Web app AND (database OR queue) = 99.95% &times; 99.99999% = ~99.95%</span></span>

<span data-ttu-id="3af76-269">하지만 이 방법에는 단점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-269">But there are tradeoffs to this approach.</span></span> <span data-ttu-id="3af76-270">애플리케이션 논리가 더 복잡하고 큐에 대한 비용을 지불해야 하며, 데이터 일관성 문제를 고려해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-270">The application logic is more complex, you are paying for the queue, and there may be data consistency issues to consider.</span></span>

<span data-ttu-id="3af76-271">**다중 지역 배포의 SLA**.</span><span class="sxs-lookup"><span data-stu-id="3af76-271">**SLA for multi-region deployments**.</span></span> <span data-ttu-id="3af76-272">또 다른 HA 기술은 여러 지역에 애플리케이션을 배포 하고, 한 지역의 애플리케이션에 오류가 발생하면 Azure Traffic Manager를 사용하여 장애 조치(failover)하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-272">Another HA technique is to deploy the application in more than one region, and use Azure Traffic Manager to fail over if the application fails in one region.</span></span> <span data-ttu-id="3af76-273">다중 지역 배포의 경우 복합 SLA는 다음과 같이 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-273">For a multi-region deployment, the composite SLA is calculated as follows.</span></span>

<span data-ttu-id="3af76-274">한 지역에 배포된 애플리케이션의 복합 SLA를 *N*, 애플리케이션이 배포된 지역 수를 *R*이라 하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-274">Let *N* be the composite SLA for the application deployed in one region, and *R* be the number of regions where the application is deployed.</span></span> <span data-ttu-id="3af76-275">모든 지역의 애플리케이션이 동시에 중단될 확률은 ((1 &minus; N) ^ R)입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-275">The expected chance that the application will fail in all regions at the same time is ((1 &minus; N) ^ R).</span></span>

<span data-ttu-id="3af76-276">예를 들어 단일 지역 SLA가 99.95%이면,</span><span class="sxs-lookup"><span data-stu-id="3af76-276">For example, if the single-region SLA is 99.95%,</span></span>

- <span data-ttu-id="3af76-277">두 지역의 결합 SLA는 (1 &minus; (0.9995 ^ 2)) = 99.999975%</span><span class="sxs-lookup"><span data-stu-id="3af76-277">The combined SLA for two regions = (1 &minus; (0.9995 ^ 2)) = 99.999975%</span></span>
- <span data-ttu-id="3af76-278">네 지역의 결합 SLA는 (1 &minus; (0.9995 ^ 4)) = 99.999999%</span><span class="sxs-lookup"><span data-stu-id="3af76-278">The combined SLA for four regions = (1 &minus; (0.9995 ^ 4)) = 99.999999%</span></span>

<span data-ttu-id="3af76-279">[Traffic Manager SLA][tm-sla]도 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-279">You must also factor in the [SLA for Traffic Manager][tm-sla].</span></span> <span data-ttu-id="3af76-280">이 문서가 작성된 시점의 Traffic Manager SLA는 99.99%입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-280">At the time of this writing, the SLA for Traffic Manager SLA is 99.99%.</span></span>

<span data-ttu-id="3af76-281">또한 활성-수동 구성에서는 장애 조치(failover)가 즉시 이루어지는 것이 아니기 때문에 장애 조치(failover) 중에 약간의 가동 중지 시간이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-281">Also, failing over is not instantaneous in active-passive configurations, which can result in some downtime during a failover.</span></span> <span data-ttu-id="3af76-282">자세한 내용은 [Traffic Manager 엔드포인트 모니터링 및 장애 조치(failover)][tm-failover]를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3af76-282">See [Traffic Manager endpoint monitoring and failover][tm-failover].</span></span>

<span data-ttu-id="3af76-283">계산된 SLA 숫자는 유용한 기본 자료이지만 가용성에 대한 전반적인 성능을 알려주지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-283">The calculated SLA number is a useful baseline, but it doesn't tell the whole story about availability.</span></span> <span data-ttu-id="3af76-284">종종 중요하지 않은 경로에 오류가 발생할 때 애플리케이션 성능이 정상적으로 저하될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-284">Often, an application can degrade gracefully when a non-critical path fails.</span></span> <span data-ttu-id="3af76-285">책 카탈로그를 표시하는 애플리케이션을 생각해 보세요.</span><span class="sxs-lookup"><span data-stu-id="3af76-285">Consider an application that shows a catalog of books.</span></span> <span data-ttu-id="3af76-286">이 애플리케이션은 표지의 썸네일 이미지를 검색할 수 없으면 자리 표시자 이미지를 표시할 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-286">If the application can't retrieve the thumbnail image for the cover, it might show a placeholder image.</span></span> <span data-ttu-id="3af76-287">이 경우, 이미지를 가져오지 못해도 사용자 경험에는 영향을 주지만 애플리케이션의 작동 시간에는 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-287">In that case, failing to get the image does not reduce the application's uptime, although it affects the user experience.</span></span>  

## <a name="design-for-resiliency"></a><span data-ttu-id="3af76-288">복원력을 위한 디자인</span><span class="sxs-lookup"><span data-stu-id="3af76-288">Design for resiliency</span></span>

<span data-ttu-id="3af76-289">디자인 단계에서 FMA(오류 모드 분석)를 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-289">During the design phase, you should perform a failure mode analysis (FMA).</span></span> <span data-ttu-id="3af76-290">FMA의 목표는 가능한 실패 지점을 식별하고 애플리케이션이 이러한 오류에 대응하는 방식을 정의하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-290">The goal of an FMA is to identify possible points of failure, and define how the application will respond to those failures.</span></span>

- <span data-ttu-id="3af76-291">애플리케이션이 이러한 종류의 오류를 어떻게 감지하나요?</span><span class="sxs-lookup"><span data-stu-id="3af76-291">How will the application detect this type of failure?</span></span>
- <span data-ttu-id="3af76-292">애플리케이션이 이러한 종류의 오류에 어떻게 대응하나요?</span><span class="sxs-lookup"><span data-stu-id="3af76-292">How will the application respond to this type of failure?</span></span>
- <span data-ttu-id="3af76-293">이러한 종류의 오류를 어떻게 로깅하고 모니터링하나요?</span><span class="sxs-lookup"><span data-stu-id="3af76-293">How will you log and monitor this type of failure?</span></span>

<span data-ttu-id="3af76-294">Azure에 대한 구체적인 추천을 비롯한 FMA 프로세스에 대한 자세한 내용은 [Azure 복원력 지침: 실패 모드 분석][fma]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3af76-294">For more information about the FMA process, with specific recommendations for Azure, see [Azure resiliency guidance: Failure mode analysis][fma].</span></span>

### <a name="example-of-identifying-failure-modes-and-detection-strategy"></a><span data-ttu-id="3af76-295">오류 모드 식별 및 감지 전략의 예</span><span class="sxs-lookup"><span data-stu-id="3af76-295">Example of identifying failure modes and detection strategy</span></span>

<span data-ttu-id="3af76-296">**실패 지점:** 외부 웹 서비스/API에 대한 호출입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-296">**Failure point:** Call to an external web service / API.</span></span>

| <span data-ttu-id="3af76-297">오류 모드</span><span class="sxs-lookup"><span data-stu-id="3af76-297">Failure mode</span></span> | <span data-ttu-id="3af76-298">감지 전략</span><span class="sxs-lookup"><span data-stu-id="3af76-298">Detection strategy</span></span> |
| --- | --- |
| <span data-ttu-id="3af76-299">서비스를 사용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="3af76-299">Service is unavailable</span></span> |<span data-ttu-id="3af76-300">HTTP 5xx</span><span class="sxs-lookup"><span data-stu-id="3af76-300">HTTP 5xx</span></span> |
| <span data-ttu-id="3af76-301">제한</span><span class="sxs-lookup"><span data-stu-id="3af76-301">Throttling</span></span> |<span data-ttu-id="3af76-302">HTTP 429(요청이 너무 많음)</span><span class="sxs-lookup"><span data-stu-id="3af76-302">HTTP 429 (Too Many Requests)</span></span> |
| <span data-ttu-id="3af76-303">인증</span><span class="sxs-lookup"><span data-stu-id="3af76-303">Authentication</span></span> |<span data-ttu-id="3af76-304">HTTP 401(권한 없음)</span><span class="sxs-lookup"><span data-stu-id="3af76-304">HTTP 401 (Unauthorized)</span></span> |
| <span data-ttu-id="3af76-305">느린 응답 시간</span><span class="sxs-lookup"><span data-stu-id="3af76-305">Slow response</span></span> |<span data-ttu-id="3af76-306">요청 시간 초과</span><span class="sxs-lookup"><span data-stu-id="3af76-306">Request times out</span></span> |

### <a name="redundancy-and-designing-for-failure"></a><span data-ttu-id="3af76-307">오류에 대한 중복성 및 디자인</span><span class="sxs-lookup"><span data-stu-id="3af76-307">Redundancy and designing for failure</span></span>

<span data-ttu-id="3af76-308">오류는 해당 영향의 범위가 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-308">Failures can vary in the scope of their impact.</span></span> <span data-ttu-id="3af76-309">실패한 디스크와 같은 일부 하드웨어 오류는 단일 호스트 컴퓨터에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-309">Some hardware failures, such as a failed disk, may affect a single host machine.</span></span> <span data-ttu-id="3af76-310">실패한 네트워크 스위치는 전체 서버 랙에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-310">A failed network switch could affect a whole server rack.</span></span> <span data-ttu-id="3af76-311">데이터 센터의 전원 손실 등 전체 데이터 센터를 방해하는 오류는 일반적이지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-311">Less common are failures that disrupt a whole data center, such as loss of power in a data center.</span></span> <span data-ttu-id="3af76-312">가끔 전체 지역을 사용할 수 없게 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-312">Rarely, an entire region could become unavailable.</span></span>

<span data-ttu-id="3af76-313">중복성을 통해 애플리케이션을 복원력 있게 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-313">One of the main ways to make an application resilient is through redundancy.</span></span> <span data-ttu-id="3af76-314">그러나 애플리케이션을 디자인할 때 이러한 중복성에 대해 계획해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-314">But you need to plan for this redundancy when you design the application.</span></span> <span data-ttu-id="3af76-315">또한 필요한 중복성 수준은 비즈니스 요구 사항에 따라 달라집니다. &mdash; 지역 가동 중단으로부터 보호하기 위해 일부 애플리케이션에 지역 간 중복성이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-315">Also, the level of redundancy that you need depends on your business requirements &mdash; not every application needs redundancy across regions to guard against a regional outage.</span></span> <span data-ttu-id="3af76-316">일반적으로 중복성과 안정성 및 비용과 복잡성 간에 균형을 조절해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-316">In general, there is a tradeoff between greater redundancy and reliability versus higher cost and complexity.</span></span>  

<span data-ttu-id="3af76-317">Azure에는 개별 VM에서 전체 영역에 이르는 모든 오류 수준에서 애플리케이션이 중복되는 여러 기능이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-317">Azure has a number of features to make an application redundant at every level of failure, from an individual VM to an entire region.</span></span>

![Azure 복원력 기능](./images/redundancy.svg)

<span data-ttu-id="3af76-319">**단일 VM**</span><span class="sxs-lookup"><span data-stu-id="3af76-319">**Single VM**.</span></span> <span data-ttu-id="3af76-320">Azure에서는 단일 VM에 [작동 시간 SLA](https://azure.microsoft.com/support/legal/sla/virtual-machines)를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-320">Azure provides an [uptime SLA](https://azure.microsoft.com/support/legal/sla/virtual-machines) for single VMs.</span></span> <span data-ttu-id="3af76-321">(VM은 모든 운영 체제 디스크 및 데이터 디스크에 프리미엄 스토리지를 사용해야 합니다.) 둘 이상의 VM을 실행하여 SLA를 높일 수 있지만 단일 VM은 일부 워크로드에서 충분히 안정적일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-321">(The VM must use premium storage for all Operating System Disks and Data Disks.) Although you can get a higher SLA by running two or more VMs, a single VM may be reliable enough for some workloads.</span></span> <span data-ttu-id="3af76-322">그러나 프로덕션 워크로드의 경우 중복성을 위해 둘 이상의 VM을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-322">For production workloads, however, we recommend using two or more VMs for redundancy.</span></span>

<span data-ttu-id="3af76-323">**가용성 집합**.</span><span class="sxs-lookup"><span data-stu-id="3af76-323">**Availability sets**.</span></span> <span data-ttu-id="3af76-324">디스크 또는 네트워크 전환이 실패한 경우 하드웨어 오류로부터 보호하려면 가용성 집합에 둘 이상의 VM을 배포합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-324">To protect against localized hardware failures, such as a disk or network switch failing, deploy two or more VMs in an availability set.</span></span> <span data-ttu-id="3af76-325">가용성 집합은 공통 전원 소스 및 네트워크 스위치를 공유하는 두 개 이상의 *장애 도메인*으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-325">An availability set consists of two or more *fault domains* that share a common power source and network switch.</span></span> <span data-ttu-id="3af76-326">가용성 집합의 VM은 장애 도메인에 분산되어 있으므로 하드웨어 오류가 하나의 장애 도메인에 영향을 주는 경우 네트워크 트래픽은 다른 오류 도메인에서 VM을 라우팅할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-326">VMs in an availability set are distributed across the fault domains, so if a hardware failure affects one fault domain, network traffic can still be routed the VMs in the other fault domains.</span></span> <span data-ttu-id="3af76-327">가용성 집합에 대한 자세한 내용은 [Azure에서 Windows 가상 머신의 가용성 관리](/azure/virtual-machines/windows/manage-availability)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3af76-327">For more information about Availability Sets, see [Manage the availability of Windows virtual machines in Azure](/azure/virtual-machines/windows/manage-availability).</span></span>

<span data-ttu-id="3af76-328">**가용성 영역**.</span><span class="sxs-lookup"><span data-stu-id="3af76-328">**Availability zones**.</span></span>  <span data-ttu-id="3af76-329">가용성 영역은 Azure 지역 내에서 물리적으로 별도 영역입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-329">An Availability Zone is a physically separate zone within an Azure region.</span></span> <span data-ttu-id="3af76-330">각 가용성 영역에는 고유한 소스, 네트워크 및 냉각 장치가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-330">Each Availability Zone has a distinct power source, network, and cooling.</span></span> <span data-ttu-id="3af76-331">가용성 영역 간에 VM을 배포하면 데이터 센터 전체의 오류로부터 애플리케이션을 보호할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-331">Deploying VMs across availability zones helps to protect an application against datacenter-wide failures.</span></span> <span data-ttu-id="3af76-332">모든 Azure 지역에서 가용성 영역을 지원하는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-332">Not all regions support Availability Zones.</span></span> <span data-ttu-id="3af76-333">지원되는 Azure 지역 및 서비스 목록은 [Azure에서 가용성 영역이란?](/azure/availability-zones/az-overview)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3af76-333">For a list of supported regions and services, see [What are Availability Zones in Azure?](/azure/availability-zones/az-overview).</span></span>

<span data-ttu-id="3af76-334">배포에서 가용성 영역을 사용하려면 먼저 애플리케이션 아키텍처와 코드 베이스가 이 구성을 지원할 수 있는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-334">If you are planning to use Availability Zones in your deployment, first validate that your application architecture and code base can support this configuration.</span></span> <span data-ttu-id="3af76-335">COTS 소프트웨어를 배포하려는 경우 소프트웨어 공급업체에 문의하여 프로덕션 환경에 배포하기 전에 적절한 테스트를 수행하세요.</span><span class="sxs-lookup"><span data-stu-id="3af76-335">If you are deploying commercial off-the-shelf software, consult with the software vendor and test adequately before deploying into production.</span></span> <span data-ttu-id="3af76-336">구성된 영역 내에서 중단이 발생하는 동안 애플리케이션이 상태를 유지하고 데이터 손실을 방지할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-336">An application must be able to maintain state and prevent loss of data during an outage within the configured zone.</span></span> <span data-ttu-id="3af76-337">코드 베이스에 지정된 하드 코드된 인프라 구성 요소가 없는 탄력적인 분산 인프라에서 애플리케이션을 실행할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-337">The application must support running in an elastic and distributed infrastructure with no hard-coded infrastructure components specified in the code base.</span></span>

<span data-ttu-id="3af76-338">**Azure Site Recovery**</span><span class="sxs-lookup"><span data-stu-id="3af76-338">**Azure Site Recovery**.</span></span>  <span data-ttu-id="3af76-339">비즈니스 연속성 및 재해 복구 요구 사항을 위해 다른 Azure 지역에 Azure Virtual Machines를 복제합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-339">Replicate Azure virtual machines to another Azure region for business continuity and disaster recovery needs.</span></span> <span data-ttu-id="3af76-340">규정 준수 요구 사항을 충족하도록 정기적인 DR 훈련을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-340">You can conduct periodic DR drills to ensure you meet the compliance needs.</span></span> <span data-ttu-id="3af76-341">VM은 원본 지역에서 중단이 발생한 경우 애플리케이션을 복구할 수 있도록 선택한 지역에 지정된 설정을 사용하여 복제됩니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-341">The VM will be replicated with the specified settings to the selected region so that you can recover your applications in the event of outages in the source region.</span></span> <span data-ttu-id="3af76-342">자세한 내용은 [ASR을 사용하여 Azure VM 복제][site-recovery]를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3af76-342">For more information, see [Replicate Azure VMs using ASR][site-recovery].</span></span> <span data-ttu-id="3af76-343">여기서 솔루션의 RTO 및 RPO를 고려하고, 테스트할 때 복구 시간 및 복구 지점이 요구 사항에 적합한지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-343">Consider the RTO and RPO numbers for your solution here and ensure that when testing, the recovery time and recovery point is appropriate for your needs.</span></span>

<span data-ttu-id="3af76-344">**쌍을 이루는 지역**</span><span class="sxs-lookup"><span data-stu-id="3af76-344">**Paired regions**.</span></span> <span data-ttu-id="3af76-345">지역 가동 중단으로부터 애플리케이션을 보호하려면 인터넷 트래픽을 서로 다른 지역에 배포하기 위해 Azure Traffic Manager를 사용하여 애플리케이션을 여러 지역에 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-345">To protect an application against a regional outage, you can deploy the application across multiple regions, using Azure Traffic Manager to distribute internet traffic to the different regions.</span></span> <span data-ttu-id="3af76-346">각 Azure 지역은 다른 지역과 쌍을 이룹니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-346">Each Azure region is paired with another region.</span></span> <span data-ttu-id="3af76-347">이러한 지역은 함께 [지역 쌍](/azure/best-practices-availability-paired-regions)을 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-347">Together, these form a [regional pair](/azure/best-practices-availability-paired-regions).</span></span> <span data-ttu-id="3af76-348">브라질 남부를 제외하고 지역 쌍은 세금 및 법률 집행 관할 구역의 데이터 상주 요구 사항을 충족하기 위해 동일한 지리적 위치 내에 위치합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-348">With the exception of Brazil South, regional pairs are located within the same geography in order to meet data residency requirements for tax and law enforcement jurisdiction purposes.</span></span>

<span data-ttu-id="3af76-349">다중 지역 애플리케이션을 디자인할 때 지역 간 네트워크 대기 시간이 지역 내 네트워크 대기 시간보다 길다는 점을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-349">When you design a multi-region application, take into account that network latency across regions is higher than within a region.</span></span> <span data-ttu-id="3af76-350">예를 들어 장애 조치할 수 있도록 데이터베이스를 복제하는 경우 지역 간의 비동기 데이터 복제가 아니라 지역 내의 동기 데이터 복제를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-350">For example, if you are replicating a database to enable failover, use synchronous data replication within a region, but asynchronous data replication across regions.</span></span>

| &nbsp; | <span data-ttu-id="3af76-351">가용성 집합</span><span class="sxs-lookup"><span data-stu-id="3af76-351">Availability Set</span></span> | <span data-ttu-id="3af76-352">가용성 영역</span><span class="sxs-lookup"><span data-stu-id="3af76-352">Availability Zone</span></span> | <span data-ttu-id="3af76-353">Azure Site Recovery/페어링된 지역</span><span class="sxs-lookup"><span data-stu-id="3af76-353">Azure Site Recovery/Paired region</span></span> |
|--------|------------------|-------------------|---------------|
| <span data-ttu-id="3af76-354">오류의 범위</span><span class="sxs-lookup"><span data-stu-id="3af76-354">Scope of failure</span></span> | <span data-ttu-id="3af76-355">랙</span><span class="sxs-lookup"><span data-stu-id="3af76-355">Rack</span></span> | <span data-ttu-id="3af76-356">데이터 센터</span><span class="sxs-lookup"><span data-stu-id="3af76-356">Datacenter</span></span> | <span data-ttu-id="3af76-357">지역</span><span class="sxs-lookup"><span data-stu-id="3af76-357">Region</span></span> |
| <span data-ttu-id="3af76-358">요청 라우팅</span><span class="sxs-lookup"><span data-stu-id="3af76-358">Request routing</span></span> | <span data-ttu-id="3af76-359">Load Balancer</span><span class="sxs-lookup"><span data-stu-id="3af76-359">Load Balancer</span></span> | <span data-ttu-id="3af76-360">영역 간 부하 분산 장치</span><span class="sxs-lookup"><span data-stu-id="3af76-360">Cross-zone Load Balancer</span></span> | <span data-ttu-id="3af76-361">Traffic Manager</span><span class="sxs-lookup"><span data-stu-id="3af76-361">Traffic Manager</span></span> |
| <span data-ttu-id="3af76-362">네트워크 대기 시간</span><span class="sxs-lookup"><span data-stu-id="3af76-362">Network latency</span></span> | <span data-ttu-id="3af76-363">매우 낮음</span><span class="sxs-lookup"><span data-stu-id="3af76-363">Very low</span></span> | <span data-ttu-id="3af76-364">낮음</span><span class="sxs-lookup"><span data-stu-id="3af76-364">Low</span></span> | <span data-ttu-id="3af76-365">중간부터 높음</span><span class="sxs-lookup"><span data-stu-id="3af76-365">Mid to high</span></span> |
| <span data-ttu-id="3af76-366">가상 네트워크</span><span class="sxs-lookup"><span data-stu-id="3af76-366">Virtual network</span></span>  | <span data-ttu-id="3af76-367">VNet</span><span class="sxs-lookup"><span data-stu-id="3af76-367">VNet</span></span> | <span data-ttu-id="3af76-368">VNet</span><span class="sxs-lookup"><span data-stu-id="3af76-368">VNet</span></span> | <span data-ttu-id="3af76-369">지역 간 VNet 피어링</span><span class="sxs-lookup"><span data-stu-id="3af76-369">Cross-region VNet peering</span></span> |

## <a name="implement-resiliency-strategies"></a><span data-ttu-id="3af76-370">복원력 전략 구현</span><span class="sxs-lookup"><span data-stu-id="3af76-370">Implement resiliency strategies</span></span>

<span data-ttu-id="3af76-371">이 섹션에서는 몇 가지 일반적인 복원력 전략에 대한 설문 조사를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-371">This section provides a survey of some common resiliency strategies.</span></span> <span data-ttu-id="3af76-372">이들 중 대부분은 특정 기술에 제한되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-372">Most of these are not limited to a particular technology.</span></span> <span data-ttu-id="3af76-373">이 섹션에서는 각 기술의 밑바탕에 깔려 있는 일반적인 개념을 설명하고 추가 정보에 대한 링크를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-373">The descriptions in this section summarize the general idea behind each technique, with links to further reading.</span></span>

<span data-ttu-id="3af76-374">**일시적인 오류 다시 시도**.</span><span class="sxs-lookup"><span data-stu-id="3af76-374">**Retry transient failures**.</span></span> <span data-ttu-id="3af76-375">서비스 사용량이 많을 때 일시적인 네트워크 연결 해제, 데이터베이스 연결 끊김 또는 시간 제한으로 인해 일시적 오류가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-375">Transient failures can be caused by momentary loss of network connectivity, a dropped database connection, or a timeout when a service is busy.</span></span> <span data-ttu-id="3af76-376">일시적인 오류는 요청을 다시 시도하면 해결되는 경우가 자주 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-376">Often, a transient failure can be resolved simply by retrying the request.</span></span> <span data-ttu-id="3af76-377">여러 Azure 서비스의 경우 클라이언트 SDK는 호출자에게 투명한 방식으로 자동 다시 시도를 구현합니다. 자세한 내용은 [다시 시도 서비스별 지침][retry-service-specific guidance]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3af76-377">For many Azure services, the client SDK implements automatic retries, in a way that is transparent to the caller; see [Retry service specific guidance][retry-service-specific guidance].</span></span>

<span data-ttu-id="3af76-378">각 다시 시도는 총 대기 시간에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-378">Each retry attempt adds to the total latency.</span></span> <span data-ttu-id="3af76-379">또한 실패한 요청 수가 너무 많으면 보류 중인 요청이 큐에 누적되어 병목 상태가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-379">Also, too many failed requests can cause a bottleneck, as pending requests accumulate in the queue.</span></span> <span data-ttu-id="3af76-380">이처럼 차단된 요청이 메모리, 스레드, 데이터베이스 연결 등의 중요한 시스템 리소스를 계속 잡아 두어 연속 오류를 일으킬 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-380">These blocked requests might hold critical system resources such as memory, threads, database connections, and so on, which can cause cascading failures.</span></span> <span data-ttu-id="3af76-381">이 문제를 방지하려면 각 다시 시도 사이의 지연 시간을 늘리고 총 실패한 요청 수를 제한하세요.</span><span class="sxs-lookup"><span data-stu-id="3af76-381">To avoid this, increase the delay between each retry attempt, and limit the total number of failed requests.</span></span>

![재시도 횟수의 다이어그램](./images/retry.png)

<span data-ttu-id="3af76-383">**인스턴스 간에 부하 분산**.</span><span class="sxs-lookup"><span data-stu-id="3af76-383">**Load balance across instances**.</span></span> <span data-ttu-id="3af76-384">확장성을 위해 클라우드 애플리케이션은 인스턴스를 추가하여 규모 확장할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-384">For scalability, a cloud application should be able to scale out by adding more instances.</span></span> <span data-ttu-id="3af76-385">이 방법은 회전 대상에서 비정상 인스턴스를 제거할 수 있으므로 복원력도 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-385">This approach also improves resiliency, because unhealthy instances can be removed from rotation.</span></span> <span data-ttu-id="3af76-386">예: </span><span class="sxs-lookup"><span data-stu-id="3af76-386">For example:</span></span>

- <span data-ttu-id="3af76-387">부하 분산 장치 뒤에 둘 이상의 VM을 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-387">Put two or more VMs behind a load balancer.</span></span> <span data-ttu-id="3af76-388">부하 분산 장치는 모든 VM에 트래픽을 분산합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-388">The load balancer distributes traffic to all the VMs.</span></span> <span data-ttu-id="3af76-389">[부하가 분산된 VM을 실행하여 확장성 및 가용성 확보][ra-multi-vm]를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3af76-389">See [Run load-balanced VMs for scalability and availability][ra-multi-vm].</span></span>
- <span data-ttu-id="3af76-390">Azure App Service 앱을 여러 인스턴스로 규모 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-390">Scale out an Azure App Service app to multiple instances.</span></span> <span data-ttu-id="3af76-391">App Service는 자동으로 인스턴스 간에 부하를 분산합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-391">App Service automatically balances load across instances.</span></span> <span data-ttu-id="3af76-392">[기본 웹 애플리케이션][ra-basic-web]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3af76-392">See [Basic web application][ra-basic-web].</span></span>
- <span data-ttu-id="3af76-393">[Azure Traffic Manager][tm]를 사용하여 엔드포인트 집합에 트래픽을 분산합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-393">Use [Azure Traffic Manager][tm] to distribute traffic across a set of endpoints.</span></span>

<span data-ttu-id="3af76-394">**데이터 복제**.</span><span class="sxs-lookup"><span data-stu-id="3af76-394">**Replicate data**.</span></span> <span data-ttu-id="3af76-395">데이터 복제는 데이터 저장소의 일시적이지 않은 오류를 처리하는 일반적인 전략입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-395">Replicating data is a general strategy for handling non-transient failures in a data store.</span></span> <span data-ttu-id="3af76-396">Azure Storage, Azure SQL Database, Cosmos DB, Apache Cassandra를 비롯한 여러 스토리지 기술은 기본적으로 복제 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-396">Many storage technologies provide built-in replication, including Azure Storage, Azure SQL Database, Cosmos DB, and Apache Cassandra.</span></span> <span data-ttu-id="3af76-397">읽기 및 쓰기 경로를 모두 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-397">It's important to consider both the read and write paths.</span></span> <span data-ttu-id="3af76-398">저장소 기술에 따라 여러 개의 쓰기 가능한 복제본이 생길 수도 있고, 쓰기 가능한 복제본 하나와 읽기 전용 복제본 여러 개가 생길 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-398">Depending on the storage technology, you might have multiple writable replicas, or a single writable replica and multiple read-only replicas.</span></span>

<span data-ttu-id="3af76-399">가용성을 최대화하기 위해 복제본을 여러 영역에 배치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-399">To maximize availability, replicas can be placed in multiple regions.</span></span> <span data-ttu-id="3af76-400">그러나 데이터를 복제할 때 대기 시간이 증가하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-400">However, this increases the latency when replicating the data.</span></span> <span data-ttu-id="3af76-401">일반적으로 지역 간 복제는 비동기적으로 수행되며, 이는 복제본 오류가 발생할 경우 궁극적으로 일관성 모델 및 데이터 손실 가능성이 있다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-401">Typically, replicating across regions is done asynchronously, which implies an eventual consistency model and potential data loss if a replica fails.</span></span>

<span data-ttu-id="3af76-402">[Azure Site Recovery][site-recovery]를 사용하여 Azure 지역 간에 Azure Virtual Machines를 복제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-402">You can use [Azure Site Recovery][site-recovery] to replicate Azure virtual machines from one region to another region.</span></span> <span data-ttu-id="3af76-403">Site Recovery는 지속적으로 대상 지역에 데이터를 복제합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-403">Site Recovery replicates data continuously to the target region.</span></span> <span data-ttu-id="3af76-404">기본 사이트에서 중단이 발생하면 보조 위치로 장애 조치(failover)합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-404">When an outage occurs at your primary site, you fail over to secondary location</span></span>

<span data-ttu-id="3af76-405">**정상적으로 성능 저하**.</span><span class="sxs-lookup"><span data-stu-id="3af76-405">**Degrade gracefully**.</span></span> <span data-ttu-id="3af76-406">서비스에 오류가 발생하고 장애 조치(failover) 경로가 없는 경우 애플리케이션이 정상적으로 성능을 내리고 계속해서 허용 가능한 수준의 사용자 환경을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-406">If a service fails and there is no failover path, the application may be able to degrade gracefully while still providing an acceptable user experience.</span></span> <span data-ttu-id="3af76-407">예: </span><span class="sxs-lookup"><span data-stu-id="3af76-407">For example:</span></span>

- <span data-ttu-id="3af76-408">나중에 처리하도록 작업 항목을 큐에 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-408">Put a work item on a queue, to be handled later.</span></span>
- <span data-ttu-id="3af76-409">예상 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-409">Return an estimated value.</span></span>
- <span data-ttu-id="3af76-410">로컬로 캐시된 데이터를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-410">Use locally cached data.</span></span>
- <span data-ttu-id="3af76-411">사용자에게 오류 메시지를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-411">Show the user an error message.</span></span> <span data-ttu-id="3af76-412">(요청에 대응하여 애플리케이션을 중지하는 것보다는 이 옵션이 낫습니다.)</span><span class="sxs-lookup"><span data-stu-id="3af76-412">(This option is better than having the application stop responding to requests.)</span></span>

<span data-ttu-id="3af76-413">**대규모 사용자 제한**.</span><span class="sxs-lookup"><span data-stu-id="3af76-413">**Throttle high-volume users**.</span></span> <span data-ttu-id="3af76-414">소수의 사용자가 과도한 로드를 생성하는 경우가 가끔 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-414">Sometimes a small number of users create excessive load.</span></span> <span data-ttu-id="3af76-415">이 경우 애플리케이션의 가용성을 떨어트려 다른 사용자에게 영향을 줄 수입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-415">That can have an impact on other users, reducing the overall availability of your application.</span></span>

<span data-ttu-id="3af76-416">단일 클라이언트가 과도한 요청을 만드는 경우 애플리케이션에서 클라이언트를 일정 기간 동안 제한할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-416">When a single client makes an excessive number of requests, the application might throttle the client for a certain period of time.</span></span> <span data-ttu-id="3af76-417">제한 기간 동안 애플리케이션은 해당 클라이언트의 요청 중 일부 또는 전부를 거부합니다(정확한 제한 전략에 따라).</span><span class="sxs-lookup"><span data-stu-id="3af76-417">During the throttling period, the application refuses some or all of the requests from that client (depending on the exact throttling strategy).</span></span> <span data-ttu-id="3af76-418">제한의 임계값은 고객의 서비스 계층에 따라 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-418">The threshold for throttling might depend on the customer's service tier.</span></span>

<span data-ttu-id="3af76-419">제한은 반드시 클라이언트가 악의적으로 작동했다는 의미가 아니라 서비스 할당량을 초과한다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-419">Throttling does not imply the client was necessarily acting maliciously, only that it exceeded its service quota.</span></span> <span data-ttu-id="3af76-420">경우에 따라 소비자가 지속적으로 할당량을 초과하거나 악의적으로 행동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-420">In some cases, a consumer might consistently exceed their quota or otherwise behave badly.</span></span> <span data-ttu-id="3af76-421">이 경우 더 나아가서 해당 사용자를 차단할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-421">In that case, you might go further and block the user.</span></span> <span data-ttu-id="3af76-422">일반적으로 사용자 차단은 API 키 또는 IP 주소 범위를 차단하여 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-422">Typically, this is done by blocking an API key or an IP address range.</span></span> <span data-ttu-id="3af76-423">자세한 내용은 [제한 패턴][throttling-pattern]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3af76-423">For more information, see [Throttling Pattern][throttling-pattern].</span></span>

<span data-ttu-id="3af76-424">**회로 차단기 사용**.</span><span class="sxs-lookup"><span data-stu-id="3af76-424">**Use a circuit breaker**.</span></span> <span data-ttu-id="3af76-425">[회로 차단기][circuit-breaker-pattern] 패턴은 애플리케이션이 실패 가능성이 있는 작업을 반복해서 다시 시도하지 않도록 차단할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-425">The [Circuit Breaker][circuit-breaker-pattern] pattern can prevent an application from repeatedly trying an operation that is likely to fail.</span></span> <span data-ttu-id="3af76-426">회로 차단기는 서비스에 대한 호출을 래핑하고 최근 실패 횟수를 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-426">The circuit breaker wraps calls to a service and tracks the number of recent failures.</span></span> <span data-ttu-id="3af76-427">실패 횟수가 임계값을 초과하면 차단기는 서비스를 호출하지 않고 오류 코드를 반환하기 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-427">If the failure count exceeds a threshold, the circuit breaker starts returning an error code without calling the service.</span></span> <span data-ttu-id="3af76-428">이렇게 하면 복구할 서비스 시간을 확보할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-428">This gives the service time to recover.</span></span>

<span data-ttu-id="3af76-429">**부하 평준화를 사용하여 트래픽 급증을 매끄럽게 처리**.</span><span class="sxs-lookup"><span data-stu-id="3af76-429">**Use load leveling to smooth out spikes in traffic**.</span></span>
<span data-ttu-id="3af76-430">백 엔드의 서비스가 감당할 수 없을 정도로 애플리케이션의 트래픽이 갑자기 치솟을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-430">Applications may experience sudden spikes in traffic, which can overwhelm services on the backend.</span></span> <span data-ttu-id="3af76-431">백 엔드 서비스가 요청에 충분히 신속하게 응답할 수 없는 경우 요청이 큐에 추가되거나(백업) 서비스가 애플리케이션을 제한할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-431">If a backend service cannot respond to requests quickly enough, it may cause requests to queue (back up), or cause the service to throttle the application.</span></span> <span data-ttu-id="3af76-432">큐를 버퍼로 사용하면 이 상황을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-432">To avoid this, you can use a queue as a buffer.</span></span> <span data-ttu-id="3af76-433">새 작업 항목이 있으면 백 엔드 서비스를 즉시 호출하는 대신 애플리케이션이 작업 항목을 비동기적으로 실행되도록 큐에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-433">When there is a new work item, instead of calling the backend service immediately, the application queues a work item to run asynchronously.</span></span> <span data-ttu-id="3af76-434">큐는 피크 부하를 매끄럽게 하는 버퍼 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-434">The queue acts as a buffer that smooths out peaks in the load.</span></span> <span data-ttu-id="3af76-435">자세한 내용은 [큐 기반 부하 평준화 패턴][load-leveling-pattern]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3af76-435">For more information, see [Queue-Based Load Leveling Pattern][load-leveling-pattern].</span></span>

<span data-ttu-id="3af76-436">**중요한 리소스 격리**.</span><span class="sxs-lookup"><span data-stu-id="3af76-436">**Isolate critical resources**.</span></span> <span data-ttu-id="3af76-437">가끔 한 하위 시스템의 오류가 원인이 되어 애플리케이션의 다른 부분에서 오류가 발생하기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-437">Failures in one subsystem can sometimes cascade, causing failures in other parts of the application.</span></span> <span data-ttu-id="3af76-438">오류가 스레드 또는 소켓 같은 리소스를 적시에 놓아주지 않으면 리소스가 고갈되어 이와 같은 상황이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-438">This can happen if a failure causes some resources, such as threads or sockets, not to get freed in a timely manner, leading to resource exhaustion.</span></span>

<span data-ttu-id="3af76-439">이 상황을 방지하려면 한 파티션의 오류 때문에 전체 시스템이 중단되는 일이 없도록 시스템을 격리된 그룹으로 분할하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-439">To avoid this, you can partition a system into isolated groups, so that a failure in one partition does not bring down the entire system.</span></span> <span data-ttu-id="3af76-440">이 기술을 격벽 패턴이라고도 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-440">This technique is sometimes called the Bulkhead pattern.</span></span>

<span data-ttu-id="3af76-441">예제:</span><span class="sxs-lookup"><span data-stu-id="3af76-441">Examples:</span></span>

- <span data-ttu-id="3af76-442">데이터베이스를 분할하고(예를 들어 테넌트 기준으로 분할) 각 파티션에 대한 별도의 웹 서버 인스턴스 풀을 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-442">Partition a database (for example, by tenant) and assign a separate pool of web server instances for each partition.</span></span>  
- <span data-ttu-id="3af76-443">별도의 스레드 풀을 사용하여 호출을 서로 다른 서비스에 격리합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-443">Use separate thread pools to isolate calls to different services.</span></span> <span data-ttu-id="3af76-444">이렇게 하면 서비스 중 하나가 실패하더라도 연쇄 오류가 발생하지 않도록 방지하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-444">This helps to prevent cascading failures if one of the services fails.</span></span> <span data-ttu-id="3af76-445">예제는 Netflix [Hystrix 라이브러리][hystrix]를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3af76-445">For an example, see the Netflix [Hystrix library][hystrix].</span></span>
- <span data-ttu-id="3af76-446">[컨테이너][containers]를 사용하여 특정 하위 시스템에만 리소스를 제공하도록 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-446">Use [containers][containers] to limit the resources available to a particular subsystem.</span></span>

![격벽 패턴의 다이어그램](./images/bulkhead.png)

<span data-ttu-id="3af76-448">**보정 트랜잭션 적용**.</span><span class="sxs-lookup"><span data-stu-id="3af76-448">**Apply compensating transactions**.</span></span> <span data-ttu-id="3af76-449">[보정 트랜잭션][compensating-transaction-pattern]은 완료된 다른 트랜잭션의 효과를 실행 취소하는 트랜잭션입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-449">A [compensating transaction][compensating-transaction-pattern] is a transaction that undoes the effects of another completed transaction.</span></span> <span data-ttu-id="3af76-450">분산 시스템에서 강력한 트랜잭션 일관성을 달성하기가 매우 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-450">In a distributed system, it can be very difficult to achieve strong transactional consistency.</span></span> <span data-ttu-id="3af76-451">보정 트랜잭션은 각 단계에서 실행 취소할 수 있는 더 작은 일련의 개별 트랜잭션을 사용하여 일관성을 확보하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-451">Compensating transactions are a way to achieve consistency by using a series of smaller, individual transactions that can be undone at each step.</span></span>

<span data-ttu-id="3af76-452">예를 들어 출장을 준비하려면 고객은 자동차, 호텔 객실 및 항공편을 예약해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-452">For example, to book a trip, a customer might reserve a car, a hotel room, and a flight.</span></span> <span data-ttu-id="3af76-453">이러한 단계 중 하나라도 실패하면 전체 작업이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-453">If any of these steps fails, the entire operation fails.</span></span> <span data-ttu-id="3af76-454">전체 작업에 단일 분산 트랜잭션을 사용하는 대신, 각 단계에 대한 보정 트랜잭션을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-454">Instead of trying to use a single distributed transaction for the entire operation, you can define a compensating transaction for each step.</span></span> <span data-ttu-id="3af76-455">예를 들어 자동차 예약을 실행 취소하려면 예약을 취소하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-455">For example, to undo a car reservation, you cancel the reservation.</span></span> <span data-ttu-id="3af76-456">전체 작업을 완료하기 위해 코디네이터는 각 단계를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-456">In order to complete the whole operation, a coordinator executes each step.</span></span> <span data-ttu-id="3af76-457">어느 단계가 실패하면 코디네이터가 보정 트랜잭션을 적용하여 완료된 단계를 실행 취소합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-457">If any step fails, the coordinator applies compensating transactions to undo any steps that were completed.</span></span>

## <a name="test-for-resiliency"></a><span data-ttu-id="3af76-458">복원력 테스트</span><span class="sxs-lookup"><span data-stu-id="3af76-458">Test for resiliency</span></span>

<span data-ttu-id="3af76-459">일반적으로 애플리케이션의 기능을 테스트하는 방법과 동일한 방법으로는(단위 테스트 등을 실행) 복원력을 테스트할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-459">Generally, you can't test resiliency in the same way that you test application functionality (by running unit tests and so on).</span></span> <span data-ttu-id="3af76-460">그 대신, 간헐적으로 발생하는 오류 조건 하에서 종단 간 워크로드가 수행되는 방식을 테스트해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-460">Instead, you must test how the end-to-end workload performs under failure conditions which only occur intermittently.</span></span>

<span data-ttu-id="3af76-461">테스트는 반복적인 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-461">Testing is an iterative process.</span></span> <span data-ttu-id="3af76-462">애플리케이션을 테스트하고, 결과를 측정하고, 결과를 분석 및 해결하고, 다시 프로세스를 반복합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-462">Test the application, measure the outcome, analyze and address any failures that result, and repeat the process.</span></span>

<span data-ttu-id="3af76-463">**오류 주입 테스트**.</span><span class="sxs-lookup"><span data-stu-id="3af76-463">**Fault injection testing**.</span></span> <span data-ttu-id="3af76-464">실제 오류를 트리거하거나 시뮬레이션하여 오류 시 시스템 복원력을 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-464">Test the resiliency of the system during failures, either by triggering actual failures or by simulating them.</span></span> <span data-ttu-id="3af76-465">다음은 테스트에 자주 사용되는 몇 가지 일반적인 오류 시나리오입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-465">Here are some common failure scenarios to test:</span></span>

- <span data-ttu-id="3af76-466">VM 인스턴스가 중단됩니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-466">Shut down VM instances.</span></span>
- <span data-ttu-id="3af76-467">프로세스가 충돌합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-467">Crash processes.</span></span>
- <span data-ttu-id="3af76-468">인증서가 만료됩니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-468">Expire certificates.</span></span>
- <span data-ttu-id="3af76-469">액세스 키가 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-469">Change access keys.</span></span>
- <span data-ttu-id="3af76-470">도메인 컨트롤러에서 DNS 서비스를 중단합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-470">Shut down the DNS service on domain controllers.</span></span>
- <span data-ttu-id="3af76-471">RAM 또는 스레드 수 같은 가용 시스템 리소스를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-471">Limit available system resources, such as RAM or number of threads.</span></span>
- <span data-ttu-id="3af76-472">디스크를 탑재 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-472">Unmount disks.</span></span>
- <span data-ttu-id="3af76-473">VM을 다시 배포합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-473">Redeploy a VM.</span></span>

<span data-ttu-id="3af76-474">복구 시간을 측정하고 비즈니스 요구 사항이 충족되었는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-474">Measure the recovery times and verify that your business requirements are met.</span></span> <span data-ttu-id="3af76-475">오류 모드를 조합하여 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-475">Test combinations of failure modes as well.</span></span> <span data-ttu-id="3af76-476">오류가 연쇄적으로 발생하지 않아야 하며, 오류를 격리된 방식으로 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-476">Make sure that failures don't cascade, and are handled in an isolated way.</span></span>

<span data-ttu-id="3af76-477">이러한 이유로 디자인 단계에서 잠재적인 실패 지점을 분석하는 것이 매우 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-477">This is another reason why it's important to analyze possible failure points during the design phase.</span></span> <span data-ttu-id="3af76-478">분석 결과를 테스트 계획에 입력해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-478">The results of that analysis should be inputs into your test plan.</span></span>

<span data-ttu-id="3af76-479">**부하 테스트**.</span><span class="sxs-lookup"><span data-stu-id="3af76-479">**Load testing**.</span></span> <span data-ttu-id="3af76-480">부하 테스트는 백 엔드 데이터베이스 성능 초과나 서비스 제한처럼 부하 상태에서만 발생하는 오류를 식별하는 데 있어서 매우 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-480">Load testing is crucial for identifying failures that only happen under load, such as the backend database being overwhelmed or service throttling.</span></span> <span data-ttu-id="3af76-481">프로덕션 데이터와 최대한 비슷한 프로덕션 데이터 또는 가상 데이터를 사용하여 최대 부하를 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-481">Test for peak load, using production data or synthetic data that is as close to production data as possible.</span></span> <span data-ttu-id="3af76-482">애플리케이션이 실제 조건에서 어떻게 동작하는지 확인하는 것이 목표입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-482">The goal is to see how the application behaves under real-world conditions.</span></span>

<span data-ttu-id="3af76-483">**재해 복구 훈련**</span><span class="sxs-lookup"><span data-stu-id="3af76-483">**Disaster recovery drills**.</span></span> <span data-ttu-id="3af76-484">좋은 재해 복구 계획이 있더라도 충분하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-484">It is not enough if you have a good disaster recovery plan in place.</span></span> <span data-ttu-id="3af76-485">복구 계획에 문제가 발생할 경우 제대로 작동하는지 확인하기 위해 정기적으로 테스트해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-485">You need to test it periodically to ensure your recovery plan works fine when it matters.</span></span> <span data-ttu-id="3af76-486">Azure 가상 머신의 경우 [Azure Site Recovery][site-recovery]를 사용하여 프로덕션 애플리케이션 또는 진행 중인 복제에 영향을 주지 않고 [DR 훈련을 복제하고 수행][site-recovery-test-failover]할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-486">For Azure virtual machines, you can use [Azure Site Recovery][site-recovery] to replicate and [perform DR drills][site-recovery-test-failover] without impacting production applications or ongoing replication.</span></span>

## <a name="deploy-using-reliable-processes"></a><span data-ttu-id="3af76-487">신뢰할 수 있는 프로세스를 사용하여 배포</span><span class="sxs-lookup"><span data-stu-id="3af76-487">Deploy using reliable processes</span></span>

<span data-ttu-id="3af76-488">애플리케이션이 프로덕션 환경에 배포된 후에는 업데이트로 인해 오류가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-488">Once an application is deployed to production, updates are a possible source of errors.</span></span> <span data-ttu-id="3af76-489">최악의 경우 잘못된 업데이트 때문에 가동이 중지될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-489">In the worst case, a bad update can cause downtime.</span></span> <span data-ttu-id="3af76-490">이를 방지하려면 배포 프로세스가 예측 가능하고 반복 가능해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-490">To avoid this, the deployment process must be predictable and repeatable.</span></span> <span data-ttu-id="3af76-491">배포에는 Azure 리소스를 프로비전하고, 애플리케이션 코드를 배포하고, 구성 설정을 적용하는 것이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-491">Deployment includes provisioning Azure resources, deploying application code, and applying configuration settings.</span></span> <span data-ttu-id="3af76-492">업데이트에 세 가지가 모두 관련될 수도 있고 일부만 관련될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-492">An update may involve all three, or a subset.</span></span>

<span data-ttu-id="3af76-493">중요한 점은, 수동 배포는 오류가 발생하기 쉽다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-493">The crucial point is that manual deployments are prone to error.</span></span> <span data-ttu-id="3af76-494">따라서 요청이 있을 때 실행할 수 있고 오류가 발생하면 다시 실행할 수 있는 자동화된 멱등원(idempotent) 프로세스를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-494">Therefore, it's recommended to have an automated, idempotent process that you can run on demand, and re-run if something fails.</span></span>

- <span data-ttu-id="3af76-495">Azure Resource Manager 템플릿을 사용하여 Azure 리소스의 프로비전을 자동화하세요.</span><span class="sxs-lookup"><span data-stu-id="3af76-495">Use Azure Resource Manager templates to automate provisioning of Azure resources.</span></span>
- <span data-ttu-id="3af76-496">[Azure Automation DSC(Desired State Configuration)][dsc]를 사용하여 VM을 구성하세요.</span><span class="sxs-lookup"><span data-stu-id="3af76-496">Use [Azure Automation Desired State Configuration][dsc] (DSC) to configure VMs.</span></span>
- <span data-ttu-id="3af76-497">애플리케이션 코드에 자동화 배포 프로세스를 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="3af76-497">Use an automated deployment process for application code.</span></span>

<span data-ttu-id="3af76-498">복원력 있는 배포와 관련된 두 가지 개념은 *코드로써의 인프라* 및 *변경이 불가능한 인프라*입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-498">Two concepts related to resilient deployment are *infrastructure as code* and *immutable infrastructure*.</span></span>

- <span data-ttu-id="3af76-499">**코드로써의 인프라**는 인프라를 프로비전하고 구성하기 위한 코드 사용 관행입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-499">**Infrastructure as code** is the practice of using code to provision and configure infrastructure.</span></span> <span data-ttu-id="3af76-500">코드로써의 인프라는 선언적 방법 또는 명령적 방법(또는 두 가지 조합)을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-500">Infrastructure as code may use a declarative approach or an imperative approach (or a combination of both).</span></span> <span data-ttu-id="3af76-501">Resource Manager 템플릿은 선언적 방법의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-501">Resource Manager templates are an example of a declarative approach.</span></span> <span data-ttu-id="3af76-502">PowerShell 스크립트는 명령적 방법의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-502">PowerShell scripts are an example of an imperative approach.</span></span>
- <span data-ttu-id="3af76-503">**변경이 불가능한 인프라**는 프로덕션 환경에 인프라가 배포된 후에는 인프라를 수정하면 안 된다는 원칙입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-503">**Immutable infrastructure** is the principle that you shouldn’t modify infrastructure after it’s deployed to production.</span></span> <span data-ttu-id="3af76-504">그렇지 않으면 임시 변경 작업이 수행되어 무엇이 변경되었는지 정확하게 알기 어렵고 시스템에 대해 추론하기 어려운 상태에 빠질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-504">Otherwise, you can get into a state where ad hoc changes have been applied, so it's hard to know exactly what changed, and hard to reason about the system.</span></span>

<span data-ttu-id="3af76-505">또 다른 문제는 애플리케이션 업데이트를 수행하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-505">Another question is how to roll out an application update.</span></span> <span data-ttu-id="3af76-506">잘못된 배포의 악영향을 최소화할 수 있도록 정교하게 통제되는 방식으로 업데이트를 푸시하는 청록색 배포 또는 카나리아 릴리스 같은 기술을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-506">We recommend techniques such as blue-green deployment or canary releases, which push updates in highly controlled way to minimize possible impacts from a bad deployment.</span></span>

- <span data-ttu-id="3af76-507">[청록색 배포][blue-green]는 실시간 애플리케이션과 분리된 프로덕션 환경에 업데이트를 배포하는 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-507">[Blue-green deployment][blue-green] is a technique where an update is deployed into a production environment separate from the live application.</span></span> <span data-ttu-id="3af76-508">배포의 유효성을 검사한 후에는 업데이트된 버전으로 트래픽 라우팅을 전환합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-508">After you validate the deployment, switch the traffic routing to the updated version.</span></span> <span data-ttu-id="3af76-509">예를 들어 Azure App Service Web Apps는 스테이징 슬롯을 사용하여 이를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-509">For example, Azure App Service Web Apps enables this with staging slots.</span></span>
- <span data-ttu-id="3af76-510">[카나리아 릴리스][canary-release]는 청록색 배포와 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-510">[Canary releases][canary-release] are similar to blue-green deployments.</span></span> <span data-ttu-id="3af76-511">모든 트래픽을 업데이트된 버전으로 전환하는 대신, 트래픽의 일부를 새 배포로 라우팅하여 일부 사용자에게만 업데이트를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-511">Instead of switching all traffic to the updated version, you roll out the update to a small percentage of users, by routing a portion of the traffic to the new deployment.</span></span> <span data-ttu-id="3af76-512">문제가 있으면 업데이트를 중단하고 이전 배포를 되돌립니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-512">If there is a problem, back off and revert to the old deployment.</span></span> <span data-ttu-id="3af76-513">문제가 없으면 트래픽 100%에 도달할 때까지 점점 더 많은 트래픽을 새 버전으로 라우팅합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-513">Otherwise, route more of the traffic to the new version, until it gets 100% of the traffic.</span></span>

<span data-ttu-id="3af76-514">어떤 방법을 사용하든, 새 버전이 작동하지 않는 경우 마지막으로 알려진 정상 배포로 롤백할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-514">Whatever approach you take, make sure that you can roll back to the last-known-good deployment, in case the new version is not functioning.</span></span> <span data-ttu-id="3af76-515">또한 오류가 발생하면 어떤 버전 때문에 오류가 발생했는지 애플리케이션 로그를 보고 알 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-515">Also, if errors occur, the application logs must indicate which version caused the error.</span></span>

## <a name="monitor-to-detect-failures"></a><span data-ttu-id="3af76-516">오류를 감지하기 위한 모니터링</span><span class="sxs-lookup"><span data-stu-id="3af76-516">Monitor to detect failures</span></span>

<span data-ttu-id="3af76-517">모니터링 및 진단은 복원력에 매우 중요한 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-517">Monitoring and diagnostics are crucial for resiliency.</span></span> <span data-ttu-id="3af76-518">오류가 발생하면 오류가 있다는 사실을 알 수 있어야 하고 오류 원인을 파악할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-518">If something fails, you need to know that it failed, and you need insights into the cause of the failure.</span></span>

<span data-ttu-id="3af76-519">대규모 분산 시스템을 모니터링하는 것은 상당한 과제입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-519">Monitoring a large-scale distributed system poses a significant challenge.</span></span> <span data-ttu-id="3af76-520">수십 개의 VM&mdash;에서 실행되는 애플리케이션이 있다고 생각해 봅시다. 각 VM에 한 번에 하나씩 로그인하여 로그 파일을 살펴보고 문제를 해결하는 것은 현실적이지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-520">Think about an application that runs on a few dozen VMs &mdash; it's not practical to log into each VM, one at a time, and look through log files, trying to troubleshoot a problem.</span></span> <span data-ttu-id="3af76-521">뿐만 아니라 VM 인스턴스의 수는 고정적이지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-521">Moreover, the number of VM instances is probably not static.</span></span> <span data-ttu-id="3af76-522">애플리케이션이 규모 감축 또는 확장되면 VM이 추가 또는 제거되며, 인스턴스가 실패하여 다시 프로비전해야 하는 경우가 가끔 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-522">VMs get added and removed as the application scales in and out, and occasionally an instance may fail and need to be reprovisioned.</span></span> <span data-ttu-id="3af76-523">또한 일반적인 클라우드 애플리케이션은 여러 데이터 저장소(Azure 스토리지, SQL Database, Cosmos DB, Redis 캐시)를 사용할 수 있으며, 단일 사용자 작업이 여러 하위 시스템에 걸쳐 이어질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-523">In addition, a typical cloud application might use multiple data stores (Azure storage, SQL Database, Cosmos DB, Redis cache), and a single user action may span multiple subsystems.</span></span>

<span data-ttu-id="3af76-524">모니터링 및 진단 프로세스를 여러 개별 단계로 구성된 파이프라인이라고 생각하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-524">You can think of the monitoring and diagnostics process as a pipeline with several distinct stages:</span></span>

![복합 SLA](./images/monitoring.png)

- <span data-ttu-id="3af76-526">**계측**.</span><span class="sxs-lookup"><span data-stu-id="3af76-526">**Instrumentation**.</span></span> <span data-ttu-id="3af76-527">모니터링 및 진단에 사용되는 원시 데이터는 애플리케이션 로그, 웹 서버 로그, OS 성능 카운터, 데이터베이스 로그, Azure 플랫폼에 기본 제공되는 진단 기능을 포함하여 다양한 소스에서 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-527">The raw data for monitoring and diagnostics comes from a variety of sources, including application logs, web server logs, OS performance counters, database logs, and diagnostics built into the Azure platform.</span></span> <span data-ttu-id="3af76-528">대부분의 Azure 서비스는 문제의 원인을 파악하는 데 사용할 수 있는 진단 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-528">Most Azure services have a diagnostics feature that you can use to determine the cause of problems.</span></span>
- <span data-ttu-id="3af76-529">**수집 및 저장**.</span><span class="sxs-lookup"><span data-stu-id="3af76-529">**Collection and storage**.</span></span> <span data-ttu-id="3af76-530">원시 계측 데이터는 다양한 위치에 다양한 형식으로 저장할 수 있습니다(예: 애플리케이션 추적 로그, IIS 로그, 성능 카운터).</span><span class="sxs-lookup"><span data-stu-id="3af76-530">Raw instrumentation data can be held in various locations and with various formats (e.g., application trace logs, IIS logs, performance counters).</span></span> <span data-ttu-id="3af76-531">이러한 서로 다른 원본을 수집, 통합하여 신뢰할 수 있는 저장소에 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-531">These disparate sources are collected, consolidated, and put into reliable storage.</span></span>
- <span data-ttu-id="3af76-532">**분석 및 진단**.</span><span class="sxs-lookup"><span data-stu-id="3af76-532">**Analysis and diagnosis**.</span></span> <span data-ttu-id="3af76-533">데이터를 통합한 후에는 데이터를 분석하여 문제를 해결하고 애플리케이션 상태에 대한 전체적인 보기를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-533">After the data is consolidated, it can be analyzed to troubleshoot issues and provide an overall view of application health.</span></span>
- <span data-ttu-id="3af76-534">**시각화 및 경고**.</span><span class="sxs-lookup"><span data-stu-id="3af76-534">**Visualization and alerts**.</span></span> <span data-ttu-id="3af76-535">이 단계에서는 운영자가 문제 또는 추세를 신속하게 파악할 수 있는 방식으로 원격 분석 데이터가 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-535">In this stage, telemetry data is presented in such a way that an operator can quickly notice problems or trends.</span></span> <span data-ttu-id="3af76-536">대시보드 또는 전자 메일 경고를 예로 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-536">Example include dashboards or email alerts.</span></span>  

<span data-ttu-id="3af76-537">모니터링은 오류 감지와 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-537">Monitoring is not the same as failure detection.</span></span> <span data-ttu-id="3af76-538">예를 들어 애플리케이션이 임시 오류 및 다시 시도를 감지했지만, 결과적으로 가동 중지 없이 넘어갈 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-538">For example, your application might detect a transient error and retry, resulting in no downtime.</span></span> <span data-ttu-id="3af76-539">하지만 그렇더라도 오류 비율을 모니터링하여 애플리케이션의 전체적인 상태를 확인할 수 있도록 애플리케이션에서 다시 시도 작업을 로깅해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-539">But it should also log the retry operation, so that you can monitor the error rate, in order to get an overall picture of application health.</span></span>

<span data-ttu-id="3af76-540">애플리케이션 로그는 진단 데이터의 중요한 소스입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-540">Application logs are an important source of diagnostics data.</span></span> <span data-ttu-id="3af76-541">애플리케이션 로깅에 대한 모범 사례는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-541">Best practices for application logging include:</span></span>

- <span data-ttu-id="3af76-542">프로덕션 환경에 로그인합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-542">Log in production.</span></span> <span data-ttu-id="3af76-543">그렇지 않으면 데이터가 가장 필요할 때 데이터를 얻을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-543">Otherwise, you lose insight where you need it most.</span></span>
- <span data-ttu-id="3af76-544">서비스 경계에서 이벤트를 로깅합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-544">Log events at service boundaries.</span></span> <span data-ttu-id="3af76-545">서비스 경계 너머로 흐르는 상관 관계 ID를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-545">Include a correlation ID that flows across service boundaries.</span></span> <span data-ttu-id="3af76-546">한 트랜잭션이 여러 서비스를 통과하는데 그 중 하나가 실패하면 상관 관계 ID를 통해 트랜잭션 실패 이유를 찾아낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-546">If a transaction flows through multiple services and one of them fails, the correlation ID will help you pinpoint why the transaction failed.</span></span>
- <span data-ttu-id="3af76-547">구조적 로깅이라고도 하는 의미 체계 로깅을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-547">Use semantic logging, also known as structured logging.</span></span> <span data-ttu-id="3af76-548">구조화되지 않은 로그는 클라우드 규모에서 필요한 로그 데이터의 사용 및 분석 자동화가 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-548">Unstructured logs make it hard to automate the consumption and analysis of the log data, which is needed at cloud scale.</span></span>
- <span data-ttu-id="3af76-549">비동기 로깅을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-549">Use asynchronous logging.</span></span> <span data-ttu-id="3af76-550">그렇지 않으면 로깅 시스템 자체에서 요청을 백업하게 하여 애플리케이션 오류가 발생할 수 있습니다. 요청 로깅 이벤트 작성을 기다리는 동안 요청이 차단되기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-550">Otherwise, the logging system itself can cause the application to fail by causing requests to back up, as they block while waiting to write a logging event.</span></span>
- <span data-ttu-id="3af76-551">애플리케이션 로깅은 감사와 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-551">Application logging is not the same as auditing.</span></span> <span data-ttu-id="3af76-552">감사는 규정 또는 규제 준수를 위해 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-552">Auditing may be done for compliance or regulatory reasons.</span></span> <span data-ttu-id="3af76-553">따라서 감사 레코드는 완전해야 하고, 트랜잭션을 처리하는 동안 손실이 발생하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-553">As such, audit records must be complete, and it's not acceptable to drop any while processing transactions.</span></span> <span data-ttu-id="3af76-554">애플리케이션에서 감사를 요구하는 경우 감사 레코드를 진단 로깅과 별도로 보관해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-554">If an application requires auditing, this should be kept separate from diagnostics logging.</span></span>

<span data-ttu-id="3af76-555">모니터링 및 진단에 대한 자세한 내용은 [모니터링 및 진단 지침][monitoring-guidance]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3af76-555">For more information about monitoring and diagnostics, see [Monitoring and diagnostics guidance][monitoring-guidance].</span></span>

## <a name="respond-to-failures"></a><span data-ttu-id="3af76-556">오류에 대한 대응</span><span class="sxs-lookup"><span data-stu-id="3af76-556">Respond to failures</span></span>

<span data-ttu-id="3af76-557">이전 섹션에서는 고가용성을 위해 중요한 자동 복구 전략에 집중했습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-557">Previous sections have focused on automated recovery strategies, which are critical for high availability.</span></span> <span data-ttu-id="3af76-558">그러나 경우에 따라 수동 개입이 필요할 때도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-558">However, sometimes manual intervention is needed.</span></span>

- <span data-ttu-id="3af76-559">**경고**.</span><span class="sxs-lookup"><span data-stu-id="3af76-559">**Alerts**.</span></span> <span data-ttu-id="3af76-560">애플리케이션을 모니터링하여 사전 개입이 필요할 수도 있는 경고 기호를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-560">Monitor your application for warning signs that may require proactive intervention.</span></span> <span data-ttu-id="3af76-561">예를 들어 SQL Database 또는 Cosmos DB가 지속적으로 애플리케이션을 제한하는 것을 확인하면 데이터베이스 용량을 높이거나 쿼리를 최적화해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-561">For example, if you see that SQL Database or Cosmos DB consistently throttles your application, you might need to increase your database capacity or optimize your queries.</span></span> <span data-ttu-id="3af76-562">이 예제에서는 애플리케이션이 제한 오류를 투명하게 처리할 수도 있지만 후속 조치를 취할 수 있도록 원격 분석에서 계속 경고를 보내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-562">In this example, even though the application might handle the throttling errors transparently, your telemetry should still raise an alert so that you can follow up.</span></span>  
- <span data-ttu-id="3af76-563">**수동 장애 조치(Failover)**.</span><span class="sxs-lookup"><span data-stu-id="3af76-563">**Manual failover**.</span></span> <span data-ttu-id="3af76-564">일부 시스템은 자동 장애 조치(failover)가 불가능하기 때문에 수동 장애 조치(failover)가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-564">Some systems cannot fail over automatically and require a manual failover.</span></span> <span data-ttu-id="3af76-565">[Azure Site Recovery][site-recovery]를 사용하여 구성된 Azure 가상 머신의 경우 몇 분 내에 다른 지역에서 [장애 조치를 수행][site-recovery-failover]하고 가상 머신을 복구할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-565">For Azure virtual machines configured with [Azure Site Recovery][site-recovery], you can [perform failover][site-recovery-failover] and recover your virtual machines in another region within minutes.</span></span>
- <span data-ttu-id="3af76-566">**운영 준비 테스트**.</span><span class="sxs-lookup"><span data-stu-id="3af76-566">**Operational readiness testing**.</span></span> <span data-ttu-id="3af76-567">애플리케이션이 보조 지역으로 장애 조치(failover)되는 경우 주 지역으로 장애 복구(failback)하기 전에 운영 준비 테스트를 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-567">If your application fails over to a secondary region, you should perform an operational readiness test before you fail back to the primary region.</span></span> <span data-ttu-id="3af76-568">테스트를 통해 주 지역이 정상 상태이고 다시 트래픽을 받을 준비가 되었는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-568">The test should verify that the primary region is healthy and ready to receive traffic again.</span></span>
- <span data-ttu-id="3af76-569">**데이터 일관성 확인**.</span><span class="sxs-lookup"><span data-stu-id="3af76-569">**Data consistency check**.</span></span> <span data-ttu-id="3af76-570">데이터 저장소에 오류가 발생한 후 데이터를 다시 사용할 수 있게 되었을 때, 특히 데이터가 복제된 경우 데이터 불일치가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-570">If a failure happens in a data store, there may be data inconsistencies when the store becomes available again, especially if the data was replicated.</span></span>
- <span data-ttu-id="3af76-571">**백업에서 복원**.</span><span class="sxs-lookup"><span data-stu-id="3af76-571">**Restoring from backup**.</span></span> <span data-ttu-id="3af76-572">예를 들어 한 지역의 SQL Database가 가동 중지된 경우 최신 백업을 사용하여 데이터베이스를 지역 복원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-572">For example, if SQL Database experiences a regional outage, you can geo-restore the database from the latest backup.</span></span>

<span data-ttu-id="3af76-573">재해 복구 계획을 문서화 및 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-573">Document and test your disaster recovery plan.</span></span> <span data-ttu-id="3af76-574">애플리케이션 오류가 비즈니스에 미치는 영향을 평가합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-574">Evaluate the business impact of application failures.</span></span> <span data-ttu-id="3af76-575">프로세스를 최대한 자동화하고 수동 장애 조치(failover), 백업에서 데이터 복원 등의 수동 단계를 문서화합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-575">Automate the process as much as possible, and document any manual steps, such as manual failover or data restoration from backups.</span></span> <span data-ttu-id="3af76-576">재해 복구 프로세스를 주기적으로 테스트하여 유효성을 검사하고 계획을 개선합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-576">Regularly test your disaster recovery process to validate and improve the plan.</span></span>

## <a name="summary"></a><span data-ttu-id="3af76-577">요약</span><span class="sxs-lookup"><span data-stu-id="3af76-577">Summary</span></span>

<span data-ttu-id="3af76-578">이 문서에서는 전체적인 관점에서 복원력을 살펴보고, 클라우드의 고유한 과제 중 일부를 강조했습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-578">This article discussed resiliency from a holistic perspective, emphasizing some of the unique challenges of the cloud.</span></span> <span data-ttu-id="3af76-579">그 중에는 분산, 상용 하드웨어 사용, 일시적 네트워크 오류라는 클라우드 컴퓨팅의 특성도 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-579">These include the distributed nature of cloud computing, the use of commodity hardware, and the presence of transient network faults.</span></span>

<span data-ttu-id="3af76-580">다음은 이 문서에서 기억해야 할 핵심 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-580">Here are the major points to take away from this article:</span></span>

- <span data-ttu-id="3af76-581">복원력이 높으면 가용성이 높고 평균 오류 복구 시간은 짧습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-581">Resiliency leads to higher availability, and lower mean time to recover from failures.</span></span>
- <span data-ttu-id="3af76-582">클라우드에서 높은 복원력을 얻으려면 기존 온-프레미스 솔루션과는 다른 여러 기술 집합이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-582">Achieving resiliency in the cloud requires a different set of techniques from traditional on-premises solutions.</span></span>
- <span data-ttu-id="3af76-583">복원력은 우연히 얻을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-583">Resiliency does not happen by accident.</span></span> <span data-ttu-id="3af76-584">처음부터 디자인하고 구축해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-584">It must be designed and built in from the start.</span></span>
- <span data-ttu-id="3af76-585">복원력은 계획부터 코딩 및 운영까지 애플리케이션의 모든 수명 주기와 관련되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3af76-585">Resiliency touches every part of the application lifecycle, from planning and coding to operations.</span></span>
- <span data-ttu-id="3af76-586">테스트하고 모니터링하세요!</span><span class="sxs-lookup"><span data-stu-id="3af76-586">Test and monitor!</span></span>

<!-- links -->

[blue-green]: https://martinfowler.com/bliki/BlueGreenDeployment.html
[canary-release]: https://martinfowler.com/bliki/CanaryRelease.html
[circuit-breaker-pattern]: https://msdn.microsoft.com/library/dn589784.aspx
[compensating-transaction-pattern]: https://msdn.microsoft.com/library/dn589804.aspx
[containers]: https://en.wikipedia.org/wiki/Operating-system-level_virtualization
[dsc]: /azure/automation/automation-dsc-overview
[contingency-planning-guide]: https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-34r1.pdf
[fma]: failure-mode-analysis.md
[hystrix]: https://medium.com/netflix-techblog/introducing-hystrix-for-resilience-engineering-13531c1ab362
[jmeter]: https://jmeter.apache.org/
[load-leveling-pattern]: ../patterns/queue-based-load-leveling.md
[monitoring-guidance]: ../best-practices/monitoring.md
[ra-basic-web]: ../reference-architectures/app-service-web-app/basic-web-app.md
[ra-multi-vm]: ../reference-architectures/virtual-machines-windows/multi-vm.md
[checklist]: ../checklist/resiliency.md
[retry-pattern]: ../patterns/retry.md
[retry-service-specific guidance]: ../best-practices/retry-service-specific.md
[sla]: https://azure.microsoft.com/support/legal/sla/
[throttling-pattern]: ../patterns/throttling.md
[tm]: https://azure.microsoft.com/services/traffic-manager/
[tm-failover]: /azure/traffic-manager/traffic-manager-monitoring
[tm-sla]: https://azure.microsoft.com/support/legal/sla/traffic-manager
[site-recovery]:/azure/site-recovery/azure-to-azure-quickstart/
[site-recovery-test-failover]:/azure/site-recovery/azure-to-azure-tutorial-dr-drill/
[site-recovery-failover]:/azure/site-recovery/azure-to-azure-tutorial-failover-failback/
