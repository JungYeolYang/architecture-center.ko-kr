---
title: Design resilient applications
description: How to build resilient applications in Azure, for high availability and disaster recovery.
author: MikeWasson
ms.service: guidance
ms.topic: article
ms.date: 03/24/2017
ms.author: pnp
ms.custom: resiliency

pnp.series.title: Design for Resiliency
---
# 복원 가능한 Azure용 응용 프로그램 설계

분산 시스템에서도 장애가 발생합니다. 하드웨어 고장도 발생할 수 있습니다. 네트워크에 일시적 장애가 발생할 수 있습니다. 드물게 전체 서비스나 지역이 중단될 수 있지만, 그에 대한 계획도 세워야 합니다.

클라우드에 신뢰성 있는 응용 프로그램을 구축하는 것은 엔터프라이즈 환경에 신뢰성 있는 응용 프로그램을 구축하는 것과는 다릅니다. 과거에는 수직 확장을 위해 고급 사양의 하드웨어를 구매하였을 수 있지만, 클라우드 환경에서는 수직 확장 대신에 수평 확장을 해야 합니다. 상용 하드웨어를 사용함으로써 클라우드 환경 비용이 낮게 유지됩니다. 장애 방지 및 "평균 무고장 시간" 최적화에 초점을 맞추는 대신에, 이 새로운 환경에서는 "평균 복원 시간"에 초점을 맞춥니다. 목표는 장애의 영향을 최소화하는 것입니다.

이 문서에서는 Microsoft Azure에서 복원 가능한 응용 프로그램을 구축하는 방법의 개요를 설명합니다. 우선 *복원력* 이라는 용어와 관련 개념의 정의부터 시작합니다. 그 다음에 설계, 구현, 배포, 운영에 이르기까지 응용 프로그램의 수명 동안 구조화된 접근법을 사용하여 복원력을 달성하는 프로세스를 설명합니다.

## 복원력이란 무엇일까요?
**복원력** 은 장애로부터 복구하여 계속 기능을 발휘하는 것을 말합니다. 이는 장애를 *피하는 것* 이 아니라 가동 중시 또는 데이터 손실을 방지하는 방식으로 장애에 *대응* 하는 것을 말합니다. 복원의 목표는 장애 이후에 응용 프로그램을 완전히 작동하는 상태로 되돌리는 것입니다.

복원의 중요한 두 가지 측면은 고가용성과 장애 복구입니다.

* **고가용성** (HA) 은 응용 프로그램이 유의미한 가동 중지 없이 정상 상태로 계속 작동하게 하는 능력입니다. "정상 상태"란 응용 프로그램이 응답하고 사용자가 응용 프로그램에 연결하여 상호작용할 수 있는 상태를 의미합니다.  
* **재해 복구** (DR) 는 드물지만 중대한 사고 즉 전체 지역에 영향을 주는 서비스 중단처럼 일시적이지 않고 광범위한 규모의 장애로부터 복구하는 능력을 말합니다. 재해 복구에는 데이터 백업과 보관이 포함되며, 백업에서 데이터베이스를 복원하는 등 수동 개입도 포함될 수 있습니다.

DR에 대비하여 HA를 생각하는 한 가지 방법은, DR은 장애의 영향이 설계된 HA의 처리 능력을 초과했을 때 시작됩니다. 예를 들어, 부하 분산 장치 뒤에 몇 개의 VM을 두면 하나의 VM에 장애가 발생해도 가용성을 제공하지만, 그 VM 모두에 동시에 장애가 발생하면 그렇게 할 수 없습니다.

복원 가능한 응용 프로그램을 설계할 때에는 가용성 요구사항을 이해해야 합니다. 어느 정도의 가동 중지 시간이 허용 가능합니까? 이는 부분적으로 비용의 함수입니다. 잠재적 가동 중지로 얼마의 비즈니스 비용이 발생할까요? 응용 프로그램의 고가용성 확보를 위해 얼마를 투자해야 할까요? 또한 응용 프로그램의 가용성에 대한 정의도 해야 합니다. 예를 들어, 고객이 주문서를 제출할 수 있지만 시스템이 정상 기간 내에 처리할 수 없다면 응용 프로그램이 "다운"되었다고 간주합니까?

또 하나의 일반적인 용어가 **비즈니스 연속성**(BC)인데, 이는 재해 기간 또는 그 후에 필수적 비즈니스 기능을 수행하는 능력을 말합니다. BC는 물리적 시설, 인력, 커뮤니케이션, 운송, IT 등 전체 비즈니스 운영에 적용됩니다. 이 문서에서는 클라우드 응용 프로그램에만 초점을 맞추지만, 복원 계획은 전반적 BC 요구 사항 맥락에서 수행해야 합니다. 

## 복원력 달성을 위한 프로세스
복원력은 애드온이 아닙니다. 이는 반드시 시스템 내에 설계하고 운영 시 실행해야 하는 것입니다. 따라야 할 일반적인 모델은 다음과 같습니다.

1. **정의:** 비즈니스 요구를 기준으로 가용성 요구 사항을 정의합니다.
2. **설계:** 응용 프로그램의 복원력을 설계합니다. 검증된 관행을 따르는 아키텍처로 시작한 후, 그 아키텍처에서 예상되는 장애 지점을 식별합니다.
3. **구현:** 장애를 감지하고 복원하는 전략을 구현합니다.
4. **테스트:** 장애를 시뮬레이션하고 강제 장애 조치를 트리거하여 구현 내용을 테스트합니다.
5. **배포:** 신뢰성 있고 반복할 수 있는 프로세스를 사용하여 응용 프로그램을 생산 환경에 배포합니다.
6. **모니터링:** 응용 프로그램을 모니터링하여 장애를 감지합니다. 시스템을 모니터링함으로써 응용 프로그램의 상태를 측정하고 필요 시 사고에 대응할 수 있습니다.
7. **대응:** 수동 개입이 필요한 사고가 있을 경우에 대응합니다.

이 문서의 나머지 부분에서는 이들 각 단계에 관해서 자세히 설명합니다.

## 복원 요구 사항의 정의
복원 계획은 비즈니스 요구 사항에서 시작됩니다. 그러한 조건에서 복원력에 관하여 생각하는 몇 가지 접근법이 있습니다.

### 작업을 기준으로 구성 해체
다수의 클라우드 솔루션은 여러 응용 프로그램 작업으로 구성됩니다. 이러한 맥락에서 "작업"(workload)이란 용어는 비즈니스 논리와 데이터 저장 요구 사항 측면에서 다른 작업과 논리적으로 분리될 수 있는 개별 기능 또는 컴퓨팅 작업을 의미합니다. 예를 들어, 전자 상거래 앱에는 아래의 작업이 포함될 수 있습니다.

* 제품 카탈로그 찾아보기 및 검색.
* 주문서 작성 및 추적.
* 권장 사항 보기.

이들 작업의 가용성, 확장성, 데이터 일관성, 재해 복구 등에 대한 요구 사항은 다를 수 있습니다. 다시 말하지만 그것은 비즈니스 결정 사항입니다.

또한 이용 패턴도 생각하십시오. 시스템이 반드시 가용성을 유지해야 할 중요한 특정 기간이 있습니까? 예를 들어 신고 기간 직전에 세무 신고 서비스가 다운되어서는 안 되며, 큰 스포츠 이벤트 기간 동안에는 비디오 스트리밍 서비스가 반드시 작동되어야 합니다. 중요한 기간에는, 한 지역에 장애가 발생해도 응용 프로그램이 장애 조치를 취할 수 있도록 여러 지역에 걸쳐 중복 배포를 보유할 수 있습니다. 하지만 다중 지역 배포는 비용이 더 많이 소요되므로 덜 중요한 기간에는 응용 프로그램을 단일 지역에서 실행할 수 있습니다.

### RTO와 RPO
고려해야 할 중요한 두 가지 메트릭은 복구 시간 목표와 복구 지점 목표입니다.

* **복구 시간 목표** (RTO)는 사고 후에 응용 프로그램의 사용 불가 상태를 허용하는 최대 수용 가능한 시간입니다. RTO가 90분이면 재해 시작 시점부터 90분 이내에 응용 프로그램을 작동 상태로 복원할 수 있어야 합니다. RTO 시간이 매우 낮으면 지역의 서비스 중단을 방지하기 위해 보조 배포를 계속 대기 상태로 운영하는 것이 필요할 수 있습니다.
* **복구 지점 목표** (RPO) 는 재해 시 수용 가능한 최대 데이터 손실 기간을 말합니다. 예를 들어 데이터를 단일 데이터베이스에 저장하는데 다른 데이터베이스에 복제하지 않고 매시간 백업을 수행한다면, 최대 1시간 분량의 데이터가 손실될 수 있습니다.

RTO와 RPO는 비즈니스 요구 사항입니다. 또 하나의 일반적 메트릭으로 **평균 복구 시간** (MTTR)이 있는데 이는 장애 후에 응용 프로그램을 복구하는 데 소요되는 평균 시간을 말합니다. MTTR는 시스템에 관한 경험적 사실입니다. MTTR가 RTO를 초과하면 정의된 RTO 내에 시스템을 복원할 수 없기 때문에 시스템 장애가 수용 불가능한 비즈니스 중단을 야기합니다. 

### SLAs
Azure에서 [서비스 수준 계약][sla] (SLA)은 가동 시간과 연결성에 관한 Microsoft의 약속을 설명합니다. 특정 서비스의 SLA가 99.9%이면, 서비스가 시간 중 99.9% 동안 이용할 수 있다고 기대할 수 있습니다.

> [!참고]
> T또한 Azure SLA에는 SLA가 충족되지 않았을 경우에 서비스 크레딧을 받는 조항, 그리고 각 서비스에 대한 "가용성"의 구체적 정의도 포함되어 있습니다. SLA의 그러한 측면이 적용 정책의 역할을 수행합니다.
> 
> 

여러분은 솔루션 내의 각 작업에 대해 자체적인 목표 SLA를 정의해야 합니다. SLA가 있으면 아키텍처에 관한 추론이 가능하고 아키텍처가 비즈니스 요구 사항을 충족하는지 여부를 판단할 수 있습니다. 예를 들어 작업이 99.99%의 가동 시간을 요구하지만 99.99% SLA의 서비스에 의존한다면, 그 서비스는 시스템에서 단일 실패 지점이 될 수 없습니다. 한 가지 해결책은 서비스 장애가 발생할 경우에 대비하여 대체 경로를 확보하거나 그 서비스의 장애로부터 복구하는 다른 조치를 취하는 것입니다.

아래 표는 다양한 SLA 수준별로 예상되는 누적 가동 중지 시간을 표시하고 있습니다.

| SLA | 주간 가동 중지 시간 | 월간 가동 중지 시간 | 연간 가동 중지 시간 |
| --- | --- | --- | --- |
| 99% |1.68 시간 |7.2 시간 |3.65 일 |
| 99.9% |10.1 분 |43.2 분 |8.76 시간 |
| 99.95% |5 분 |21.6 분 |4.38 시간 |
| 99.99% |1.01 분 |4.32 분 |52.56 분 |
| 99.999% |6 초 |25.9 초 |5.26 분 |

물론 모든 조건이 동일하다면 고가용성이 더 좋습니다. 하지만 더 많은 9를 확보하려면 그 수준의 가용성을 달성하기 위한 비용과 복잡성도 증가합니다. 99.99%의 가동 시간은 월간 총 가동 중지 시간이 약 5분임을 의미합니다. 다섯 개의 9를 달성하는 데 소요되는 추가적 복잡성과 비용을 투입할 가치가 있습니까? 그 답변은 비즈니스 요구 사항에 달려있습니다.

SLA를 정의할 때 고려해야 할 기타 몇 가지 고려사항이 있습니다.

* 네 개의 9(99.99%)를 달성하려면 아마도 장애 복구를 위해 수동 개입에 의존할 수는 없을 것입니다. 응용 프로그램이 자가 진단을 하고 자가 복구를 수행해야 합니다.
* 네 개의 9를 넘어서면 SLA를 충족하기 위해 충분히 신속하게 중단을 감지하는 것이 어렵습니다.
* SLA를 측정하는 시간대를 생각해보십시오. 시간대가 작을수록 허용 범위가 더 작아집니다. 시간별 또는 일별 가동 시간 측면에서 SLA를 정의하는 것이 의미가 없을 수도 있습니다. 

### 복합 SLA
Azure SQL 데이터베이스에 작성하는 앱 서비스 웹 응용 프로그램을 생각해보십시오. 작성 시점에 이들 Azure 서비스는 아래와 같은 SLA를 가지고 있습니다.

* 앱 서비스 웹 응용 프로그램 = 99.95%
* SQL 데이터베이스 = 99.99%

![Composite SLA](./images/sla1.png)

이 응용 프로그램에서 기대할 수 있는 최대 가동 중지 시간은 얼마일까요? 어느 한 서비스에 장애가 발생하면 전체 응용 프로그램에 장애가 발생합니다. 일반적으로 각 서비스의 장애 발생 가능성은 독립적이므로 이 응용 프로그램의 복합 SLA는 99.95% x 99.99% = 99.94%입니다. 이는 개별 SLA보다 낮은데, 그 이유는 여러 서비스에 의존하는 응용 프로그램은 잠재적 장애 지점이 더 많기 때문입니다.

한편, 독립적 대체 경로를 만들어서 복합 SAL를 향상할 수 있습니다. 예를 들어 SQL 데이터베이스를 사용할 수 없을 경우, 트랜잭션을 큐에 넣어 나중에 처리하도록 합니다.

![Composite SLA](./images/sla2.png)

이와 같이 설계하면 응용 프로그램이 데이터베이스에 연결할 수 없을 경우에도 계속 이용할 수 있습니다. 하지만 데이터베이스와 큐가 모두 동시에 실패하면 장애가 발생합니다. 동시 장애가 발생할 예상 비율은 0.0001 × 0.001이므로 결합된 경로의 복합 SLA는 다음과 같습니다.

* 데이터베이스 또는 큐 = 1.0 &minus; (0.0001 &times; 0.001) = 99.99999%

총 복합 SLA:

* 웹 응용 프로그램 그리고 (데이터베이스 또는 큐) = 99.95% &times; 99.99999% = ~99.95%

하지만 이러한 접근법에는 장단점이 있습니다. 응용 프로그램 논리가 더 복잡하고, 큐에 대한 비용도 지불하며, 고려해야 할 데이터 일관성 문제도 있을 수 있습니다.

**다중 지역 배포의 SLA**. 또 하나의 HA 기법은 응용 프로그램을 두 개 이상의 지역에 배포하고, 한 지역에서 응용 프로그램이 실패할 경우 장애 조치를 위해 Azure Traffic Manager를 사용하는 것입니다. 2지역 배포의 경우 복합 SLA는 다음과 같이 계산합니다.

*N* 을 한 지역에 배포되는 응용 프로그램의 SLA라고 하겠습니다. 양쪽 지역에서 동시에 응용 프로그램이 실패할 가능성은 (1 &minus; N) &times; (1 &minus; N)입니다. 그러므로,

* 양쪽 지역의 결합 SLA = 1 &minus; (1 &minus; N)(1 &minus; N) = N + (1 &minus; N)N

마지막으로 [Traffic Manager의 SLA][tm-sla]를 고려해야 합니다. 본 기사의 작성 시점에 Traffic Manager의 SLA는 99.99%입니다.

* 복합 SLA = 99.99% &times; (양쪽 지역의 결합 SLA)

자세히 설명하자면 장애 조치가 즉시 이루어지는 것이 아니기 때문에 장애 조치 시에 약간의 가동 중지 시간이 발생할 수 있습니다. [Traffic Manager 끝점 모니터링 및 장애 조치][tm-failover]를 참조하십시오.

계산된 SLA는 유용한 기준선이 되지만, 가용성에 관한 전체 내용을 말해주지는 않습니다. 중요하지 않은 경로가 실패하면 응용 프로그램 기능이 안정적으로 저하될 수 있습니다. 책 카탈로그를 보여주는 응용 프로그램을 생각해보십시오. 응용 프로그램이 커버의 미리 보기 이미지를 검색할 수 없을 경우 자리 표시자 이미지를 보여줄 수 있습니다. 이 경우, 이미지 가져오기가 실패해도 사용자 경험에는 영향을 주지만 응용 프로그램의 가동 시간을 줄이지는 않습니다.

## 복원력 설계
디자인 단계에서 장애 모드 분석(FMA)을 수행해야 합니다. FMA의 목표는 예상 장애 지점을 식별하고 응용 프로그램의 장애 대응 방법을 정의하는 것입니다.

* 응용 프로그램이 어떻게 장애 유형을 감지할까요?
* 응용 프로그램이 어떻게 그 장애 유형에 대응할까요?
* 그 장애 유형을 어떻게 기록하고 모니터링할까요?

FMA 프로세스 및 Azure의 자세한 권장 사항에 관한 내용은 [Azure 복원 지침: 장애 모드 분석][fma]을 참조하십시오.

### 장애 모드 식별 및 감지 전략의 예
**장애 지점:** 외부 웹 서비스 / API로 호출.

| 장애 모드 | 감지 전략 |
| --- | --- |
| 서비스를 사용할 수 없음 |HTTP 5xx |
| 제한 |HTTP 429 (너무 많은 요청) |
| 인증 |HTTP 401 (인증 받지 않음) |
| 느린 응답 |요청 시간 초과 |

## 복원 전략
이 섹션에서는 일부 일반적인 복원 전략에 관한 조사 내용을 제시합니다. 그 전략의 대부분은 특정 기술에 국한되지 않습니다. 이 섹션의 내용은 각 기법 이면의 일반적 아이디어 및 추가로 읽을 자료를 요약하여 설명합니다.

### 일시적 장애의 재시도
일시적 장애는 순간적인 네트워크 연결 끊김, 데이터베이스 연결 끊김 또는 서비스를 사용 중일 때 시간 초과로 인하여 발생할 수 있습니다. 일시적 장애는 간단히 요청을 재시도함으로써 해결되는 경우가 많습니다. 많은 Azure 서비스의 경우 호출자에게 투명한 방식으로 클라이언트 SDK가 자동으로 재시도를 수행합니다. 관련 내용은 [서비스별 재시도 지침][retry-service-specific guidance]을 참조하십시오.

각각의 재시도는 전체 대기 시간을 증가시킵니다. 또한 실패한 요청이 너무 많으면 큐에 대기 중인 요청이 누적되어 병목 현상이 야기됩니다. 이렇게 차단된 요청은 메모리, 스레드, 데이터베이스 연결 등 중요한 시스템 자원을 붙들고 있어서 연속적인 장애를 유발할 수 있습니다. 이를 방지하려면 각 재시도 간의 대기 시간을 증가시켜 실패한 요청의 총 수를 제한해야 합니다.

![Composite SLA](./images/retry.png)

자세한 내용은 [재시도 패턴][retry-pattern]을 참조하십시오.

### 인스턴스 간 부하 분산
확장성의 경우 클라우드 응용 프로그램이 인스턴스 추가를 통한 수평 확장이 가능해야 합니다. 또한 이러한 접근법은 복원력도 향상시키는데 그 이유는 비정상적 인스턴스는 로테이션에서 제외할 수 있기 때문입니다.

예제:

* 부하 분산 장치 뒤에 두 개 이상의 VM을 두십시오. 부하 분산 장치가 트래픽을 모든 VM에 분산시킵니다. 관련 내용은 [확장성 및 가용성을 위해 Azure에서 다수의 VM 실행][ra-multi-vm] 을 참조하십시오.
* Azure App Service 앱을 여러 인스턴스로 확장하십시오. App Service는 자동으로 인스턴스 간 부하 분산을 수행합니다. [기본 웹 응용 프로그램][ra-basic-web]을 참조하십시오.
* 끝점 집합에 걸쳐 트래픽을 배분하려면 [Azure Traffic Manager][tm]를 사용하십시오.

### 데이터 복제
데이터 복제는 일시적이 아닌 데이터 저장소의 장애를 처리하는 일반적인 전략입니다. 많은 저장소 기술이 Azure SQL Database, DocumentDB, Apache Cassandra 등 복제 기능을 기본으로 제공합니다.

읽기 및 쓰기 경로를 모두 고려하는 것이 중요합니다. 저장소 기술에 따라 기록이 가능한 여러 복제본이 있거나 또는 한 개의 기록 가능 복제본과 여러 개의 읽기 전용 복제본이 있을 수 있습니다.

최고의 가용성을 얻으려면 복제본을 여러 지역에 배치해야 합니다. 하지만 그렇게 하면 데이터 복제 대기 시간이 증가합니다. 일반적으로 지역 간 복제는 비동기식으로 수행되므로 궁극적인 일관성 모델을 의미하며 복제에 실패할 경우 데이터가 손실될 가능성이 있습니다.

### 안정적 기능 저하
서비스가 실패하고 장애 조치 경로가 없을 경우, 응용 프로그램은 여전히 수용 가능한 사용자 환경을 제공하면서 안정적으로 기능이 저하될 수 있습니다. 예를 들면 다음과 같습니다.

* 작업 항목을 큐에 넣어 나중에 실행되도록 합니다.
* 추정값을 반환합니다.
* 로컬로 캐시된 데이터를 사용합니다.
* 사용자에게 오류 메시지를 표시합니다. (이 옵션은 응용 프로그램이 요청에 대한 대응을 중지하는 것보다 낫습니다.)

### 대용량 사용자의 제한
때로는 소수의 사용자가 과도한 부하를 야기할 때가 있습니다. 그러면 다른 사용자들에게 영향을 줄 수 있고, 응용 프로그램의 전반적 가용성을 떨어뜨립니다.

단일 클라이언트가 지나치게 많은 요청을 하면, 응용 프로그램이 해당 클라이언트를 일정 기간 제한할 수도 있습니다. 제한 기간 동안 (정확한 제한 전략에 따라) 응용 프로그램이 그 클라이언트의 일부 또는 전체 요청을 거절합니다. 제한 임계값은 고객의 서비스 계층에 따라 달라질 수 있습니다.

제한을 하는 것이 반드시 클라이언트가 악의적 행위를 했다는 것을 의미하지는 않습니다. 단순히 클라이언트가 서비스 할당량을 초과했음을 의미하는 것입니다. 일부의 경우 고객이 지속적으로 할당량을 초과했거나, 불량한 행위를 했을 가능성이 있습니다. 그 경우, 해당 사용자에 대해 추가적인 차단 조치를 취할 수 있습니다. 일반적으로 그 조치는 API 키 또는 IP 주소 범위를 차단하는 방식으로 합니다.

자세한 내용은 [제한 패턴][throttling-pattern]을 참조하십시오.

### 회로 차단기 사용
회로 차단기 패턴을 이용하여 응용 프로그램이 실패할 가능성이 있는 작업을 반복적으로 시도하는 것을 방지할 수 있습니다. 비유로서 물리적 차단기를 들 수 있는데, 이는 회로에 과부하가 걸리면 전류 흐름을 중지시키는 스위치입니다.

회로 차단기는 서비스 호출을 래핑합니다. 차단기의 상태는 다음 세 가지입니다.

* **닫힘**. 정상 상태를 말합니다. 회로 차단기가 서비스로 요청을 보내고 카운터가 최근 실패 수를 추적합니다. 실패 수가 주어진 기간의 임계치를 초과하면 회로 차단기가 열림 상태로 전환됩니다.
* **개방**. 이 상태에서는 회로 차단기가 서비스를 호출하지 않고 즉시 모든 요청을 실패 처리합니다. 응용 프로그램이 완화 경로를 사용해야 하며, 예를 들면 본제본에서 데이터를 읽거나 단순히 오류를 사용자에게 반환해야 합니다. 회로 차단기가 개방으로 전환되면 타이머가 시작됩니다. 타이머가 만료되면 회로 차단기가 절반 개방 상태로 전환됩니다.
* **절반 개방**. 이 상태에서는 회로 차단기가 제한된 수의 요청만 서비스로 전달되도록 합니다. 이들이 성공하면 서비스가 복구된 것으로 가정하고, 회로 차단기가 닫힘 상태로 다시 전환됩니다. 그렇지 않으면 개방 상태로 되돌아갑니다. 절반 개방 상태는 서비스에 갑자기 다량의 요청이 유입되는 것을 방지합니다.

자세한 내용은 [회로 차단기 패턴][circuit-breaker-pattern]을 참조하십시오.

### 트래픽 급증을 원활히 처리하기 위해 부하 평준화 사용
응용 프로그램이 갑작스런 트래픽 급증을 경험할 수 있고, 그러면 백엔드의 서비스에 과부하가 걸릴 수 있습니다. 백엔드서비스가 충분히 신속히 요청에 응답할 수 없으면, 큐 요청(백업)이 발생하거나 또는 서비스가 응용 프로그램을 제한할 수 있습니다.

이를 방지하기 위해서 큐를 버퍼로 사용할 수 있습니다. 새로운 작업 항목이 있을 경우, 즉시 백엔드 서비스를 호출하는 대신에 응용 프로그램이 비동기 실행을 위해 작업 항목을 큐에 넣습니다. 큐는 부하의 급증을 원활히 처리하는 버퍼 역할을 수행합니다.

자세한 내용은 [큐 기반 부하 평준화 패턴][load-leveling-pattern]을 참조하십시오.

### 중요한 리소스 격리
때로는 한 서브시스템의 장애가 연속 장애를 유발할 수 있고 따라서 응용 프로그램의 다른 부분들이 실패할 수 있습니다. 장애 때문에 스레드, 소켓 등 일부 리소스가 제때 해제되지 않아서 리소스가 소진되는 경우에 이런 상황이 발생할 수 있습니다. 

이를 방지하려면, 시스템을 격리된 그룹들로 분할하여 한 파티션의 장애가 전체 시스템을 다운시키지 않도록 해야 합니다. 이 기법을 때로는 벌크헤드 패턴이라고도 합니다.

예를 들면 다음과 같습니다.

* 예를 들어 테넌트로 데이터베이스를 분할하고, 각 파티션에 별도의 웹 서버 인스턴스 풀을 할당합니다.
* 별도의 스레드 풀을 사용하여 다른 서비스에 대한 호출을 격리합니다. 그러면 서비스 중 하나가 실패할 때 연속적인 장애가 발생하는 것이 방지됩니다. 예를 들어, Netflix [Hystrix 라이브러리][hystrix]를 참조하십시오.
* 특정 서브시스템에서 사용 가능한 리소스를 제한하려면 [컨테이너][containers]를 사용하십시오.

![Composite SLA](./images/bulkhead.png)

### 보상 트랜잭션의 적용
보상 트랜잭션은 다른 완료된 트랜잭션의 결과를 실행 취소하는 트랜잭션입니다.

분산 시스템에서는 강력한 트랜잭션 일관성을 달성하는 것이 매우 어려울 수 있습니다. 보상 트랜잭션은 각 단계를 실행 취소할 수 있는 보다 작은 일련의 개별 트랜잭션을 사용하여 일관성을 달성하는 방법입니다.

예를 들어 여행을 예약하려면 차량, 호텔 객실 및 항공편 예약이 필요할 수 있습니다. 이들 단계 중 하나라도 실패하면 전체 작업이 실패합니다. 이 전체 작업을 위해 단일 분산 트랜잭션을 사용하는 대신에 각 단계에 대한 보상 트랜잭션을 정의할 수 있습니다. 예를 들면 차량 예약을 실행 취소하기 위해 예약을 취소할 수 있습니다. 전체 작업을 완료하기 위해 코디네이터가 각 단계를 실행합니다. 임의 단계가 실패하면 코디네이터가 보상 트랜잭션을 적용하여 이전에 완료되었던 모든 단계를 취소합니다.

자세한 내용은 [보상 트랜잭션 패턴][compensating-transaction-pattern]을 참조하십시오. 

## 복원력 테스트
일반적으로 (단위 테스트 실행 등을 통한) 응용 프로그램 기능 테스트와 동일한 방식으로 복원력을 테스트할 수는 없습니다. 대신에 장애 조건에서 종단 간 작업이 어떻게 수행되는지 테스트해야 하는데 이는 정의상 항상 발생하는 상황이 아닙니다.

테스트는 반복적 프로세스의 일부입니다. 응용 프로그램을 테스트하고, 결과를 측정하고, 도출된 장애를 분석하여 수정하고 이 프로세스를 반복합니다.

**오류 삽입 테스트**. 실제 장애를 트리거하거나 시뮬레이션을 통해서 시스템의 장애 복원력을 테스트합니다. 일반적으로 테스트하는 장애 시나리오는 다음과 같습니다.

* VM 인스턴스를 종료합니다.
* 프로세스를 충돌시킵니다.
* 인증서를 만료시킵니다.
* 액세스 키를 변경합니다.
* 도메인 컨트롤러에서 DNS 서비스를 종료합니다.
* RAM, 스레드 수 등 가용 시스템 리소스를 제한합니다.
* 디스크를 분리합니다.
* VM을 다시 배포합니다.

복구 시간을 측정하고 비즈니스 요구 사항을 충족하는지 확인합니다. 장애 모드가 결합된 상황도 테스트합니다. 장애가 연속으로 발생하지 않도록 하고 분리된 방식으로 처리되도록 합니다.

이것이 설계 단계에서 예상 실패 지점을 분석하는 것이 중요한 또 하나의 이유입니다. 분석 결과가 테스트 계획의 투입 자료가 되어야 합니다.

**부하 테스트**. [Visual Studio Team Services][vsts] 또는 [Apache JMeter][jmeter]를 사용한 응용 프로그램 부하 테스트는 부하 상태에서만 발생하는 장애(예: 백엔드 데이터베이스의 과부하, 또는 서비스 제한 등)를 식별할 때 매우 중요합니다. 최대 부하 테스트는 프로덕션 데이터 또는 프로덕션 데이터와 유사한 가상 데이터를 사용하여 수행합니다. 그 목표는 응용 프로그램이 실제 상황에서 어떻게 작동하는지 확인하는 것입니다.

## 복원 가능한 배포
응용 프로그램이 생산 환경에 배포되고 나면, 업데이트가 예상되는 오류의 출처가 됩니다. 최악의 경우 불량 업데이트는 가동 중지를 야기할 수도 있습니다. 이를 방지하려면 배포 프로세스가 예측 가능하고 반복적이어야 합니다. 배포 작업에는 Azure 리소스 프로비저닝, 응용 프로그램 코드 배포 및 구성 설정을 적용하는 것이 포함됩니다. 업데이트에는 세 개 모두 또는 하위 집합이 포함될 수 있습니다. 

중요한 사항은 수동 배포가 오류에 취약하다는 점입니다. 그러므로 온디맨드 방식으로 실행할 수 있고 실패 발생 시 다시 실행할 수 있는 자동 Idempotent 프로세스를 보유할 것을 권장합니다. 

* Azure 리소스 프로비저닝을 자동화하려면 Resource Manager 템플릿을 사용하십시오.
* VM을 구성하려면 [Azure 자동화 필요한 상태 구성][dsc] (DSC)을 사용하십시오.
* 응용 프로그램 코드를 위해 자동화된 배포 프로세스를 사용하십시오.

복원 가능한 배포와 관련된 두 가지 주제는 *코드형 인프라* 및 *수정 불가 인프라* 입니다.

* **코드형 인프라** 는 인프라 프로비저닝 및 구성을 위해 코드를 사용하는 방식을 말합니다. 코드형 인프라는 선언적 접근법 또는 명령적 접근법(또는 이 두 개의 조합)을 사용할 수 있습니다. Resource Manager 템플릿은 선언적 접근법의 예입니다. PowerShell 스크립트는 명령적 접근법의 예입니다.
* **수정 불가 인프라** 는 생산 용으로 배포된 후에는 인프라를 수정해서는 안 된다는 원칙입니다. 그렇지 않으면 특별 변경사항이 적용된 상태로 들어갈 수 있고, 무엇을 변경했는지 정확히 알기가 어려우며, 시스템에 관한 추론을 하기가 어렵습니다. 

또 하나의 질문은 응용 프로그램 업데이트를 배포하는 방법에 관한 것입니다. 저희는 블루-그린 배포 또는 카나리아 릴리스와 같은 기법을 권장하는데, 이는 불량 배포로 예상되는 영향을 최소화하기 위해 매우 통제된 방식으로 업데이트를 진행합니다.

* [•	블루-그린 배포][blue-green] 는 업데이트를 라이브 응용 프로그램과는 분리된의 생산 환경에 배포하는 기법입니다. 배포를 확인한 후 트래픽 라우팅을 업데이트된 버전으로 전환합니다. 예를 들면 Azure App Service 웹 응용 프로그램은 [준비 슬롯][staging-slots]을 통해서 이를 지원합니다.
* [•	카나리아 릴리스][canary-release] 는 블루-그린 배포와 유사합니다. 모든 트래픽을 업데이트된 버전으로 전환하는 대신에, 트래픽의 일부만을 새로운 배포에 라우팅함으로써 업데이트를 적은 비율의 사용자들에게만 배포합니다. 문제가 있으면 철회하고 기존 배포로 되돌아갑니다. 문제가 없으면, 트래픽의 10%가 될 때까지 더 많은 트래픽을 새 버전으로 라우팅합니다.

어떤 접근법을 취하든 간에, 새 버전이 제대로 작동하지 않을 경우 최근에 알려진 양호한 배포로 롤백할 수 있어야 합니다. 또한 오류가 발생할 경우 응용 프로그램 로그를 통해서 어느 버전이 오류를 유발했는지 알 수 있어야 합니다.

## 모니터링 및 진단
복원을 위해 모니터링 및 진단은 매우 중요합니다. 무언가 실패하면, 실패 사실을 알아야 하고, 실패 원인에 대한 통찰력이 필요합니다.

대규모 분산 시스템을 모니터링하는 것은 상당히 어려운 과제입니다. 수십 개의 VM에서 실행되는 응용 프로그램에 대해서 생각해보십시오. 각 VM에 로그인하여 한번에 하나씩 로그 파일을 검토하여 문제 해결을 시도하는 것은 실용적이지 않습니다. 게다가 VM 인스턴스의 수는 아마도 정적이지 않습니다. 응용 프로그램을 축소 및 확장함에 따라 VM이 추가, 제거되며 가끔 인스턴스가 실패하고 다시 프로비저닝하는 것이 필요합니다. 또한 일반적인 클라우드 응용 프로그램은 여러 데이터 스토어(Azure 저장소, SQL 데이터베이스, DocumentDB, Redis 캐시)를 사용할 수 있으며, 단일 사용자 행위에 여러 서브시스템이 포함될 수 있습니다.

모니터링과 진단 프로세스를 여러 개의 명확한 단계가 있는 파이프라인으로 생각할 수 있습니다.

![Composite SLA](./images/monitoring.png)

* **계측**. 모니터링 및 진단을 위한 원시 데이터는 응용 프로그램 로그, 웹 서버 로그, OS 성능 카운터, 데이터베이스 로그, Azure 플랫폼에 구축된 진단 기능 등 다양한 소스에서 나옵니다. 대부분의 Azure 서비스에는 문제의 원인을 파악할 때 사용할 수 있는 진단 기능이 있습니다.
* **컬렉션 및 저장소**. 원시 계측 데이터는 다양한 형식(응용 프로그램 추적 로그, 성능 카운터, IIS 로그)으로 다양한 위치에 유지할 수 있습니다. 이렇게 서로 다른 소스를 수집하여 통합하고 신뢰할 수 있는 저장소에 넣습니다.
* **분석 및 진단**. 데이터를 통합하고 나면, 문제해결 및 응용 프로그램의 전반적 상태를 보여주기 위해 분석할 수 있습니다.
* **시각화 및 알림**. 이 단계에서는 운영자가 추세나 문제점을 신속히 찾을 수 있는 방식으로 원격 분석 데이터가 제시됩니다. 예를 들면 대시보드 또는 이메일 알림 등이 있습니다.

모니터링은 장애 감지와는 다릅니다. 예를 들어, 응용 프로그램이 일시적 오류를 감지하고 재시도함으로써 가동 중지 시간이 발생하지 않을 수 있습니다. 하지만 재시도 작업도 기록해야 하며, 따라서 응용 프로그램의 전반적 상태를 파악하기 위해 오류 비율을 모니터링할 수 있습니다.

응용 프로그램 로그는 진단 데이터의 중요한 소스입니다. 응용 프로그램 로깅의 모범 사례의 예를 들면 다음과 같습니다.

* 실운영에서 로그하십시오. 그렇지 않으면 가장 필요할 때에 통찰력을 잃을 수 있습니다.
* 서비스 경계에서 이벤트를 로그하십시오 서비스 경계를 따라 흐르는 상관 관계 ID를 포함시킵니다. 트랜잭션 X가 여러 서비스를 통해 흐르는데 그 중 하나가 실패하면, 상관 관계 ID가 트랜잭션 실패 이유를 정확히 파악하도록 도와줍니다.
* 의미 중심 로깅(구조화된 로깅이라고도 함)을 사용하십시오. 구조화되지 않은 로그는 클라우드 규모에서 필요한 로그 데이터의 사용 및 분석의 자동화를 어렵게 합니다.
* 비동기 로깅을 사용하십시오. 그렇지 않으면 로깅 시스템 자체가 응용 프로그램의 실패를 야기할 수 있습니다. 그 이유는 요청이 로깅 이벤트 기록 대기를 차단하므로 요청의 백업을 야기하기 때문입니다.
* 응용 프로그램 로깅은 감사와 동일하지 않습니다. 감사는 규정 준수 또는 규제상 이유로 수행할 수 있습니다. 그러므로 감사 기록은 완전해야 하며, 트랜잭션 처리 중에 일부를 놓치는 것이 허용되지 않습니다. 응용 프로그램에 감사가 필요한 경우 기록을 진단 로깅과는 별도로 유지해야 합니다.

모니터링 및 진단에 관한 자세한 내용은 [모니터링 및 진단 지침][monitoring-guidance]을 참조하십시오.

## 수동 장애 대응
이전의 섹션에서는 고가용성을 위해 매우 중요한 자동 복구 전략에 초점을 맞추었습니다. 하지만 때로는 수동 개입이 필요할 수 있습니다.

* **알림**. 사전에 개입을 요구하는 경호 신호를 파악하기 위해 응용 프로그램을 모니터링하십시오. 예를 들어 SQL 데이터베이스나 DocumentDB가 계속 응용 프로그램을 제한할 경우, 데이터베이스 용량을 늘리거나 쿼리를 최적화하는 것이 필요할 수 있습니다. 이 경우 응용 프로그램이 제한 오류를 투명하게 처리할 수 있지만, 여전히 원격 분석을 통해 알려줌으로써 후속 조치를 취할 수 있게 합니다.
* **수동 장애 조치**. 일부 시스템은 자동으로 장애 조치를 수행할 수 없으므로 수동 장애 조치가 필요합니다.
* **운영 준비 상태 테스트**. 응용 프로그램이 보조 지역으로 장애 조치된 경우, 기본 지역으로 다시 되돌리기 전에 운영 준비 상태 테스트를 수행해야 합니다. 이 테스트를 통해 기본 지역이 정상이고 다시 트래픽을 수신할 준비가 되어 있는지 확인해야 합니다.
* **데이터 일관성 확인**. 데이터 스토어에서 장애가 발생할 경우, 스토어를 다시 사용하게 될 때 특히 데이터가 복제된 경우 데이터 불일치가 있을 수 있습니다.
* **백업에서 복원**. 예를 들어 SQL 데이터베이스에 지역 서비스 중단이 발생한 경우, 최근 백업으로부터 데이터베이스의 지리적 복원을 수행할 수 있습니다.

재해 복구 계획을 문서화하고 테스트하십시오. 수동 장애 조치, 백업의 데이터 복원 등 모든 수동 단계에 대한 서면 절차서를 포함시키십시오.

## 요약
이 문서에서는 클라우드의 일부 고유한 과제를 강조하면서 전체적 관점에서 복원에 관하여 살펴보았습니다. 그 내용에는 클라우드 컴퓨팅의 분산 특성, 상용 하드웨어의 사용, 일시적 네트워크 장애의 존재 등이 포함됩니다.

이 문서의 주요 요점은 다음과 같습니다.

* 복원력을 통해 고가용성과 낮은 평균 고장 복구 시간을 달성할 수 있습니다.
* 클라우드에서 복원력을 확보하려면 전통적 온프레미스 솔루션의 다양한 기법들이 필요합니다.
* 복원력은 우연히 달성되는 것이 아닙니다. 처음부터 설계하고 구축해야 합니다.
* 복원은 계획부터 코딩, 운영까지 응용 프로그램 수명 주기의 모든 부분과 관련됩니다.
* 테스트와 모니터링이 필요합니다.


<!-- links -->

[blue-green]: http://martinfowler.com/bliki/BlueGreenDeployment.html
[canary-release]: http://martinfowler.com/bliki/CanaryRelease.html
[circuit-breaker-pattern]: https://msdn.microsoft.com/library/dn589784.aspx
[compensating-transaction-pattern]: https://msdn.microsoft.com/library/dn589804.aspx
[containers]: https://en.wikipedia.org/wiki/Operating-system-level_virtualization
[dsc]: https://azure.microsoft.com/documentation/articles/automation-dsc-overview/
[fma]: failure-mode-analysis.md
[hystrix]: http://techblog.netflix.com/2012/11/hystrix.html
[jmeter]: http://jmeter.apache.org/
[load-leveling-pattern]: https://msdn.microsoft.com/library/dn589783.aspx
[monitoring-guidance]: ../best-practices/monitoring.md
[ra-basic-web]: https://azure.microsoft.com/documentation/articles/web-apps-basic/
[ra-multi-vm]: https://azure.microsoft.com/documentation/articles/compute-multi-vm/
[checklist]: ../checklist/resiliency.md
[retry-pattern]: https://msdn.microsoft.com/library/dn589788.aspx
[retry-service-specific guidance]: ../best-practices/retry-service-specific.md
[sla]: https://azure.microsoft.com/support/legal/sla/
[staging-slots]: https://azure.microsoft.com/documentation/articles/web-apps-basic/
[throttling-pattern]: https://msdn.microsoft.com/library/dn589798.aspx
[tm]: https://azure.microsoft.com/services/traffic-manager/
[tm-failover]: https://azure.microsoft.com/documentation/articles/traffic-manager-monitoring/
[tm-sla]: https://azure.microsoft.com/support/legal/sla/traffic-manager/v1_0/
[vsts]: https://www.visualstudio.com/features/vso-cloud-load-testing-vs.aspx
