---
title: Azure용 복원 애플리케이션 디자인
description: Azure에서 고가용성 및 재해 복구를 제공하는 복원 애플리케이션을 빌드하는 방법을 설명합니다.
author: MikeWasson
ms.date: 12/18/2018
ms.topic: article
ms.service: architecture-center
ms.subservice: cloud-design-principles
ms.custom: resiliency
ms.openlocfilehash: 7fd0e1bd42266b5e5718be4519352d99b58c0584
ms.sourcegitcommit: 644c2692a80e89648a80ea249fd17a3b17dc0818
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/11/2019
ms.locfileid: "55987158"
---
# <a name="designing-resilient-applications-for-azure"></a><span data-ttu-id="6e8f5-103">Azure용 복원 애플리케이션 디자인</span><span class="sxs-lookup"><span data-stu-id="6e8f5-103">Designing resilient applications for Azure</span></span>

<span data-ttu-id="6e8f5-104">분산 시스템에서는 오류가 발생하기 마련입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-104">In a distributed system, failures will happen.</span></span> <span data-ttu-id="6e8f5-105">하드웨어 고장이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-105">Hardware can fail.</span></span> <span data-ttu-id="6e8f5-106">일시적인 네트워크 오류가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-106">The network can have transient failures.</span></span> <span data-ttu-id="6e8f5-107">매우 드물게 서비스 또는 지역 전체가 중단될 수도 있지만 그렇다 하더라도 계획된 중단이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-107">Rarely, an entire service or region may experience a disruption, but even those must be planned for.</span></span>

<span data-ttu-id="6e8f5-108">클라우드에서 신뢰할 수 있는 애플리케이션을 빌드하는 것은 엔터프라이즈 환경에서 신뢰할 수 있는 애플리케이션을 빌드하는 것과 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-108">Building a reliable application in the cloud is different than building a reliable application in an enterprise setting.</span></span> <span data-ttu-id="6e8f5-109">기존에는 규모 확장을 위해 고성능 하드웨어를 구입해야 했지만, 클라우드 환경에서는 강화 대신 규모 확장을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-109">While historically you may have purchased higher-end hardware to scale up, in a cloud environment you must scale out instead of scaling up.</span></span> <span data-ttu-id="6e8f5-110">클라우드 환경의 비용은 상용 하드웨어를 사용하는 내내 낮은 수준으로 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-110">Costs for cloud environments are kept low through the use of commodity hardware.</span></span> <span data-ttu-id="6e8f5-111">목표는 모든 장애를 막는 것이 아니라 시스템 내에서 발생하는 장애의 영향을 최소화하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-111">Instead of trying to prevent failures altogether, the goal is to minimize the effects of a failure within the system.</span></span>

<span data-ttu-id="6e8f5-112">이 문서에서는 Microsoft Azure에서 복원 애플리케이션을 빌드하는 방법에 대한 개요를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-112">This article provides an overview of how to build resilient applications in Microsoft Azure.</span></span> <span data-ttu-id="6e8f5-113">먼저 *복원력*이라는 용어의 정의와 관련 개념부터 시작하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-113">It starts with a definition of the term *resiliency* and related concepts.</span></span> <span data-ttu-id="6e8f5-114">그런 다음, 디자인 및 구현부터 배포 및 운영에 이르는 애플리케이션의 전체 수명에 걸쳐 구조화된 방법을 사용하여 복원력을 달성하는 프로세스를 설명하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-114">Then it describes a process for achieving resiliency, using a structured approach over the lifetime of an application, from design and implementation to deployment and operations.</span></span>

<!-- markdownlint-disable MD026 -->

## <a name="what-is-resiliency"></a><span data-ttu-id="6e8f5-115">복원력이란?</span><span class="sxs-lookup"><span data-stu-id="6e8f5-115">What is resiliency?</span></span>

<!-- markdownlint-enable MD026 -->

<span data-ttu-id="6e8f5-116">**복원력**은 오류를 복구하여 계속 작동하는 시스템 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-116">**Resiliency** is the ability of a system to recover from failures and continue to function.</span></span> <span data-ttu-id="6e8f5-117">오류 *방지*가 아니라 가동 중지 또는 데이터 손실을 방지하는 방법으로 오류에 *대응*하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-117">It's not about *avoiding* failures, but *responding* to failures in a way that avoids downtime or data loss.</span></span> <span data-ttu-id="6e8f5-118">복원력의 목표는 오류가 발생한 후 애플리케이션을 완전히 작동하는 상태로 되돌리기 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-118">The goal of resiliency is to return the application to a fully functioning state following a failure.</span></span>

<span data-ttu-id="6e8f5-119">복원력의 두 가지 중요한 측면은 고가용성과 재해 복구입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-119">Two important aspects of resiliency are high availability and disaster recovery.</span></span>

- <span data-ttu-id="6e8f5-120">**HA(고가용성)** 은 애플리케이션이 심각한 가동 중지 없이 정상 상태로 계속 실행되는 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-120">**High availability** (HA) is the ability of the application to continue running in a healthy state, without significant downtime.</span></span> <span data-ttu-id="6e8f5-121">"정상 상태"는 애플리케이션에서 응답하고 사용자가 애플리케이션에 연결하여 애플리케이션과 상호 작용할 수 있음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-121">By "healthy state," we mean the application is responsive, and users can connect to the application and interact with it.</span></span>  
- <span data-ttu-id="6e8f5-122">**DR(재해 복구)** 은 드물지만 중요한 사고, 즉 전체 지역에 영향을 주는 서비스 중단과 같이 일시적이지 않은 대규모 장애로부터 복구할 수 있는 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-122">**Disaster recovery** (DR) is the ability to recover from rare but major incidents: non-transient, wide-scale failures, such as service disruption that affects an entire region.</span></span> <span data-ttu-id="6e8f5-123">재해 복구에는 데이터 백업 및 보관이 포함되며, 백업에서 데이터베이스를 복원하는 것과 같은 수동 작업이 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-123">Disaster recovery includes data backup and archiving, and may include manual intervention, such as restoring a database from backup.</span></span>

<span data-ttu-id="6e8f5-124">HA와 DR을 구분하는 방법 중 하나로, DR은 오류의 영향이 HA 디자인의 오류 처리 능력을 초과할 때 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-124">One way to think about HA versus DR is that DR starts when the impact of a fault exceeds the ability of the HA design to handle it.</span></span>  

<span data-ttu-id="6e8f5-125">복원력을 디자인할 때 가용성 요구 사항을 이해해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-125">When you design resiliency, you must understand your availability requirements.</span></span> <span data-ttu-id="6e8f5-126">허용되는 가동 중지 시간이 얼마나 됩니까?</span><span class="sxs-lookup"><span data-stu-id="6e8f5-126">How much downtime is acceptable?</span></span> <span data-ttu-id="6e8f5-127">이것은 비용 함수의 일종입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-127">This is partly a function of cost.</span></span> <span data-ttu-id="6e8f5-128">가동 중지로 인한 잠재적 비용이 얼마나 발생할까요?</span><span class="sxs-lookup"><span data-stu-id="6e8f5-128">How much will potential downtime cost your business?</span></span> <span data-ttu-id="6e8f5-129">고가용성 애플리케이션을 만들려면 얼마를 투자해야 할까요?</span><span class="sxs-lookup"><span data-stu-id="6e8f5-129">How much should you invest in making the application highly available?</span></span> <span data-ttu-id="6e8f5-130">애플리케이션을 사용할 수 있다는 것이 무슨 뜻인지도 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-130">You also have to define what it means for the application to be available.</span></span> <span data-ttu-id="6e8f5-131">예를 들어 고객이 주문을 제출할 수 있지만 시스템이 일반적인 시간 내에 처리할 수 없으면 애플리케이션 "가동 중지"입니까?</span><span class="sxs-lookup"><span data-stu-id="6e8f5-131">For example, is the application "down" if a customer can submit an order but the system cannot process it within the normal timeframe?</span></span> <span data-ttu-id="6e8f5-132">특정 유형의 정전이 발생할 확률, 그리고 완화 전략이 비용 효율적인지 여부도 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-132">Also consider the probability of a particular type of outage occurring, and whether a mitigation strategy is cost-effective.</span></span>

<span data-ttu-id="6e8f5-133">또 다른 일반적인 용어로 **BC(비즈니스 연속성)** 가 사용되고 있는데, 자연 재해나 서비스 중단 같은 악조건이 발생하는 동안 그리고 발생 후에 필수 비즈니스 기능을 수행하는 기능을 말합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-133">Another common term is **business continuity** (BC), which is the ability to perform essential business functions during and after adverse conditions, such as a natural disaster or a downed service.</span></span> <span data-ttu-id="6e8f5-134">물리적 시설, 사람, 통신, 운송, IT를 포함한 기업의 전체 운영이 BC 범위에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-134">BC covers the entire operation of the business, including physical facilities, people, communications, transportation, and IT.</span></span> <span data-ttu-id="6e8f5-135">이 문서에서는 클라우드 애플리케이션을 집중적으로 다루지만, 전체적인 BC 요구 사항에 맞춰서 복원력 계획을 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-135">This article focuses on cloud applications, but resilience planning must be done in the context of overall BC requirements.</span></span>

<span data-ttu-id="6e8f5-136">**데이터 백업**은 DR의 중요한 부분입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-136">**Data backup** is a critical part of DR.</span></span> <span data-ttu-id="6e8f5-137">애플리케이션의 상태 비저장 구성 요소가 실패하면 언제든지 다시 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-137">If the stateless components of an application fail, you can always redeploy them.</span></span> <span data-ttu-id="6e8f5-138">하지만 데이터가 손실되면 시스템은 안정적인 상태로 돌아갈 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-138">But if data is lost, the system can't return to a stable state.</span></span> <span data-ttu-id="6e8f5-139">이상적으로 지역 수준의 재해 발생 시 다른 지역에 데이터를 백업해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-139">Data must be backed up, ideally in a different region in case of a region-wide disaster.</span></span>

<span data-ttu-id="6e8f5-140">백업은 *데이터 복제*와 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-140">Backup is distinct from *data replication*.</span></span> <span data-ttu-id="6e8f5-141">시스템이 복제본을 신속하게 장애 조치할 수 있도록 데이터 복제는 근실시간으로 데이터를 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-141">Data replication involves copying data in near-real-time, so that the system can fail over quickly to a replica.</span></span> <span data-ttu-id="6e8f5-142">많은 데이터베이스 시스템은 복제를 지원합니다. 예를 들어 SQL Server는 SQL Server Always On 가용성 그룹을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-142">Many databases systems support replication; for example, SQL Server supports SQL Server Always On Availability Groups.</span></span> <span data-ttu-id="6e8f5-143">데이터의 복제본을 항상 준비함으로써 데이터 복제가 가동 중단으로부터 복구하는 데 걸리는 시간을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-143">Data replication can reduce how long it takes to recover from an outage, by ensuring that a replica of the data is always standing by.</span></span> <span data-ttu-id="6e8f5-144">그러나 데이터 복제는 사용자 오류로부터 보호될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-144">However, data replication won't protect against human error.</span></span> <span data-ttu-id="6e8f5-145">사용자 오류로 인해 데이터가 손상되면 손상된 데이터가 바로 복제본에 복사됩니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-145">If data gets corrupted because of human error, the corrupted data just gets copied to the replicas.</span></span> <span data-ttu-id="6e8f5-146">따라서 장기 백업을 DR 전략에 포함해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-146">Therefore, you still need to include long-term backup in your DR strategy.</span></span>

## <a name="process-to-achieve-resiliency"></a><span data-ttu-id="6e8f5-147">복원력을 구현하기 위한 프로세스</span><span class="sxs-lookup"><span data-stu-id="6e8f5-147">Process to achieve resiliency</span></span>

<span data-ttu-id="6e8f5-148">복원력은 추가 기능이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-148">Resiliency is not an add-on.</span></span> <span data-ttu-id="6e8f5-149">시스템적으로 설계하여 운영 방식 속에 담아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-149">It must be designed into the system and put into operational practice.</span></span> <span data-ttu-id="6e8f5-150">다음은 일반적인 모델입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-150">Here is a general model to follow:</span></span>

1. <span data-ttu-id="6e8f5-151">**정의** - 비즈니스 요구에 따라 가용성 요구 사항을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-151">**Define** your availability requirements, based on business needs.</span></span>
2. <span data-ttu-id="6e8f5-152">**디자인** - 복원력 있는 애플리케이션을 디자인합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-152">**Design** the application for resiliency.</span></span> <span data-ttu-id="6e8f5-153">검증된 사례를 따르는 아키텍처로 시작한 후 해당 아키텍처에서 발생 가능한 오류를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-153">Start with an architecture that follows proven practices, and then identify the possible failure points in that architecture.</span></span>
3. <span data-ttu-id="6e8f5-154">**구현** - 오류를 감지하고 복구할 전략을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-154">**Implement** strategies to detect and recover from failures.</span></span>
4. <span data-ttu-id="6e8f5-155">**테스트** - 오류를 시뮬레이션하고 강제 장애 조치(failover)를 트리거하여 구현된 전략을 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-155">**Test** the implementation by simulating faults and triggering forced failovers.</span></span>
5. <span data-ttu-id="6e8f5-156">**배포** - 안정적이고 반복 가능한 프로세스를 사용하여 프로덕션 환경에 애플리케이션을 배포합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-156">**Deploy** the application into production using a reliable, repeatable process.</span></span>
6. <span data-ttu-id="6e8f5-157">**모니터링** - 애플리케이션을 모니터링하여 오류를 감지합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-157">**Monitor** the application to detect failures.</span></span> <span data-ttu-id="6e8f5-158">시스템을 모니터링하여 애플리케이션 상태를 측정하고 필요할 때 사고에 대응할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-158">By monitoring the system, you can gauge the health of the application and respond to incidents if necessary.</span></span>
7. <span data-ttu-id="6e8f5-159">**대응** - 수동 개입이 필요한 실패가 있는 경우 적절하게 대응합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-159">**Respond** if there are failure that require manual interventions.</span></span>

<span data-ttu-id="6e8f5-160">이 문서의 나머지 부분에서는 이러한 각 단계를 좀 더 자세히 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-160">In the remainder of this article, we discuss each of these steps in more detail.</span></span>

## <a name="define-your-availability-requirements"></a><span data-ttu-id="6e8f5-161">가용성 요구 사항 정의</span><span class="sxs-lookup"><span data-stu-id="6e8f5-161">Define your availability requirements</span></span>

<span data-ttu-id="6e8f5-162">복원력 계획은 비즈니스 요구 사항으로 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-162">Resiliency planning starts with business requirements.</span></span> <span data-ttu-id="6e8f5-163">다음과 같은 몇 가지 용어를 통해 복원력에 대해 생각해볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-163">Here are some approaches for thinking about resiliency in those terms.</span></span>

### <a name="decompose-by-workload"></a><span data-ttu-id="6e8f5-164">워크로드별로 분해</span><span class="sxs-lookup"><span data-stu-id="6e8f5-164">Decompose by workload</span></span>

<span data-ttu-id="6e8f5-165">많은 클라우드 솔루션이 여러 애플리케이션 워크로드로 구성되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-165">Many cloud solutions consist of multiple application workloads.</span></span> <span data-ttu-id="6e8f5-166">여기서 "워크로드"라는 용어는 별개의 기능 또는 계산 작업을 의미하며, 비즈니스 논리와 데이터 저장소 요구 사항의 측면에서 다른 작업과 논리적으로 분리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-166">The term "workload" in this context means a discrete capability or computing task, which can be logically separated from other tasks, in terms of business logic and data storage requirements.</span></span> <span data-ttu-id="6e8f5-167">예를 들어 전자 상거래 앱에는 다음과 같은 워크로드가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-167">For example, an e-commerce app might include the following workloads:</span></span>

- <span data-ttu-id="6e8f5-168">제품 카탈로그를 찾아보고 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-168">Browse and search a product catalog.</span></span>
- <span data-ttu-id="6e8f5-169">주문을 작성하고 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-169">Create and track orders.</span></span>
- <span data-ttu-id="6e8f5-170">추천 제품을 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-170">View recommendations.</span></span>

<span data-ttu-id="6e8f5-171">이러한 워크로드마다 가용성, 확장성, 데이터 일관성 및 재해 복구에 대한 요구 사항이 서로 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-171">These workloads might have different requirements for availability, scalability, data consistency, and disaster recovery.</span></span> <span data-ttu-id="6e8f5-172">비용과 위험 간의 적절한 균형을 맞추기 위해 내려야 하는 비즈니스 의사 결정이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-172">There are business decisions to be made in terms of balancing cost versus risk.</span></span>

<span data-ttu-id="6e8f5-173">사용 패턴도 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-173">Also consider usage patterns.</span></span> <span data-ttu-id="6e8f5-174">시스템이 반드시 작동해야 하는 특정 중요 시간대가 있습니까?</span><span class="sxs-lookup"><span data-stu-id="6e8f5-174">Are there certain critical periods when the system must be available?</span></span> <span data-ttu-id="6e8f5-175">예를 들어 세금 신고 서비스는 신고 마감 직전에는 절대 중지되면 안 되고, 비디오 스트리밍 서비스는 대형 스포츠 행사가 진행되는 내내 작동해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-175">For example, a tax-filing service can't go down right before the filing deadline, a video streaming service must stay up during a big sports event, and so on.</span></span> <span data-ttu-id="6e8f5-176">이처럼 중요한 기간에는 여러 지역에 걸쳐 이중으로 배포하면 한 지역에서 오류가 발생하더라도 애플리케이션을 장애 조치(failover)할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-176">During the critical periods, you might have redundant deployments across several regions, so the application could fail over if one region failed.</span></span> <span data-ttu-id="6e8f5-177">그러나 다중 지역 배포는 더 많은 비용이 들기 때문에 덜 중요한 시간에는 한 지역에서만 애플리케이션을 실행할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-177">However, a multi-region deployment is potentially more expensive, so during less critical times, you might run the application in a single region.</span></span> <span data-ttu-id="6e8f5-178">경우에 따라 사용량 기반 청구 방식의 최신 서버리스 기술을 사용하면 사용률이 낮은 컴퓨팅 리소스 비용이 청구되지 않으므로 비용을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-178">In some cases, the additional expense can be mitigated by using modern serverless techniques, which use consumption-based billing, so you are not charged for under-utilitzed compute resources.</span></span>

### <a name="rto-and-rpo"></a><span data-ttu-id="6e8f5-179">RTO 및 RPO</span><span class="sxs-lookup"><span data-stu-id="6e8f5-179">RTO and RPO</span></span>

<span data-ttu-id="6e8f5-180">재해 복구와 관련하여 고려해야 할 두 가지 중요한 메트릭은 복구 시간 목표 및 복구 지점 목표입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-180">Two important metrics to consider are the recovery time objective and recovery point objective, as they pertain to disaster recovery.</span></span>

- <span data-ttu-id="6e8f5-181">**RTO(복구 시간 목표)** 는 사고 발생 후 애플리케이션 중단이 허용되는 최대 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-181">**Recovery time objective** (RTO) is the maximum acceptable time that an application can be unavailable after an incident.</span></span> <span data-ttu-id="6e8f5-182">RTO가 90분이면 재해가 시작된 시점부터 90분 이내에 애플리케이션을 실행 상태로 복원할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-182">If your RTO is 90 minutes, you must be able to restore the application to a running state within 90 minutes from the start of a disaster.</span></span> <span data-ttu-id="6e8f5-183">RTO가 매우 낮은 경우 지역 단위 정전에 대비하여 보조 지역 배포에서 항상 대기 중인 활성/수동 구성을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-183">If you have a very low RTO, you might keep a second regional deployment continually running an active/passive configuration on standby, to protect against a regional outage.</span></span> <span data-ttu-id="6e8f5-184">경우에 따라 활성/활성 구성을 배포하여 더욱 낮은 RTO를 달성할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-184">In some cases you might deploy an active/active configuration to achieve even lower RTO.</span></span>

- <span data-ttu-id="6e8f5-185">**RPO(복구 지점 목표)** 는 재해 발생 시 허용되는 최대 데이터 손실 기간입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-185">**Recovery point objective** (RPO) is the maximum duration of data loss that is acceptable during a disaster.</span></span> <span data-ttu-id="6e8f5-186">예를 들어 다른 데이터베이스에 데이터를 복제하지 않고 단일 데이터베이스에만 데이터를 저장하며 매시간 백업을 수행하는 경우 최대 1시간 분량의 데이터가 손실될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-186">For example, if you store data in a single database, with no replication to other databases, and perform hourly backups, you could lose up to an hour of data.</span></span>

<span data-ttu-id="6e8f5-187">RTO 및 RPO는 시스템의 비기능적 요구 사항이며 비즈니스 요구 사항에 따라 결정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-187">RTO and RPO are non-functional requirements of a system, and should be dictated by business requirements.</span></span> <span data-ttu-id="6e8f5-188">이러한 가치를 측정하려면 위험 평가를 수행하고 가동 중지 시간 또는 데이터 손실의 비용을 정확하게 이해하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-188">To derive these values, it's a good idea to conduct a risk assessment, and clearly understanding the cost of downtime or data loss.</span></span>

### <a name="mttr-and-mtbf"></a><span data-ttu-id="6e8f5-189">MTTR 및 MTBF</span><span class="sxs-lookup"><span data-stu-id="6e8f5-189">MTTR and MTBF</span></span>

<span data-ttu-id="6e8f5-190">가용성을 측정하는 또 다른 두 가지 일반적인 방법은 MTTR(평균 복구 시간) 및 MTBF(평균 고장 간격)입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-190">Two other common measures of availability are mean time to recover (MTTR) and mean time between failures (MTBF).</span></span> <span data-ttu-id="6e8f5-191">두 측정 방법은 일반적으로 서비스 공급 기업에서 클라우드 서비스에 중복성을 추가할 위치와 고객에게 제공할 SLA를 결정하기 위해 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-191">These measures are usually used internally by service providers to determine where to add redundancy to cloud services, and which SLAs to provide to customers.</span></span>

<span data-ttu-id="6e8f5-192">**MTTR(평균 복구 시간)** 은 장애 발생 후 구성 요소를 복원하는 데 걸리는 평균 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-192">**Mean time to recover** (MTTR) is the average time that it takes to restore a component after a failure.</span></span> <span data-ttu-id="6e8f5-193">MTTR은 구성 요소에 대한 실증적 팩트입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-193">MTTR is an empirical fact about a component.</span></span> <span data-ttu-id="6e8f5-194">각 구성 요소의 MTTR에 따라 전체 애플리케이션의 MTTR를 예측할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-194">Based on the MTTR of each component, you can estimate the MTTR of an entire application.</span></span> <span data-ttu-id="6e8f5-195">MTTR이 낮은 여러 구성 요소를 사용하여 애플리케이션을 빌드하면 전체 MTTR이 낮은, 즉, 신속하게 장애를 복구하는 애플리케이션을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-195">Building applications from multiple components with low MTTR values results in an application with a low overall MTTR &mdash; one that recovers quickly from failures.</span></span>

<span data-ttu-id="6e8f5-196">**MTBF(평균 고장 간격)** 는 합리적인 수준에서 구성 요소에 기대할 수 있는 무고장 실행 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-196">**Mean time between failures** (MTBF) is the runtime that a component can reasonably expect to last between outages.</span></span> <span data-ttu-id="6e8f5-197">이 메트릭은 서비스를 사용할 수 없게 되는 빈도를 계산하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-197">This metric can help you to calculate how frequently a service will become unavailable.</span></span> <span data-ttu-id="6e8f5-198">안정성이 부족한 구성 요소는 MTBF가 낮고, 결국 해당 구성 요소의 SLA가 낮아집니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-198">An unreliable component has a low MTBF, resulting in a low SLA number for that component.</span></span> <span data-ttu-id="6e8f5-199">그러나 구성 요소의 여러 인스턴스를 배포하고 이들 간에 장애 조치(failover)를 구현하면 MTBF가 낮은 문제를 완화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-199">However, a low MTBF can be mitigated by deploying multiple instances of the component and implementing failover between them.</span></span>

> [!NOTE]
> <span data-ttu-id="6e8f5-200">고가용성 설정에서 구성 요소의 MTTR 값이 시스템의 RTO를 초과하는 경우 시스템 오류 시 허용할 수 없는 수준의 업무 중단이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-200">If ANY of the MTTR values of components in a high-availability setup exceed the RTO of the system, then a failure in the system will cause an unacceptable business disruption.</span></span> <span data-ttu-id="6e8f5-201">정의된 RTO 내에서 시스템을 복원할 수 없을 것입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-201">It won't be possible to restore the system within the defined RTO.</span></span>

### <a name="slas"></a><span data-ttu-id="6e8f5-202">SLA</span><span class="sxs-lookup"><span data-stu-id="6e8f5-202">SLAs</span></span>

<span data-ttu-id="6e8f5-203">Azure에서 [Service Level Agreement(서비스 수준 약정)][sla]는 작동 시간 및 연결에 대한 Microsoft의 정책을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-203">In Azure, the [Service Level Agreement][sla] (SLA) describes Microsoft’s commitments for uptime and connectivity.</span></span> <span data-ttu-id="6e8f5-204">특정 서비스의 SLA가 99.9%라는 것은 시간의 99.9% 동안 서비스를 사용할 수 있다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-204">If the SLA for a particular service is 99.9%, it means you should expect the service to be available 99.9% of the time.</span></span>

> [!NOTE]
> <span data-ttu-id="6e8f5-205">Azure SLA에는 각 서비스의 "가용성"에 대한 구체적인 정의와 함께 SLA가 충족되지 않은 경우 서비스 크레딧을 제공하는 조항도 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-205">The Azure SLA also includes provisions for obtaining a service credit if the SLA is not met, along with specific definitions of "availability" for each service.</span></span> <span data-ttu-id="6e8f5-206">SLA의 이러한 측면은 적용 정책의 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-206">That aspect of the SLA acts as an enforcement policy.</span></span>

<span data-ttu-id="6e8f5-207">개발자는 솔루션의 각 워크로드에 대한 고유의 목표 SLA를 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-207">You should define your own target SLAs for each workload in your solution.</span></span> <span data-ttu-id="6e8f5-208">SLA를 사용하면 아키텍처가 비즈니스 요구 사항을 충족하는지 평가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-208">An SLA makes it possible to evaluate whether the architecture meets the business requirements.</span></span> <span data-ttu-id="6e8f5-209">종속성 매핑 작업을 수행하여 Active Directory 또는 결제 서비스 업체나 이메일 메시징 서비스 등의 타사 서비스와 같은 내부 및 외부 종속성을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-209">Perform a dependency mapping exercise to identify internal and external dependencies, such as Active Directory or third-party services such as a payment provider or e-mail messaging service.</span></span> <span data-ttu-id="6e8f5-210">특히, 이벤트 중에 병목 현상을 일으키거나 단일 실패 지점이 될 수 있는 외부 종속성에 주의합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-210">In particular, pay attention to any external dependencies that can be single point of failure or cause bottlenecks during an event.</span></span> <span data-ttu-id="6e8f5-211">예를 들어 어떤 워크로드가 99.99% 작동 시간을 요구하지만 SLA 99.9% 서비스를 사용하는 경우 해당 서비스는 시스템에서 단일 오류 지점이 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-211">For example, if a workload requires 99.99% uptime, but depends on a service with a 99.9% SLA, that service cannot be a single-point of failure in the system.</span></span> <span data-ttu-id="6e8f5-212">한 가지 해결책은 서비스 오류를 대비하여 대체 경로를 만들거나, 다른 조치를 수행하여 해당 서비스의 오류를 복구하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-212">One remedy is to have a fallback path in case the service fails, or take other measures to recover from a failure in that service.</span></span>

<span data-ttu-id="6e8f5-213">다음 표는 다양한 SLA 수준의 잠재적인 누적 가동 중지 시간을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-213">The following table shows the potential cumulative downtime for various SLA levels.</span></span>

| <span data-ttu-id="6e8f5-214">SLA</span><span class="sxs-lookup"><span data-stu-id="6e8f5-214">SLA</span></span> | <span data-ttu-id="6e8f5-215">주간 가동 중지 시간</span><span class="sxs-lookup"><span data-stu-id="6e8f5-215">Downtime per week</span></span> | <span data-ttu-id="6e8f5-216">월간 가동 중지 시간</span><span class="sxs-lookup"><span data-stu-id="6e8f5-216">Downtime per month</span></span> | <span data-ttu-id="6e8f5-217">연간 가동 중지 시간</span><span class="sxs-lookup"><span data-stu-id="6e8f5-217">Downtime per year</span></span> |
| --- | --- | --- | --- |
| <span data-ttu-id="6e8f5-218">99%</span><span class="sxs-lookup"><span data-stu-id="6e8f5-218">99%</span></span> |<span data-ttu-id="6e8f5-219">1.68시간</span><span class="sxs-lookup"><span data-stu-id="6e8f5-219">1.68 hours</span></span> |<span data-ttu-id="6e8f5-220">7.2시간</span><span class="sxs-lookup"><span data-stu-id="6e8f5-220">7.2 hours</span></span> |<span data-ttu-id="6e8f5-221">3.65일</span><span class="sxs-lookup"><span data-stu-id="6e8f5-221">3.65 days</span></span> |
| <span data-ttu-id="6e8f5-222">99.9%</span><span class="sxs-lookup"><span data-stu-id="6e8f5-222">99.9%</span></span> |<span data-ttu-id="6e8f5-223">10.1분</span><span class="sxs-lookup"><span data-stu-id="6e8f5-223">10.1 minutes</span></span> |<span data-ttu-id="6e8f5-224">43.2분</span><span class="sxs-lookup"><span data-stu-id="6e8f5-224">43.2 minutes</span></span> |<span data-ttu-id="6e8f5-225">8.76시간</span><span class="sxs-lookup"><span data-stu-id="6e8f5-225">8.76 hours</span></span> |
| <span data-ttu-id="6e8f5-226">99.95%</span><span class="sxs-lookup"><span data-stu-id="6e8f5-226">99.95%</span></span> |<span data-ttu-id="6e8f5-227">5분</span><span class="sxs-lookup"><span data-stu-id="6e8f5-227">5 minutes</span></span> |<span data-ttu-id="6e8f5-228">21.6분</span><span class="sxs-lookup"><span data-stu-id="6e8f5-228">21.6 minutes</span></span> |<span data-ttu-id="6e8f5-229">4.38시간</span><span class="sxs-lookup"><span data-stu-id="6e8f5-229">4.38 hours</span></span> |
| <span data-ttu-id="6e8f5-230">99.99%</span><span class="sxs-lookup"><span data-stu-id="6e8f5-230">99.99%</span></span> |<span data-ttu-id="6e8f5-231">1.01분</span><span class="sxs-lookup"><span data-stu-id="6e8f5-231">1.01 minutes</span></span> |<span data-ttu-id="6e8f5-232">4.32분</span><span class="sxs-lookup"><span data-stu-id="6e8f5-232">4.32 minutes</span></span> |<span data-ttu-id="6e8f5-233">52.56분</span><span class="sxs-lookup"><span data-stu-id="6e8f5-233">52.56 minutes</span></span> |
| <span data-ttu-id="6e8f5-234">99.999%</span><span class="sxs-lookup"><span data-stu-id="6e8f5-234">99.999%</span></span> |<span data-ttu-id="6e8f5-235">6초</span><span class="sxs-lookup"><span data-stu-id="6e8f5-235">6 seconds</span></span> |<span data-ttu-id="6e8f5-236">25.9초</span><span class="sxs-lookup"><span data-stu-id="6e8f5-236">25.9 seconds</span></span> |<span data-ttu-id="6e8f5-237">5.26분</span><span class="sxs-lookup"><span data-stu-id="6e8f5-237">5.26 minutes</span></span> |

<span data-ttu-id="6e8f5-238">다른 요소가 전부 동일하다면 당연히 가용성이 높을수록 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-238">Of course, higher availability is better, everything else being equal.</span></span> <span data-ttu-id="6e8f5-239">그러나 9의 수를 늘리려면 그에 따른 비용과 복잡성도 함께 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-239">But as you strive for more 9s, the cost and complexity to achieve that level of availability grows.</span></span> <span data-ttu-id="6e8f5-240">작동 시간이 99.99%이면 총 월간 가동 중지 시간이 약 5분입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-240">An uptime of 99.99% translates to about 5 minutes of total downtime per month.</span></span> <span data-ttu-id="6e8f5-241">99.999%를 달성하기 위해 추가적인 복잡성과 비용을 감수할 가치가 있습니까?</span><span class="sxs-lookup"><span data-stu-id="6e8f5-241">Is it worth the additional complexity and cost to reach five 9s?</span></span> <span data-ttu-id="6e8f5-242">대답은 비즈니스 요구 사항에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-242">The answer depends on the business requirements.</span></span>

<span data-ttu-id="6e8f5-243">다음은 SLA를 정의할 때 고려해야 할 다른 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-243">Here are some other considerations when defining an SLA:</span></span>

- <span data-ttu-id="6e8f5-244">4개의 9(99.99%)를 달성하려면 아마도 수동 개입에 의존한 오류 복구로는 불가능할 것입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-244">To achieve four 9's (99.99%), you probably can't rely on manual intervention to recover from failures.</span></span> <span data-ttu-id="6e8f5-245">애플리케이션이 자체적으로 진단하고 자체적으로 복구해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-245">The application must be self-diagnosing and self-healing.</span></span>
- <span data-ttu-id="6e8f5-246">9의 수가 4개를 넘어가면 SLA를 충족할 만큼 신속하게 가동 중단을 감지하기가 쉽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-246">Beyond four 9's, it is challenging to detect outages quickly enough to meet the SLA.</span></span>
- <span data-ttu-id="6e8f5-247">SLA가 측정되는 시간을 생각해 보세요.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-247">Think about the time window that your SLA is measured against.</span></span> <span data-ttu-id="6e8f5-248">시간이 짧을수록 허용 오차도 작습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-248">The smaller the window, the tighter the tolerances.</span></span> <span data-ttu-id="6e8f5-249">SLA를 시간별 또는 일별 작동 시간으로 정의할 수가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-249">It probably doesn't make sense to define your SLA in terms of hourly or daily uptime.</span></span>
- <span data-ttu-id="6e8f5-250">MTBF 및 MTTR 측정값을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-250">Consider the MTBF and MTTR measurements.</span></span> <span data-ttu-id="6e8f5-251">SLA가 낮을수록 서비스가 중단되는 횟수가 줄어들 수 있으며, 서비스를 더 빠르게 복구해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-251">The lower your SLA, the less frequently the service can go down, and the quicker the service must recover.</span></span>

### <a name="composite-slas"></a><span data-ttu-id="6e8f5-252">복합 SLA</span><span class="sxs-lookup"><span data-stu-id="6e8f5-252">Composite SLAs</span></span>

<span data-ttu-id="6e8f5-253">Azure SQL Database에 쓰는 App Service 웹앱을 고려해 보세요.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-253">Consider an App Service web app that writes to Azure SQL Database.</span></span> <span data-ttu-id="6e8f5-254">이 문서가 작성된 시점에 이러한 Azure 서비스의 SLA는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-254">At the time of this writing, these Azure services have the following SLAs:</span></span>

- <span data-ttu-id="6e8f5-255">App Service Web Apps = 99.95%</span><span class="sxs-lookup"><span data-stu-id="6e8f5-255">App Service Web Apps = 99.95%</span></span>
- <span data-ttu-id="6e8f5-256">SQL Database = 99.99%</span><span class="sxs-lookup"><span data-stu-id="6e8f5-256">SQL Database = 99.99%</span></span>

![복합 SLA](./images/sla1.png)

<span data-ttu-id="6e8f5-258">이 애플리케이션에 기대하는 최대 가동 중지 시간이 얼마입니까?</span><span class="sxs-lookup"><span data-stu-id="6e8f5-258">What is the maximum downtime you would expect for this application?</span></span> <span data-ttu-id="6e8f5-259">서비스 중 하나가 중단되면 전체 애플리케이션이 중단됩니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-259">If either service fails, the whole application fails.</span></span> <span data-ttu-id="6e8f5-260">일반적으로 각 서비스가 중단될 확률은 독립적이므로 이 애플리케이션의 복합 SLA는 99.95% &times; 99.99% = 99.94%입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-260">In general, the probability of each service failing is independent, so the composite SLA for this application is 99.95% &times; 99.99% = 99.94%.</span></span> <span data-ttu-id="6e8f5-261">개별 SLA보다 낮은데, 별로 놀랄 일은 아닙니다. 여러 서비스를 사용하는 애플리케이션은 잠재적 오류 지점이 더 많기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-261">That's lower than the individual SLAs, which isn't surprising, because an application that relies on multiple services has more potential failure points.</span></span>

<span data-ttu-id="6e8f5-262">반면, 독립적인 대체 경로를 만들어서 복합 SLA를 높일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-262">On the other hand, you can improve the composite SLA by creating independent fallback paths.</span></span> <span data-ttu-id="6e8f5-263">예를 들어 SQL Database를 사용할 수 없으면 트랜잭션을 큐에 배치하여 나중에 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-263">For example, if SQL Database is unavailable, put transactions into a queue, to be processed later.</span></span>

![복합 SLA](./images/sla2.png)

<span data-ttu-id="6e8f5-265">이 디자인에서는 애플리케이션이 데이터베이스에 연결할 수 없는 경우에도 계속 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-265">With this design, the application is still available even if it can't connect to the database.</span></span> <span data-ttu-id="6e8f5-266">그러나 데이터베이스와 큐가 동시에 중단되면 응용 프로그램도 중단됩니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-266">However, it fails if the database and the queue both fail at the same time.</span></span> <span data-ttu-id="6e8f5-267">예상되는 동시 중단 시간 비율은 0.0001 &times; 0.001이므로 이 복합 경로의 복합 SLA는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-267">The expected percentage of time for a simultaneous failure is 0.0001 &times; 0.001, so the composite SLA for this combined path is:</span></span>  

- <span data-ttu-id="6e8f5-268">데이터베이스 또는 큐 = 1.0 &minus; (0.0001 &times; 0.001) = 99.99999%</span><span class="sxs-lookup"><span data-stu-id="6e8f5-268">Database OR queue = 1.0 &minus; (0.0001 &times; 0.001) = 99.99999%</span></span>

<span data-ttu-id="6e8f5-269">총 복합 SLA는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-269">The total composite SLA is:</span></span>

- <span data-ttu-id="6e8f5-270">웹앱 및 (데이터베이스 또는 큐) = 99.95% &times; 99.99999% = ~99.95%</span><span class="sxs-lookup"><span data-stu-id="6e8f5-270">Web app AND (database OR queue) = 99.95% &times; 99.99999% = ~99.95%</span></span>

<span data-ttu-id="6e8f5-271">하지만 이 방법에는 단점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-271">But there are tradeoffs to this approach.</span></span> <span data-ttu-id="6e8f5-272">애플리케이션 논리가 더 복잡하고 큐에 대한 비용을 지불해야 하며, 데이터 일관성 문제를 고려해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-272">The application logic is more complex, you are paying for the queue, and there may be data consistency issues to consider.</span></span>

<span data-ttu-id="6e8f5-273">**다중 지역 배포의 SLA**.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-273">**SLA for multi-region deployments**.</span></span> <span data-ttu-id="6e8f5-274">또 다른 HA 기술은 여러 지역에 애플리케이션을 배포 하고, 한 지역의 애플리케이션에 오류가 발생하면 Azure Traffic Manager를 사용하여 장애 조치(failover)하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-274">Another HA technique is to deploy the application in more than one region, and use Azure Traffic Manager to fail over if the application fails in one region.</span></span> <span data-ttu-id="6e8f5-275">다중 지역 배포의 경우 복합 SLA는 다음과 같이 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-275">For a multi-region deployment, the composite SLA is calculated as follows.</span></span>

<span data-ttu-id="6e8f5-276">한 지역에 배포된 애플리케이션의 복합 SLA를 *N*, 애플리케이션이 배포된 지역 수를 *R*이라 하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-276">Let *N* be the composite SLA for the application deployed in one region, and *R* be the number of regions where the application is deployed.</span></span> <span data-ttu-id="6e8f5-277">모든 지역의 애플리케이션이 동시에 중단될 확률은 ((1 &minus; N) ^ R)입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-277">The expected chance that the application will fail in all regions at the same time is ((1 &minus; N) ^ R).</span></span>

<span data-ttu-id="6e8f5-278">예를 들어 단일 지역 SLA가 99.95%이면,</span><span class="sxs-lookup"><span data-stu-id="6e8f5-278">For example, if the single-region SLA is 99.95%,</span></span>

- <span data-ttu-id="6e8f5-279">두 지역의 결합 SLA는 (1 &minus; (0.9995 ^ 2)) = 99.999975%</span><span class="sxs-lookup"><span data-stu-id="6e8f5-279">The combined SLA for two regions = (1 &minus; (0.9995 ^ 2)) = 99.999975%</span></span>
- <span data-ttu-id="6e8f5-280">네 지역의 결합 SLA는 (1 &minus; (0.9995 ^ 4)) = 99.999999%</span><span class="sxs-lookup"><span data-stu-id="6e8f5-280">The combined SLA for four regions = (1 &minus; (0.9995 ^ 4)) = 99.999999%</span></span>

<span data-ttu-id="6e8f5-281">[Traffic Manager SLA][tm-sla]도 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-281">You must also factor in the [SLA for Traffic Manager][tm-sla].</span></span> <span data-ttu-id="6e8f5-282">이 문서가 작성된 시점의 Traffic Manager SLA는 99.99%입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-282">At the time of this writing, the SLA for Traffic Manager SLA is 99.99%.</span></span>

<span data-ttu-id="6e8f5-283">또한 활성-수동 구성에서는 장애 조치(failover)가 즉시 이루어지는 것이 아니기 때문에 장애 조치(failover) 중에 약간의 가동 중지 시간이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-283">Also, failing over is not instantaneous in active-passive configurations, which can result in some downtime during a failover.</span></span> <span data-ttu-id="6e8f5-284">자세한 내용은 [Traffic Manager 엔드포인트 모니터링 및 장애 조치(failover)][tm-failover]를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-284">See [Traffic Manager endpoint monitoring and failover][tm-failover].</span></span>

<span data-ttu-id="6e8f5-285">계산된 SLA 숫자는 유용한 기본 자료이지만 가용성에 대한 전반적인 성능을 알려주지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-285">The calculated SLA number is a useful baseline, but it doesn't tell the whole story about availability.</span></span> <span data-ttu-id="6e8f5-286">종종 중요하지 않은 경로에 오류가 발생할 때 애플리케이션 성능이 정상적으로 저하될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-286">Often, an application can degrade gracefully when a non-critical path fails.</span></span> <span data-ttu-id="6e8f5-287">책 카탈로그를 표시하는 애플리케이션을 생각해 보세요.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-287">Consider an application that shows a catalog of books.</span></span> <span data-ttu-id="6e8f5-288">이 애플리케이션은 표지의 썸네일 이미지를 검색할 수 없으면 자리 표시자 이미지를 표시할 것입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-288">If the application can't retrieve the thumbnail image for the cover, it might show a placeholder image.</span></span> <span data-ttu-id="6e8f5-289">이 경우, 이미지를 가져오지 못해도 사용자 경험에는 영향을 주지만 애플리케이션의 작동 시간에는 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-289">In that case, failing to get the image does not reduce the application's uptime, although it affects the user experience.</span></span>  

## <a name="design-for-resiliency"></a><span data-ttu-id="6e8f5-290">복원력을 위한 디자인</span><span class="sxs-lookup"><span data-stu-id="6e8f5-290">Design for resiliency</span></span>

<span data-ttu-id="6e8f5-291">디자인 단계에서 FMA(오류 모드 분석)를 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-291">During the design phase, you should perform a failure mode analysis (FMA).</span></span> <span data-ttu-id="6e8f5-292">FMA의 목표는 가능한 실패 지점을 식별하고 애플리케이션이 이러한 오류에 대응하는 방식을 정의하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-292">The goal of an FMA is to identify possible points of failure, and define how the application will respond to those failures.</span></span>

- <span data-ttu-id="6e8f5-293">애플리케이션이 이러한 종류의 오류를 어떻게 감지하나요?</span><span class="sxs-lookup"><span data-stu-id="6e8f5-293">How will the application detect this type of failure?</span></span>
- <span data-ttu-id="6e8f5-294">애플리케이션이 이러한 종류의 오류에 어떻게 대응하나요?</span><span class="sxs-lookup"><span data-stu-id="6e8f5-294">How will the application respond to this type of failure?</span></span>
- <span data-ttu-id="6e8f5-295">이러한 종류의 오류를 어떻게 로깅하고 모니터링하나요?</span><span class="sxs-lookup"><span data-stu-id="6e8f5-295">How will you log and monitor this type of failure?</span></span>

<span data-ttu-id="6e8f5-296">Azure에 대한 구체적인 추천을 비롯한 FMA 프로세스에 대한 자세한 내용은 [Azure 복원력 지침: 실패 모드 분석][fma]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-296">For more information about the FMA process, with specific recommendations for Azure, see [Azure resiliency guidance: Failure mode analysis][fma].</span></span>

### <a name="example-of-identifying-failure-modes-and-detection-strategy"></a><span data-ttu-id="6e8f5-297">오류 모드 식별 및 감지 전략의 예</span><span class="sxs-lookup"><span data-stu-id="6e8f5-297">Example of identifying failure modes and detection strategy</span></span>

<span data-ttu-id="6e8f5-298">**실패 지점:** 외부 웹 서비스/API에 대한 호출입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-298">**Failure point:** Call to an external web service / API.</span></span>

| <span data-ttu-id="6e8f5-299">오류 모드</span><span class="sxs-lookup"><span data-stu-id="6e8f5-299">Failure mode</span></span> | <span data-ttu-id="6e8f5-300">감지 전략</span><span class="sxs-lookup"><span data-stu-id="6e8f5-300">Detection strategy</span></span> |
| --- | --- |
| <span data-ttu-id="6e8f5-301">서비스를 사용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="6e8f5-301">Service is unavailable</span></span> |<span data-ttu-id="6e8f5-302">HTTP 5xx</span><span class="sxs-lookup"><span data-stu-id="6e8f5-302">HTTP 5xx</span></span> |
| <span data-ttu-id="6e8f5-303">제한</span><span class="sxs-lookup"><span data-stu-id="6e8f5-303">Throttling</span></span> |<span data-ttu-id="6e8f5-304">HTTP 429(요청이 너무 많음)</span><span class="sxs-lookup"><span data-stu-id="6e8f5-304">HTTP 429 (Too Many Requests)</span></span> |
| <span data-ttu-id="6e8f5-305">Authentication</span><span class="sxs-lookup"><span data-stu-id="6e8f5-305">Authentication</span></span> |<span data-ttu-id="6e8f5-306">HTTP 401(권한 없음)</span><span class="sxs-lookup"><span data-stu-id="6e8f5-306">HTTP 401 (Unauthorized)</span></span> |
| <span data-ttu-id="6e8f5-307">느린 응답 시간</span><span class="sxs-lookup"><span data-stu-id="6e8f5-307">Slow response</span></span> |<span data-ttu-id="6e8f5-308">요청 시간 초과</span><span class="sxs-lookup"><span data-stu-id="6e8f5-308">Request times out</span></span> |

### <a name="redundancy-and-designing-for-failure"></a><span data-ttu-id="6e8f5-309">오류에 대한 중복성 및 디자인</span><span class="sxs-lookup"><span data-stu-id="6e8f5-309">Redundancy and designing for failure</span></span>

<span data-ttu-id="6e8f5-310">오류는 해당 영향의 범위가 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-310">Failures can vary in the scope of their impact.</span></span> <span data-ttu-id="6e8f5-311">실패한 디스크와 같은 일부 하드웨어 오류는 단일 호스트 컴퓨터에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-311">Some hardware failures, such as a failed disk, may affect a single host machine.</span></span> <span data-ttu-id="6e8f5-312">실패한 네트워크 스위치는 전체 서버 랙에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-312">A failed network switch could affect a whole server rack.</span></span> <span data-ttu-id="6e8f5-313">데이터 센터의 전원 손실 등 전체 데이터 센터를 방해하는 오류는 일반적이지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-313">Less common are failures that disrupt a whole datacenter, such as loss of power in a datacenter.</span></span> <span data-ttu-id="6e8f5-314">가끔 전체 지역을 사용할 수 없게 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-314">Rarely, an entire region could become unavailable.</span></span>

<span data-ttu-id="6e8f5-315">중복성을 통해 애플리케이션을 복원력 있게 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-315">One of the main ways to make an application resilient is through redundancy.</span></span> <span data-ttu-id="6e8f5-316">그러나 애플리케이션을 디자인할 때 이러한 중복성에 대해 계획해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-316">But you need to plan for this redundancy when you design the application.</span></span> <span data-ttu-id="6e8f5-317">또한 필요한 중복성 수준은 비즈니스 요구 사항에 따라 달라집니다. &mdash; 지역 가동 중단으로부터 보호하기 위해 일부 애플리케이션에 지역 간 중복성이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-317">Also, the level of redundancy that you need depends on your business requirements &mdash; not every application needs redundancy across regions to guard against a regional outage.</span></span> <span data-ttu-id="6e8f5-318">일반적으로 중복성과 안정성 및 비용과 복잡성 간에 균형을 조절해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-318">In general, there is a tradeoff between greater redundancy and reliability versus higher cost and complexity.</span></span>  

<span data-ttu-id="6e8f5-319">Azure에는 개별 VM에서 전체 영역에 이르는 모든 오류 수준에서 애플리케이션이 중복되는 여러 기능이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-319">Azure has a number of features to make an application redundant at every level of failure, from an individual VM to an entire region.</span></span>

![Azure 복원력 기능](./images/redundancy.svg)

<span data-ttu-id="6e8f5-321">**단일 VM**</span><span class="sxs-lookup"><span data-stu-id="6e8f5-321">**Single VM**.</span></span> <span data-ttu-id="6e8f5-322">Azure에서는 단일 VM에 [작동 시간 SLA](https://azure.microsoft.com/support/legal/sla/virtual-machines)를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-322">Azure provides an [uptime SLA](https://azure.microsoft.com/support/legal/sla/virtual-machines) for single VMs.</span></span> <span data-ttu-id="6e8f5-323">(VM은 모든 운영 체제 디스크 및 데이터 디스크에 프리미엄 스토리지를 사용해야 합니다.) 둘 이상의 VM을 실행하여 SLA를 높일 수 있지만 단일 VM은 일부 워크로드에서 충분히 안정적일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-323">(The VM must use premium storage for all Operating System Disks and Data Disks.) Although you can get a higher SLA by running two or more VMs, a single VM may be reliable enough for some workloads.</span></span> <span data-ttu-id="6e8f5-324">그러나 프로덕션 워크로드의 경우 중복성을 위해 둘 이상의 VM을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-324">For production workloads, however, we recommend using two or more VMs for redundancy.</span></span>

<span data-ttu-id="6e8f5-325">**가용성 집합**.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-325">**Availability sets**.</span></span> <span data-ttu-id="6e8f5-326">디스크 또는 네트워크 전환이 실패한 경우 하드웨어 오류로부터 보호하려면 가용성 집합에 둘 이상의 VM을 배포합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-326">To protect against localized hardware failures, such as a disk or network switch failing, deploy two or more VMs in an availability set.</span></span> <span data-ttu-id="6e8f5-327">가용성 집합은 공통 전원 소스 및 네트워크 스위치를 공유하는 두 개 이상의 *장애 도메인*으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-327">An availability set consists of two or more *fault domains* that share a common power source and network switch.</span></span> <span data-ttu-id="6e8f5-328">가용성 집합의 VM은 장애 도메인에 분산되어 있으므로 하드웨어 오류가 하나의 장애 도메인에 영향을 주는 경우 네트워크 트래픽은 다른 오류 도메인에서 VM을 라우팅할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-328">VMs in an availability set are distributed across the fault domains, so if a hardware failure affects one fault domain, network traffic can still be routed the VMs in the other fault domains.</span></span> <span data-ttu-id="6e8f5-329">가용성 집합에 대한 자세한 내용은 [Azure에서 Windows 가상 머신의 가용성 관리](/azure/virtual-machines/windows/manage-availability)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-329">For more information about Availability Sets, see [Manage the availability of Windows virtual machines in Azure](/azure/virtual-machines/windows/manage-availability).</span></span>

<span data-ttu-id="6e8f5-330">**가용성 영역**.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-330">**Availability zones**.</span></span>  <span data-ttu-id="6e8f5-331">가용성 영역은 Azure 지역 내에서 물리적으로 별도 영역입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-331">An Availability Zone is a physically separate zone within an Azure region.</span></span> <span data-ttu-id="6e8f5-332">각 가용성 영역에는 고유한 소스, 네트워크 및 냉각 장치가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-332">Each Availability Zone has a distinct power source, network, and cooling.</span></span> <span data-ttu-id="6e8f5-333">가용성 영역 간에 VM을 배포하면 데이터 센터 전체의 오류로부터 애플리케이션을 보호할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-333">Deploying VMs across availability zones helps to protect an application against datacenter-wide failures.</span></span> <span data-ttu-id="6e8f5-334">모든 Azure 지역에서 가용성 영역을 지원하는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-334">Not all regions support Availability Zones.</span></span> <span data-ttu-id="6e8f5-335">지원되는 Azure 지역 및 서비스 목록은 [Azure에서 가용성 영역이란?](/azure/availability-zones/az-overview)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-335">For a list of supported regions and services, see [What are Availability Zones in Azure?](/azure/availability-zones/az-overview).</span></span>

<span data-ttu-id="6e8f5-336">배포에서 가용성 영역을 사용하려면 먼저 애플리케이션 아키텍처와 코드 베이스가 이 구성을 지원할 수 있는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-336">If you are planning to use Availability Zones in your deployment, first validate that your application architecture and code base can support this configuration.</span></span> <span data-ttu-id="6e8f5-337">COTS 소프트웨어를 배포하려는 경우 소프트웨어 공급업체에 문의하여 프로덕션 환경에 배포하기 전에 적절한 테스트를 수행하세요.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-337">If you are deploying commercial off-the-shelf software, consult with the software vendor and test adequately before deploying into production.</span></span> <span data-ttu-id="6e8f5-338">구성된 영역 내에서 중단이 발생하는 동안 애플리케이션이 상태를 유지하고 데이터 손실을 방지할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-338">An application must be able to maintain state and prevent loss of data during an outage within the configured zone.</span></span> <span data-ttu-id="6e8f5-339">코드 베이스에 지정된 하드 코드된 인프라 구성 요소가 없는 탄력적인 분산 인프라에서 애플리케이션을 실행할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-339">The application must support running in an elastic and distributed infrastructure with no hard-coded infrastructure components specified in the code base.</span></span>

<span data-ttu-id="6e8f5-340">**Azure Site Recovery**</span><span class="sxs-lookup"><span data-stu-id="6e8f5-340">**Azure Site Recovery**.</span></span>  <span data-ttu-id="6e8f5-341">비즈니스 연속성 및 재해 복구 요구 사항을 위해 다른 Azure 지역에 Azure Virtual Machines를 복제합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-341">Replicate Azure virtual machines to another Azure region for business continuity and disaster recovery needs.</span></span> <span data-ttu-id="6e8f5-342">규정 준수 요구 사항을 충족하도록 정기적인 DR 훈련을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-342">You can conduct periodic DR drills to ensure you meet the compliance needs.</span></span> <span data-ttu-id="6e8f5-343">VM은 원본 지역에서 중단이 발생한 경우 애플리케이션을 복구할 수 있도록 선택한 지역에 지정된 설정을 사용하여 복제됩니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-343">The VM will be replicated with the specified settings to the selected region so that you can recover your applications in the event of outages in the source region.</span></span> <span data-ttu-id="6e8f5-344">자세한 내용은 [ASR을 사용하여 Azure VM 복제][site-recovery]를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-344">For more information, see [Replicate Azure VMs using ASR][site-recovery].</span></span> <span data-ttu-id="6e8f5-345">여기서 솔루션의 RTO 및 RPO를 고려하고, 테스트할 때 복구 시간 및 복구 지점이 요구 사항에 적합한지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-345">Consider the RTO and RPO numbers for your solution here and ensure that when testing, the recovery time and recovery point is appropriate for your needs.</span></span>

<span data-ttu-id="6e8f5-346">**쌍을 이루는 지역**</span><span class="sxs-lookup"><span data-stu-id="6e8f5-346">**Paired regions**.</span></span> <span data-ttu-id="6e8f5-347">지역 가동 중단으로부터 애플리케이션을 보호하려면 인터넷 트래픽을 서로 다른 지역에 배포하기 위해 Azure Traffic Manager를 사용하여 애플리케이션을 여러 지역에 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-347">To protect an application against a regional outage, you can deploy the application across multiple regions, using Azure Traffic Manager to distribute internet traffic to the different regions.</span></span> <span data-ttu-id="6e8f5-348">각 Azure 지역은 다른 지역과 쌍을 이룹니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-348">Each Azure region is paired with another region.</span></span> <span data-ttu-id="6e8f5-349">이러한 지역은 함께 [지역 쌍](/azure/best-practices-availability-paired-regions)을 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-349">Together, these form a [regional pair](/azure/best-practices-availability-paired-regions).</span></span> <span data-ttu-id="6e8f5-350">브라질 남부를 제외하고 지역 쌍은 세금 및 법률 집행 관할 구역의 데이터 상주 요구 사항을 충족하기 위해 동일한 지리적 위치 내에 위치합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-350">With the exception of Brazil South, regional pairs are located within the same geography in order to meet data residency requirements for tax and law enforcement jurisdiction purposes.</span></span>

<span data-ttu-id="6e8f5-351">다중 지역 애플리케이션을 디자인할 때 지역 간 네트워크 대기 시간이 지역 내 네트워크 대기 시간보다 길다는 점을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-351">When you design a multi-region application, take into account that network latency across regions is higher than within a region.</span></span> <span data-ttu-id="6e8f5-352">예를 들어 장애 조치할 수 있도록 데이터베이스를 복제하는 경우 지역 간의 비동기 데이터 복제가 아니라 지역 내의 동기 데이터 복제를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-352">For example, if you are replicating a database to enable failover, use synchronous data replication within a region, but asynchronous data replication across regions.</span></span>

<span data-ttu-id="6e8f5-353">쌍을 이루는 지역을 선택할 때는 두 지역 모두에 Azure 서비스가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-353">When you select paired regions, ensure both regions have required Azure services.</span></span> <span data-ttu-id="6e8f5-354">지역별 서비스 목록은 [지역별 사용 가능한 제품](https://azure.microsoft.com/global-infrastructure/services/)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-354">For a list of services by region, see [Products available by region](https://azure.microsoft.com/global-infrastructure/services/).</span></span> <span data-ttu-id="6e8f5-355">또한 재난 복구에 적합한 배포 토폴로지를 선택하는 것이 중요하며, RPO/RTO가 부족한 경우에는 특히 그렇습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-355">It's also critical to select the right deployment topology for disaster recovery, especially if your RPO/RTO are short.</span></span> <span data-ttu-id="6e8f5-356">장애 조치(failover) 지역에 워크로드를 지원하기에 충분한 용량을 확보하려면 활성/수동(전체 복제본) 토폴로지 또는 활성/활성 토폴로지 중 하나를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-356">To ensure the failover region has enough capacity to support your workload, select either an active/passive (full replica) topology or an active/active topology.</span></span> <span data-ttu-id="6e8f5-357">이러한 배포 토폴로지는 복잡성과 비용을 증가시킬 수 있습니다. 보조 지역의 리소스가 미리 프로비저닝되어 유휴 상태로 유지될 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-357">Keep in mind these deployment topologies might increase complexity and cost as resources in the secondary region are pre-provisioned and may sit idle.</span></span> <span data-ttu-id="6e8f5-358">자세한 내용은 [재해 복구를 위한 배포 토폴로지][deployment-topologies]를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-358">For more information, see [Deployment topologies for disaster recovery][deployment-topologies]</span></span>

| &nbsp; | <span data-ttu-id="6e8f5-359">가용성 집합</span><span class="sxs-lookup"><span data-stu-id="6e8f5-359">Availability Set</span></span> | <span data-ttu-id="6e8f5-360">가용성 영역</span><span class="sxs-lookup"><span data-stu-id="6e8f5-360">Availability Zone</span></span> | <span data-ttu-id="6e8f5-361">Azure Site Recovery/페어링된 지역</span><span class="sxs-lookup"><span data-stu-id="6e8f5-361">Azure Site Recovery/Paired region</span></span> |
|--------|------------------|-------------------|---------------|
| <span data-ttu-id="6e8f5-362">오류의 범위</span><span class="sxs-lookup"><span data-stu-id="6e8f5-362">Scope of failure</span></span> | <span data-ttu-id="6e8f5-363">랙</span><span class="sxs-lookup"><span data-stu-id="6e8f5-363">Rack</span></span> | <span data-ttu-id="6e8f5-364">데이터 센터</span><span class="sxs-lookup"><span data-stu-id="6e8f5-364">Datacenter</span></span> | <span data-ttu-id="6e8f5-365">지역</span><span class="sxs-lookup"><span data-stu-id="6e8f5-365">Region</span></span> |
| <span data-ttu-id="6e8f5-366">요청 라우팅</span><span class="sxs-lookup"><span data-stu-id="6e8f5-366">Request routing</span></span> | <span data-ttu-id="6e8f5-367">Load Balancer</span><span class="sxs-lookup"><span data-stu-id="6e8f5-367">Load Balancer</span></span> | <span data-ttu-id="6e8f5-368">영역 간 부하 분산 장치</span><span class="sxs-lookup"><span data-stu-id="6e8f5-368">Cross-zone Load Balancer</span></span> | <span data-ttu-id="6e8f5-369">Traffic Manager</span><span class="sxs-lookup"><span data-stu-id="6e8f5-369">Traffic Manager</span></span> |
| <span data-ttu-id="6e8f5-370">네트워크 대기 시간</span><span class="sxs-lookup"><span data-stu-id="6e8f5-370">Network latency</span></span> | <span data-ttu-id="6e8f5-371">매우 낮음</span><span class="sxs-lookup"><span data-stu-id="6e8f5-371">Very low</span></span> | <span data-ttu-id="6e8f5-372">낮음</span><span class="sxs-lookup"><span data-stu-id="6e8f5-372">Low</span></span> | <span data-ttu-id="6e8f5-373">중간부터 높음</span><span class="sxs-lookup"><span data-stu-id="6e8f5-373">Mid to high</span></span> |
| <span data-ttu-id="6e8f5-374">가상 네트워크</span><span class="sxs-lookup"><span data-stu-id="6e8f5-374">Virtual network</span></span>  | <span data-ttu-id="6e8f5-375">VNet</span><span class="sxs-lookup"><span data-stu-id="6e8f5-375">VNet</span></span> | <span data-ttu-id="6e8f5-376">VNet</span><span class="sxs-lookup"><span data-stu-id="6e8f5-376">VNet</span></span> | <span data-ttu-id="6e8f5-377">지역 간 VNet 피어링</span><span class="sxs-lookup"><span data-stu-id="6e8f5-377">Cross-region VNet peering</span></span> |

## <a name="implement-resiliency-strategies"></a><span data-ttu-id="6e8f5-378">복원력 전략 구현</span><span class="sxs-lookup"><span data-stu-id="6e8f5-378">Implement resiliency strategies</span></span>

<span data-ttu-id="6e8f5-379">이 섹션에서는 몇 가지 일반적인 복원력 전략에 대한 설문 조사를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-379">This section provides a survey of some common resiliency strategies.</span></span> <span data-ttu-id="6e8f5-380">이들 중 대부분은 특정 기술에 제한되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-380">Most of these are not limited to a particular technology.</span></span> <span data-ttu-id="6e8f5-381">이 섹션에서는 각 기술의 밑바탕에 깔려 있는 일반적인 개념을 설명하고 추가 정보에 대한 링크를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-381">The descriptions in this section summarize the general idea behind each technique, with links to further reading.</span></span>

<span data-ttu-id="6e8f5-382">**일시적인 오류 다시 시도**.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-382">**Retry transient failures**.</span></span> <span data-ttu-id="6e8f5-383">서비스 사용량이 많을 때 일시적인 네트워크 연결 해제, 데이터베이스 연결 끊김 또는 시간 제한으로 인해 일시적 오류가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-383">Transient failures can be caused by momentary loss of network connectivity, a dropped database connection, or a timeout when a service is busy.</span></span> <span data-ttu-id="6e8f5-384">일시적인 오류는 요청을 다시 시도하면 해결되는 경우가 자주 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-384">Often, a transient failure can be resolved simply by retrying the request.</span></span> <span data-ttu-id="6e8f5-385">여러 Azure 서비스의 경우 클라이언트 SDK는 호출자에게 투명한 방식으로 자동 다시 시도를 구현합니다. 자세한 내용은 [다시 시도 서비스별 지침][retry-service-specific guidance]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-385">For many Azure services, the client SDK implements automatic retries, in a way that is transparent to the caller; see [Retry service specific guidance][retry-service-specific guidance].</span></span>

<span data-ttu-id="6e8f5-386">각 다시 시도는 총 대기 시간에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-386">Each retry attempt adds to the total latency.</span></span> <span data-ttu-id="6e8f5-387">또한 실패한 요청 수가 너무 많으면 보류 중인 요청이 큐에 누적되어 병목 상태가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-387">Also, too many failed requests can cause a bottleneck, as pending requests accumulate in the queue.</span></span> <span data-ttu-id="6e8f5-388">이처럼 차단된 요청이 메모리, 스레드, 데이터베이스 연결 등의 중요한 시스템 리소스를 계속 잡아 두어 연속 오류를 일으킬 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-388">These blocked requests might hold critical system resources such as memory, threads, database connections, and so on, which can cause cascading failures.</span></span> <span data-ttu-id="6e8f5-389">이 문제를 방지하려면 각 다시 시도 사이의 지연 시간을 늘리고 총 실패한 요청 수를 제한하세요.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-389">To avoid this, increase the delay between each retry attempt, and limit the total number of failed requests.</span></span>

![재시도 횟수의 다이어그램](./images/retry.png)

<span data-ttu-id="6e8f5-391">**인스턴스 간에 부하 분산**.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-391">**Load balance across instances**.</span></span> <span data-ttu-id="6e8f5-392">확장성을 위해 클라우드 애플리케이션은 인스턴스를 추가하여 규모 확장할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-392">For scalability, a cloud application should be able to scale out by adding more instances.</span></span> <span data-ttu-id="6e8f5-393">이 방법은 회전 대상에서 비정상 인스턴스를 제거할 수 있으므로 복원력도 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-393">This approach also improves resiliency, because unhealthy instances can be removed from rotation.</span></span> <span data-ttu-id="6e8f5-394">예: </span><span class="sxs-lookup"><span data-stu-id="6e8f5-394">For example:</span></span>

- <span data-ttu-id="6e8f5-395">부하 분산 장치 뒤에 둘 이상의 VM을 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-395">Put two or more VMs behind a load balancer.</span></span> <span data-ttu-id="6e8f5-396">부하 분산 장치는 모든 VM에 트래픽을 분산합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-396">The load balancer distributes traffic to all the VMs.</span></span> <span data-ttu-id="6e8f5-397">[부하가 분산된 VM을 실행하여 확장성 및 가용성 확보][ra-multi-vm]를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-397">See [Run load-balanced VMs for scalability and availability][ra-multi-vm].</span></span>
- <span data-ttu-id="6e8f5-398">Azure App Service 앱을 여러 인스턴스로 규모 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-398">Scale out an Azure App Service app to multiple instances.</span></span> <span data-ttu-id="6e8f5-399">App Service는 자동으로 인스턴스 간에 부하를 분산합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-399">App Service automatically balances load across instances.</span></span> <span data-ttu-id="6e8f5-400">[기본 웹 애플리케이션][ra-basic-web]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-400">See [Basic web application][ra-basic-web].</span></span>
- <span data-ttu-id="6e8f5-401">[Azure Traffic Manager][tm]를 사용하여 엔드포인트 집합에 트래픽을 분산합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-401">Use [Azure Traffic Manager][tm] to distribute traffic across a set of endpoints.</span></span>

<span data-ttu-id="6e8f5-402">**데이터 복제**.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-402">**Replicate data**.</span></span> <span data-ttu-id="6e8f5-403">데이터 복제는 데이터 저장소의 일시적이지 않은 오류를 처리하는 일반적인 전략입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-403">Replicating data is a general strategy for handling non-transient failures in a data store.</span></span> <span data-ttu-id="6e8f5-404">Azure Storage, Azure SQL Database, Cosmos DB, Apache Cassandra를 비롯한 여러 스토리지 기술은 기본적으로 복제 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-404">Many storage technologies provide built-in replication, including Azure Storage, Azure SQL Database, Cosmos DB, and Apache Cassandra.</span></span> <span data-ttu-id="6e8f5-405">읽기 및 쓰기 경로를 모두 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-405">It's important to consider both the read and write paths.</span></span> <span data-ttu-id="6e8f5-406">저장소 기술에 따라 여러 개의 쓰기 가능한 복제본이 생길 수도 있고, 쓰기 가능한 복제본 하나와 읽기 전용 복제본 여러 개가 생길 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-406">Depending on the storage technology, you might have multiple writable replicas, or a single writable replica and multiple read-only replicas.</span></span>

<span data-ttu-id="6e8f5-407">가용성을 최대화하기 위해 복제본을 여러 영역에 배치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-407">To maximize availability, replicas can be placed in multiple regions.</span></span> <span data-ttu-id="6e8f5-408">그러나 데이터를 복제할 때 대기 시간이 증가하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-408">However, this increases the latency when replicating the data.</span></span> <span data-ttu-id="6e8f5-409">일반적으로 지역 간 복제는 비동기적으로 수행되며, 이는 복제본 오류가 발생할 경우 궁극적으로 일관성 모델 및 데이터 손실 가능성이 있다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-409">Typically, replicating across regions is done asynchronously, which implies an eventual consistency model and potential data loss if a replica fails.</span></span>

<span data-ttu-id="6e8f5-410">[Azure Site Recovery][site-recovery]를 사용하여 Azure 지역 간에 Azure Virtual Machines를 복제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-410">You can use [Azure Site Recovery][site-recovery] to replicate Azure virtual machines from one region to another region.</span></span> <span data-ttu-id="6e8f5-411">Site Recovery는 지속적으로 대상 지역에 데이터를 복제합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-411">Site Recovery replicates data continuously to the target region.</span></span> <span data-ttu-id="6e8f5-412">기본 사이트에서 중단이 발생하면 보조 위치로 장애 조치(failover)합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-412">When an outage occurs at your primary site, you fail over to secondary location</span></span>

<span data-ttu-id="6e8f5-413">**정상적으로 성능 저하**.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-413">**Degrade gracefully**.</span></span> <span data-ttu-id="6e8f5-414">서비스에 오류가 발생하고 장애 조치(failover) 경로가 없는 경우 애플리케이션이 정상적으로 성능을 내리고 계속해서 허용 가능한 수준의 사용자 환경을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-414">If a service fails and there is no failover path, the application may be able to degrade gracefully while still providing an acceptable user experience.</span></span> <span data-ttu-id="6e8f5-415">예: </span><span class="sxs-lookup"><span data-stu-id="6e8f5-415">For example:</span></span>

- <span data-ttu-id="6e8f5-416">나중에 처리하도록 작업 항목을 큐에 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-416">Put a work item on a queue, to be handled later.</span></span>
- <span data-ttu-id="6e8f5-417">예상 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-417">Return an estimated value.</span></span>
- <span data-ttu-id="6e8f5-418">로컬로 캐시된 데이터를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-418">Use locally cached data.</span></span>
- <span data-ttu-id="6e8f5-419">사용자에게 오류 메시지를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-419">Show the user an error message.</span></span> <span data-ttu-id="6e8f5-420">(요청에 대응하여 애플리케이션을 중지하는 것보다는 이 옵션이 낫습니다.)</span><span class="sxs-lookup"><span data-stu-id="6e8f5-420">(This option is better than having the application stop responding to requests.)</span></span>

<span data-ttu-id="6e8f5-421">**대규모 사용자 제한**.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-421">**Throttle high-volume users**.</span></span> <span data-ttu-id="6e8f5-422">소수의 사용자가 과도한 로드를 생성하는 경우가 가끔 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-422">Sometimes a small number of users create excessive load.</span></span> <span data-ttu-id="6e8f5-423">이 경우 애플리케이션의 가용성을 떨어트려 다른 사용자에게 영향을 줄 수입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-423">That can have an impact on other users, reducing the overall availability of your application.</span></span>

<span data-ttu-id="6e8f5-424">단일 클라이언트가 과도한 요청을 만드는 경우 애플리케이션에서 클라이언트를 일정 기간 동안 제한할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-424">When a single client makes an excessive number of requests, the application might throttle the client for a certain period of time.</span></span> <span data-ttu-id="6e8f5-425">제한 기간 동안 애플리케이션은 해당 클라이언트의 요청 중 일부 또는 전부를 거부합니다(정확한 제한 전략에 따라).</span><span class="sxs-lookup"><span data-stu-id="6e8f5-425">During the throttling period, the application refuses some or all of the requests from that client (depending on the exact throttling strategy).</span></span> <span data-ttu-id="6e8f5-426">제한의 임계값은 고객의 서비스 계층에 따라 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-426">The threshold for throttling might depend on the customer's service tier.</span></span>

<span data-ttu-id="6e8f5-427">제한은 반드시 클라이언트가 악의적으로 작동했다는 의미가 아니라 서비스 할당량을 초과한다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-427">Throttling does not imply the client was necessarily acting maliciously, only that it exceeded its service quota.</span></span> <span data-ttu-id="6e8f5-428">경우에 따라 소비자가 지속적으로 할당량을 초과하거나 악의적으로 행동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-428">In some cases, a consumer might consistently exceed their quota or otherwise behave badly.</span></span> <span data-ttu-id="6e8f5-429">이 경우 더 나아가서 해당 사용자를 차단할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-429">In that case, you might go further and block the user.</span></span> <span data-ttu-id="6e8f5-430">일반적으로 사용자 차단은 API 키 또는 IP 주소 범위를 차단하여 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-430">Typically, this is done by blocking an API key or an IP address range.</span></span> <span data-ttu-id="6e8f5-431">자세한 내용은 [제한 패턴][throttling-pattern]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-431">For more information, see [Throttling Pattern][throttling-pattern].</span></span>

<span data-ttu-id="6e8f5-432">**회로 차단기 사용**.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-432">**Use a circuit breaker**.</span></span> <span data-ttu-id="6e8f5-433">[회로 차단기][circuit-breaker-pattern] 패턴은 애플리케이션이 실패 가능성이 있는 작업을 반복해서 다시 시도하지 않도록 차단할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-433">The [Circuit Breaker][circuit-breaker-pattern] pattern can prevent an application from repeatedly trying an operation that is likely to fail.</span></span> <span data-ttu-id="6e8f5-434">회로 차단기는 서비스에 대한 호출을 래핑하고 최근 실패 횟수를 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-434">The circuit breaker wraps calls to a service and tracks the number of recent failures.</span></span> <span data-ttu-id="6e8f5-435">실패 횟수가 임계값을 초과하면 차단기는 서비스를 호출하지 않고 오류 코드를 반환하기 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-435">If the failure count exceeds a threshold, the circuit breaker starts returning an error code without calling the service.</span></span> <span data-ttu-id="6e8f5-436">이렇게 하면 복구할 서비스 시간을 확보할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-436">This gives the service time to recover.</span></span>

<span data-ttu-id="6e8f5-437">**부하 평준화를 사용하여 트래픽 급증을 매끄럽게 처리**.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-437">**Use load leveling to smooth out spikes in traffic**.</span></span>
<span data-ttu-id="6e8f5-438">백 엔드의 서비스가 감당할 수 없을 정도로 애플리케이션의 트래픽이 갑자기 치솟을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-438">Applications may experience sudden spikes in traffic, which can overwhelm services on the backend.</span></span> <span data-ttu-id="6e8f5-439">백 엔드 서비스가 요청에 충분히 신속하게 응답할 수 없는 경우 요청이 큐에 추가되거나(백업) 서비스가 애플리케이션을 제한할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-439">If a backend service cannot respond to requests quickly enough, it may cause requests to queue (back up), or cause the service to throttle the application.</span></span> <span data-ttu-id="6e8f5-440">큐를 버퍼로 사용하면 이 상황을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-440">To avoid this, you can use a queue as a buffer.</span></span> <span data-ttu-id="6e8f5-441">새 작업 항목이 있으면 백 엔드 서비스를 즉시 호출하는 대신 애플리케이션이 작업 항목을 비동기적으로 실행되도록 큐에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-441">When there is a new work item, instead of calling the backend service immediately, the application queues a work item to run asynchronously.</span></span> <span data-ttu-id="6e8f5-442">큐는 피크 부하를 매끄럽게 하는 버퍼 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-442">The queue acts as a buffer that smooths out peaks in the load.</span></span> <span data-ttu-id="6e8f5-443">자세한 내용은 [큐 기반 부하 평준화 패턴][load-leveling-pattern]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-443">For more information, see [Queue-Based Load Leveling Pattern][load-leveling-pattern].</span></span>

<span data-ttu-id="6e8f5-444">**중요한 리소스 격리**.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-444">**Isolate critical resources**.</span></span> <span data-ttu-id="6e8f5-445">가끔 한 하위 시스템의 오류가 원인이 되어 애플리케이션의 다른 부분에서 오류가 발생하기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-445">Failures in one subsystem can sometimes cascade, causing failures in other parts of the application.</span></span> <span data-ttu-id="6e8f5-446">오류가 스레드 또는 소켓 같은 리소스를 적시에 놓아주지 않으면 리소스가 고갈되어 이와 같은 상황이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-446">This can happen if a failure causes some resources, such as threads or sockets, not to get freed in a timely manner, leading to resource exhaustion.</span></span>

<span data-ttu-id="6e8f5-447">이 상황을 방지하려면 한 파티션의 오류 때문에 전체 시스템이 중단되는 일이 없도록 시스템을 격리된 그룹으로 분할하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-447">To avoid this, you can partition a system into isolated groups, so that a failure in one partition does not bring down the entire system.</span></span> <span data-ttu-id="6e8f5-448">이 기술을 [격벽 패턴][bulkhead-pattern]이라고도 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-448">This technique is sometimes called the [Bulkhead pattern][bulkhead-pattern].</span></span>

<span data-ttu-id="6e8f5-449">예제:</span><span class="sxs-lookup"><span data-stu-id="6e8f5-449">Examples:</span></span>

- <span data-ttu-id="6e8f5-450">데이터베이스를 분할하고(예를 들어 테넌트 기준으로 분할) 각 파티션에 대한 별도의 웹 서버 인스턴스 풀을 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-450">Partition a database (for example, by tenant) and assign a separate pool of web server instances for each partition.</span></span>  
- <span data-ttu-id="6e8f5-451">별도의 스레드 풀을 사용하여 호출을 서로 다른 서비스에 격리합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-451">Use separate thread pools to isolate calls to different services.</span></span> <span data-ttu-id="6e8f5-452">이렇게 하면 서비스 중 하나가 실패하더라도 연쇄 오류가 발생하지 않도록 방지하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-452">This helps to prevent cascading failures if one of the services fails.</span></span> <span data-ttu-id="6e8f5-453">예제는 Netflix [Hystrix 라이브러리][hystrix]를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-453">For an example, see the Netflix [Hystrix library][hystrix].</span></span>
- <span data-ttu-id="6e8f5-454">[컨테이너][containers]를 사용하여 특정 하위 시스템에만 리소스를 제공하도록 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-454">Use [containers][containers] to limit the resources available to a particular subsystem.</span></span>

![격벽 패턴의 다이어그램](./images/bulkhead.png)

<span data-ttu-id="6e8f5-456">**보정 트랜잭션 적용**.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-456">**Apply compensating transactions**.</span></span> <span data-ttu-id="6e8f5-457">[보정 트랜잭션][compensating-transaction-pattern]은 완료된 다른 트랜잭션의 효과를 실행 취소하는 트랜잭션입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-457">A [compensating transaction][compensating-transaction-pattern] is a transaction that undoes the effects of another completed transaction.</span></span> <span data-ttu-id="6e8f5-458">분산 시스템에서 강력한 트랜잭션 일관성을 달성하기가 매우 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-458">In a distributed system, it can be very difficult to achieve strong transactional consistency.</span></span> <span data-ttu-id="6e8f5-459">보정 트랜잭션은 각 단계에서 실행 취소할 수 있는 더 작은 일련의 개별 트랜잭션을 사용하여 일관성을 확보하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-459">Compensating transactions are a way to achieve consistency by using a series of smaller, individual transactions that can be undone at each step.</span></span>

<span data-ttu-id="6e8f5-460">예를 들어 출장을 준비하려면 고객은 자동차, 호텔 객실 및 항공편을 예약해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-460">For example, to book a trip, a customer might reserve a car, a hotel room, and a flight.</span></span> <span data-ttu-id="6e8f5-461">이러한 단계 중 하나라도 실패하면 전체 작업이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-461">If any of these steps fails, the entire operation fails.</span></span> <span data-ttu-id="6e8f5-462">전체 작업에 단일 분산 트랜잭션을 사용하는 대신, 각 단계에 대한 보정 트랜잭션을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-462">Instead of trying to use a single distributed transaction for the entire operation, you can define a compensating transaction for each step.</span></span> <span data-ttu-id="6e8f5-463">예를 들어 자동차 예약을 실행 취소하려면 예약을 취소하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-463">For example, to undo a car reservation, you cancel the reservation.</span></span> <span data-ttu-id="6e8f5-464">전체 작업을 완료하기 위해 코디네이터는 각 단계를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-464">In order to complete the whole operation, a coordinator executes each step.</span></span> <span data-ttu-id="6e8f5-465">어느 단계가 실패하면 코디네이터가 보정 트랜잭션을 적용하여 완료된 단계를 실행 취소합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-465">If any step fails, the coordinator applies compensating transactions to undo any steps that were completed.</span></span>

## <a name="test-for-resiliency"></a><span data-ttu-id="6e8f5-466">복원력 테스트</span><span class="sxs-lookup"><span data-stu-id="6e8f5-466">Test for resiliency</span></span>

<span data-ttu-id="6e8f5-467">일반적으로 애플리케이션의 기능을 테스트하는 방법과 동일한 방법으로는(단위 테스트 등을 실행) 복원력을 테스트할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-467">Generally, you can't test resiliency in the same way that you test application functionality (by running unit tests and so on).</span></span> <span data-ttu-id="6e8f5-468">그 대신, 간헐적으로 발생하는 오류 조건 하에서 종단 간 워크로드가 수행되는 방식을 테스트해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-468">Instead, you must test how the end-to-end workload performs under failure conditions which only occur intermittently.</span></span>

<span data-ttu-id="6e8f5-469">테스트는 반복적인 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-469">Testing is an iterative process.</span></span> <span data-ttu-id="6e8f5-470">애플리케이션을 테스트하고, 결과를 측정하고, 결과를 분석 및 해결하고, 다시 프로세스를 반복합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-470">Test the application, measure the outcome, analyze and address any failures that result, and repeat the process.</span></span>

<span data-ttu-id="6e8f5-471">**오류 주입 테스트**.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-471">**Fault injection testing**.</span></span> <span data-ttu-id="6e8f5-472">실제 오류를 트리거하거나 시뮬레이션하여 오류 시 시스템 복원력을 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-472">Test the resiliency of the system during failures, either by triggering actual failures or by simulating them.</span></span> <span data-ttu-id="6e8f5-473">다음은 테스트에 자주 사용되는 몇 가지 일반적인 오류 시나리오입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-473">Here are some common failure scenarios to test:</span></span>

- <span data-ttu-id="6e8f5-474">VM 인스턴스가 중단됩니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-474">Shut down VM instances.</span></span>
- <span data-ttu-id="6e8f5-475">프로세스가 충돌합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-475">Crash processes.</span></span>
- <span data-ttu-id="6e8f5-476">인증서가 만료됩니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-476">Expire certificates.</span></span>
- <span data-ttu-id="6e8f5-477">액세스 키가 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-477">Change access keys.</span></span>
- <span data-ttu-id="6e8f5-478">도메인 컨트롤러에서 DNS 서비스를 중단합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-478">Shut down the DNS service on domain controllers.</span></span>
- <span data-ttu-id="6e8f5-479">RAM 또는 스레드 수 같은 가용 시스템 리소스를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-479">Limit available system resources, such as RAM or number of threads.</span></span>
- <span data-ttu-id="6e8f5-480">디스크를 탑재 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-480">Unmount disks.</span></span>
- <span data-ttu-id="6e8f5-481">VM을 다시 배포합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-481">Redeploy a VM.</span></span>

<span data-ttu-id="6e8f5-482">복구 시간을 측정하고 비즈니스 요구 사항이 충족되었는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-482">Measure the recovery times and verify that your business requirements are met.</span></span> <span data-ttu-id="6e8f5-483">오류 모드를 조합하여 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-483">Test combinations of failure modes as well.</span></span> <span data-ttu-id="6e8f5-484">오류가 연쇄적으로 발생하지 않아야 하며, 오류를 격리된 방식으로 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-484">Make sure that failures don't cascade, and are handled in an isolated way.</span></span>

<span data-ttu-id="6e8f5-485">이러한 이유로 디자인 단계에서 잠재적인 실패 지점을 분석하는 것이 매우 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-485">This is another reason why it's important to analyze possible failure points during the design phase.</span></span> <span data-ttu-id="6e8f5-486">분석 결과를 테스트 계획에 입력해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-486">The results of that analysis should be inputs into your test plan.</span></span>

<span data-ttu-id="6e8f5-487">**부하 테스트**.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-487">**Load testing**.</span></span> <span data-ttu-id="6e8f5-488">부하 테스트는 백 엔드 데이터베이스 성능 초과나 서비스 제한처럼 부하 상태에서만 발생하는 오류를 식별하는 데 있어서 매우 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-488">Load testing is crucial for identifying failures that only happen under load, such as the backend database being overwhelmed or service throttling.</span></span> <span data-ttu-id="6e8f5-489">프로덕션 데이터와 최대한 비슷한 프로덕션 데이터 또는 가상 데이터를 사용하여 최대 부하를 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-489">Test for peak load, using production data or synthetic data that is as close to production data as possible.</span></span> <span data-ttu-id="6e8f5-490">애플리케이션이 실제 조건에서 어떻게 동작하는지 확인하는 것이 목표입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-490">The goal is to see how the application behaves under real-world conditions.</span></span>

<span data-ttu-id="6e8f5-491">**재해 복구 훈련**</span><span class="sxs-lookup"><span data-stu-id="6e8f5-491">**Disaster recovery drills**.</span></span> <span data-ttu-id="6e8f5-492">좋은 재해 복구 계획이 있더라도 충분하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-492">It is not enough if you have a good disaster recovery plan in place.</span></span> <span data-ttu-id="6e8f5-493">복구 계획에 문제가 발생할 경우 제대로 작동하는지 확인하기 위해 정기적으로 테스트해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-493">You need to test it periodically to ensure your recovery plan works fine when it matters.</span></span> <span data-ttu-id="6e8f5-494">Azure 가상 머신의 경우 [Azure Site Recovery][site-recovery]를 사용하여 프로덕션 애플리케이션 또는 진행 중인 복제에 영향을 주지 않고 [DR 훈련을 복제하고 수행][site-recovery-test-failover]할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-494">For Azure virtual machines, you can use [Azure Site Recovery][site-recovery] to replicate and [perform DR drills][site-recovery-test-failover] without impacting production applications or ongoing replication.</span></span>

## <a name="deploy-using-reliable-processes"></a><span data-ttu-id="6e8f5-495">신뢰할 수 있는 프로세스를 사용하여 배포</span><span class="sxs-lookup"><span data-stu-id="6e8f5-495">Deploy using reliable processes</span></span>

<span data-ttu-id="6e8f5-496">애플리케이션이 프로덕션 환경에 배포된 후에는 업데이트로 인해 오류가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-496">Once an application is deployed to production, updates are a possible source of errors.</span></span> <span data-ttu-id="6e8f5-497">최악의 경우 잘못된 업데이트 때문에 가동이 중지될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-497">In the worst case, a bad update can cause downtime.</span></span> <span data-ttu-id="6e8f5-498">이를 방지하려면 배포 프로세스가 예측 가능하고 반복 가능해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-498">To avoid this, the deployment process must be predictable and repeatable.</span></span> <span data-ttu-id="6e8f5-499">배포에는 Azure 리소스를 프로비전하고, 애플리케이션 코드를 배포하고, 구성 설정을 적용하는 것이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-499">Deployment includes provisioning Azure resources, deploying application code, and applying configuration settings.</span></span> <span data-ttu-id="6e8f5-500">업데이트에 세 가지가 모두 관련될 수도 있고 일부만 관련될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-500">An update may involve all three, or a subset.</span></span>

<span data-ttu-id="6e8f5-501">중요한 점은, 수동 배포는 오류가 발생하기 쉽다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-501">The crucial point is that manual deployments are prone to error.</span></span> <span data-ttu-id="6e8f5-502">따라서 요청이 있을 때 실행할 수 있고 오류가 발생하면 다시 실행할 수 있는 자동화된 멱등원(idempotent) 프로세스를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-502">Therefore, it's recommended to have an automated, idempotent process that you can run on demand, and re-run if something fails.</span></span>

* <span data-ttu-id="6e8f5-503">Azure 리소스 프로비전을 자동화하려면 [Terraform][terraform], [Ansible][ansible], [Chef][chef], [Puppet][puppet], [PowerShell][powershell], [CLI][cli] 또는 [Azure Resource Manager 템플릿][template-deployment]을 사용하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-503">To automate provisioning of Azure resources you can use [Terraform][terraform], [Ansible][ansible], [Chef][chef], [Puppet][puppet], [PowerShell][powershell], [CLI][cli] or [Azure Resource Manager templates][template-deployment]</span></span>
* <span data-ttu-id="6e8f5-504">[Azure Automation DSC(Desired State Configuration)][dsc]를 사용하여 VM을 구성하세요.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-504">Use [Azure Automation Desired State Configuration][dsc] (DSC) to configure VMs.</span></span> <span data-ttu-id="6e8f5-505">Linux VM의 경우 [Cloud-init][cloud-init]를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-505">For Linux VMs, you can use [Cloud-init][cloud-init].</span></span>
* <span data-ttu-id="6e8f5-506">[Azure DevOps Services][azure-devops-services]나 [Jenkins][jenkins]를 사용하여 애플리케이션 배포를 자동화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-506">You can automate application deployment using [Azure DevOps Services][azure-devops-services] or [Jenkins][jenkins].</span></span>

<span data-ttu-id="6e8f5-507">복원력 있는 배포와 관련된 두 가지 개념은 *코드로써의 인프라* 및 *변경이 불가능한 인프라*입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-507">Two concepts related to resilient deployment are *infrastructure as code* and *immutable infrastructure*.</span></span>

- <span data-ttu-id="6e8f5-508">**코드로써의 인프라**는 인프라를 프로비전하고 구성하기 위한 코드 사용 관행입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-508">**Infrastructure as code** is the practice of using code to provision and configure infrastructure.</span></span> <span data-ttu-id="6e8f5-509">코드로써의 인프라는 선언적 방법 또는 명령적 방법(또는 두 가지 조합)을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-509">Infrastructure as code may use a declarative approach or an imperative approach (or a combination of both).</span></span> <span data-ttu-id="6e8f5-510">Resource Manager 템플릿은 선언적 방법의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-510">Resource Manager templates are an example of a declarative approach.</span></span> <span data-ttu-id="6e8f5-511">PowerShell 스크립트는 명령적 방법의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-511">PowerShell scripts are an example of an imperative approach.</span></span>
- <span data-ttu-id="6e8f5-512">**변경이 불가능한 인프라**는 프로덕션 환경에 인프라가 배포된 후에는 인프라를 수정하면 안 된다는 원칙입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-512">**Immutable infrastructure** is the principle that you shouldn’t modify infrastructure after it’s deployed to production.</span></span> <span data-ttu-id="6e8f5-513">그렇지 않으면 임시 변경 작업이 수행되어 무엇이 변경되었는지 정확하게 알기 어렵고 시스템에 대해 추론하기 어려운 상태에 빠질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-513">Otherwise, you can get into a state where ad hoc changes have been applied, so it's hard to know exactly what changed, and hard to reason about the system.</span></span>

<span data-ttu-id="6e8f5-514">또 다른 문제는 애플리케이션 업데이트를 수행하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-514">Another question is how to roll out an application update.</span></span> <span data-ttu-id="6e8f5-515">잘못된 배포의 악영향을 최소화할 수 있도록 정교하게 통제되는 방식으로 업데이트를 푸시하는 청록색 배포 또는 카나리아 릴리스 같은 기술을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-515">We recommend techniques such as blue-green deployment or canary releases, which push updates in highly controlled way to minimize possible impacts from a bad deployment.</span></span>

- <span data-ttu-id="6e8f5-516">[청록색 배포][blue-green]는 실시간 애플리케이션과 분리된 프로덕션 환경에 업데이트를 배포하는 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-516">[Blue-green deployment][blue-green] is a technique where an update is deployed into a production environment separate from the live application.</span></span> <span data-ttu-id="6e8f5-517">배포의 유효성을 검사한 후에는 업데이트된 버전으로 트래픽 라우팅을 전환합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-517">After you validate the deployment, switch the traffic routing to the updated version.</span></span> <span data-ttu-id="6e8f5-518">예를 들어 Azure App Service Web Apps는 [스테이징 슬롯][staging-slots]을 통해 이 기능을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-518">For example, Azure App Service Web Apps enables this with [staging slots][staging-slots].</span></span>
- <span data-ttu-id="6e8f5-519">[카나리아 릴리스][canary-release]는 청록색 배포와 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-519">[Canary releases][canary-release] are similar to blue-green deployments.</span></span> <span data-ttu-id="6e8f5-520">모든 트래픽을 업데이트된 버전으로 전환하는 대신, 트래픽의 일부를 새 배포로 라우팅하여 일부 사용자에게만 업데이트를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-520">Instead of switching all traffic to the updated version, you roll out the update to a small percentage of users, by routing a portion of the traffic to the new deployment.</span></span> <span data-ttu-id="6e8f5-521">문제가 있으면 업데이트를 중단하고 이전 배포를 되돌립니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-521">If there is a problem, back off and revert to the old deployment.</span></span> <span data-ttu-id="6e8f5-522">문제가 없으면 트래픽 100%에 도달할 때까지 점점 더 많은 트래픽을 새 버전으로 라우팅합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-522">Otherwise, route more of the traffic to the new version, until it gets 100% of the traffic.</span></span>

<span data-ttu-id="6e8f5-523">어떤 방법을 사용하든, 새 버전이 작동하지 않는 경우 마지막으로 알려진 정상 배포로 롤백할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-523">Whatever approach you take, make sure that you can roll back to the last-known-good deployment, in case the new version is not functioning.</span></span> <span data-ttu-id="6e8f5-524">또한 기타 종속 서비스에 대한 변경 내용 및 데이터베이스 변경 내용을 롤백하는 전략을 마련해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-524">Also have a strategy in place to roll back database changes and any other changes to dependent services.</span></span> <span data-ttu-id="6e8f5-525">오류가 발생하면 어떤 버전 때문에 오류가 발생했는지 애플리케이션 로그를 보고 알 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-525">If errors occur, the application logs must indicate which version caused the error.</span></span>

## <a name="monitor-to-detect-failures"></a><span data-ttu-id="6e8f5-526">오류를 감지하기 위한 모니터링</span><span class="sxs-lookup"><span data-stu-id="6e8f5-526">Monitor to detect failures</span></span>
<span data-ttu-id="6e8f5-527">모니터링은 복원력에 매우 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-527">Monitoring is crucial for resiliency.</span></span> <span data-ttu-id="6e8f5-528">오류가 발생하면 오류가 있다는 사실을 알 수 있어야 하고 오류 원인을 파악할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-528">If something fails, you need to know that it failed, and you need insights into the cause of the failure.</span></span> 

<span data-ttu-id="6e8f5-529">대규모 분산 시스템을 모니터링하는 것은 상당한 과제입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-529">Monitoring a large-scale distributed system poses a significant challenge.</span></span> <span data-ttu-id="6e8f5-530">수십 개의 VM&mdash;에서 실행되는 애플리케이션이 있다고 생각해 봅시다. 각 VM에 한 번에 하나씩 로그인하여 로그 파일을 살펴보고 문제를 해결하는 것은 현실적이지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-530">Think about an application that runs on a few dozen VMs &mdash; it's not practical to log into each VM, one at a time, and look through log files, trying to troubleshoot a problem.</span></span> <span data-ttu-id="6e8f5-531">또한 VM 인스턴스 수는 대개 정적이지 않습니다. 애플리케이션 규모가 감축 또는 확장되면 VM이 추가 또는 제거되며, 인스턴스가 실패하여 다시 프로비저닝해야 하는 경우가 가끔 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-531">Moreover, the number of VM instances is probably not static VMs get added and removed as the application scales in and out, and occasionally an instance may fail and need to be reprovisioned.</span></span> <span data-ttu-id="6e8f5-532">또한 일반적인 클라우드 애플리케이션은 여러 데이터 저장소(Azure 스토리지, SQL Database, Cosmos DB, Redis 캐시)를 사용할 수 있으며, 단일 사용자 작업이 여러 하위 시스템에 걸쳐 이어질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-532">In addition, a typical cloud application might use multiple data stores (Azure storage, SQL Database, Cosmos DB, Redis cache), and a single user action may span multiple subsystems.</span></span> 

<span data-ttu-id="6e8f5-533">모니터링 프로세스는 다수의 개별 단계로 구성된 파이프라인이라고 생각하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-533">You can think of the monitoring process as a pipeline with several distinct stages:</span></span>

![복합 SLA](./images/monitoring.png)

* <span data-ttu-id="6e8f5-535">**계측**.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-535">**Instrumentation**.</span></span> <span data-ttu-id="6e8f5-536">모니터링을 위한 원시 데이터는 [애플리케이션 로그](/azure/application-insights/app-insights-overview?toc=/azure/azure-monitor/toc.json), [운영 체제 성능 메트릭](/azure/azure-monitor/platform/agents-overview), [Azure 리소스](/azure/monitoring-and-diagnostics/monitoring-supported-metrics?toc=/azure/azure-monitor/toc.json), [Azure 구독](/azure/service-health/service-health-overview) 및 [Azure 테넌트](/azure/active-directory/reports-monitoring/howto-integrate-activity-logs-with-log-analytics)를 비롯한 다양한 출처에서 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-536">The raw data for monitoring comes from a variety of sources, including [application logs](/azure/application-insights/app-insights-overview?toc=/azure/azure-monitor/toc.json), [operating systems performance metrics](/azure/azure-monitor/platform/agents-overview), [Azure resources](/azure/monitoring-and-diagnostics/monitoring-supported-metrics?toc=/azure/azure-monitor/toc.json), [Azure subscriptions](/azure/service-health/service-health-overview) and [Azure tenants](/azure/active-directory/reports-monitoring/howto-integrate-activity-logs-with-log-analytics).</span></span> <span data-ttu-id="6e8f5-537">대부분의 Azure 서비스는 구성을 통해 문제를 분석하여 원인을 확인할 수 있는 [메트릭](/azure/azure-monitor/platform/data-collection)을 노출합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-537">Most Azure services expose [metrics](/azure/azure-monitor/platform/data-collection) that you can configure to analyze and determine the cause of problems.</span></span>
* <span data-ttu-id="6e8f5-538">**수집 및 저장**.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-538">**Collection and storage**.</span></span> <span data-ttu-id="6e8f5-539">원시 계측 데이터는 다양한 위치에 다양한 형식으로 저장할 수 있습니다(예: 애플리케이션 추적 로그, IIS 로그, 성능 카운터).</span><span class="sxs-lookup"><span data-stu-id="6e8f5-539">Raw instrumentation data can be held in various locations and with various formats (e.g., application trace logs, IIS logs, performance counters).</span></span> <span data-ttu-id="6e8f5-540">이렇게 서로 다른 원본은 수집되고 통합되어 Application Insights, Azure Monitor 메트릭, Service Health, 스토리지 계정 및 Log Analytics와 같은 안정적인 데이터 저장소에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-540">These disparate sources are collected, consolidated, and put into reliable data stores such as Application Insights, Azure Monitor metrics, Service Health, storage accounts and Log Analytics.</span></span>
* <span data-ttu-id="6e8f5-541">**분석 및 진단**.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-541">**Analysis and diagnosis**.</span></span> <span data-ttu-id="6e8f5-542">데이터가 서로 다른 데이터 저장소에 통합되면, 분석을 통해 문제를 해결하고 애플리케이션 상태에 대한 전체 보기를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-542">After the data is consolidated in these different data stores, it can be analyzed to troubleshoot issues and provide an overall view of application health.</span></span> <span data-ttu-id="6e8f5-543">일반적으로 [Kusto 쿼리](/azure/log-analytics/log-analytics-queries)를 사용하여 Application Insights와 Log Analytics에서 데이터를 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-543">Generally, you can search for the data in Application Insights and Log Analytics using [Kusto queries](/azure/log-analytics/log-analytics-queries).</span></span> <span data-ttu-id="6e8f5-544">Azure Advisor는 [복원력](/azure/advisor/advisor-high-availability-recommendations)과 [최적화](/azure/advisor/advisor-performance-recommendations)에 중점을 둔 권장 사항을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-544">Azure Advisor provides recommendations with a focus on [resiliency](/azure/advisor/advisor-high-availability-recommendations) and [optimization](/azure/advisor/advisor-performance-recommendations).</span></span> 
* <span data-ttu-id="6e8f5-545">**시각화 및 경고**.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-545">**Visualization and alerts**.</span></span> <span data-ttu-id="6e8f5-546">이 단계에서는 운영자가 문제 또는 추세를 신속하게 파악할 수 있는 방식으로 원격 분석 데이터가 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-546">In this stage, telemetry data is presented in such a way that an operator can quickly notice problems or trends.</span></span> <span data-ttu-id="6e8f5-547">이러한 예에는 대시보드나 이메일 경고가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-547">Examples include dashboards or email alerts.</span></span> <span data-ttu-id="6e8f5-548">[Azure 대시보드](/azure/azure-portal/azure-portal-dashboards)를 사용하면 Application Insights, Log Analytics, Azure Monitor 메트릭 및 Service Health에서 발생한 모니터링 그래프의 단일 창 보기를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-548">With [Azure dashboards](/azure/azure-portal/azure-portal-dashboards), you can build a single-pane of glass view of monitoring graphs originating from Application Insights, Log Analytics, Azure Monitor metrics and service health.</span></span> <span data-ttu-id="6e8f5-549">[Azure Monitor 경고](/azure/monitoring-and-diagnostics/monitoring-overview-alerts?toc=/azure/azure-monitor/toc.json)를 통해 서비스 상태 및 리소스 상태에 대한 경고를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-549">With [Azure Monitor alerts](/azure/monitoring-and-diagnostics/monitoring-overview-alerts?toc=/azure/azure-monitor/toc.json), you can create alerts on service health and resource health.</span></span>

<span data-ttu-id="6e8f5-550">모니터링은 오류 감지와 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-550">Monitoring is not the same as failure detection.</span></span> <span data-ttu-id="6e8f5-551">예를 들어 애플리케이션이 임시 오류 및 다시 시도를 감지했지만, 결과적으로 가동 중지 없이 넘어갈 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-551">For example, your application might detect a transient error and retry, resulting in no downtime.</span></span> <span data-ttu-id="6e8f5-552">하지만 그렇더라도 오류 비율을 모니터링하여 애플리케이션의 전체적인 상태를 확인할 수 있도록 애플리케이션에서 다시 시도 작업을 로깅해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-552">But it should also log the retry operation, so that you can monitor the error rate, in order to get an overall picture of application health.</span></span>

<span data-ttu-id="6e8f5-553">애플리케이션 로그는 진단 데이터의 중요한 소스입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-553">Application logs are an important source of diagnostics data.</span></span> <span data-ttu-id="6e8f5-554">애플리케이션 로깅에 대한 모범 사례는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-554">Best practices for application logging include:</span></span>

- <span data-ttu-id="6e8f5-555">프로덕션 환경에 로그인합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-555">Log in production.</span></span> <span data-ttu-id="6e8f5-556">그렇지 않으면 데이터가 가장 필요할 때 데이터를 얻을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-556">Otherwise, you lose insight where you need it most.</span></span>
- <span data-ttu-id="6e8f5-557">서비스 경계에서 이벤트를 로깅합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-557">Log events at service boundaries.</span></span> <span data-ttu-id="6e8f5-558">서비스 경계 너머로 흐르는 상관 관계 ID를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-558">Include a correlation ID that flows across service boundaries.</span></span> <span data-ttu-id="6e8f5-559">한 트랜잭션이 여러 서비스를 통과하는데 그 중 하나가 실패하면 상관 관계 ID를 통해 트랜잭션 실패 이유를 찾아낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-559">If a transaction flows through multiple services and one of them fails, the correlation ID will help you pinpoint why the transaction failed.</span></span>
- <span data-ttu-id="6e8f5-560">구조적 로깅이라고도 하는 의미 체계 로깅을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-560">Use semantic logging, also known as structured logging.</span></span> <span data-ttu-id="6e8f5-561">구조화되지 않은 로그는 클라우드 규모에서 필요한 로그 데이터의 사용 및 분석 자동화가 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-561">Unstructured logs make it hard to automate the consumption and analysis of the log data, which is needed at cloud scale.</span></span>
- <span data-ttu-id="6e8f5-562">비동기 로깅을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-562">Use asynchronous logging.</span></span> <span data-ttu-id="6e8f5-563">그렇지 않으면 로깅 시스템 자체에서 요청을 백업하게 하여 애플리케이션 오류가 발생할 수 있습니다. 요청 로깅 이벤트 작성을 기다리는 동안 요청이 차단되기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-563">Otherwise, the logging system itself can cause the application to fail by causing requests to back up, as they block while waiting to write a logging event.</span></span>
- <span data-ttu-id="6e8f5-564">애플리케이션 로깅은 감사와 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-564">Application logging is not the same as auditing.</span></span> <span data-ttu-id="6e8f5-565">감사는 규정 또는 규제 준수를 위해 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-565">Auditing may be done for compliance or regulatory reasons.</span></span> <span data-ttu-id="6e8f5-566">따라서 감사 레코드는 완전해야 하고, 트랜잭션을 처리하는 동안 손실이 발생하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-566">As such, audit records must be complete, and it's not acceptable to drop any while processing transactions.</span></span> <span data-ttu-id="6e8f5-567">애플리케이션에서 감사를 요구하는 경우 감사 레코드를 진단 로깅과 별도로 보관해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-567">If an application requires auditing, this should be kept separate from diagnostics logging.</span></span>

<span data-ttu-id="6e8f5-568">모니터링 및 진단에 대한 자세한 내용은 [모니터링 및 진단 지침][monitoring-guidance]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-568">For more information about monitoring and diagnostics, see [Monitoring and diagnostics guidance][monitoring-guidance].</span></span>

## <a name="respond-to-failures"></a><span data-ttu-id="6e8f5-569">오류에 대한 대응</span><span class="sxs-lookup"><span data-stu-id="6e8f5-569">Respond to failures</span></span>
<span data-ttu-id="6e8f5-570">이전 섹션에서는 고가용성을 위해 중요한 자동 복구 전략에 집중했습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-570">Previous sections have focused on automated recovery strategies, which are critical for high availability.</span></span> <span data-ttu-id="6e8f5-571">그러나 경우에 따라 수동 개입이 필요할 때도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-571">However, sometimes manual intervention is needed.</span></span>

* <span data-ttu-id="6e8f5-572">**경고**.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-572">**Alerts**.</span></span> <span data-ttu-id="6e8f5-573">애플리케이션을 모니터링하여 사전 개입이 필요할 수도 있는 경고 기호를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-573">Monitor your application for warning signs that may require proactive intervention.</span></span> <span data-ttu-id="6e8f5-574">예를 들어 SQL Database 또는 Cosmos DB가 지속적으로 애플리케이션을 제한하는 것을 확인하면 데이터베이스 용량을 높이거나 쿼리를 최적화해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-574">For example, if you see that SQL Database or Cosmos DB consistently throttles your application, you might need to increase your database capacity or optimize your queries.</span></span> <span data-ttu-id="6e8f5-575">이 예제에서는 애플리케이션이 제한 오류를 투명하게 처리할 수도 있지만 후속 조치를 취할 수 있도록 원격 분석에서 계속 경고를 보내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-575">In this example, even though the application might handle the throttling errors transparently, your telemetry should still raise an alert so that you can follow up.</span></span> <span data-ttu-id="6e8f5-576">Azure 리소스 메트릭 및 진단 로그에 서비스 한도 및 할당량 임계값에 대한 경고를 구성하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-576">It is recommended to configure alerts on Azure resources metrics and diagnostics logs against the services limits and quotas thresholds.</span></span> <span data-ttu-id="6e8f5-577">메트릭에 대한 경고를 설정하는 것이 좋습니다. 대기 시간 대비 진단 로그가 적기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-577">We recommend to setup alerts on metrics as they are lower latency vs. diagnostics logs.</span></span> <span data-ttu-id="6e8f5-578">또한 Azure는 [Resource Health](https://docs.microsoft.com/en-us/azure/service-health/resource-health-checks-resource-types)를 통해 기본 제공되는 상태를 제공할 수 있으며, 이것은 Azure 서비스의 제한을 진단하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-578">In addition, Azure is able to provide with some out-of-the-box health status through [resource health](https://docs.microsoft.com/en-us/azure/service-health/resource-health-checks-resource-types) which can help diagnose throttling of Azure services.</span></span>    
* <span data-ttu-id="6e8f5-579">**장애 조치(Failover)**.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-579">**Failover**.</span></span> <span data-ttu-id="6e8f5-580">애플리케이션 재해 복구 전략을 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-580">Configure a disaster recovery strategy your application.</span></span> <span data-ttu-id="6e8f5-581">적절한 전략은 SLA에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-581">The appropriate strategy will depend on your SLAs.</span></span> <span data-ttu-id="6e8f5-582">많은 경우 활성-수동 구현으로 충분합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-582">For more scenarous, an active-passive implementation is sufficient.</span></span> <span data-ttu-id="6e8f5-583">자세한 내용은 [재해 복구를 위한 배포 토폴로지](./disaster-recovery-azure-applications.md#deployment-topologies-for-disaster-recovery)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-583">For more information, see [Deployment topologies for disaster recovery ](./disaster-recovery-azure-applications.md#deployment-topologies-for-disaster-recovery).</span></span> <span data-ttu-id="6e8f5-584">대부분의 Azure 서비스는 수동 또는 자동 장애 조치(failover)를 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-584">Most Azure services allow for either manual or automated failover.</span></span> <span data-ttu-id="6e8f5-585">예를 들어 IaaS 애플리케이션은 웹 계층과 논리 계층에 [Azure Site Recovery](/azure/site-recovery/azure-to-azure-architecture)를 사용하고 데이터베이스 계층에는 [SQL AlwaysOn 가용성 그룹](/azure/virtual-machines/windows/sql/virtual-machines-windows-portal-sql-availability-group-dr)을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-585">For example, in an IaaS application, use [Azure Site Recovery](/azure/site-recovery/azure-to-azure-architecture) for the web and logic tiers and [SQL AlwaysOn Availability Groups](/azure/virtual-machines/windows/sql/virtual-machines-windows-portal-sql-availability-group-dr) for the database tier.</span></span> <span data-ttu-id="6e8f5-586">[Traffic Manager](https://docs.microsoft.com/en-us/azure/traffic-manager/traffic-manager-overview)는 여러 지역에 자동화된 장애 조치(failover)를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-586">[Traffic Manager](https://docs.microsoft.com/en-us/azure/traffic-manager/traffic-manager-overview) provides automated failover across regions.</span></span>
* <span data-ttu-id="6e8f5-587">**운영 준비 테스트**.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-587">**Operational readiness testing**.</span></span> <span data-ttu-id="6e8f5-588">보조 지역에 대한 장애 조치(failover) 및 기본 지역에 대한 장애 복구(failback)를 위해 운영 준비 테스트를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-588">Perform an operational readiness test for both failover to the secondary region and failback to the primary region.</span></span> <span data-ttu-id="6e8f5-589">많은 Azure 서비스에서 재해 복구 훈련을 위해 수동 장애 조치(failover)나 테스트 장애 조치를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-589">Many Azure services support manual failover or test failover for disaster recovery drills.</span></span> <span data-ttu-id="6e8f5-590">또는 서비스를 종료하거나 제거하여 가동 중단을 시뮬레이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-590">Alternatevely, you can simulate an outage by shutting down or removing services.</span></span>
* <span data-ttu-id="6e8f5-591">**데이터 일관성 확인**.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-591">**Data consistency check**.</span></span> <span data-ttu-id="6e8f5-592">데이터 저장소에 오류가 발생한 후 데이터를 다시 사용할 수 있게 되었을 때, 특히 데이터가 복제된 경우 데이터 불일치가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-592">If a failure happens in a data store, there may be data inconsistencies when the store becomes available again, especially if the data was replicated.</span></span> <span data-ttu-id="6e8f5-593">지역 간 복제를 제공하는 Azure 서비스의 경우 RTO 및 RPO를 살펴보고 장애 발생 시 예상되는 데이터 손실을 파악합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-593">For Azure services that provide cross-regional replication, look at the RTO and RPO to understand the expected data loss in a failure.</span></span> <span data-ttu-id="6e8f5-594">Azure 서비스에 대한 SLA를 검토하여, 지역 간 장애 조치가 수동으로 시작될 수 있는지 아니면 Microsoft에서 시작되는지 이해해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-594">Review the SLAs for Azure services to understand whether cross-regional failover can be initiated manually or is initiated by Microsoft.</span></span> <span data-ttu-id="6e8f5-595">일부 서비스는 장애 조치를 수행 할 시점을 Microsoft가 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-595">For some services, Microsoft decides when to perform the failover.</span></span> <span data-ttu-id="6e8f5-596">Microsoft는 기본 지역에 데이터의 복구 우선 순위를 지정할 수 있으며 기본 지역의 데이터를 복구할 수 없는 것으로 간주되는 경우에만 보조 지역으로 장애 조치(failover)합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-596">Microsoft may prioritize the recovery of data in the primary region, only failing over to a secondary region if data in the primary region is deemed unrecoverable.</span></span> <span data-ttu-id="6e8f5-597">예를 들어 [지역 중복 스토리지](/azure/storage/common/storage-redundancy-grs)와 [Key Vault](/azure/key-vault/key-vault-disaster-recovery-guidance)는 이 모델을 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-597">For example, [Geo-redundant storage)](/azure/storage/common/storage-redundancy-grs) and [Key Vault](/azure/key-vault/key-vault-disaster-recovery-guidance) follow this model.</span></span>
* <span data-ttu-id="6e8f5-598">**백업에서 복원**.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-598">**Restoring from backup**.</span></span> <span data-ttu-id="6e8f5-599">일부 시나리오에서는, 백업에서 복원하는 것이 같은 지역 내에서만 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-599">In some scenarios, restoring from backup is only possible within the same region.</span></span> <span data-ttu-id="6e8f5-600">[Azure VM 백업](/azure/backup/backup-azure-vms-first-look-arm)이 이런 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-600">This is the case for [Azure VMs Backup](/azure/backup/backup-azure-vms-first-look-arm).</span></span> <span data-ttu-id="6e8f5-601">다른 Azure 서비스는 [Redis Cache 지리적 복제본](/azure/redis-cache/cache-how-to-geo-replication)과 같은 지리적으로 복제된 백업을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-601">Other Azure services provide geo-replicated backups, such as [Redis Cache Geo-Replicas](/azure/redis-cache/cache-how-to-geo-replication).</span></span> <span data-ttu-id="6e8f5-602">백업의 목적은 데이터가 실수로 삭제되거나 손상되지 않도록 보호하고, 애플리케이션을 작동 가능한 이전 버전으로 복원하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-602">The purpose of backups is to protect against accidental deletion or corruption of data, restoring the application to a functional version earlier in time.</span></span> <span data-ttu-id="6e8f5-603">따라서 백업이 재해 복구 솔루션의 역할을 할 수도 있지만 그 반대의 경우가 항상 참은 아닙니다. 데이터가 실수로 삭제되거나 손상되는 것을 재해 복구가 보호하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-603">Therefore, while backups can serve as a disaster recovery solution in some cases, the inverse is not always true: Disaster recovery won't protect you against accidental deletion or corruption a data.</span></span>  

<span data-ttu-id="6e8f5-604">재해 복구 계획을 문서화 및 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-604">Document and test your disaster recovery plan.</span></span> <span data-ttu-id="6e8f5-605">애플리케이션 오류가 비즈니스에 미치는 영향을 평가합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-605">Evaluate the business impact of application failures.</span></span> <span data-ttu-id="6e8f5-606">프로세스를 최대한 자동화하고 수동 장애 조치(failover), 백업에서 데이터 복원 등의 수동 단계를 문서화합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-606">Automate the process as much as possible, and document any manual steps, such as manual failover or data restoration from backups.</span></span> <span data-ttu-id="6e8f5-607">재해 복구 프로세스를 주기적으로 테스트하여 유효성을 검사하고 계획을 개선합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-607">Regularly test your disaster recovery process to validate and improve the plan.</span></span> <span data-ttu-id="6e8f5-608">애플리케이션에 사용되는 Azure 서비스에 대한 경고를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-608">Set up alerts for the Azure services consumed by your application.</span></span>

## <a name="summary"></a><span data-ttu-id="6e8f5-609">요약</span><span class="sxs-lookup"><span data-stu-id="6e8f5-609">Summary</span></span>
<span data-ttu-id="6e8f5-610">이 문서에서는 전체적인 관점에서 복원력을 살펴보고, 클라우드의 고유한 과제 중 일부를 강조했습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-610">This article discussed resiliency from a holistic perspective, emphasizing some of the unique challenges of the cloud.</span></span> <span data-ttu-id="6e8f5-611">그 중에는 분산, 상용 하드웨어 사용, 일시적 네트워크 오류라는 클라우드 컴퓨팅의 특성도 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-611">These include the distributed nature of cloud computing, the use of commodity hardware, and the presence of transient network faults.</span></span>

<span data-ttu-id="6e8f5-612">다음은 이 문서에서 기억해야 할 핵심 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-612">Here are the major points to take away from this article:</span></span>

- <span data-ttu-id="6e8f5-613">복원력이 높으면 가용성이 높고 평균 오류 복구 시간은 짧습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-613">Resiliency leads to higher availability, and lower mean time to recover from failures.</span></span>
- <span data-ttu-id="6e8f5-614">클라우드에서 높은 복원력을 얻으려면 기존 온-프레미스 솔루션과는 다른 여러 기술 집합이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-614">Achieving resiliency in the cloud requires a different set of techniques from traditional on-premises solutions.</span></span>
- <span data-ttu-id="6e8f5-615">복원력은 우연히 얻을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-615">Resiliency does not happen by accident.</span></span> <span data-ttu-id="6e8f5-616">처음부터 디자인하고 구축해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-616">It must be designed and built in from the start.</span></span>
- <span data-ttu-id="6e8f5-617">복원력은 계획부터 코딩 및 운영까지 애플리케이션의 모든 수명 주기와 관련되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6e8f5-617">Resiliency touches every part of the application lifecycle, from planning and coding to operations.</span></span>
- <span data-ttu-id="6e8f5-618">테스트하고 모니터링하세요!</span><span class="sxs-lookup"><span data-stu-id="6e8f5-618">Test and monitor!</span></span>

<!-- links -->

[blue-green]: https://martinfowler.com/bliki/BlueGreenDeployment.html
[canary-release]: https://martinfowler.com/bliki/CanaryRelease.html
[circuit-breaker-pattern]: ../patterns/circuit-breaker.md
[compensating-transaction-pattern]: ../patterns/compensating-transaction.md
[containers]: https://en.wikipedia.org/wiki/Operating-system-level_virtualization
[dsc]: /azure/automation/automation-dsc-overview
[contingency-planning-guide]: https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-34r1.pdf
[fma]: ./failure-mode-analysis.md
[hystrix]: https://medium.com/netflix-techblog/introducing-hystrix-for-resilience-engineering-13531c1ab362
[jmeter]: https://jmeter.apache.org/
[load-leveling-pattern]: ../patterns/queue-based-load-leveling.md
[monitoring-guidance]: ../best-practices/monitoring.md
[ra-basic-web]: ../reference-architectures/app-service-web-app/basic-web-app.md
[ra-multi-vm]: ../reference-architectures/virtual-machines-windows/multi-vm.md
[checklist]: ../checklist/resiliency.md
[retry-pattern]: ../patterns/retry.md
[retry-service-specific guidance]: ../best-practices/retry-service-specific.md
[sla]: https://azure.microsoft.com/support/legal/sla/
[throttling-pattern]: ../patterns/throttling.md
[tm]: https://azure.microsoft.com/services/traffic-manager/
[tm-failover]: /azure/traffic-manager/traffic-manager-monitoring
[tm-sla]: https://azure.microsoft.com/support/legal/sla/traffic-manager
[site-recovery]: /azure/site-recovery/azure-to-azure-quickstart/
[site-recovery-test-failover]: /azure/site-recovery/azure-to-azure-tutorial-dr-drill/
[site-recovery-failover]: /azure/site-recovery/azure-to-azure-tutorial-failover-failback/
[deployment-topologies]: ./disaster-recovery-azure-applications.md#deployment-topologies-for-disaster-recovery
[bulkhead-pattern]: ../patterns/bulkhead.md
[terraform]: /azure/virtual-machines/windows/infrastructure-automation#terraform
[ansible]: /azure/virtual-machines/windows/infrastructure-automation#ansible
[chef]: /azure/virtual-machines/windows/infrastructure-automation#chef
[puppet]: /azure/virtual-machines/windows/infrastructure-automation#puppet
[template-deployment]: /azure/azure-resource-manager/resource-group-overview#template-deployment
[cloud-init]: /azure/virtual-machines/windows/infrastructure-automation#cloud-init
[azure-devops-services]: /azure/virtual-machines/windows/infrastructure-automation#azure-devops-services
[jenkins]: /azure/virtual-machines/windows/infrastructure-automation#jenkins
[staging-slots]: /azure/app-service/deploy-staging-slots
[powershell]: /powershell/azure/overview
[cli]: /cli/azure
