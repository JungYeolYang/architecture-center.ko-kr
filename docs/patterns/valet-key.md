---
title: 발레 키
description: 클라이언트에 특정 리소스 또는 서비스에 대한 제한된 직접 액세스를 제공하는 토큰 또는 키를 사용합니다.
keywords: 디자인 패턴
author: dragon119
ms.date: 06/23/2017
pnp.series.title: Cloud Design Patterns
pnp.pattern.categories:
- data-management
- security
ms.openlocfilehash: 791132eabf926cc285567454c60f894efa286433
ms.sourcegitcommit: b0482d49aab0526be386837702e7724c61232c60
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/14/2017
---
# <a name="valet-key-pattern"></a><span data-ttu-id="01290-104">발레 키 패턴</span><span class="sxs-lookup"><span data-stu-id="01290-104">Valet Key pattern</span></span>

[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="01290-105">응용 프로그램으로부터 데이터 전송을 오프로드하기 위해서 클라이언트에 특정 리소스에 대한 제한적 직접 액세스 권한을 제공하는 토큰을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-105">Use a token that provides clients with restricted direct access to a specific resource, in order to offload data transfer from the application.</span></span> <span data-ttu-id="01290-106">클라우드 호스티드 저장소 시스템이나 큐를 사용하는 응용 프로그램에 특히 유용하며, 비용을 최소화하고 확장성과 성능을 최대화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-106">This is particularly useful in applications that use cloud-hosted storage systems or queues, and can minimize cost and maximize scalability and performance.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="01290-107">컨텍스트 및 문제점</span><span class="sxs-lookup"><span data-stu-id="01290-107">Context and problem</span></span>

<span data-ttu-id="01290-108">클라이언트 프로그램과 웹 브라우저는 종종 파일이나 데이터 스트림을 응용 프로그램 저장소에서 읽고, 저장소에 쓰는 작업이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-108">Client programs and web browsers often need to read and write files or data streams to and from an application’s storage.</span></span> <span data-ttu-id="01290-109">일반적으로 응용 프로그램은 저장소에서 데이터를 가져오거나 클라이언트에 데이터를 스트리밍하거나 업로드된 스트림을 클라이언트에서 읽고 데이터 저장소에 저장하는 방법으로 데이터 이동을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-109">Typically, the application will handle the movement of the data &mdash; either by fetching it from storage and streaming it to the client, or by reading the uploaded stream from the client and storing it in the data store.</span></span> <span data-ttu-id="01290-110">그러나, 이 접근 방식은 계산, 메모리, 대역과 같은 소중한 리소스를 소비합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-110">However, this approach absorbs valuable resources such as compute, memory, and bandwidth.</span></span>

<span data-ttu-id="01290-111">데이터 저장소는 응용 프로그램에 데이터의 이동 처리를 수행할 것을 요구하지 않고, 데이터를 직접 업로드하고 다운로드할 수 있는 능력이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-111">Data stores have the ability to handle upload and download of data directly, without requiring that the application perform any processing to move this data.</span></span> <span data-ttu-id="01290-112">그러나, 일반적으로 클라이언트가 저장소에 대한 보안 자격 증명을 액세스할 것을 요구합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-112">But, this typically requires the client to have access to the security credentials for the store.</span></span> <span data-ttu-id="01290-113">이는 데이터 전송 비용을 최소화하는 데 유용한 기법이며, 응용 프로그램을 확장하고 성능을 최대화하기 위한 요구 사항일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-113">This can be a useful technique to minimize data transfer costs and the requirement to scale out the application, and to maximize performance.</span></span> <span data-ttu-id="01290-114">그렇다 해도, 응용 프로그램이 더 이상 데이터 보안을 관리할 수 없음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-114">It means, though, that the application is no longer able to manage the security of the data.</span></span> <span data-ttu-id="01290-115">클라이언트가 직접 액세스를 위해 데이터 저장소에 접속한 이후에는, 응용 프로그램이 게이터키퍼 역할을 할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-115">After the client has a connection to the data store for direct access, the application can't act as the gatekeeper.</span></span> <span data-ttu-id="01290-116">더 이상 프로세스를 제어하지 못하고, 데이터 저장소의 후속 업로드나 다운로드를 막을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-116">It's no longer in control of the process and can't prevent subsequent uploads or downloads from the data store.</span></span>

<span data-ttu-id="01290-117">신뢰되지 않는 클라이언트에 서비스를 제공해야 하는 분산 시스템에는 현실적인 접근 방식이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="01290-117">This isn't a realistic approach in distributed systems that need to serve untrusted clients.</span></span> <span data-ttu-id="01290-118">대신, 응용 프로그램은 데이터 액세스를 자세히 안전하게 제어할 수 있어야 하며, 이렇게 연결을 설정한 다음 클라이언트가 직접 데이터 저장소와 통신하면서 필요한 읽기 또는 쓰기 작업을 수행하게 허용함으로써 서버에 대한 부하를 계속해서 줄여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-118">Instead, applications must be able to securely control access to data in a granular way, but still reduce the load on the server by setting up this connection and then allowing the client to communicate directly with the data store to perform the required read or write operations.</span></span>

## <a name="solution"></a><span data-ttu-id="01290-119">해결 방법</span><span class="sxs-lookup"><span data-stu-id="01290-119">Solution</span></span>

<span data-ttu-id="01290-120">저장소가 클라이언트의 인증과 권한 부여를 관리할 수 없는 데이터 저장소에 대한 액세스를 제어하는 문제를 해결해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-120">You need to resolve the problem of controlling access to a data store where the store can't manage authentication and authorization of clients.</span></span> <span data-ttu-id="01290-121">일반적인 해결 방법은 데이터 저장소의 공용 연결에 대한 액세스를 제한하고 클라이언트에 데이터 저장소가 확인할 수 있는 키 또는 토큰을 제공하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="01290-121">One typical solution is to restrict access to the data store’s public connection and provide the client with a key or token that the data store can validate.</span></span>

<span data-ttu-id="01290-122">이것이 일반적으로 발레 키라고 부르는 키 또는 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="01290-122">This key or token is usually referred to as a valet key.</span></span> <span data-ttu-id="01290-123">발레 키는 특정 리소스에 대한 시간 제한된 액세스를 제공하고, 저장소나 큐에 읽기와 쓰기 또는 웹 브라우저에 업로드 및 다운로드와 같은 미리 정의된 작업 하나만 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-123">It provides time-limited access to specific resources and allows only predefined operations such as reading and writing to storage or queues, or uploading and downloading in a web browser.</span></span> <span data-ttu-id="01290-124">응용 프로그램은 클라이언트 장치와 웹 브라우저에 대한 발레 키를 빠르고 쉽게 만들고 발급할 수 있습니다. 이 키로 클라이언트는 응용 프로그램이 직접 데이터 전송을 처리할 것을 요구하지 않고 필요한 작업을 자신이 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-124">Applications can create and issue valet keys to client devices and web browsers quickly and easily, allowing clients to perform the required operations without requiring the application to directly handle the data transfer.</span></span> <span data-ttu-id="01290-125">이 경우, 응용 프로그램과 서버에서 일어나는 처리 오버헤드, 성능과 확장성에 미치는 영향이 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="01290-125">This removes the processing overhead, and the impact on performance and scalability, from the application and the server.</span></span>

<span data-ttu-id="01290-126">그림과 같이, 클라이언트는 이 토큰을 사용하여 특정 기간에만, 액세스 사용 권한에 제한하여, 데이터 저장소에서 특정 리소스를 액세스합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-126">The client uses this token to access a specific resource in the data store for only a specific period, and with specific restrictions on access permissions, as shown in the figure.</span></span> <span data-ttu-id="01290-127">지정된 기간 후에 키는 무효화되며 리소스 액세스를 허용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-127">After the specified period, the key becomes invalid and won't allow access to the resource.</span></span>

![그림 1 - 패턴의 개요](./_images/valet-key-pattern.png)

<span data-ttu-id="01290-129">데이터 범위와 같이 다른 종속성을 갖도록 키를 구성하는 것도 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-129">It's also possible to configure a key that has other dependencies, such as the scope of the data.</span></span> <span data-ttu-id="01290-130">예를 들면, 데이터 저장소 역량에 따라 키는 데이터 저장소에 완전한 표를 지정하거나 표에서 특정 행만 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-130">For example, depending on the data store capabilities, the key can specify a complete table in a data store, or only specific rows in a table.</span></span> <span data-ttu-id="01290-131">클라우드 저장소 시스템에서 키는 컨테이너, 즉 컨테이너 내 특정 항목을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-131">In cloud storage systems the key can specify a container, or just a specific item within a container.</span></span>

<span data-ttu-id="01290-132">키는 응용 프로그램에 의해 무효화될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-132">The key can also be invalidated by the application.</span></span> <span data-ttu-id="01290-133">클라이언트가 서버에 데이터 전송 작업이 완료되었음을 알릴 경우, 이는 유용한 접근 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="01290-133">This is a useful approach if the client notifies the server that the data transfer operation is complete.</span></span> <span data-ttu-id="01290-134">서버는 더 이상의 진행을 막기 위해 키를 무효화시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-134">The server can then invalidate that key to prevent further.</span></span>

<span data-ttu-id="01290-135">이 패턴을 사용하면 사용자 생성 및 인증, 사용 권한 부여, 사용자 다시 제거에 대한 요구 사항이 없기 때문에 리소스에 대한 액세스 관리가 단순화될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-135">Using this pattern can simplify managing access to resources because there's no requirement to create and authenticate a user, grant permissions, and then remove the user again.</span></span> <span data-ttu-id="01290-136">장소 제한, 사용 권한, 유효 기간을 제한하는 것도 쉬워졌습니다. 이러한 모든 작업이 런타임에 키를 생성하여 가능해집니다.</span><span class="sxs-lookup"><span data-stu-id="01290-136">It also makes it easy to limit the location, the permission, and the validity period&mdash;all by simply generating a key at runtime.</span></span> <span data-ttu-id="01290-137">유효 기간, 특히 리소스의 위치를, 수신자만 그 용도에 맞게 사용할 수 있도록 가능한 한 엄격히 제한하는 것은 중요한 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="01290-137">The important factors are to limit the validity period, and especially the location of the resource, as tightly as possible so that the recipient can only use it for the intended purpose.</span></span>

## <a name="issues-and-considerations"></a><span data-ttu-id="01290-138">문제 및 고려 사항</span><span class="sxs-lookup"><span data-stu-id="01290-138">Issues and considerations</span></span>

<span data-ttu-id="01290-139">이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="01290-139">Consider the following points when deciding how to implement this pattern:</span></span>

<span data-ttu-id="01290-140">**키의 유효 상태와 기간 관리**.</span><span class="sxs-lookup"><span data-stu-id="01290-140">**Manage the validity status and period of the key**.</span></span> <span data-ttu-id="01290-141">키가 유출되거나 노출된 경우, 키는 효과적으로 대상 항목을 잠금 해제하고, 유효 기간 동안 악의적 사용에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-141">If leaked or compromised, the key effectively unlocks the target item and makes it available for malicious use during the validity period.</span></span> <span data-ttu-id="01290-142">일반적으로 키는 어떻게 발급되었는지에 따라 취소되거나 사용할 수 없게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="01290-142">A key can usually be revoked or disabled, depending on how it was issued.</span></span> <span data-ttu-id="01290-143">서버 쪽 정책이 변경되거나 서명된 서버 키가 무효화될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-143">Server-side policies can be changed or, the server key it was signed with can be invalidated.</span></span> <span data-ttu-id="01290-144">데이터 저장소에 대해서 권한이 없는 작업이 발생하는 위험을 최소화하려면 유효 기간을 짧게 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-144">Specify a short validity period to minimize the risk of allowing unauthorized operations to take place against the data store.</span></span> <span data-ttu-id="01290-145">하지만, 유효 기간이 너무 짧으면 키가 만료되기 전에 클라이언트가 작업을 완료할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-145">However, if the validity period is too short, the client might not be able to complete the operation before the key expires.</span></span> <span data-ttu-id="01290-146">보호된 리소스에 다중 액세스가 요구될 경우, 유효 기간이 만료되기 전에 권한 있는 사용자가 키를 검토하도록 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-146">Allow authorized users to renew the key before the validity period expires if multiple accesses to the protected resource are required.</span></span>

<span data-ttu-id="01290-147">**키가 제공하는 액세스 수준 제어**.</span><span class="sxs-lookup"><span data-stu-id="01290-147">**Control the level of access the key will provide**.</span></span> <span data-ttu-id="01290-148">일반적으로, 클라이언트가 데이터 저장소에 데이터를 업로드하면 안 될 경우, 키는 사용자에게 읽기 전용 액세스와 같은 작업을 완료하는 데 필요한 동작만 수행하도록 허용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-148">Typically, the key should allow the user to only perform the actions necessary to complete the operation, such as read-only access if the client shouldn't be able to upload data to the data store.</span></span> <span data-ttu-id="01290-149">파일 업로드의 경우, 장소와 유효 기간뿐만 아니라 쓰기 전용 사용 권한을 제공하는 키를 지정하는 것이 보통입니다.</span><span class="sxs-lookup"><span data-stu-id="01290-149">For file uploads, it's common to specify a key that provides write-only permission, as well as the location and the validity period.</span></span> <span data-ttu-id="01290-150">키가 적용되는 리소스나 리소스 집합을 정확하게 지정하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-150">It's critical to accurately specify the resource or the set of resources to which the key applies.</span></span>

<span data-ttu-id="01290-151">**사용자 동작에 대한 제어 방법 고려**.</span><span class="sxs-lookup"><span data-stu-id="01290-151">**Consider how to control users’ behavior**.</span></span> <span data-ttu-id="01290-152">이 패턴을 구현하는 것은 사용자가에게 액세스가 허용된 리소스에 대한 제어가 일정 정도 손실된다는 뜻입니다.</span><span class="sxs-lookup"><span data-stu-id="01290-152">Implementing this pattern means some loss of control over the resources users are granted access to.</span></span> <span data-ttu-id="01290-153">가해지는 제어 수준은 서비스 또는 대상 데이터 저장소에서 사용 가능한 정책과 사용 권한의 역량에 의해 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="01290-153">The level of control that can be exerted is limited by the capabilities of the policies and permissions available for the service or the target data store.</span></span> <span data-ttu-id="01290-154">예를 들면, 일반적으로 저장소에 기록되는 데이터 크기와, 키가 파일 액세스에 사용될 수 있는 횟수를 제한하는 키를 만드는 것은 불가능합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-154">For example, it's usually not possible to create a key that limits the size of the data to be written to storage, or the number of times the key can be used to access a file.</span></span> <span data-ttu-id="01290-155">이는 데이터 전송에 예상치 않은 큰 비용을 발생시킬 수 있는데, 심지어 대상 고객에 의해 사용될 때, 그리고 반복된 업로드나 다운로드를 유발하는 코드 오류에 의해 야기될 수 있을 때도 마찬가지입니다.</span><span class="sxs-lookup"><span data-stu-id="01290-155">This can result in huge unexpected costs for data transfer, even when used by the intended client, and might be caused by an error in the code that causes repeated upload or download.</span></span> <span data-ttu-id="01290-156">파일이 업로드될 수 있는 횟수를 제한하려면, 가능한 한 클라이언트가 응용 프로그램에 작업 하나가 언제 완료되었는지 알리도록 강제해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-156">To limit the number of times a file can be uploaded, where possible, force the client to notify the application when one operation has completed.</span></span> <span data-ttu-id="01290-157">예를 들면, 어떤 데이터 저장소는 응용 프로그램 코드가 작업을 모니터링하고 사용자 동작을 제어하는 데 사용할 수 있는 이벤트를 발생시킵니다.</span><span class="sxs-lookup"><span data-stu-id="01290-157">For example, some data stores raise events the application code can use to monitor operations and control user behavior.</span></span> <span data-ttu-id="01290-158">그러나, 한 테넌트의 모든 사용자에 의해 동일한 키가 사용되는 다중 테넌트 시나리오에서 개별 사용자들의 할당량을 집행하기는 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-158">However, it's hard to enforce quotas for individual users in a multi-tenant scenario where the same key is used by all the users from one tenant.</span></span>

<span data-ttu-id="01290-159">**업로드된 모든 데이터의 유효성 검사 및 선택적 삭제**.</span><span class="sxs-lookup"><span data-stu-id="01290-159">**Validate, and optionally sanitize, all uploaded data**.</span></span> <span data-ttu-id="01290-160">키를 액세스하는 악의적 사용자가 시스템을 손상할 수 있게 설계된 데이터를 업로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-160">A malicious user that gains access to the key could upload data designed to compromise the system.</span></span> <span data-ttu-id="01290-161">또는, 권한 있는 사용자가 유효하지 않은 데이터를 업로드할 수 있는데, 이 작업이 처리되면 오류 또는 시스템 실패로 이어질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-161">Alternatively, authorized users might upload data that's invalid and, when processed, could result in an error or system failure.</span></span> <span data-ttu-id="01290-162">이를 막기 위해서, 업로드된 모든 데이터는 사용 전에 유효한지 검사받고 악의적인 콘텐츠가 없는지 확인받아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-162">To protect against this, ensure that all uploaded data is validated and checked for malicious content before use.</span></span>

<span data-ttu-id="01290-163">**모든 작업 감사**.</span><span class="sxs-lookup"><span data-stu-id="01290-163">**Audit all operations**.</span></span> <span data-ttu-id="01290-164">많은 키 기반 메커니즘은 업로드, 다운로드, 실패와 같은 작업을 기록할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-164">Many key-based mechanisms can log operations such as uploads, downloads, and failures.</span></span> <span data-ttu-id="01290-165">일반적으로 그런 기록은 감사 프로세스에 포함될 수 있고, 사용자에게 파일 크기나 데이터 볼륨에 근거한 요금이 부과된 경우 대금 청구에도 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-165">These logs can usually be incorporated into an audit process, and also used for billing if the user is charged based on file size or data volume.</span></span> <span data-ttu-id="01290-166">키 공급자와의 불화 또는 실수로 저장된 액세스 정책 삭제 등으로 야기될 수 있는 인증 실패를 검출하는 데 로그를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-166">Use the logs to detect authentication failures that might be caused by issues with the key provider, or accidental removal of a stored access policy.</span></span>

<span data-ttu-id="01290-167">**안전한 키 전달**.</span><span class="sxs-lookup"><span data-stu-id="01290-167">**Deliver the key securely**.</span></span> <span data-ttu-id="01290-168">웹 페이지에서 사용자가 활성화하는 URL에 포함되거나, 다운로드가 자동으로 일어날 수 있도록 서버 리디렉션 작업에 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-168">It can be embedded in a URL that the user activates in a web page, or it can be used in a server redirection operation so that the download occurs automatically.</span></span> <span data-ttu-id="01290-169">안전한 채널을 통해서 키를 전달하려면 항상 HTTP를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-169">Always use HTTPS to deliver the key over a secure channel.</span></span>

<span data-ttu-id="01290-170">**전송 중인 중요한 데이터 보호**.</span><span class="sxs-lookup"><span data-stu-id="01290-170">**Protect sensitive data in transit**.</span></span> <span data-ttu-id="01290-171">일반적으로 응용 프로그램을 통해서 전달된 중요한 정보는 SSL이나 TLS를 사용하여 발생하는데, 이는 데이터 저장소를 직접 액세스하는 클라이언트를 위해서 수행되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-171">Sensitive data delivered through the application will usually take place using SSL or TLS, and this should be enforced for clients accessing the data store directly.</span></span>

<span data-ttu-id="01290-172">이 패턴을 구현할 때 알아야 할 다른 문제점은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-172">Other issues to be aware of when implementing this pattern are:</span></span>

- <span data-ttu-id="01290-173">클라이언트가 서버에 작업 완료를 알리지 않거나 알리지 못하고, 유일한 제한이 키의 만료 기간인 경우, 응용 프로그램은 업로드나 다운로드 횟수 집계, 다중 업로드나 다운로드 예방과 같은 감사 작업을 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-173">If the client doesn't, or can't, notify the server of completion of the operation, and the only limit is the expiration period of the key, the application won't be able to perform auditing operations such as counting the number of uploads or downloads, or preventing multiple uploads or downloads.</span></span>

- <span data-ttu-id="01290-174">키 정책의 유연성이 제한될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-174">The flexibility of key policies that can be generated might be limited.</span></span> <span data-ttu-id="01290-175">예를 들면, 일부 메커니즘만 만료 기간의 사용을 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-175">For example, some mechanisms only allow the use of a timed expiration period.</span></span> <span data-ttu-id="01290-176">다른 메커니즘은 읽기/쓰기 사용 권한을 아주 자세하게 지정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-176">Others aren't able to specify a sufficient granularity of read/write permissions.</span></span>

- <span data-ttu-id="01290-177">키 또는 토큰 유효 기간의 시작 시간이 지정된 경우, 동기화에서 약간 벗어나 있을 수 있는 클라이언트 시계를 고려하여 시간이 현재의 서버 시간보다 조금 이른지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-177">If the start time for the key or token validity period is specified, ensure that it's a little earlier than the current server time to allow for client clocks that might be slightly out of synchronization.</span></span> <span data-ttu-id="01290-178">지정되지 않은 경우, 일반적으로 기본 값은 현재의 서버 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="01290-178">The default, if not specified, is usually the current server time.</span></span>

- <span data-ttu-id="01290-179">키를 포함한 URL은 서버 로그 파일에 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="01290-179">The URL containing the key will be recorded in server log files.</span></span> <span data-ttu-id="01290-180">일반적으로 분석에 로그 파일이 사용되기 전에 키가 만료되는 동안, 키에 대한 액세스를 제한하는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-180">While the key will typically have expired before the log files are used for analysis, ensure that you limit access to them.</span></span> <span data-ttu-id="01290-181">로그 데이터가 모니터링 시스템에 전송되거나 다른 장소에 저장된 경우, 유효 기간이 만료된 후까지 키 누출을 막기 위해 지연을 구현할 것을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-181">If log data is transmitted to a monitoring system or stored in another location, consider implementing a delay to prevent leakage of keys until after their validity period has expired.</span></span>

- <span data-ttu-id="01290-182">클라이언트 코드가 웹 브라우저에서 실행될 경우, 브라우저는 웹 브라우저에서 실행되는 코드가 그 페이지를 제공한 곳에서 다른 도메인에 있는 데이터를 액세스할 수 있도록 CORS(원본 간 리소스 공유)를 지원해야할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-182">If the client code runs in a web browser, the browser might need to support cross-origin resource sharing (CORS) to enable code that executes within the web browser to access data in a different domain from the one that served the page.</span></span> <span data-ttu-id="01290-183">일부 오래된 브라우저와 일부 데이터 저장소는 CORS를 지원하지 않으며, 이 브라우저에서 실행되는 코드는 클라우드 저장소 계정과 같은 다른 도메인에 있는 데이터에 대한 액세스 권한을 제공하기 위해서 발레 키를 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-183">Some older browsers and some data stores don't support CORS, and code that runs in these browsers might be able to use a valet key to provide access to data in a different domain, such as a cloud storage account.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="01290-184">이 패턴을 사용해야 하는 경우</span><span class="sxs-lookup"><span data-stu-id="01290-184">When to use this pattern</span></span>

<span data-ttu-id="01290-185">이 패턴은 다음 상황에서 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-185">This pattern is useful for the following situations:</span></span>

- <span data-ttu-id="01290-186">리소스 부하를 최소화하고 성능과 확장성을 최대화하기 위해서.</span><span class="sxs-lookup"><span data-stu-id="01290-186">To minimize resource loading and maximize performance and scalability.</span></span> <span data-ttu-id="01290-187">발레 키 사용은 리소스 잠김을 요구하지 않고, 원격 서버 호출을 요구하지 않으며, 발급될 수 있는 발레 키의 개수를 제한하지 않습니다. 그래서 응용 프로그램 코드를 통한 데이터 전송을 수행함으로써 발생되는 단일 실패 지점을 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-187">Using a valet key doesn't require the resource to be locked, no remote server call is required, there's no limit on the number of valet keys that can be issued, and it avoids a single point of failure resulting from performing the data transfer through the application code.</span></span> <span data-ttu-id="01290-188">발레 키 생성은 키로 문자열을 서명하는 간단한 암호화 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="01290-188">Creating a valet key is typically a simple cryptographic operation of signing a string with a key.</span></span>

- <span data-ttu-id="01290-189">업무비를 최소화하기 위해서.</span><span class="sxs-lookup"><span data-stu-id="01290-189">To minimize operational cost.</span></span> <span data-ttu-id="01290-190">저장소와 큐에 대한 직접 액세스 사용은 리소스와 비용 효율적이고, 네트워크 왕복을 줄일 수 있으며, 필요한 계산 리소스 수의 감소를 고려할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-190">Enabling direct access to stores and queues is resource and cost efficient, can result in fewer network round trips, and might allow for a reduction in the number of compute resources required.</span></span>

- <span data-ttu-id="01290-191">클라이언트가 규칙적으로 데이터를 업로드하거나 다운로드할 때, 특히 대용량이거나 작업이 큰 파일을 포함할 때</span><span class="sxs-lookup"><span data-stu-id="01290-191">When clients regularly upload or download data, particularly where there's a large volume or when each operation involves large files.</span></span>

- <span data-ttu-id="01290-192">호스팅 제한이나 비용 고려 때문에 응용 프로그램이 사용 가능한 계산 리소스를 제한할 때.</span><span class="sxs-lookup"><span data-stu-id="01290-192">When the application has limited compute resources available, either due to hosting limitations or cost considerations.</span></span> <span data-ttu-id="01290-193">이 시나리오에서, 이 패턴은 훨씬 더 유용한데, 데이터의 업로드나 다운로드가 동시에 많은 경우, 데이터 전송으로 생기는 응용 프로그램의 부담을 덜어주기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="01290-193">In this scenario, the pattern is even more helpful if there are many concurrent data uploads or downloads because it relieves the application from handling the data transfer.</span></span>

- <span data-ttu-id="01290-194">데이터가 원격 데이터 저장소나 다른 데이터센터에 저장될 때.</span><span class="sxs-lookup"><span data-stu-id="01290-194">When the data is stored in a remote data store or a different datacenter.</span></span> <span data-ttu-id="01290-195">응용 프로그램이 게이트키퍼 역할을 해야할 경우, 데이터센터 또는 클라이언트와 응용 프로그램 간, 그 다음 응용 프로그램과 데이터 저장소 간의 공용 또는 개인 네트워크에서 데이터를 전송하는 추가 대역에 대한 요금이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-195">If the application was required to act as a gatekeeper, there might be a charge for the additional bandwidth of transferring the data between datacenters, or across public or private networks between the client and the application, and then between the application and the data store.</span></span>

<span data-ttu-id="01290-196">이 패턴은 다음과 같은 경우에 유용하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-196">This pattern might not be useful in the following situations:</span></span>

- <span data-ttu-id="01290-197">응용 프로그램이 데이터가 저장되기 전 또는 데이터가 클라이언트에 전송되기 전에, 그 데이터에서 어떤 태스크를 수행해야 할 경우.</span><span class="sxs-lookup"><span data-stu-id="01290-197">If the application must perform some task on the data before it's stored or before it's sent to the client.</span></span> <span data-ttu-id="01290-198">예를 들면, 응용 프로그램이 유효성 검사를 수행하거나, 액세스 성공 기록하거나, 그 데이터에서 변환을 실행할 필요가 있는 경우가 여기에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-198">For example, if the application needs to perform validation, log access success, or execute a transformation on the data.</span></span> <span data-ttu-id="01290-199">그러나 일부 데이터 저장소와 클라이언트는 압축과 압축 풀기와 같은 간단한 변환을 협상하고 수행할 수 있습니다(예를 들어 일반적으로 웹 브라우저는 GZip 형식을 처리할 수 있음).</span><span class="sxs-lookup"><span data-stu-id="01290-199">However, some data stores and clients are able to negotiate and carry out simple transformations such as compression and decompression (for example, a web browser can usually handle GZip formats).</span></span>

- <span data-ttu-id="01290-200">기존의 응용 프로그램의 설계가 패턴을 포함하기 어려운 경우.</span><span class="sxs-lookup"><span data-stu-id="01290-200">If the design of an existing application makes it difficult to incorporate the pattern.</span></span> <span data-ttu-id="01290-201">일반적으로 이 패턴은 데이터를 주고 받을 때 다른 아키텍처적 접근 방식을 요구합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-201">Using this pattern typically requires a different architectural approach for delivering and receiving data.</span></span>

- <span data-ttu-id="01290-202">감사 내역을 유지 관리하거나 데이터 전송 작업의 실행 횟수를 제어할 필요가 있는 경우, 또 사용되는 발레 키 메커니즘이 서버가 이 작업을 유지하는 데 사용할 수 있는 알림을 지원하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="01290-202">If it's necessary to maintain audit trails or control the number of times a data transfer operation is executed, and the valet key mechanism in use doesn't support notifications that the server can use to manage these operations.</span></span>

- <span data-ttu-id="01290-203">특히 업로드 작업 시 데이터 크기 제한이 필요한 경우.</span><span class="sxs-lookup"><span data-stu-id="01290-203">If it's necessary to limit the size of the data, especially during upload operations.</span></span> <span data-ttu-id="01290-204">이를 위한 유일한 해결 방법은 응용 프로그램이 작업이 완료된 후 데이터 크기를 확인하거나, 특정 기간 이후 또는 예약된 일정에 따라 업로드 크기를 확인하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="01290-204">The only solution to this is for the application to check the data size after the operation is complete, or check the size of uploads after a specified period or on a scheduled basis.</span></span>

## <a name="example"></a><span data-ttu-id="01290-205">예</span><span class="sxs-lookup"><span data-stu-id="01290-205">Example</span></span>

<span data-ttu-id="01290-206">Azure는 Blob, 테이블, 큐에 있는 데이터에 대한 세분화된 액세스 제어를 위해서, 그리고 Service Bus 큐 및 토픽을 위해서 Azure Storage의 공유 액세스 서명을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-206">Azure supports shared access signatures on Azure Storage for granular access control to data in blobs, tables, and queues, and for Service Bus queues and topics.</span></span> <span data-ttu-id="01290-207">공유 액세스 서명 토큰은 특정 테이블, 테이블 내 키 범위, 큐, Blob, Blob 컨테이너에 대한 읽기, 쓰기, 업데이트, 삭제와 같은 특정 액세스 권한을 제공하도록 구성될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-207">A shared access signature token can be configured to provide specific access rights such as read, write, update, and delete to a specific table; a key range within a table; a queue; a blob; or a blob container.</span></span> <span data-ttu-id="01290-208">유효성은 특정 기간이 지정되거나 시간 제한이 없을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-208">The validity can be a specified time period or with no time limit.</span></span>

<span data-ttu-id="01290-209">Azure 공유 액세스 서명은 테이블 또는 Blob과 같은 특정 리소스와 관련이 있을 수 있는 서버 저장 액세스 정책을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-209">Azure shared access signatures also support server-stored access policies that can be associated with a specific resource such as a table or blob.</span></span> <span data-ttu-id="01290-210">이 기능은 응용 프로그램이 생성한 공유 액세스 서명 토큰과 비교할 때 추가 제어 및 유연성을 제공하므로, 가능한 한 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-210">This feature provides additional control and flexibility compared to application-generated shared access signature tokens, and should be used whenever possible.</span></span> <span data-ttu-id="01290-211">서버 저장 정책에 정의된 설정은 새 토큰을 발급하지 않고 토큰에 변경되고 반영될 수 있지만, 토큰에 정의된 설정은 새 토큰을 발급하지 않고 변경될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-211">Settings defined in a server-stored policy can be changed and are reflected in the token without requiring a new token to be issued, but settings defined in the token can't be changed without issuing a new token.</span></span> <span data-ttu-id="01290-212">이 접근 방식은 만료 전에 유효한 공유 액세스 서명을 취소하는 것이 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-212">This approach also makes it possible to revoke a valid shared access signature token before it's expired.</span></span>

> <span data-ttu-id="01290-213">자세한 내용은 MSDN의 [테이블 SAS(공유 액세스 서명), 큐 SAS 및 Blob SAS 업데이트 소개](https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/12/introducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas/) 및 [공유 액세스 서명 사용](https://azure.microsoft.com/documentation/articles/storage-dotnet-shared-access-signature-part-1/)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="01290-213">For more information see [Introducing Table SAS (Shared Access Signature), Queue SAS and update to Blob SAS](https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/12/introducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas/) and [Using Shared Access Signatures](https://azure.microsoft.com/documentation/articles/storage-dotnet-shared-access-signature-part-1/) on MSDN.</span></span>

<span data-ttu-id="01290-214">다음 코드는 5분 동안 유효한 공유 액세스 서명 토큰을 생성하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="01290-214">The following code shows how to create a shared access signature token that's valid for five minutes.</span></span> <span data-ttu-id="01290-215">`GetSharedAccessReferenceForUpload` 메서드는 Azure Blob Storage에 파일을 업로드하는 데 사용될 수 있는 공유 액세스 서명 토큰을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-215">The `GetSharedAccessReferenceForUpload` method returns a shared access signatures token that can be used to upload a file to Azure Blob Storage.</span></span>

```csharp
public class ValuesController : ApiController
{
  private readonly CloudStorageAccount account;
  private readonly string blobContainer;
  ...
  /// <summary>
  /// Return a limited access key that allows the caller to upload a file
  /// to this specific destination for a defined period of time.
  /// </summary>
  private StorageEntitySas GetSharedAccessReferenceForUpload(string blobName)
  {
    var blobClient = this.account.CreateCloudBlobClient();
    var container = blobClient.GetContainerReference(this.blobContainer);

    var blob = container.GetBlockBlobReference(blobName);

    var policy = new SharedAccessBlobPolicy
    {
      Permissions = SharedAccessBlobPermissions.Write,

      // Specify a start time five minutes earlier to allow for client clock skew.
      SharedAccessStartTime = DateTime.UtcNow.AddMinutes(-5),

      // Specify a validity period of five minutes starting from now.
      SharedAccessExpiryTime = DateTime.UtcNow.AddMinutes(5)
    };

    // Create the signature.
    var sas = blob.GetSharedAccessSignature(policy);

    return new StorageEntitySas
    {
      BlobUri = blob.Uri,
      Credentials = sas,
      Name = blobName
    };
  }

  public struct StorageEntitySas
  {
    public string Credentials;
    public Uri BlobUri;
    public string Name;
  }
}
```

> <span data-ttu-id="01290-216">전체 예제는 [GitHub](https://github.com/mspnp/cloud-design-patterns/tree/master/valet-key)에서 다운로드할 수 있는 ValetKey 솔루션에서 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-216">The complete sample is available in the ValetKey solution available for download from [GitHub](https://github.com/mspnp/cloud-design-patterns/tree/master/valet-key).</span></span> <span data-ttu-id="01290-217">이 솔루션의 ValetKey.Web 프로젝트는 위와 같은 `ValuesController` 클래스를 포함한 웹 응용 프로그램을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-217">The ValetKey.Web project in this solution contains a web application that includes the `ValuesController` class shown above.</span></span> <span data-ttu-id="01290-218">공유 액세스 서명 키를 검색하고 Blob Storage에 파일을 업로드하는 데 이 웹 응용 프로그램을 사용하는 예제 클라이언트 응용 프로그램은 ValetKey.Client 프로젝트에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-218">A sample client application that uses this web application to retrieve a shared access signatures key and upload a file to blob storage is available in the ValetKey.Client project.</span></span>

## <a name="next-steps"></a><span data-ttu-id="01290-219">다음 단계</span><span class="sxs-lookup"><span data-stu-id="01290-219">Next steps</span></span>

<span data-ttu-id="01290-220">이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-220">The following patterns and guidance might also be relevant when implementing this pattern:</span></span>
- <span data-ttu-id="01290-221">이 패턴을 [GitHub](https://github.com/mspnp/cloud-design-patterns/tree/master/valet-key)에서 사용할 수 있음을 보여주는 샘플.</span><span class="sxs-lookup"><span data-stu-id="01290-221">A sample that demonstrates this pattern is available on [GitHub](https://github.com/mspnp/cloud-design-patterns/tree/master/valet-key).</span></span>
- <span data-ttu-id="01290-222">[게이트키퍼 패턴](gatekeeper.md)</span><span class="sxs-lookup"><span data-stu-id="01290-222">[Gatekeeper pattern](gatekeeper.md).</span></span> <span data-ttu-id="01290-223">이 패턴은 클라이언트와 응용 프로그램 또는 서비스 간 브로커 역할을 하는 전용 호스트 인스턴스를 사용하여 응용 프로그램 및 서비스를 보호하는 데 발레 키 패턴과 함께 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-223">This pattern can be used in conjunction with the Valet Key pattern to protect applications and services by using a dedicated host instance that acts as a broker between clients and the application or service.</span></span> <span data-ttu-id="01290-224">게이트키퍼는 요청의 유효성을 검사하고 삭제하고, 클라이언트와 응용 프로그램 간에 요청 및 데이터를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-224">The gatekeeper validates and sanitizes requests, and passes requests and data between the client and the application.</span></span> <span data-ttu-id="01290-225">보안의 추가적인 계층을 제공하고 공격에 노출되는 시스템 부분을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-225">Can provide an additional layer of security, and reduce the attack surface of the system.</span></span>
- <span data-ttu-id="01290-226">[정적 콘텐츠 호스팅 패턴](static-content-hosting.md).</span><span class="sxs-lookup"><span data-stu-id="01290-226">[Static Content Hosting pattern](static-content-hosting.md).</span></span> <span data-ttu-id="01290-227">정적 리소스를 클라이언트에 직접 전달할 수 있는 클라우드 기반 저장소 서비스에 배포하여 비용이 많이 드는 계산 인스턴스에 대한 요구를 줄이는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="01290-227">Describes how to deploy static resources to a cloud-based storage service that can deliver these resources directly to the client to reduce the requirement for expensive compute instances.</span></span> <span data-ttu-id="01290-228">리소스를 공개적으로 사용하려는 경우가 아니면 발레 키 패턴을 사용하여 보안을 유지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="01290-228">Where the resources aren't intended to be publicly available, the Valet Key pattern can be used to secure them.</span></span>
- [<span data-ttu-id="01290-229">테이블 SAS(공유 액세스 서명), 큐 SAS 및 Blob SAS 업데이트 소개</span><span class="sxs-lookup"><span data-stu-id="01290-229">Introducing Table SAS (Shared Access Signature), Queue SAS and update to Blob SAS</span></span>](https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/12/introducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas/)
- [<span data-ttu-id="01290-230">공유 액세스 서명 사용</span><span class="sxs-lookup"><span data-stu-id="01290-230">Using Shared Access Signatures</span></span>](https://azure.microsoft.com/documentation/articles/storage-dotnet-shared-access-signature-part-1/)
- [<span data-ttu-id="01290-231">Service Bus를 사용한 공유 액세스 서명 인증</span><span class="sxs-lookup"><span data-stu-id="01290-231">Shared Access Signature Authentication with Service Bus</span></span>](https://azure.microsoft.com/documentation/articles/service-bus-shared-access-signature-authentication/)
