---
title: Federated Identity
description: Delegate authentication to an external identity provider.
keywords: design pattern
author: dragon119
ms.service: guidance
ms.topic: article
ms.author: pnp
ms.date: 03/24/2017

pnp.series.title: Cloud Design Patterns
pnp.pattern.categories: [security]
---

# 페더레이션 ID

[!INCLUDE [header](../_includes/header.md)]

외부 ID 공급자에게 인증을 위임합니다. 이렇게 하면 개발을 단순화하고, 사용자 관리의 요구 사항을 최소화하며, 응용 프로그램의 사용자 경험을 개선할 수 있습니다.

## 배경 및 문제

일반적으로 사용자는 비즈니스 관계에 있는 다양한 조직이 제공하고 호스팅하는 여러 응용 프로그램으로 업무를 볼 필요가 있습니다. 이와 같은 사용자에게는 각자 특정한(다른) 자격 증명을 사용할 필요가 있습니다. 그러면 다음과 같은 일이 발생할 수 있습니다.

- **사용자 경험 단절**. 서로 다른 자격 증명을 사용하는 사용자는 로그인 자격 증명을 잊어버리기 일쑤입니다.

- **보안 취약성 노출**. 사용자가 퇴사하면 해당 계정에 대한 프로비전을 즉시 해제해야 하는데, 큰 조직에서는 이를 간과하기 쉽습니다.

- **사용자 관리의 복잡성 증가**. 관리자는 모든 사용자의 자격 증명을 관리해야 하며 암호 힌트 제공과 같은 추가 작업을 수행해야 합니다.

보통 사용자는 이런 모든 응용 프로그램에 동일한 자격 증명의 사용을 선호합니다.v

## 해결책

페더레이션 ID를 사용할 수 있는 인증 방식을 구현합니다. 응용 프로그램 코드에서 사용자 인증을 분리하고 인증을 신뢰할 수 있는 ID 공급자에게 위임합니다. 이렇게 하면 개발을 단순화하고 관리 오버헤드를 최소화하면서 다양한 ID 공급자(IdP)를 사용해 사용자를 인증할 수 있습니다. 또한 권한 부여와 인증을 명확하게 분리할 수도 있습니다.

신뢰할 수 있는 ID 공급자에는 비즈니스 파트너 또는 Microsoft, Google, Yahoo!, Facebook 계정을 보유한 사용자를 인증할 수 있는 소셜 ID 공급자가 제공하는 회사 디렉터리, 온-프레미스 페더레이션 서비스 및 기타 보안 토큰 서비스(STS)가 포함됩니다.

다음 그림은 클라이언트 응용 프로그램이 인증을 요구하는 서비스에 액세스해야 할 때의 페더레이션 ID 패턴을 보여줍니다. 인증은 STS와 연계하여 작동하는 IdP를 통해 수행됩니다. IdP는 인증된 사용자에 대한 정보를 제공하는 보안 토큰을 발행합니다. 클레임이라고 부르는 이런 정보는 사용자의 ID를 포함하며 역할 멤버 자격과 더 세분화된 액세스 권한 같은 다른 정보도 포함할 수 있습니다.

![An overview of federated authentication](./_images/federated-identity-overview.png)


클레임 기반 액세스 제어라고 불리기도 하는 이 모델에서 응용 프로그램과 서비스는 토큰에 포함된 클레임을 기반으로 기능에 대한 액세스 권한을 부여합니다. 인증이 필요한 서비스는 반드시 IdP를 신뢰해야 합니다. 클라이언트 응용 프로그램은 인증을 수행하는 IdP와 통신합니다. 인증이 성공하면 IdP는 사용자를 식별하는 클레임을 포함한 토큰을 STS에 반환합니다(IdP와 STS는 동일한 서비스일 수 있습니다.). STS는 클라이언트에 클레임을 반환하기 전에 사전 정의된 규칙을 기반으로 토큰의 클레임을 변환하고 증가시킬 수 있습니다. 그런 다음 클라이언트 응용 프로그램은 이런 토큰을 식별 증거로 서비스에 전달할 수 있습니다.

> 신뢰 체인에는 추가 STS가 있을 수 있습니다. 예를 들면 나중에 설명할 시나리오에서 온-프레미스 STS는 사용자 인증을 위해 ID 공급자에 액세스하는 다른 STS를 신뢰합니다. 이런 접근 방식은 온-프레미스 STS와 디렉터리가 있는 기업 시나리오에서 일반적입니다.

페더레이션 인증은 다양한 도메인에서 ID를 신뢰하는 문제에 대한 표준 기반 해결책을 제공하며 SSO(Single Sign-On) 기능을 지원할 수 있습니다. 페더레이션 인증은 ID 공급자에게 직접 네트워크로 연결할 필요 없이 SSO(Single Sign-On) 기능을 지원하기 때문에, 모든 유형의 응용 프로그램, 특히 클라우드 호스팅 응용 프로그램에서 점점 보편화되는 추세입니다. 사용자는 응용 프로그램마다 자격 증명을 입력할 필요가 없습니다. 이런 방식은 많은 다른 응용 프로그램에 액세스하는 데 필요한 자격 증명을 만들지 않기 때문에 보안이 향상됩니다. 또한 원래 ID 공급자를 제외한 모든 대상에게 사용자의 자격 증명을 표시하지 않습니다.  응용 프로그램은 토큰 내에 포함되는 인증된 ID 정보만 확인할 수 있습니다.

페더레이션 ID는 ID와 자격 증명의 관리가 ID 공급자의 책임이라는 주요 이점도 제공합니다. 응용 프로그램이나 서비스는 ID 관리 기능을 제공할 필요가 없습니다. 또한 회사 시나리오에서 회사 디렉터리도 ID 공급자를 신뢰하는 경우 사용자를 확인할 필요가 없습니다. 따라서 회사 디렉터리 내의 사용자 ID를 관리하는 관리 오버헤드가 모두 제거됩니다.

## 문제 및 고려 사항

페더레이션 인증을 구현하는 응용 프로그램을 설계할 때는 다음을 고려해야 합니다.

- 인증은 단일 실패 지점이 될 수 있습니다. 응용 프로그램을 여러 데이터 센터에 배포하는 경우에는 응용 프로그램의 안정성과 가용성을 유지하기 위해 동일한 데이터 센터에 ID 관리 메커니즘의 배포를 고려해야 합니다.

- 인증 도구는 인증 토큰에 포함된 역할 클레임을 기반으로 액세스 제어를 구성할 수 있습니다. 역할 기반 액세스 제어(RBAC)라고 부르는 이런 방식을 활용하면 기능과 리소스에 대한 액세스를 더 세분화된 수준으로 제어할 수 있습니다.

- 회사 디렉터리와 달리 소셜 ID 공급자를 사용하는 클레임 기반 인증은 일반적으로 이메일 주소와 이름을 제외하고는 인증된 사용자에 대한 정보를 제공하지 않습니다. Microsoft 계정과 같은 일부 소셜 ID 공급자만 고유 식별자를 제공합니다. 보통 응용 프로그램은 등록된 사용자에 대한 일부 정보를 유지할 필요가 있고 이런 정보를 토큰의 클레임에 포함된 식별자와 일치시킬 수 있어야 합니다. 일반적으로 이런 일치는 사용자가 응용 프로그램에 처음 액세스할 때 등록을 통해 이루어지고, 그런 다음에는 정보가 각각의 인증 후 추가 클레임으로 토큰에 삽입됩니다.

- STS에 구성된 ID 공급자가 하나 이상이면 인증을 위해 사용자가 리디렉션되어야 하는 ID 공급자를 검색해야 합니다. 이런 프로세스는 홈 영역 검색이라 부릅니다. STS는 사용자가 제공하는 이메일 주소 또는 사용자 이름, 사용자가 액세스 중인 응용 프로그램의 하위 도메인, 사용자의 IP 주소 범위 또는 사용자 브라우저에 저장된 쿠키의 내용을 기반으로 홈 영역 검색을 자동으로 수행할 수 있습니다. 예를 들어 사용자가 Microsoft 도메인에 user@live.com과 같은 이메일 주소를 입력하면 STS는 사용자를 Microsoft 계정 로그인 페이지로 리디렉션합니다. 나중에 방문할 때 STS는 쿠키를 사용해 마지막 로그인이 Microsoft 계정이었다는 것을 표시할 수 있습니다. 자동 검색으로 홈 영역을 결정할 수 없으면 STS는 신뢰할 수 있는 ID 공급자를 나열하는 홈 영역 검색 페이지를 표시할 것이고 사용자는 사용을 원하는 ID 공급자를 선택해야 합니다.

## 패턴 사용 사례

다음 시나리오에는 이 패턴이 유용합니다.

- **기업 SSO(Single Sign-On)**. 이 시나리오에서는 응용 프로그램을 방문할 때마다 로그인할 필요가 없고, 회사 보안 경계를 벗어나는 클라우드에서 호스팅되는 회사 응용 프로그램에 대해서만 인증하면 됩니다. 사용자 경험은 회사 네트워크에 로그인할 때 인증을 거친 뒤에는 다시 로그인할 필요 없이 관련된 모든 응용 프로그램에 액세스할 수 있는 온-프레미스 응용 프로그램을 사용할 때와 동일합니다.

- **여러 파트너의 페더레이션 ID**. 이 시나리오에서는 회사 디렉터리에 계정이 없는 회사 직원과 비즈니스 파트너를 모두 인증해야 합니다. 이런 방식은 기업 대 기업 응용 프로그램, 타사 서비스를 통합하는 응용 프로그램 및 다양한 IT 시스템을 사용하는 회사가 리소스를 병합하거나 공유하는 경우에 일반적으로 사용됩니다.

- **SaaS 응용 프로그램에서 페더레이션 ID**. 이 시나리오에서 독립 소프트웨어 공급업체는 여러 클라이언트 또는 테넌트에 즉시 사용 가능한 서비스를 제공합니다. 각 테넌트는 적절한 ID 공급자를 사용해 인증합니다. 예를 들면 비즈니스 사용자는 회사 디렉터리를 사용하는 반면, 소비자와 테넌트의 클라이언트는 소셜 ID 자격 증명을 사용합니다.

다음의 상황에는 이 패턴이 유용하지 않습니다.

- 응용 프로그램의 모든 사용자를 하나의 ID 공급자를 통해 인증할 수 있고 다른 ID 공급자를 사용해 인증할 필요가 없는 경우. VPN을 사용하거나 클라우드 호스팅 시나리오에서 온-프레미스 디렉터리와 응용 프로그램 사이의 가상 네트워크 연결을 통해 회사 디렉터리(응용 프로그램에서 액세스 가능)를 사용해 인증하는 비즈니스 응용 프로그램이 대표적인 사례입니다.

- 응용 프로그램이 원래 다른 인증 방식(사용자 지정 사용자 저장소)을 사용해 작성되었거나 클레임 기반 기술에서 사용하는 협상 기준을 처리하는 기능을 제공하지 않는 경우. 기존 응용 프로그램에 대한 클레임 기반 인증과 액세스 제어의 변경은 복잡할 수 있고 경제적이지 않습니다.

## 예제

Microsoft Azure에서 다중 테넌트 SaaS(software as a service) 응용 프로그램을 호스팅하는 조직이 있습니다. 이 응용 프로그램에는 테넌트 사용자가 사용하는 응용 프로그램을 관리하기 위해 테넌트가 활용할 수 있는 웹 사이트가 포함됩니다. 응용 프로그램은 조직의 자체 Active Directory를 통해 사용자를 인증할 때 ADFS(Active Directory Federation Services)가 생성한 페더레이션 ID를 사용해 테넌트가 웹 사이트에 액세스하도록 허용합니다.

![How users at a large enterprise subscriber access the application](./_images/federated-identity-multitenat.png)


위의 그림은 테넌트가 자체 ID 공급자(1단계)인 ADFS로 인증하는 방법을 보여줍니다. 테넌트 인증에 성공하면 ADFS는 토큰을 발행합니다. 클라이언트 브라우저는 SaaS 페더레이션 공급자에 유효한 토큰을 다시 가져오기 위해(2단계) 이 토큰을 SaaS 응용 프로그램의 페더레이션 공급자(테넌트의 ADFS가 발행한 토큰을 신뢰)에게 전달합니다. 필요한 경우, SaaS 페더레이션 공급자는 새로운 토큰을 클라이언트 브라우저에 반환하기 전에 토큰의 클레임을 응용 프로그램이 인식하는 클레임으로 변환(3단계)합니다. 응용 프로그램은 SaaS 페더레이션 공급자가 발행한 토큰을 신뢰하고 토큰의 클레임을 사용해 권한 부여 규칙을 적용합니다(4단계).

테넌트는 응용 프로그램에 액세스하기 위한 별도의 자격 증명을 기억할 필요가 없고, 테넌트 회사의 관리자는 응용 프로그램에 액세스할 수 있는 사용자 목록을 자체 ADFS에 구성할 수 있습니다.

## 관련 지침

- [Microsoft Azure Active Directory](https://azure.microsoft.com/services/active-directory/)
- [AD DS(Active Directory Domain Services)](https://msdn.microsoft.com/library/bb897402.aspx)
- [AD FS(Active Directory Federation Services)](https://msdn.microsoft.com/library/bb897402.aspx)
- [Microsoft Azure에서 다중 테넌트 응용 프로그램을 위한 ID 관리](https://azure.microsoft.com/documentation/articles/guidance-multitenant-identity/)
- [Azure에서 다중 테넌트 응용 프로그램](https://azure.microsoft.com/documentation/articles/dotnet-develop-multitenant-applications/)
