---
title: Sharding
description: Divide a data store into a set of horizontal partitions or shards.
keywords: design pattern
author: dragon119
ms.service: guidance
ms.topic: article
ms.author: pnp
ms.date: 03/24/2017

pnp.series.title: Cloud Design Patterns
pnp.pattern.categories: [data-management, performance-scalability]
---

# 샤딩(Sharding)

[!INCLUDE [header](../_includes/header.md)]

데이터 저장소를 수직 분할 또는 샤드로 나눕니다. 이를 통해 많은 데이터를 저장하고 액세스할 때 확장성을 개선할 수 있습니다.

## 컨텍스트와 문제점

단일 서버에 의해 호스트된 데이터 저장소는 다음과 같은 제한을 받을 수 있습니다.

- **저장소 공간**. 대규모 클라우드 응용 프로그램을 위한 데이터 저장소는 시간에 따라 크게 늘어날 수 있는 대규모 데이터를 포함할 것으로 예상됩니다. 서버는 일반적으로 한정된 디스크 저장소만 제공하지만, 데이터 볼륨이 늘어남에 따라 기존의 디스크를 큰 것으로 교체하거나 컴퓨터에 디스크를 추가할 수 있습니다. 그러나, 시스템은 결국 정해진 서버의 저장소 용량을 쉽게 늘리는 것이 불가능한 한계에 이르게 됩니다.

- **컴퓨팅 리소스**. 클라우드 응용 프로그램은 다수의 동시 사용자를 지원해야 합니다. 이 사용자 개개인은 데이터 저장소에서 정보를 검색하는 쿼리를 실행합니다. 데이터 저장소를 호스팅하는 단일 서버는, 데이터를 저장하고 검색하려고 하는 응용 프로그램이 시간 초과되면서, 사용자 응답 시간이 길어지고 빈번한 실패를 야기함에 따라, 이 부하를 지원하는 데 필요한 처리 능력을 제공하지 못할 수 있습니다. 메모리를 추가하거나 프로세서를 업데이트하는 것이 가능할 수도 있지만, 더 이상 계산 리소스 늘리는 것이 불가능하면 시스템은 한계에 도달하게 됩니다.

- **네트워크 대역**. 궁극적으로 단일 서버에서 실행되는 데이터 저장소의 성능은 서버가 요청을 검색하고 응답을 전송할 수 있는 속도에 따라 통제됩니다. 네트워크 트래픽 볼륨이 서버 연결에 사용된 네트워크 용량을 초과하여, 요청 실패를 야기할 수 있습니다.

- **지역**. 법적, 규정 준수, 성능상의 이유로, 또는 데이터 액세스의 대기 시간을 줄이려고, 같은 지역에 있는 특정 사용자들에 의해 생성된 데이터를 저장해야할 수 있습니다. 사용자들이 여러 나라나 지역에 분산된 경우, 단일 데이터 저장소에 응용 프로그램의 전체 데이터를 저장하는 것이 불가능할 수 있습니다.

디스크 용량, 처리 능력, 메모리, 네트워크 연결을 추가하여 수직적으로 확장하는 작업은 이러한 한계의 영향을 늦출 수 있지만, 일시적 해결책에 불과할 수 있습니다. 많은 사용자와 대용량 데이터를 지원할 수 있는 상용 클라우드 응용 프로그램은 거의 무한정으로 크기 조정이 가능해야 하기 때문에, 수직적 확장이 반드시 최선의 솔루션은 아닙니다.

## 솔루션

데이터 저장소를 수직 분할 또는 샤드로 나눕니다. 각 샤드는 같은 스키마를 갖지만. 자체적으로 구분한 데이터 부분집합을 관리합니다. 샤드는 자체 능력을 갖는 (다양한 유형의 많은 항목에 대한 데이터를 보유할 수 있음) 데이터 저장소로, 저장소 노드 역할을 하는 서버에서 실행됩니다.

이 패턴의 장점은 다음과 같습니다:

- 추가 저장소 노드에서 실행되는 샤드를 추가하여 시스템 규모를 확장할 수 있습니다.

- 시스템은 저장소 노드에 특수하고 값비싼 컴퓨터보다 양산되는 하드웨어를 사용할 수 있습니다.

- 사드에 작업량을 분산하여 경합을 줄이고 성능을 개선할 수 있습니다.

- 클라우드에서, 샤드는 데이터를 액세스할 사용자들과 물리적으로 가까이 있습니다.

데이터 저장소를 샤드로 분배할 때, 각 샤드에 어떤 데이터가 배치되어야 할지를 결정합니다.  일반적으로 샤드는 특성이 하나 이상인 데이터에 의해 결정된 특정한 범위에 속한 항목들을 포함합니다. 이 특성들은 공유 키를 만듭니다(종종 파티션 키라고 함). 공유 키는 정적이어야 합니다. 변경될 수 있는 데이터에 근거하면 안 됩니다.

샤딩은 데이터를 물리적으로 구조화합니다. 응용 프로그램이 데이터를 저장하고 검색할 때, 샤딩 로직은 응용 프로그램을 적절한 샤드로 전달합니다. 이 샤딩 로직은 응용 프로그램에서 데이터 액세스 코드의 일부로 구현되거나, 샤딩을 투명하게 지원할 경우 데이터 저장소 시스템에 의해 구현될 수 있습니다.

데이터의 물리적 위치를 샤딩 로직으로 요약하는 것은 어떤 샤드가 어떤 데이터를 포함하는지에 대하여 상위 수준의 관리를 제공하는 것입니다. 샤드에 있는 데이터가 추후 재분배되어야 할 경우(예를 들면, 샤드가 불균형한 경우), 응용 프로그램의 비즈니스 로직을 재작업하지 않고 샤드끼리 데이터를 마이그레이션할 수 있습니다. 절충(tradeoff)은 각 데이터 항목 검색 시 그 위치 결정에 필요한 추가적인 데이터 액세스 오버헤드입니다.

최적의 성능과 확장성을 위해서, 응용 프로그램이 수행하는 쿼리 유형에 적절한 방식으로 데이터를 분할하는 것이 중요합니다. 많은 경우에, 샤딩 체계는 모든 쿼리의 요구 사항과 정확히 일치할 가능성이 낮습니다. 예를 들면, 다중 테넌트 시스템에서 응용 프로그램은 테넌트 ID로 테넌트 데이터를 검색해야 할 수 있지만, 이 데이터를 테넌트 이름이나 위치 등 다른 특성에 근거하여 찾아야 할 수도 있습니다. 이런 상황을 처리하기 위해서는, 가장 일반적으로 수행되는 쿼리를 지원하는 샤드 키로 샤딩 전략을 구현합니다.

쿼리가 특성 값을 조합하여 규칙적으로 데이터를 검색할 경우, 아마도 특성을 함께 연결시켜서 복합 샤드 키를 정의할 수 있을 것입니다. 그렇지 않고, 샤드 키로 찾을 수 없는 데이터를 빨리 찾기 위해서는, [인덱스 테이블](index-table.md) 과 같은 패턴을 사용합니다.

## 샤딩 전략

샤드 키를 선택하고 샤드에 데이터를 어떻게 분배할지 결정할 때 일반적으로 사용하는 3가지 전략이 있습니다. 샤드와 그것을 호스트하는 서버가 일대일로 대응할 필요가 없음에 주의하세요 - 단일 서버는 다수의 샤드를 호스트할 수 있습니다. 전략은 다음과 같습니다:

**검색 전략**. 이 전략에서 샤드 로직은 샤드 키를 사용하여, 데이터 요청을 그 데이터를 포함한 샤드로 경로 지정하는 맵을 구현합니다.  다중 테넌트 응용 프로그램에서 한 테넌트의 모든 데이터는 샤드 키로 테넌트 ID를 사용하여 샤드에 함께 저장될 수 있습니다. 다중 테넌트는 같은 샤드를 공유할 수 있지만, 단일 테넌트의 데이터는 다중 샤드에 분배되지 않습니다. 그림은 테넌트 ID를 기준으로 한 샤딩 테넌트 데이터를 보여줍니다.

   ![Figure 1 - Sharding tenant data based on tenant IDs](./_images/sharding-tenant.png)


   샤드 키와 물리적 저장소 사이의 매핑은 각 샤드 키가 물리적 파티션에 표시되는 물리적 샤드에 근거할 수 있습니다. 또는, 더 유연한 샤드 재분배 기술은 가상 파티션으로서, 이 기술에 의하면 샤드 키는 같은 수의 가상 샤드에 표시되고, 결국 더 적은 수의 물리적 파티션에 표시됩니다. 이 접근 방식에서, 응용 프로그램은 가상 샤드를 참조하는 샤드 키를 사용하여 데이터를 찾고, 시스템은 가상 샤드를 물리적 파티션에 투명하게 표시합니다. 가상 샤드와 물리적 파티션 사이의 매핑은 다양한 샤드 키 사용을 위해 응용 프로그램 코드를 수정하지 않고도 변경될 수 있습니다.

**범위 전략**. 이 전략은 관련된 항목을 같은 샤드에 함께 그룹으로 묶고 샤드 키에 따라 정리합니다 - 샤드 키는 순차적입니다. 범위 쿼리로 항목을 자주 검색하는 응용 프로그램에 유용합니다(일정한 범위에 속하는 샤드 키에 대한 데이터 항목을 반환하는 쿼리). 예를 들면, 응용 프로그램이 일정한 달에 내린 모든 주문을 찾아야할 경우, 한 달 동안 모든 주문이 같은 샤드에 날짜와 시간 순서로 저장되었다면 이 데이터는 더 빨리 검색될 수 있습니다. 각 주문이 다른 샤드에 저장된 경우, 많은 포인트 쿼리를(단일 데이터 항목을 반환하는 쿼리) 수행하여 주문을 개별적으로 가져와야 합니다. 다음 그림은 순차적 데이터 세트를 샤드에 저장한 모습을 보여줍니다.

   ![Figure 2 - Storing sequential sets (ranges) of data in shards](./_images/sharding-sequential-sets.png)

이 예에서, 샤드 키는 가장 중요한 요소로 주문한 달을, 그 다음으로 주문한 날짜와 시간을 포함하는 복합 키입니다. 새 주문이 생성되어 샤드에 추가되면 주문 데이터는 자연스럽게 정렬됩니다. 어떤 데이터 저장소는 샤드를 식별하는 분할 키와 샤드에서 항목을 유일하게 식별하는 행 키를 포함한, 두 부분으로 구성된(two-part) 샤드 키를 지원합니다. 일반적으로 데이터는 샤드에 행 키 순서로 저장됩니다. 범위 쿼리를 조건으로 하고 함께 그룹화되어야 하는 항목들은, 파티션 키에 대해서는 같은 값을 갖지만 샤드 키에 대해서는 고유한 값을 갖는 샤드 키를 사용할 수 있습니다. 

**해시 전략**. 이 전략의 목적은 핫스폿(부적절한 양의 부하를 받는 샤드) 기회를 줄이는 것입니다. 샤드의 크기와 샤드가 맞닥뜨릴 부하 사이에 균형 잡힌 방식으로 데이터를 샤드에 분배합니다. 샤딩 로직은 데이터의 다수의 특성에 대한 해시에 근거하여 항목을 저장할 샤드를 계산합니다. 선택된 해시 함수는 가능하면 무작위 요소들을 계산에 도입하여, 데이터를 샤드에 골고루 분배해야 합니다.  다음 그림은 테넌트 ID의 해시에 근거하여 테넌트 데이터를 샤딩하는 것을 보여줍니다.

   ![Figure 3 - Sharding tenant data based on a hash of tenant IDs](./_images/sharding-data-hash.png)

다른 샤딩 전략에 대비하여 해시 전략의 장점을 이해하려면, 새 테넌트를 순차적으로 등록한 다중 테넌트 응용 프로그램이 어떤 식으로 데이터 저장소에서 샤드에 테넌트를 지정할 수 있는지 고려해보아야 합니다. 범위 전략을 사용할 때, 테넌트 1 ~ n의 데이터는 모두 샤드 A에, 테넌트 n+1 ~ m의 데이터는 모두 샤드 B에, ... 이런 식으로 저장됩니다. 가장 최근에 등록된 테넌트가 가장 활동적인 경우, 대부분의 데이터 활동은 소수의 샤드에서 발생하고, 이것이 핫스폿을 야기할 수 있습니다. 반대로, 해시 전략은 테넌트를 테넌트 ID의 해시에 근거한 샤드에 할당합니다. 이는 순차적인 테넌트가 다양한 샤드에 할당될 가능성이 높고, 결국 여러 샤드에 부하를 배분한다는 뜻입니다. 앞의 그림은 테넌트 55와 56에 대하여 이 전략을 보여줍니다.

3가지 샤딩 전략에는 다음과 같은 장점과 고려사항이 있습니다:

- **검색**. 샤드가 구성되고 사용되는 방식을 제어합니다. 가상 샤드를 사용하면 새로운 물리적 파티션이 추가되어 작업량을 골고루 배분할 수 있기 때문에 데이터 재분배 시 충격이 줄어듭니다. 샤드를 구현하는 가상 샤드와 물리적 파티션 사이의 매핑은 데이터 저장 및 검색에 샤드 키를 사용하는 응용 프로그램 코드에 영향을 주지 않고 수정될 수 있습니다. 샤드 위치 검색은 추가 오버헤드가 발생할 수 있습니다.

- **범위**. 단일 작업에서 단일 샤드로부터 여러 데이터 항목을 자주 가져올 수 있는 범위 쿼리와 잘 맞고 구현하기 쉽습니다. 이 전략은 데이터 관리가 쉽습니다. 예를 들면, 지역이 같은 사용자들이 같은 샤드에 있을 경우, 업데이트 일정이 그 지역의 부하와 요구 패턴에 근거한 각 시간대에 계획될 수 있습니다. 그러나, 이 전략은 샤드에서 적합한 분산을 제공하지 않습니다. 샤드 재분산은 어렵고, 다수의 활동이 인접한 샤드 키에 관한 것일 경우 불균등한 부하 문제를 해결할 수 없습니다.

- **해시**. 보다 균등한 데이터와 부하 분산이라는 더 좋은 기회를 제공합니다. 경로 설정 요청은 해시 함수를 사용하여 직접 수행할 수 있습니다. 맵을 유지 관리할 필요가 없습니다. 해시 계산은 추가적인 오버헤드를 부여할 수 있음을 주의하세요. 샤드 재분산(rebalancing)도 어렵습니다.

가장 일반적인 샤딩 시스템들은 위에서 설명한 접근 방식 중 하나를 구현하는데, 응용 프로그램의 비즈니스 요구 사항과 그 데이터 사용 패턴도 고려해야 합니다. 예를 들면, 다중 테넌트 응용 프로그램에서:

- 작업량에 근거하여 데이터를 분할할 수 있습니다. 별도의 샤드에서 고휘발성 테넌트에 대한 데이터를 분리할 수 있습니다. 결과적으로 다른 테넌트에 대한 데이터 액세스 속도가 개선될 수 있습니다.

- 테넌트 위치에 근거하여 데이터를 분할할 수 있습니다. 백업 및 유지 관리를 위해 피크 시간이 아닌 때 특정 지역의 테넌트 데이터를 오프라인으로 가져올 수 있는 반면, 다른 지역의 테넌트 데이터는 온라인으로 유지되며 근무시간에 액세스할 수 있습니다.

- 고가의 테넌트가 개인 소유의, 성과가 높고 부하가 낮은 샤드로 할당되는 반면, 저가의 테넌트는 더 밀집되고 바쁜 샤드를 공유할 것으로 예상됩니다.

- 고도의 데이터 격리와 프라이버시가 필요한 테넌트 데이터는 완전히 분리된 서버에 저장될 수 있습니다.

## 크기 조정 및 데이터 이동 작업

각 샤딩 전략은 규모 축소, 규모 확장, 데이터 이동, 유지 관리 상태를 관리하기 위한 다양한 기능과 복잡도를 나타냅니다.

검색 전략은 온라인이든 오프라인이든, 사용자 수준에서 수행될 수 있도록 크기 조정과 데이터 이동 작업을 허용합니다. 이 기법은 사용자 활동 일부 또는 전체를 중단한 후(피크 시간이 아닌 때), 데이터를 새로운 가상 파티선이나 물리적 샤드로 옮기고, 매핑을 변경한 다음, 이 데이터를 보관하는 캐시를 무효화하거나 새로 고치고 나서, 사용자 활동 재개를 허용합니다.  보통 이 유형의 작업은 중앙에서 관리될 수 있습니다. 검색 전략은 캐시가 원활하고 복제하기 쉬운 상태를 요구합니다.

범위 전략은 크기 조정과 데이터 이동 작업을 제한합니다. 따라서, 이런 작업은 일부 또는 모든 데이터 저장소가 오프라인일 때 수행되어야 하는데, 이 때 데이터가 샤드에서 분할되고 병합되기 때문입니다. 대다수 활동이 인접한 샤드 키 또는 같은 범위에 있는 데이터 식별자에 관한 것인 경우, 샤드 재분산을 위한 데이터 이동은 불균등한 부하의 문제점을 해결할 수 없습니다. 범위 전략은 범위를 물리적 파티션에 표시하기 위해서 일부 상태가 그대로 유지되기를 요구할 수도 있습니다.

파티션 키가 샤드 키 또는 데이터 식별자에 대한 해시이기 때문에, 해시 전략은 크기 조정과 데이터 이동을 더 복잡하게 만듭니다. 각 샤드의 새로운 위치가 해시 함수 또는 정확한 매핑을 제공하도록 수정된 함수에서 결정되어야 합니다. 그러나 해시 전략은 상태 관리를 요구하지 않습니다.

## 문제점 및 고려사항

이 패턴을 구현하는 방법을 결정할 때 다음 사항을 고려해야 합니다:

- 샤딩은 수직적 분할, 기능적 분할 등 다른 형태의 분할을 보조합니다.  예를 들면, 단일 샤드는 수직으로 분할된 항목을 포함할 수 있고, 기능적 파티션은 다중 샤드로서 구현될 수 있습니다. 분할에 관한 자세한 정보는, [데이터 분할 지침](https://msdn.microsoft.com/library/dn589795.aspx)을 참조하세요.

- 모든 샤드가 비슷한 용량의 I/O를 처리할 수 있게 샤드를 분산하여 관리합니다. 데이터가 삽입되고 감지됨에 따라, 균등한 분산을 보장하고 핫스폿 기회를 줄이기 위해서 주기적으로 샤드를 재분산하는 것이 필요합니다. 재분산은 비용이 드는 작업일 수 있습니다. 재분산의 필요성을 줄이려면, 각 샤드가 예상되는 변경 분량을 처리할 충분한 여유 공간을 갖게 하여 증가에 대비한 계획을 세웁니다. 필요한 경우, 샤드를 신속히 재분산하는 데 사용할 수 있는 전략과 스크립트를 마련해야 합니다.

- 샤드 키에 대한 안정적 데이터를 사용합니다. 샤드 키가 변경된 경우, 대응하는 데이터 항목은 샤드에서 이동해야 하는데, 이 때 업데이트 작업에 의해 수행되는 작업량이 늘어날 수 있습니다.  이런 이유로, 샤드 키를 잠재적 휘발성 정보에 근거를 두지 않도록 합니다. 그 대신, 불변이거나 자연스럽게 키를 만드는 특성을 검색합니다.

- 샤드 키가 고유한 값인지 확인합니다. 예를 들면, 자동 증가 필드를 샤드 키로 사용하지 않도록 합니다. 시스템에 따라, 자동 증가된 필드는 샤드에서 조정될 수 없으며, 그 결과 다양한 샤드에 있는 항목들이 같은 샤드 키를 갖게 됩니다.

    >  샤드 키가 아닌 다른 필드의 자동 증가 값 또한 문제를 일으킬 수 있습니다. 예를 들면, 고유한 ID를 생성하기 위해 자동 증가된 필드를 사용한 경우, 다양한 샤드에 위치한 두 가지 다른 항목들이 같은 ID로 지정될 수 있습니다.

- 데이터에 대하여 가능한 모든 쿼리의 요구사항과 일치하는 샤드 키를 설계하는 것이 불가능할 수 있습니다. 가장 빈번히 수행되는 쿼리를 지원하기 위해서 데이터를 분할합니다. 또 필요한 경우, 샤드 키에 속하지 않는 특성들에 근거한 기준을 사용하여 데이터를 검색하는 쿼리를 지원하기 위해서 2차 인덱스 테이블을 만듭니다. 자세한 정보는, [인덱스 테이블 패턴](index-table.md)을 참조하세요.

- 단일 샤드만 액세스하는 쿼리는 다중 샤드에서 데이터를 검색하는 쿼리보다 더 효율적이므로, 응용 프로그램이 다양한 샤드에 보유된 데이터와 연결된 다수의 쿼리를 수행하는 샤드 시스템은 구현하지 않도록 합니다. 단일 샤드는 다중 유형의 항목에 대한 데이터를 포함할 수 있음을 기억하세요. 일반적으로 함께 쿼리되는 관련 항목을(고객의 세부 사항과 주문 등) 같은 샤드에 보관하여 응용 프로그램이 별도로 수행하는 읽기 횟수를 줄이려면 데이터 비정규화를 고려해봅니다.

    >  한 샤드에 있는 항목이 다른 샤드에 저장된 항목을 참조할 경우, 첫 번째 항목에 대한 스키마의 일부로서 두 번째 항목에 대한 샤드 키를 포함합니다.  이 경우, 샤드에서 참조 관련 데이터가 액세스하는 쿼리의 성능을 개선하는 데 도움이 될 수 있습니다.

- 응용 프로그램이 다중 샤드에서 데이터를 검색하는 쿼리를 수행해야 하는 경우, 병렬 태스크로 이 데이터를 가져올 수 있습니다. 예를 들면, 팬아웃(fan-out) 쿼리의 경우 다중 샤드에 있는 데이터는 병렬로 검색된 다음 하나의 결과로 합쳐집니다. 그러나, 이 접근 방식은 불가피하게 솔루션의 데이터 액세스 로직의 복잡도를 높입니다.

- 여러 응용 프로그램에서, 다수의 소형 샤드의 생성은 소수의 대형 샤드의 보유보다 더 효율적일 수 있는데, 이는 부하 분산의 기회를 늘릴 수 있기 때문입니다. 이는, 어떤 물리적 장소에서 다른 장소로 샤드를 마이그레이션할 필요성이 예상될 경우, 유용할 수도 있습니다. 소형 샤드의 이동이 대형 샤드의 이동보다 빠릅니다.

- 각 샤드 저장소 노드가 이용할 수 있는 리소스가 데이터 크기와 처리량 관점에서 확장성 요구 사항을 처리하기에 충분한지 반드시 확인합니다. 자세한 정보는, [데이터 분할 지침](https://msdn.microsoft.com/library/dn589795.aspx)의 "확장성을 위한 분할 설계" 절을 참조하세요.

- 모든 샤드에 참조 데이터를 복제하는 것을 고려합니다. 샤드에서 데이터를 검색하는 작업이 동일 쿼리의 일부로서 정적 또는 저속 데이터도 참조할 경우, 이 데이터를 샤드에 추가합니다. 그렇게 하면, 응용 프로그램은 별도의 데이터 저장소를 추가로 왕복하지 않고 쿼리의 모든 데이터를 쉽게 가져올 수 있습니다.

    >  다중 샤드에 보관된 참조 데이터가 변경된경우, 시스템은 모든 샤드에서 이 변경 내용을 동기화해야 합니다. 이 동기화가 일어나는 동안 시스템은 불일치도를 경험할 수 있습니다. 이를 수행하려면, 응용 프로그램이 작업을 처리할 수있게 설계해야 합니다.

- 샤드 간에 참조 무결성과 일관성을 유지하기가 어려울 수 있으므로, 다중 샤드에 있는 데이터에 영향을 주는 작업을 최소화해야 합니다. 응용 프로그램이 샤드에서 데이터를 수정해야 하는 경우, 실제로 완전한 데이터 일관성이 요구되는지 여부를 확인합니다. 대신, 클라우드의 일반적인 접근 방식은 최종 일관성을 구현하는 것입니다. 각 파티션의 데이터가 각각 따로 업데이트되면, 응용 프로그램 로직은 최종 일관성 작업이 실행되는 동안 데이터 쿼리에서 일어날 수 있는 불일치를 처리할 뿐만 아니라 업데이트가 모두 성공적으로 완료되었는지도 확인해야 합니다.  최종 일관성 구현에 관한 자세한 정보는, [데이터 불일치 프라이머](https://msdn.microsoft.com/library/dn589800.aspx)를 참조하세요. 

- 많은 샤드를 구성하고 관리하는 작업은 어려울 수 있습니다. 모니터링, 백업, 일관성 확인, 로깅 또는 감사 등의 태스크는 가능하면 여러 지역에 보관된 다중 샤드와 서버에서 수행되어야 합니다.  이런 태스크는 스크립트나 다른 자동화 솔루션으로 구현되기 쉽지만, 추가적인 관리 요구 사항을 완전히 제거하지는 못할 수 있습니다. 

- 샤드는 그것이 포함하는 데이터가 그 데이터를 사용하는 응용 프로그램의 인스턴스와 가깝게 위치할 수 있습니다. 이 접근 방식은 성능을 크게 개선할 수 있지만, 여러 장소에 있는 다중 샤드를 액세스해야 하는 태스크에 대하여 추가 고려사항을 요구합니다.

## 이 패턴을 사용하는 때

데이터 저장소가 단일 저장소 노드에서 이용 가능한 리소스 이상으로 크기 조정이 필요하거나, 데이터 저장소에서 경합을 줄여 성능 개선이 필요한 경우, 이 패턴을 사용합니다.

>  샤딩의 주안점은 시스템의 성능 및 확장성을 개선하는 것이지만, 부산물로서 데이터가 별도의 파티션으로 어떻게 분할되느냐에 따라 가용성을 개선할 수도 있습니다. 한 파티션에서 오류가 발생했다고 해서 반드시 응용 프로그램이 다른 파티션에 보관된 데이터를 액세스할 수 없는 것은 아닙니다. 또 운영자는 응용 프로그램의 전체 데이터를 액세스 불가로 만들지 않고 유지 관리 또는 하나 이상의 파티션 복구를 수행할 수 있습니다. 자세한 정보는, [데이터 분할 지침](https://msdn.microsoft.com/library/dn589795.aspx)을 참조하세요.

## 예제

C#로 작성된 다음 예제는 샤드 역할을 하는 SQL Server 데이터베이스를 사용합니다.  각 데이터베이스는 응용 프로그램에 의해 사용된 데이터의 부분집합을 갖습니다. 응용 프로그램은 자체의 샤딩 로직을(팬아웃 쿼리의 예) 사용하여 샤드에 분산된 데이터를 검색합니다. 각 샤드에 위치한 데이터의 세부 내용은 `GetShards`라는 메서드에 의해 반환됩니다. 이 메서드는 `ShardInformation` 개체의 열거 목록을 반환하는데, 여기서 `ShardInformation` 유형은 샤드에 대한 식별자와, 응용 프로그램이 샤드 연결에 사용해야 하는 SQL Server 연결 문자열을 포함합니다(연결 문자열은 코드 예제에 표시되지 않음).

```csharp
private IEnumerable<ShardInformation> GetShards()
{
  // This retrieves the connection information from a shard store
  // (commonly a root database).
  return new[]
  {
    new ShardInformation
    {
      Id = 1,
      ConnectionString = ...
    },
    new ShardInformation
    {
      Id = 2,
      ConnectionString = ...
    }
  };
}
```

다음 코드는 응용 프로그램 사용자가 각 샤드에서 병렬로 데이터를 가져오는 쿼리를 수행하기 위해서 `ShardInformation` 개체의 목록을 어떻게 사용하는지 보여줍니다. 자세한 쿼리는 표시되지 않았지만, 이 예제에서 검색된 데이터는 샤드가 고객의 세부 사항을 포함한 경우 고객 이름과 같은 정보를 담을 수 있는 문자열을 포함합니다. 그 결과는 응용 프로그램에 의한 처리를 위해 `ConcurrentBag` 컬렉션으로 수집됩니다.

```csharp
// Retrieve the shards as a ShardInformation[] instance.
var shards = GetShards();

var results = new ConcurrentBag<string>();

// Execute the query against each shard in the shard list.
// This list would typically be retrieved from configuration
// or from a root/master shard store.
Parallel.ForEach(shards, shard =>
{
  // NOTE: Transient fault handling isn't included,
  // but should be incorporated when used in a real world application.
  using (var con = new SqlConnection(shard.ConnectionString))
  {
    con.Open();
    var cmd = new SqlCommand("SELECT ... FROM ...", con);

    Trace.TraceInformation("Executing command against shard: {0}", shard.Id);

    var reader = cmd.ExecuteReader();
    // Read the results in to a thread-safe data structure.
    while (reader.Read())
    {
      results.Add(reader.GetString(0));
    }
  }
});

Trace.TraceInformation("Fanout query complete - Record Count: {0}",
                        results.Count);
```

## 관련 패턴 및 지침

이 패턴을 구현할 때 다음 패턴과 지침 또한 관련될 수 있습니다:
- [데이터 일관성 프라이머](https://msdn.microsoft.com/library/dn589800.aspx). 여러 샤드에 분산된 데이터의 일관성을 유지하는 것이 필요할 수 있습니다. 분산된 데이터에 대해서 일관성 유지를 둘러싼 문제점을 요약하고, 다양한 일관성 모델의 혜택과 절충에 대해 설명합니다.
- [데이터 분할 지침](https://msdn.microsoft.com/library/dn589795.aspx). 데이터 저장소에 대한 분할은 다양한 문제를 추가로 제기할 수 있습니다. 확장성을 개선하고, 경합을 줄이고, 성능을 최적확하기 위해 클라우드의 데이터 저장소 분할과 관련된 이런 문제들에 대해 설명합니다.
- [인덱스 테이블 패턴](index-table.md). 때때로 샤드 키의 설계를 통해서만 쿼리를 완전히 지원하는 것은 불가능합니다. 응용 프로그램이 샤드 키 이외의 키를 지정하여 대규모 데이터 저장소에서 데이터를 빠르게 검색할 수 있게 합니다.
- [구체화 뷰 패턴](materialized-view.md). 쿼리 작업의 성능을 유지하기 위해서, 데이터를 모으고 요약하는 구체화 뷰를 만드는 것이 유용합니다(특히 이 요약 데이터가 샤드에 분산된 정보에 근거한 경우). 이 뷰를 생성하고 표시하는 방법에 대해 설명합니다.
- Adding Simplicity 블로그의 [샤드 학습](http://www.addsimplicity.com/adding_simplicity_an_engi/2008/08/shard-lessons.html).
- 웹 사이트의 [데이터베이스 샤딩](http://dbshards.com/database-sharding/).
- Max Indelicato 블로그의 [확장성 전략 프라이머: 데이터베이스 샤딩](http://blog.maxindelicato.com/2008/12/scalability-strategies-primer-database-sharding.html).
- Dare Obasanjo 블로그의 [확장 가능한 데이터베이스 빌드하기: 다양한 데이터베이스 샤딩 체계의 장단점](http://www.25hoursaday.com/weblog/2009/01/16/BuildingScalableDatabasesProsAndConsOfVariousDatabaseShardingSchemes.aspx).
