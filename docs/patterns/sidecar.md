---
title: 사이드카 패턴
description: 격리 및 캡슐화를 제공하는 별도의 프로세스 또는 컨테이너에 애플리케이션 구성 요소를 배포합니다.
author: dragon119
ms.date: 06/23/2017
ms.openlocfilehash: ec168009aa99f412c3f1222a1c404ea4ea5cb669
ms.sourcegitcommit: b0482d49aab0526be386837702e7724c61232c60
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/14/2017
ms.locfileid: "26582762"
---
# <a name="sidecar-pattern"></a><span data-ttu-id="999d0-103">사이드카 패턴</span><span class="sxs-lookup"><span data-stu-id="999d0-103">Sidecar pattern</span></span>

<span data-ttu-id="999d0-104">격리 및 캡슐화를 제공하는 별도의 프로세스 또는 컨테이너에 애플리케이션 구성 요소를 배포합니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-104">Deploy components of an application into a separate process or container to provide isolation and encapsulation.</span></span> <span data-ttu-id="999d0-105">이 패턴을 사용하면 응용 프로그램을 서로 다른 유형의 구성 요소 및 기술로 구성할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-105">This pattern can also enable applications to be composed of heterogeneous components and technologies.</span></span>

<span data-ttu-id="999d0-106">이 패턴은 오토바이에 연결된 사이드카와 유사하므로 *사이드카*라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-106">This pattern is named *Sidecar* because it resembles a sidecar attached to a motorcycle.</span></span> <span data-ttu-id="999d0-107">패턴에서 사이드카는 상위 응용 프로그램에 연결되고 응용 프로그램에 대한 지원 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-107">In the pattern, the sidecar is attached to a parent application and provides supporting features for the application.</span></span> <span data-ttu-id="999d0-108">또한 사이드카는 상위 응용 프로그램과 동일한 수명 주기를 공유하므로 상위 응용 프로그램과 함께 만들어지고 사용 중지됩니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-108">The sidecar also shares the same lifecycle as the parent application, being created and retired alongside the parent.</span></span> <span data-ttu-id="999d0-109">사이드카 패턴은 경우에 따라 사이드킥 패턴이라고도 하며 분해 패턴입니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-109">The sidecar pattern is sometimes referred to as the sidekick pattern and is a decomposition pattern.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="999d0-110">컨텍스트 및 문제</span><span class="sxs-lookup"><span data-stu-id="999d0-110">Context and Problem</span></span>

<span data-ttu-id="999d0-111">응용 프로그램 및 서비스에는 모니터링, 로깅, 구성 및 네트워킹 서비스 등의 관련 기능이 필요한 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-111">Applications and services often require related functionality, such as monitoring, logging, configuration, and networking services.</span></span> <span data-ttu-id="999d0-112">이러한 주변 작업은 별도 구성 요소 또는 서비스로 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-112">These peripheral tasks can be implemented as separate components or services.</span></span> 

<span data-ttu-id="999d0-113">이러한 작업이 응용 프로그램에 긴밀하게 통합된 경우 응용 프로그램과 동일한 프로세스에서 실행되어 공유 리소스를 효과적으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-113">If they are tightly integrated into the application, they can run in the same process as the application, making efficient use of shared resources.</span></span> <span data-ttu-id="999d0-114">그러나 이는 제대로 격리되지 않았음을 의미하며 이러한 구성 요소 중 하나가 중단되면 다른 구성 요소 또는 전체 응용 프로그램에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-114">However, this also means they are not well isolated, and an outage in one of these components can affect other components or the entire application.</span></span> <span data-ttu-id="999d0-115">또한 일반적으로 상위 응용 프로그램과 동일한 언어를 사용하여 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-115">Also, they usually need to be implemented using the same language as the parent application.</span></span> <span data-ttu-id="999d0-116">결과적으로 구성 요소 및 응용 프로그램은 서로 긴밀하게 상호 종속됩니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-116">As a result, the component and the application have close interdependence on each other.</span></span>

<span data-ttu-id="999d0-117">응용 프로그램을 서비스로 분해할 경우 각 서비스를 다른 언어와 기술을 사용하여 빌드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-117">If the application is decomposed into services, then each service can be built using different languages and technologies.</span></span> <span data-ttu-id="999d0-118">이렇게 하면 유연성이 높아지지만 각 구성 요소에 고유 종속성이 있으며 상위 응용 프로그램과 공유되는 모든 리소스 및 기본 플랫폼에 액세스하는 데 언어별 라이브러리가 필요하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-118">While this gives more flexibility, it means that each component has its own dependencies and requires language-specific libraries to access the underlying platform and any resources shared with the parent application.</span></span> <span data-ttu-id="999d0-119">또한 이러한 기능을 별도 서비스로 배포하면 응용 프로그램에 대기 시간이 추가될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-119">In addition, deploying these features as separate services can add latency to the application.</span></span> <span data-ttu-id="999d0-120">이러한 언어별 인터페이스에 대한 코드 및 종속성 관리로 인해 상당한 복잡성이 추가될 수도 있습니다(특히 호스팅, 배포 및 관리의 경우).</span><span class="sxs-lookup"><span data-stu-id="999d0-120">Managing the code and dependencies for these language-specific interfaces can also add considerable complexity, especially for hosting, deployment, and management.</span></span>

## <a name="solution"></a><span data-ttu-id="999d0-121">해결 방법</span><span class="sxs-lookup"><span data-stu-id="999d0-121">Solution</span></span>

<span data-ttu-id="999d0-122">기본 응용 프로그램과 결합되는 작업 집합을 함께 배치하지만 해당 프로세스 또는 컨테이너 내에 배치하여 여러 언어 간에 플랫폼 서비스에 같은 유형의 인터페이스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-122">Co-locate a cohesive set of tasks with the primary application, but place them inside their own process or container, providing a homogeneous interface for platform services across languages.</span></span> 

![](./_images/sidecar.png)

<span data-ttu-id="999d0-123">사이드카 서비스는 응용 프로그램의 일부일 필요는 없지만 응용 프로그램에 연결되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-123">A sidecar service is not necessarily part of the application, but is connected to it.</span></span> <span data-ttu-id="999d0-124">상위 응용 프로그램의 이동 위치로 어디든 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-124">It goes wherever the parent application goes.</span></span> <span data-ttu-id="999d0-125">사이드카는 기본 응용 프로그램을 사용하여 배포되는 프로세스 또는 서비스를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-125">Sidecars are supporting processes or services that are deployed with the primary application.</span></span> <span data-ttu-id="999d0-126">오토바이의 경우 사이드카는 하나의 오토바이에 연결되고 각 오토바이는 자체 사이드카를 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-126">On a motorcycle, the sidecar is attached to one motorcycle, and each motorcycle can have its own sidecar.</span></span> <span data-ttu-id="999d0-127">마찬가지로 사이드카 서비스는 해당 상위 응용 프로그램과 함께 운용됩니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-127">In the same way, a sidecar service shares the fate of its parent application.</span></span> <span data-ttu-id="999d0-128">응용 프로그램의 각 인스턴스에 대해 사이드카의 인스턴스가 배포되고 그 옆에 호스트됩니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-128">For each instance of the application, an instance of the sidecar is deployed and hosted alongside it.</span></span> 

<span data-ttu-id="999d0-129">사이드카 패턴 사용의 장점은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-129">Advantages of using a sidecar pattern include:</span></span>

- <span data-ttu-id="999d0-130">사이드카는 런타임 환경 및 프로그래밍 언어와 관련하여 해당 기본 응용 프로그램과 독립적이므로 언어마다 하나의 사이드카를 개발할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-130">A sidecar is independent from its primary application in terms of runtime environment and programming language, so you don't need to develop one sidecar per language.</span></span> 

- <span data-ttu-id="999d0-131">사이드카는 기본 응용 프로그램과 동일한 리소스에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-131">The sidecar can access the same resources as the primary application.</span></span> <span data-ttu-id="999d0-132">예를 들어 사이드카는 사이드카 및 기본 응용 프로그램 둘 다에서 사용하는 시스템 리소스를 모니터링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-132">For example, a sidecar can monitor system resources used by both the sidecar and the primary application.</span></span> 

- <span data-ttu-id="999d0-133">기본 응용 프로그램에 대한 사이드카의 근접도로 인해 둘 간의 통신 시 대기 시간이 길지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-133">Because of its proximity to the primary application, there’s no significant latency when communicating between them.</span></span>

- <span data-ttu-id="999d0-134">확장성 메커니즘을 제공하지 않는 응용 프로그램의 경우에도 사이드카를 사용하여 기본 응용 프로그램과 동일한 호스트 또는 하위 컨테이너에서 자체 프로세스로 연결하여 기능을 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-134">Even for applications that don’t provide an extensibility mechanism, you can use a sidecar to extend functionality by attaching it as own process in the same host or sub-container as the primary application.</span></span>

<span data-ttu-id="999d0-135">사이드카 패턴은 컨테이너와 함께 사용되는 경우가 많으며 사이드카 컨테이너 또는 사이드킥 컨테이너라고도 합니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-135">The sidecar pattern is often used with containers and referred to as a sidecar container or sidekick container.</span></span> 

## <a name="issues-and-considerations"></a><span data-ttu-id="999d0-136">문제 및 고려 사항</span><span class="sxs-lookup"><span data-stu-id="999d0-136">Issues and Considerations</span></span>

- <span data-ttu-id="999d0-137">서비스, 프로세스 또는 컨테이너를 배포하는 데 사용할 배포 형식 및 패키지 형식을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-137">Consider the deployment and packaging format you will use to deploy services, processes, or containers.</span></span> <span data-ttu-id="999d0-138">특히 컨테이너는 사이드카 패턴에 매우 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-138">Containers are particularly well suited to the sidecar pattern.</span></span>
- <span data-ttu-id="999d0-139">사이드카 서비스를 디자인할 때는 프로세스 간 통신 메커니즘을 신중하게 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-139">When designing a sidecar service, carefully decide on the interprocess communication mechanism.</span></span> <span data-ttu-id="999d0-140">성능 요구 사항으로 불가능하게 되는 경우가 아니라면 언어(또는 프레임워크) 중립적 기술을 사용해 봅니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-140">Try to use language- or framework-agnostic technologies unless performance requirements make that impractical.</span></span>
- <span data-ttu-id="999d0-141">사이드카에 기능을 설정하기 전에 별도 서비스 또는 전형적인 디먼 중 어느 것으로 더 잘 작동할지 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-141">Before putting functionality into a sidecar, consider whether it would work better as a separate service or a more traditional daemon.</span></span>
- <span data-ttu-id="999d0-142">또한 기능을 라이브러리로 구현할 수 있는지 또는 전형적인 확장 메커니즘을 사용하여 구현할 수 있는지도 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-142">Also consider whether the functionality could be implemented as a library or using a traditional extension mechanism.</span></span> <span data-ttu-id="999d0-143">언어별 라이브러리는 심도 있게 통합되어 있으며 네트워크 오버헤드는 적습니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-143">Language-specific libraries may have a deeper level of integration and less network overhead.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="999d0-144">이 패턴을 사용해야 하는 경우</span><span class="sxs-lookup"><span data-stu-id="999d0-144">When to Use this Pattern</span></span>

<span data-ttu-id="999d0-145">다음 경우에 이 패턴을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-145">Use this pattern when:</span></span>

- <span data-ttu-id="999d0-146">기본 응용 프로그램이 다른 유형의 언어 집합 및 프레임워크를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-146">Your primary application uses a heterogenous set of languages and frameworks.</span></span> <span data-ttu-id="999d0-147">사이드카 서비스에 있는 구성 요소는 다양한 프레임워크를 사용하여 서로 다른 언어로 작성된 응용 프로그램에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-147">A component located in a sidecar service can be consumed by applications written in different languages using different frameworks.</span></span>
- <span data-ttu-id="999d0-148">구성 요소가 원격 팀 또는 다른 조직에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-148">A component is owned by a remote team or a different organization.</span></span>
- <span data-ttu-id="999d0-149">구성 요소 또는 기능을 응용 프로그램과 동일한 호스트에 함께 배치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-149">A component or feature must be co-located on the same host as the application</span></span>
- <span data-ttu-id="999d0-150">주 응용 프로그램의 전체 수명 주기를 공유하지만 개별적으로 업데이트할 수 있는 서비스가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-150">You need a service that shares the overall lifecycle of your main application, but can be independently updated.</span></span>
- <span data-ttu-id="999d0-151">특정 리소스 또는 구성 요소에 대한 리소스 제한을 세부적으로 제어해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-151">You need fine-grained control over resource limits for a particular resource or component.</span></span> <span data-ttu-id="999d0-152">예를 들어 특정 구성 요소가 사용하는 메모리의 양을 제한할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-152">For example, you may want to restrict the amount of memory a specific component uses.</span></span> <span data-ttu-id="999d0-153">사이드카로 구성 요소를 배포하고 주 응용 프로그램과 별개로 메모리 사용량을 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-153">You can deploy the component as a sidecar and manage memory usage independently of the main application.</span></span>

<span data-ttu-id="999d0-154">다음 경우에는 이 패턴이 적합하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-154">This pattern may not be suitable:</span></span>

- <span data-ttu-id="999d0-155">프로세스 간 통신을 최적화해야 할 경우.</span><span class="sxs-lookup"><span data-stu-id="999d0-155">When interprocess communication needs to be optimized.</span></span> <span data-ttu-id="999d0-156">상위 응용 프로그램과 사이드카 서비스 간의 통신에 일부 오버헤드(특히 호출 시 대기 시간)가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-156">Communication between a parent application and sidecar services includes some overhead, notably latency in the calls.</span></span> <span data-ttu-id="999d0-157">이에 대해서는 자주 발생하는 인터페이스에서 절충이 허용될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-157">This may not be an acceptable trade-off for chatty interfaces.</span></span>
- <span data-ttu-id="999d0-158">각 인스턴스에 대한 사이드카 서비스를 배포하는 리소스 비용에 격리를 통한 이점만큼 가치가 있지 않은 소규모 응용 프로그램의 경우</span><span class="sxs-lookup"><span data-stu-id="999d0-158">For small applications where the resource cost of deploying a sidecar service for each instance is not worth the advantage of isolation.</span></span>
- <span data-ttu-id="999d0-159">서비스를 주 응용 프로그램과 다르거나 독립적으로 확장해야 할 경우.</span><span class="sxs-lookup"><span data-stu-id="999d0-159">When the service needs to scale differently than or independently from the main applications.</span></span> <span data-ttu-id="999d0-160">이 경우에는 별도 서비스로 기능을 배포하는 것이 나을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-160">If so, it may be better to deploy the feature as a separate service.</span></span>

## <a name="example"></a><span data-ttu-id="999d0-161">예</span><span class="sxs-lookup"><span data-stu-id="999d0-161">Example</span></span>

<span data-ttu-id="999d0-162">사이드카 패턴은 많은 시나리오에 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-162">The sidecar pattern is applicable to many scenarios.</span></span> <span data-ttu-id="999d0-163">일부 일반적인 예는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-163">Some common examples:</span></span>

- <span data-ttu-id="999d0-164">인프라 API.</span><span class="sxs-lookup"><span data-stu-id="999d0-164">Infrastructure API.</span></span> <span data-ttu-id="999d0-165">인프라 개발 팀은 인프라에 액세스할 언어별 클라이언트 라이브러리 대신 각 응용 프로그램과 함께 배포되는 서비스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-165">The infrastructure development team creates a service that's deployed alongside each application, instead of a language-specific client library to access the infrastructure.</span></span> <span data-ttu-id="999d0-166">서비스는 사이드카로 로드되고 로깅, 환경 데이터, 구성 저장소, 검색, 상태 검사 및 watchdog 서비스를 비롯한 인프라 서비스에 대한 공통 계층을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-166">The service is loaded as a sidecar and provides a common layer for infrastructure services, including logging, environment data, configuration store, discovery, health checks, and watchdog services.</span></span> <span data-ttu-id="999d0-167">또한 사이드카는 상위 응용 프로그램의 호스트 환경 및 프로세스(또는 컨테이너)를 모니터링하고 중앙 집중식 서비스에 정보를 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-167">The sidecar also monitors the parent application's host environment and process (or container) and logs the information to a centralized service.</span></span>
- <span data-ttu-id="999d0-168">NGINX/HAProxy 관리.</span><span class="sxs-lookup"><span data-stu-id="999d0-168">Manage NGINX/HAProxy.</span></span> <span data-ttu-id="999d0-169">환경 상태를 모니터링한 다음 NGINX 구성 파일을 업데이트하고 상태 변경이 필요한 경우 프로세스를 재활용하는 사이드카 서비스를 사용하여 NGINX를 배포합니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-169">Deploy NGINX with a sidecar service that monitors environment state, then updates the NGINX configuration file and recycles the process when a change in state is needed.</span></span>
- <span data-ttu-id="999d0-170">특사 사이드카.</span><span class="sxs-lookup"><span data-stu-id="999d0-170">Ambassador sidecar.</span></span> <span data-ttu-id="999d0-171">[특사][ ambassador] 서비스를 사이드카로 배포합니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-171">Deploy an [ambassador][ambassador] service as a sidecar.</span></span> <span data-ttu-id="999d0-172">응용 프로그램이 요청 로깅, 라우팅, 회로 차단 및 기타 연결 관련 기능을 처리하는 특사를 통해 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-172">The application calls through the ambassador, which handles request logging, routing, circuit breaking, and other connectivity related features.</span></span>
- <span data-ttu-id="999d0-173">오프로드 프록시.</span><span class="sxs-lookup"><span data-stu-id="999d0-173">Offload proxy.</span></span> <span data-ttu-id="999d0-174">서비스에 대한 사용 중인 정적 파일 콘텐츠를 처리하도록 NGINX 프록시를 node.js 서비스 인스턴스 앞에 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="999d0-174">Place an NGINX proxy in front of a node.js service instance, to handle serving static file content for the service.</span></span>


## <a name="related-guidance"></a><span data-ttu-id="999d0-175">관련 지침</span><span class="sxs-lookup"><span data-stu-id="999d0-175">Related guidance</span></span>

- <span data-ttu-id="999d0-176">[특사 패턴][ambassador]</span><span class="sxs-lookup"><span data-stu-id="999d0-176">[Ambassador pattern][ambassador]</span></span>


[ambassador]: ./ambassador.md

