---
title: 이벤트 소싱 패턴
titleSuffix: Cloud Design Patterns
description: 추가 전용 저장소를 사용하여 도메인의 데이터에 대해 수행된 작업을 설명하는 일련의 이벤트 전체를 기록합니다.
keywords: 디자인 패턴
author: dragon119
ms.date: 06/23/2017
ms.custom: seodec18
ms.openlocfilehash: 56db321e33ecef17704eda4eda971ff3c7e44133
ms.sourcegitcommit: 680c9cef945dff6fee5e66b38e24f07804510fa9
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/04/2019
ms.locfileid: "54011636"
---
# <a name="event-sourcing-pattern"></a><span data-ttu-id="d3efb-104">이벤트 소싱 패턴</span><span class="sxs-lookup"><span data-stu-id="d3efb-104">Event Sourcing pattern</span></span>

[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="d3efb-105">데이터의 현재 상태만 도메인에 저장하는 대신 추가 전용 저장소를 사용하여 해당 데이터에 수행된 전체 작업을 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-105">Instead of storing just the current state of the data in a domain, use an append-only store to record the full series of actions taken on that data.</span></span>
<span data-ttu-id="d3efb-106">저장소는 레코드 시스템 역할을 하며, 도메인 개체를 구체화하는 데 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-106">The store acts as the system of record and can be used to materialize the domain objects.</span></span> <span data-ttu-id="d3efb-107">이렇게 하면 데이터 모델과 비즈니스 도메인을 동기화할 필요가 없고 성능, 확장성 및 응답성이 향상되므로 복잡한 도메인의 태스크를 간소화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-107">This can simplify tasks in complex domains, by avoiding the need to synchronize the data model and the business domain, while improving performance, scalability, and responsiveness.</span></span> <span data-ttu-id="d3efb-108">또한 트랜잭션 데이터에 일관성을 제공하고 보정 작업에 사용할 수 있는 전체 감사 추적 및 기록을 유지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-108">It can also provide consistency for transactional data, and maintain full audit trails and history that can enable compensating actions.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="d3efb-109">컨텍스트 및 문제점</span><span class="sxs-lookup"><span data-stu-id="d3efb-109">Context and problem</span></span>

<span data-ttu-id="d3efb-110">대부분의 애플리케이션은 데이터를 사용하며, 일반적인 접근 방법은 사용자가 데이터로 작업할 때 애플리케이션이 데이터의 현재 상태를 업데이트하여 유지 관리하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-110">Most applications work with data, and the typical approach is for the application to maintain the current state of the data by updating it as users work with it.</span></span> <span data-ttu-id="d3efb-111">예를 들어 기존의 CRUD(만들기, 읽기, 업데이트 및 삭제) 모델에서 일반적인 데이터 프로세스는 저장소에서 데이터를 읽고 수정한 다음 주로 데이터를 잠그는 트랜잭션을 사용하여 데이터의 현재 상태를 새 값으로 업데이트하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-111">For example, in the traditional create, read, update, and delete (CRUD) model a typical data process is to read data from the store, make some modifications to it, and update the current state of the data with the new values&mdash;often by using transactions that lock the data.</span></span>

<span data-ttu-id="d3efb-112">CRUD 접근 방법에는 다음과 같은 몇 가지 제한 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-112">The CRUD approach has some limitations:</span></span>

- <span data-ttu-id="d3efb-113">CRUD 시스템은 데이터 저장소에서 직접 업데이트 작업을 수행하므로 성능 및 응답 속도가 저하되고 필요한 처리 오버헤드로 인해 확장성이 제한될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-113">CRUD systems perform update operations directly against a data store, which can slow down performance and responsiveness, and limit scalability, due to the processing overhead it requires.</span></span>

- <span data-ttu-id="d3efb-114">많은 동시 사용자가 있는 공동 작업 도메인에서 데이터 업데이트 충돌은 대체로 업데이트 작업이 단일 데이터 항목에서 수행되기 때문에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-114">In a collaborative domain with many concurrent users, data update conflicts are more likely because the update operations take place on a single item of data.</span></span>

- <span data-ttu-id="d3efb-115">각 작업의 세부 정보를 개별 로그에 기록하는 추가 감사 메커니즘이 없으면 기록이 유실됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-115">Unless there's an additional auditing mechanism that records the details of each operation in a separate log, history is lost.</span></span>

> <span data-ttu-id="d3efb-116">CRUD 접근 방식의 제한에 대한 자세한 내용은 [CRUD, Only When You Can Afford It](https://blogs.msdn.microsoft.com/maarten_mullender/2004/07/23/crud-only-when-you-can-afford-it-revisited/)(CRUD, 사용 가능한 경우에만)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d3efb-116">For a deeper understanding of the limits of the CRUD approach see [CRUD, Only When You Can Afford It](https://blogs.msdn.microsoft.com/maarten_mullender/2004/07/23/crud-only-when-you-can-afford-it-revisited/).</span></span>

## <a name="solution"></a><span data-ttu-id="d3efb-117">해결 방법</span><span class="sxs-lookup"><span data-stu-id="d3efb-117">Solution</span></span>

<span data-ttu-id="d3efb-118">이벤트 소싱 패턴은 각각 추가 전용 저장소에 기록되는 일련의 이벤트에 의해 구동되는 데이터 작업 처리 방법을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-118">The Event Sourcing pattern defines an approach to handling operations on data that's driven by a sequence of events, each of which is recorded in an append-only store.</span></span> <span data-ttu-id="d3efb-119">애플리케이션 코드가 데이터에서 수행된 각 작업을 명확하게 설명하는 일련의 이벤트를 이벤트 저장소로 보내며, 이벤트는 여기에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-119">Application code sends a series of events that imperatively describe each action that has occurred on the data to the event store, where they're persisted.</span></span> <span data-ttu-id="d3efb-120">각 이벤트는 데이터에 대한 변경 집합(예: `AddedItemToOrder`)을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-120">Each event represents a set of changes to the data (such as `AddedItemToOrder`).</span></span>

<span data-ttu-id="d3efb-121">이벤트는 데이터의 현재 상태에 대한 레코드 시스템(권한 있는 데이터 원본) 역할을 하는 이벤트 저장소에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-121">The events are persisted in an event store that acts as the system of record (the authoritative data source) about the current state of the data.</span></span> <span data-ttu-id="d3efb-122">이벤트 저장소는 일반적으로 이 이벤트를 게시하여 소비자에게 알리고 필요한 경우 처리할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-122">The event store typically publishes these events so that consumers can be notified and can handle them if needed.</span></span> <span data-ttu-id="d3efb-123">예를 들어 소비자는 이벤트의 작업을 다른 시스템에 적용하는 태스크를 시작하거나 작업을 완료하는 데 필요한 기타 관련 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-123">Consumers could, for example, initiate tasks that apply the operations in the events to other systems, or perform any other associated action that's required to complete the operation.</span></span> <span data-ttu-id="d3efb-124">이벤트를 생성하는 애플리케이션 코드와 이벤트를 구독하는 시스템은 분리됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-124">Notice that the application code that generates the events is decoupled from the systems that subscribe to the events.</span></span>

<span data-ttu-id="d3efb-125">이벤트 저장소에서 게시된 이벤트는 일반적으로 애플리케이션의 작업이 엔터티를 변경할 때 엔터티의 구체화된 뷰를 유지 관리하고 외부 시스템과 통합하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-125">Typical uses of the events published by the event store are to maintain materialized views of entities as actions in the application change them, and for integration with external systems.</span></span> <span data-ttu-id="d3efb-126">예를 들어 시스템에서 UI 부분을 채우는 데 사용되는 모든 고객 주문의 구체화된 뷰를 유지 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-126">For example, a system can maintain a materialized view of all customer orders that's used to populate parts of the UI.</span></span> <span data-ttu-id="d3efb-127">애플리케이션이 새 주문을 추가하고, 주문에 품목을 추가 또는 제거하고, 배송 정보를 추가할 때 이러한 변경 내용을 설명하는 이벤트를 처리하고 [구체화된 뷰](./materialized-view.md)를 업데이트하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-127">As the application adds new orders, adds or removes items on the order, and adds shipping information, the events that describe these changes can be handled and used to update the [materialized view](./materialized-view.md).</span></span>

<span data-ttu-id="d3efb-128">또한 언제든지 애플리케이션이 이벤트 기록을 읽고 해당 엔터티와 관련된 모든 이벤트를 재생 및 이용하여 엔터티의 현재 상태를 구체화하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-128">In addition, at any point it's possible for applications to read the history of events, and use it to materialize the current state of an entity by playing back and consuming all the events related to that entity.</span></span> <span data-ttu-id="d3efb-129">이 작업은 프레젠테이션 레이어를 지원하기 위해 엔터티 상태를 구체화된 뷰로 저장할 수 있도록 예약된 태스크를 통해 또는 요청을 처리할 때 도메인 개체 구체화 요청 시 수행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-129">This can occur on demand to materialize a domain object when handling a request, or through a scheduled task so that the state of the entity can be stored as a materialized view to support the presentation layer.</span></span>

<span data-ttu-id="d3efb-130">이 그림은 구체화된 뷰 만들기, 외부 애플리케이션 및 시스템과 이벤트 통합, 이벤트를 재생하여 특정 엔터티의 현재 상태 프로젝션 만들기 등의 몇 가지 이벤트 스트림 사용 옵션을 포함하여 패턴 개요를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-130">The figure shows an overview of the pattern, including some of the options for using the event stream such as creating a materialized view, integrating events with external applications and systems, and replaying events to create projections of the current state of specific entities.</span></span>

![이벤트 소싱 패턴의 개요 및 예](./_images/event-sourcing-overview.png)

<span data-ttu-id="d3efb-132">이벤트 소싱 패턴에는 다음과 같은 장점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-132">The Event Sourcing pattern provides the following advantages:</span></span>

- <span data-ttu-id="d3efb-133">이벤트를 변경할 수 없으며 추가 전용 작업을 사용하여 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-133">Events are immutable and can be stored using an append-only operation.</span></span> <span data-ttu-id="d3efb-134">이벤트를 시작한 사용자 인터페이스, 워크플로 또는 프로세스가 계속 진행될 수 있고, 이벤트를 처리하는 태스크를 백그라운드에서 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-134">The user interface, workflow, or process that initiated an event can continue, and tasks that handle the events can run in the background.</span></span> <span data-ttu-id="d3efb-135">트랜잭션 처리 중 경합이 없다는 사실과 더불어 이 장점으로 인해 특히 프레젠테이션 수준 또는 사용자 인터페이스에서 애플리케이션의 성능과 확장성이 훨씬 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-135">This, combined with the fact that there's no contention during the processing of transactions, can vastly improve performance and scalability for applications, especially for the presentation level or user interface.</span></span>

- <span data-ttu-id="d3efb-136">이벤트는 이벤트가 나타내는 작업을 설명하는 데 필요한 관련 데이터와 함께 수행된 일부 작업을 설명하는 단순 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-136">Events are simple objects that describe some action that occurred, together with any associated data required to describe the action represented by the event.</span></span> <span data-ttu-id="d3efb-137">이벤트는 데이터 저장소를 직접 업데이트하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-137">Events don't directly update a data store.</span></span> <span data-ttu-id="d3efb-138">단순히 적절한 시간에 처리하기 위해 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-138">They're simply recorded for handling at the appropriate time.</span></span> <span data-ttu-id="d3efb-139">이렇게 하면 구현 및 관리를 간소화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-139">This can simplify implementation and management.</span></span>

- <span data-ttu-id="d3efb-140">이벤트는 일반적으로 도메인 전문가에게 의미가 있는 반면, [개체 관계형 임피던스 불일치](https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch)로 인해 복잡한 데이터베이스 테이블을 이해하기 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-140">Events typically have meaning for a domain expert, whereas [object-relational impedance mismatch](https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch) can make complex database tables hard to understand.</span></span> <span data-ttu-id="d3efb-141">테이블은 발생한 이벤트가 아니라 시스템의 현재 상태를 나타내는 인공 구문입니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-141">Tables are artificial constructs that represent the current state of the system, not the events that occurred.</span></span>

- <span data-ttu-id="d3efb-142">이벤트 소싱을 사용하면 데이터 저장소의 개체를 직접 업데이트하지 않아도 되기 때문에 동시 업데이트로 인한 충돌을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-142">Event sourcing can help prevent concurrent updates from causing conflicts because it avoids the requirement to directly update objects in the data store.</span></span> <span data-ttu-id="d3efb-143">그러나 도메인 모델이 상태 불일치를 초래할 수 있는 요청으로부터 보호되도록 디자인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-143">However, the domain model must still be designed to protect itself from requests that might result in an inconsistent state.</span></span>

- <span data-ttu-id="d3efb-144">추가 전용 이벤트 저장소에서 제공하는 감사 추적을 사용하면 데이터 저장소에 대해 수행된 작업을 모니터하고, 언제든지 이벤트를 재생하여 현재 상태를 구체화된 뷰 또는 프로젝션으로 재생성하고, 시스템 테스트 및 디버그를 지원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-144">The append-only storage of events provides an audit trail that can be used to monitor actions taken against a data store, regenerate the current state as materialized views or projections by replaying the events at any time, and assist in testing and debugging the system.</span></span> <span data-ttu-id="d3efb-145">또한 변경 내용을 취소하기 위해 보정 이벤트를 사용해야 하므로 모델이 현재 상태만 저장하는 경우와 달리 취소된 변경 기록이 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-145">In addition, the requirement to use compensating events to cancel changes provides a history of changes that were reversed, which wouldn't be the case if the model simply stored the current state.</span></span> <span data-ttu-id="d3efb-146">이벤트 목록을 사용하여 애플리케이션 성능을 분석하고 사용자 행동 경향을 검색하거나 기타 유용한 비즈니스 정보를 얻을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-146">The list of events can also be used to analyze application performance and detect user behavior trends, or to obtain other useful business information.</span></span>

- <span data-ttu-id="d3efb-147">이벤트 저장소는 이벤트를 발생하고, 태스크는 이러한 이벤트에 대한 응답으로 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-147">The event store raises events, and tasks perform operations in response to those events.</span></span> <span data-ttu-id="d3efb-148">이렇게 태스크와 이벤트를 분리하면 유연성과 확장성이 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-148">This decoupling of the tasks from the events provides flexibility and extensibility.</span></span> <span data-ttu-id="d3efb-149">태스크는 이벤트 유형과 이벤트 데이터를 알고 있지만 이벤트를 트리거한 작업에 대해서는 알 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-149">Tasks know about the type of event and the event data, but not about the operation that triggered the event.</span></span> <span data-ttu-id="d3efb-150">또한 여러 태스크가 각 이벤트를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-150">In addition, multiple tasks can handle each event.</span></span> <span data-ttu-id="d3efb-151">이 경우 이벤트 저장소에서 발생하는 새 이벤트만 수신 대기하는 다른 서비스 및 시스템과 쉽게 통합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-151">This enables easy integration with other services and systems that only listen for new events raised by the event store.</span></span> <span data-ttu-id="d3efb-152">그러나 이벤트 소싱 이벤트는 대체로 매우 낮은 수준이며, 대신 특정 통합 이벤트를 생성해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-152">However, the event sourcing events tend to be very low level, and it might be necessary to generate specific integration events instead.</span></span>

> <span data-ttu-id="d3efb-153">이벤트 소싱은 일반적으로 이벤트에 대한 응답으로 데이터 관리 태스크를 수행하고 저장된 이벤트에서 뷰를 구체화하여 CQRS 패턴과 결합됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-153">Event sourcing is commonly combined with the CQRS pattern by performing the data management tasks in response to the events, and by materializing views from the stored events.</span></span>

## <a name="issues-and-considerations"></a><span data-ttu-id="d3efb-154">문제 및 고려 사항</span><span class="sxs-lookup"><span data-stu-id="d3efb-154">Issues and considerations</span></span>

<span data-ttu-id="d3efb-155">이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="d3efb-155">Consider the following points when deciding how to implement this pattern:</span></span>

<span data-ttu-id="d3efb-156">구체화된 뷰를 만들거나 이벤트를 재생하여 데이터 프로젝션을 생성할 때만 시스템이 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-156">The system will only be eventually consistent when creating materialized views or generating projections of data by replaying events.</span></span> <span data-ttu-id="d3efb-157">요청 처리의 결과로 애플리케이션이 이벤트 저장소에 이벤트 추가, 이벤트 게시 및 이벤트 소비자의 이벤트 처리 사이에 약간의 지연이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-157">There's some delay between an application adding events to the event store as the result of handling a request, the events being published, and consumers of the events handling them.</span></span> <span data-ttu-id="d3efb-158">이 기간 동안 엔터티의 추가 변경 내용을 설명하는 새 이벤트가 이벤트 저장소에 도착했을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-158">During this period, new events that describe further changes to entities might have arrived at the event store.</span></span>

> [!NOTE]
> <span data-ttu-id="d3efb-159">결과적 일관성에 대한 자세한 내용은 [데이터 일관성 입문서](https://msdn.microsoft.com/library/dn589800.aspx)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d3efb-159">See the [Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx) for information about eventual consistency.</span></span>

<span data-ttu-id="d3efb-160">이벤트 저장소는 영구적인 정보 소스이므로 이벤트 데이터가 업데이트되면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-160">The event store is the permanent source of information, and so the event data should never be updated.</span></span> <span data-ttu-id="d3efb-161">변경 내용을 취소하기 위해 엔터티를 업데이트하는 유일한 방법은 이벤트 저장소에 보정 이벤트를 추가하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-161">The only way to update an entity to undo a change is to add a compensating event to the event store.</span></span> <span data-ttu-id="d3efb-162">지속형 이벤트의 형식(데이터 아님)을 변경해야 하는 경우, 마이그레이션 중에 저장소의 기존 이벤트를 새 버전과 결합하기 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-162">If the format (rather than the data) of the persisted events needs to change, perhaps during a migration, it can be difficult to combine existing events in the store with the new version.</span></span> <span data-ttu-id="d3efb-163">새 형식을 준수하도록 모든 이벤트를 반복해서 변경하거나 새 형식을 사용하는 새 이벤트를 추가해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-163">It might be necessary to iterate through all the events making changes so they're compliant with the new format, or add new events that use the new format.</span></span> <span data-ttu-id="d3efb-164">이벤트 스키마의 각 버전에 버전 스탬프를 사용하여 이전 이벤트 형식과 새 이벤트 형식을 둘 다 유지 관리하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-164">Consider using a version stamp on each version of the event schema to maintain both the old and the new event formats.</span></span>

<span data-ttu-id="d3efb-165">다중 스레드 애플리케이션과 여러 애플리케이션 인스턴스가 이벤트 저장소에 이벤트를 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-165">Multi-threaded applications and multiple instances of applications might be storing events in the event store.</span></span> <span data-ttu-id="d3efb-166">이벤트 저장소의 이벤트 일관성은 특정 엔터티에 영향을 주는 이벤트 순서와 마찬가지로 중요합니다(엔터티에 대한 변경 순서는 현재 상태에 영향을 줌).</span><span class="sxs-lookup"><span data-stu-id="d3efb-166">The consistency of events in the event store is vital, as is the order of events that affect a specific entity (the order that changes occur to an entity affects its current state).</span></span> <span data-ttu-id="d3efb-167">모든 이벤트에 타임스탬프를 추가하면 문제를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-167">Adding a timestamp to every event can help to avoid issues.</span></span> <span data-ttu-id="d3efb-168">또 다른 일반적인 방법은 요청에서 발생하는 각 이벤트에 증분 식별자를 주석으로 추가하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-168">Another common practice is to annotate each event resulting from a request with an incremental identifier.</span></span> <span data-ttu-id="d3efb-169">두 작업이 동일한 엔터티에 대한 이벤트를 동시에 추가하려고 하면 이벤트 저장소에서 기존 엔터티 식별자 및 이벤트 식별자와 일치하는 이벤트를 거부할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-169">If two actions attempt to add events for the same entity at the same time, the event store can reject an event that matches an existing entity identifier and event identifier.</span></span>

<span data-ttu-id="d3efb-170">정보를 얻기 위해 이벤트를 읽는 표준 방법이나 SQL 쿼리와 같은 기존 메커니즘은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-170">There's no standard approach, or existing mechanisms such as SQL queries, for reading the events to obtain information.</span></span> <span data-ttu-id="d3efb-171">추출할 수 있는 데이터는 이벤트 식별자를 기준으로 사용하는 이벤트 스트림뿐입니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-171">The only data that can be extracted is a stream of events using an event identifier as the criteria.</span></span> <span data-ttu-id="d3efb-172">이벤트 ID는 일반적으로 개별 엔터티에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-172">The event ID typically maps to individual entities.</span></span> <span data-ttu-id="d3efb-173">엔터티의 현재 상태는 관련된 모든 이벤트를 해당 엔터티의 원래 상태에 대해 재생해야만 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-173">The current state of an entity can be determined only by replaying all of the events that relate to it against the original state of that entity.</span></span>

<span data-ttu-id="d3efb-174">각 이벤트 스트림의 길이는 시스템 관리 및 업데이트에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-174">The length of each event stream affects managing and updating the system.</span></span> <span data-ttu-id="d3efb-175">스트림이 큰 경우 지정된 이벤트 수 등의 특정 간격으로 스냅숏을 만드는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-175">If the streams are large, consider creating snapshots at specific intervals such as a specified number of events.</span></span> <span data-ttu-id="d3efb-176">스냅숏에서 해당 시점 이후에 발생한 이벤트를 재생하면 엔터티의 현재 상태를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-176">The current state of the entity can be obtained from the snapshot and by replaying any events that occurred after that point in time.</span></span> <span data-ttu-id="d3efb-177">데이터 스냅숏을 만드는 방법에 대한 자세한 내용은 [Martin Fowler 엔터프라이즈 애플리케이션 아키텍처 웹 사이트의 스냅숏](https://martinfowler.com/eaaDev/Snapshot.html) 및 [마스터-하위 스냅숏 복제](https://msdn.microsoft.com/library/ff650012.aspx)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d3efb-177">For more information about creating snapshots of data, see [Snapshot on Martin Fowler’s Enterprise Application Architecture website](https://martinfowler.com/eaaDev/Snapshot.html) and [Master-Subordinate Snapshot Replication](https://msdn.microsoft.com/library/ff650012.aspx).</span></span>

<span data-ttu-id="d3efb-178">이벤트 소싱이 데이터 업데이트의 충돌 가능성을 최소화하더라도 애플리케이션이 결과적 일관성과 트랜잭션 부족에서 발생하는 불일치를 처리할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-178">Even though event sourcing minimizes the chance of conflicting updates to the data, the application must still be able to deal with inconsistencies that result from eventual consistency and the lack of transactions.</span></span> <span data-ttu-id="d3efb-179">예를 들어 해당 품목이 주문되는 동안 재고 감소를 나타내는 이벤트가 데이터 저장소에 도착하여 고객에게 안내하거나 이월 주문을 만들어 두 작업을 조정해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-179">For example, an event that indicates a reduction in stock inventory might arrive in the data store while an order for that item is being placed, resulting in a requirement to reconcile the two operations either by advising the customer or creating a back order.</span></span>

<span data-ttu-id="d3efb-180">이벤트 게시는 "최소한 한 번"일 수 있으므로 이벤트 소비자가 멱등적이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-180">Event publication might be “at least once,” and so consumers of the events must be idempotent.</span></span> <span data-ttu-id="d3efb-181">이벤트가 두 번 이상 처리되는 경우 이벤트에 설명된 업데이트를 다시 적용하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-181">They must not reapply the update described in an event if the event is handled more than once.</span></span> <span data-ttu-id="d3efb-182">예를 들어 여러 소비자 인스턴스가 총 주문 수와 같은 엔터티 속성의 집계를 유지 관리하는 경우 주문 이벤트가 발생할 때 한 인스턴스만 집계 증분에 성공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-182">For example, if multiple instances of a consumer maintain an aggregate an entity's property, such as the total number of orders placed, only one must succeed in incrementing the aggregate when an order placed event occurs.</span></span> <span data-ttu-id="d3efb-183">이벤트 소싱의 주요 특성은 아니지만 일반적인 구현 결정입니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-183">While this isn't a key characteristic of event sourcing, it's the usual implementation decision.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="d3efb-184">이 패턴을 사용해야 하는 경우</span><span class="sxs-lookup"><span data-stu-id="d3efb-184">When to use this pattern</span></span>

<span data-ttu-id="d3efb-185">다음 시나리오에서 이 패턴을 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="d3efb-185">Use this pattern in the following scenarios:</span></span>

- <span data-ttu-id="d3efb-186">데이터에 의도, 목적 또는 이유를 캡처하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="d3efb-186">When you want to capture intent, purpose, or reason in the data.</span></span> <span data-ttu-id="d3efb-187">예를 들어 고객 엔터티의 변경 내용을 _이사_, _계정 폐쇄_ 또는 _사망_과 같은 일련의 특정 이벤트 유형으로 캡처할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-187">For example, changes to a customer entity can be captured as a series of specific event types such as _Moved home_, _Closed account_, or _Deceased_.</span></span>

- <span data-ttu-id="d3efb-188">데이터 업데이트 충돌 발생을 최소화하거나 완전히 방지하는 것이 중요한 경우.</span><span class="sxs-lookup"><span data-stu-id="d3efb-188">When it's vital to minimize or completely avoid the occurrence of conflicting updates to data.</span></span>

- <span data-ttu-id="d3efb-189">발생하는 이벤트를 기록하고 재생하여 시스템 상태를 복원하거나, 변경 내용을 롤백하거나, 기록 및 감사 로그를 유지하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="d3efb-189">When you want to record events that occur, and be able to replay them to restore the state of a system, roll back changes, or keep a history and audit log.</span></span> <span data-ttu-id="d3efb-190">예를 들어 태스크에 여러 단계가 필요한 경우 업데이트를 되돌리는 작업을 실행한 후 일부 단계를 재생하여 데이터를 일관된 상태로 되돌려야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-190">For example, when a task involves multiple steps you might need to execute actions to revert updates and then replay some steps to bring the data back into a consistent state.</span></span>

- <span data-ttu-id="d3efb-191">이벤트 사용이 애플리케이션 작업의 자연 기능이고 추가 개발 또는 구현 노력이 거의 필요하지 않은 경우.</span><span class="sxs-lookup"><span data-stu-id="d3efb-191">When using events is a natural feature of the operation of the application, and requires little additional development or implementation effort.</span></span>

- <span data-ttu-id="d3efb-192">데이터 입력 또는 업데이트 프로세스와 이러한 작업을 적용하는 데 필요한 태스크를 분리해야 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="d3efb-192">When you need to decouple the process of inputting or updating data from the tasks required to apply these actions.</span></span> <span data-ttu-id="d3efb-193">UI 성능을 향상하거나 이벤트 발생 시 작업을 수행하는 다른 수신기에 이벤트를 분배하기 위한 것일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-193">This might be to improve UI performance, or to distribute events to other listeners that take action when the events occur.</span></span> <span data-ttu-id="d3efb-194">예를 들어 웹 사이트의 데이터 업데이트에 대한 응답으로 이벤트 저장소에서 발생하는 이벤트가 웹 사이트와 급여 시스템 둘 다에서 이용되도록 급여 시스템과 비용 제출 웹 사이트를 통합합니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-194">For example, integrating a payroll system with an expense submission website so that events raised by the event store in response to data updates made in the website are consumed by both the website and the payroll system.</span></span>

- <span data-ttu-id="d3efb-195">요구 사항 변경에 따라 구체화된 모델 및 엔터티 데이터의 형식을 변경할 수 있는 유연성을 원하거나 CQRS와 함께 사용 시 읽기 모델 또는 데이터를 표시하는 뷰를 조정해야 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="d3efb-195">When you want flexibility to be able to change the format of materialized models and entity data if requirements change, or&mdash;when used in conjunction with CQRS&mdash;you need to adapt a read model or the views that expose the data.</span></span>

- <span data-ttu-id="d3efb-196">CQRS와 함께 사용 시 읽기 모델이 업데이트되는 동안 결과적 일관성이 허용되거나 이벤트 스트림에서 엔터티와 데이터를 리하이드레이션할 때의 성능 영향이 허용되는 경우.</span><span class="sxs-lookup"><span data-stu-id="d3efb-196">When used in conjunction with CQRS, and eventual consistency is acceptable while a read model is updated, or the performance impact of rehydrating entities and data from an event stream is acceptable.</span></span>

<span data-ttu-id="d3efb-197">이 패턴은 다음과 같은 경우에 유용하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-197">This pattern might not be useful in the following situations:</span></span>

- <span data-ttu-id="d3efb-198">작거나 단순한 도메인, 비즈니스 논리가 거의 없거나 전혀 없는 시스템 또는 기존의 CRUD 데이터 관리 메커니즘에서 기본적으로 잘 작동하는 비도메인 시스템.</span><span class="sxs-lookup"><span data-stu-id="d3efb-198">Small or simple domains, systems that have little or no business logic, or nondomain systems that naturally work well with traditional CRUD data management mechanisms.</span></span>

- <span data-ttu-id="d3efb-199">데이터 뷰에 대한 일관성 및 실시간 업데이트가 필요한 시스템.</span><span class="sxs-lookup"><span data-stu-id="d3efb-199">Systems where consistency and real-time updates to the views of the data are required.</span></span>

- <span data-ttu-id="d3efb-200">감사 추적, 기록, 작업 롤백 및 재생 기능이 필요하지 않은 시스템.</span><span class="sxs-lookup"><span data-stu-id="d3efb-200">Systems where audit trails, history, and capabilities to roll back and replay actions are not required.</span></span>

- <span data-ttu-id="d3efb-201">기본 데이터에 대한 업데이트 충돌 발생이 매우 적은 시스템.</span><span class="sxs-lookup"><span data-stu-id="d3efb-201">Systems where there's only a very low occurrence of conflicting updates to the underlying data.</span></span> <span data-ttu-id="d3efb-202">예를 들어 데이터를 업데이트하지 않고 주로 추가하는 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-202">For example, systems that predominantly add data rather than updating it.</span></span>

## <a name="example"></a><span data-ttu-id="d3efb-203">예</span><span class="sxs-lookup"><span data-stu-id="d3efb-203">Example</span></span>

<span data-ttu-id="d3efb-204">회의 관리 시스템은 잠재적 참석자가 예약을 시도할 때 사용 가능한 좌석이 있는지 확인할 수 있도록 완료된 회의 예약 수를 추적해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-204">A conference management system needs to track the number of completed bookings for a conference so that it can check whether there are seats still available when a potential attendee tries to make a booking.</span></span> <span data-ttu-id="d3efb-205">다음과 같이 총 회의 예약 수를 둘 이상의 방법으로 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-205">The system could store the total number of bookings for a conference in at least two ways:</span></span>

- <span data-ttu-id="d3efb-206">예약 정보를 보유하는 데이터베이스에 총 예약 수에 대한 정보를 별도의 엔터티로 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-206">The system could store the information about the total number of bookings as a separate entity in a database that holds booking information.</span></span> <span data-ttu-id="d3efb-207">예약이 완료되거나 취소되면 시스템이 이 개수를 적절하게 증분하거나 감소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-207">As bookings are made or canceled, the system could increment or decrement this number as appropriate.</span></span> <span data-ttu-id="d3efb-208">이 접근 방법은 이론상 간단하지만, 짧은 기간 동안 많은 참석자가 좌석을 예약하려고 시도할 경우 확장성 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-208">This approach is simple in theory, but can cause scalability issues if a large number of attendees are attempting to book seats during a short period of time.</span></span> <span data-ttu-id="d3efb-209">예를 들어 예약 기간 마감 전날 등에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-209">For example, in the last day or so prior to the booking period closing.</span></span>

- <span data-ttu-id="d3efb-210">시스템이 예약 및 취소 정보를 이벤트 저장소에 보류된 이벤트로 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-210">The system could store information about bookings and cancellations as events held in an event store.</span></span> <span data-ttu-id="d3efb-211">그런 다음 이 이벤트를 재생하여 사용 가능한 좌석 수를 계산할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-211">It could then calculate the number of seats available by replaying these events.</span></span> <span data-ttu-id="d3efb-212">이 접근 방법은 이벤트를 변경할 수 없기 때문에 더 확장성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-212">This approach can be more scalable due to the immutability of events.</span></span> <span data-ttu-id="d3efb-213">시스템이 이벤트 저장소에서 데이터를 읽거나 이벤트 저장소에 데이터를 추가할 수 있기만 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-213">The system only needs to be able to read data from the event store, or append data to the event store.</span></span> <span data-ttu-id="d3efb-214">예약 및 취소에 대한 이벤트 정보는 수정되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-214">Event information about bookings and cancellations is never modified.</span></span>

<span data-ttu-id="d3efb-215">다음 다이어그램은 이벤트 소싱을 사용하여 회의 관리 시스템의 좌석 예약 하위 시스템을 구현할 수 있는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-215">The following diagram illustrates how the seat reservation subsystem of the conference management system might be implemented using event sourcing.</span></span>

![이벤트 소싱을 사용하여 회의 관리 시스템에서 좌석 예약 정보 캡처](./_images/event-sourcing-bounded-context.png)

<span data-ttu-id="d3efb-217">두 개의 좌석을 예약하기 위한 작업 시퀀스는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-217">The sequence of actions for reserving two seats is as follows:</span></span>

1. <span data-ttu-id="d3efb-218">사용자 인터페이스가 두 명의 참석자를 위한 좌석을 예약하는 명령을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-218">The user interface issues a command to reserve seats for two attendees.</span></span> <span data-ttu-id="d3efb-219">명령은 별도의 명령 처리기에 의해 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-219">The command is handled by a separate command handler.</span></span> <span data-ttu-id="d3efb-220">사용자 인터페이스에서 분리되고 명령으로 게시된 요청을 처리하는 논리 부분입니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-220">A piece of logic that is decoupled from the user interface and is responsible for handling requests posted as commands.</span></span>

2. <span data-ttu-id="d3efb-221">예약 및 취소를 설명하는 이벤트를 쿼리하여 회의에 대한 모든 예약 정보를 포함하는 집계가 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-221">An aggregate containing information about all reservations for the conference is constructed by querying the events that describe bookings and cancellations.</span></span> <span data-ttu-id="d3efb-222">이 집계는 `SeatAvailability`라고 하며, 집계의 데이터를 쿼리하고 수정하기 위한 메서드를 노출하는 도메인 모델에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-222">This aggregate is called `SeatAvailability`, and is contained within a domain model that exposes methods for querying and modifying the data in the aggregate.</span></span>

    > <span data-ttu-id="d3efb-223">고려할 몇 가지 최적화는 스냅숏 사용(집계의 현재 상태를 얻기 위해 전체 이벤트 목록을 쿼리 및 재생할 필요가 없음) 및 메모리에 캐시된 집계 사본 유지 관리입니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-223">Some optimizations to consider are using snapshots (so that you don’t need to query and replay the full list of events to obtain the current state of the aggregate), and maintaining a cached copy of the aggregate in memory.</span></span>

3. <span data-ttu-id="d3efb-224">명령 처리기는 도메인 모델에서 노출된 메서드를 호출하여 예약을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-224">The command handler invokes a method exposed by the domain model to make the reservations.</span></span>

4. <span data-ttu-id="d3efb-225">`SeatAvailability` 집계는 예약된 좌석 수를 포함하는 이벤트를 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-225">The `SeatAvailability` aggregate records an event containing the number of seats that were reserved.</span></span> <span data-ttu-id="d3efb-226">다음에 집계가 이벤트를 적용하면 모든 예약이 남아 있는 좌석 수를 계산하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-226">The next time the aggregate applies events, all the reservations will be used to compute how many seats remain.</span></span>

5. <span data-ttu-id="d3efb-227">시스템이 이벤트 저장소의 이벤트 목록에 새 이벤트를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-227">The system appends the new event to the list of events in the event store.</span></span>

<span data-ttu-id="d3efb-228">사용자가 좌석을 취소하는 경우 명령 처리기가 좌석 취소 이벤트를 생성하고 이벤트 저장소에 추가하는 명령을 사용한다는 점을 제외하고 시스템이 유사한 프로세스를 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-228">If a user cancels a seat, the system follows a similar process except the command handler issues a command that generates a seat cancellation event and appends it to the event store.</span></span>

<span data-ttu-id="d3efb-229">이벤트 저장소를 사용하면 추가 확장성 범위가 제공될 뿐 아니라 회의 예약 및 취소의 전체 기록 또는 감사 추적도 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-229">As well as providing more scope for scalability, using an event store also provides a complete history, or audit trail, of the bookings and cancellations for a conference.</span></span> <span data-ttu-id="d3efb-230">이벤트 저장소의 이벤트는 정확한 레코드입니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-230">The events in the event store are the accurate record.</span></span> <span data-ttu-id="d3efb-231">시스템이 쉽게 이벤트를 재생하고 상태를 특정 시점으로 복원할 수 있으므로 다른 방법으로 집계를 저장할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-231">There is no need to persist aggregates in any other way because the system can easily replay the events and restore the state to any point in time.</span></span>

> <span data-ttu-id="d3efb-232">이 예제에 대한 정보는 [이벤트 소싱 소개](https://msdn.microsoft.com/library/jj591559.aspx)에서 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-232">You can find more information about this example in [Introducing Event Sourcing](https://msdn.microsoft.com/library/jj591559.aspx).</span></span>

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="d3efb-233">관련 패턴 및 지침</span><span class="sxs-lookup"><span data-stu-id="d3efb-233">Related patterns and guidance</span></span>

<span data-ttu-id="d3efb-234">이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-234">The following patterns and guidance might also be relevant when implementing this pattern:</span></span>

- <span data-ttu-id="d3efb-235">[CQRS(명령 및 쿼리 책임 분리)](./cqrs.md).</span><span class="sxs-lookup"><span data-stu-id="d3efb-235">[Command and Query Responsibility Segregation (CQRS) pattern](./cqrs.md).</span></span> <span data-ttu-id="d3efb-236">CQRS 구현에 대한 영구적 정보 소스를 제공하는 쓰기 저장소는 종종 이벤트 소싱 패턴 구현을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-236">The write store that provides the permanent source of information for a CQRS implementation is often based on an implementation of the Event Sourcing pattern.</span></span> <span data-ttu-id="d3efb-237">개별 인터페이스를 사용하여 애플리케이션의 데이터를 읽는 작업과 데이터를 업데이트하는 작업을 분리하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-237">Describes how to segregate the operations that read data in an application from the operations that update data by using separate interfaces.</span></span>

- <span data-ttu-id="d3efb-238">[구체화된 뷰 패턴](./materialized-view.md).</span><span class="sxs-lookup"><span data-stu-id="d3efb-238">[Materialized View pattern](./materialized-view.md).</span></span> <span data-ttu-id="d3efb-239">이벤트 소싱을 기준으로 시스템에서 사용되는 데이터 저장소는 일반적으로 효율적인 쿼리에 적합하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-239">The data store used in a system based on event sourcing is typically not well suited to efficient querying.</span></span> <span data-ttu-id="d3efb-240">대신, 일반적인 접근 방법은 정기적인 간격으로 또는 데이터가 변경될 때 미리 채워진 데이터 뷰를 생성하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-240">Instead, a common approach is to generate prepopulated views of the data at regular intervals, or when the data changes.</span></span> <span data-ttu-id="d3efb-241">이 작업을 수행하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-241">Shows how this can be done.</span></span>

- <span data-ttu-id="d3efb-242">[보상 트랜잭션 패턴](./compensating-transaction.md).</span><span class="sxs-lookup"><span data-stu-id="d3efb-242">[Compensating Transaction pattern](./compensating-transaction.md).</span></span> <span data-ttu-id="d3efb-243">이벤트 소싱 저장소의 기존 데이터는 업데이트되지 않고, 대신 엔터티 상태를 새 값으로 변환하는 새 항목이 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-243">The existing data in an event sourcing store is not updated, instead new entries are added that transition the state of entities to the new values.</span></span> <span data-ttu-id="d3efb-244">단순히 이전 변경을 되돌릴 수 없기 때문에 변경을 취소하기 위해 보정 항목이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-244">To reverse a change, compensating entries are used because it isn't possible to simply reverse the previous change.</span></span> <span data-ttu-id="d3efb-245">이전 작업에서 수행한 작업을 실행 취소하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-245">Describes how to undo the work that was performed by a previous operation.</span></span>

- <span data-ttu-id="d3efb-246">[데이터 일관성 입문서](https://msdn.microsoft.com/library/dn589800.aspx).</span><span class="sxs-lookup"><span data-stu-id="d3efb-246">[Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span> <span data-ttu-id="d3efb-247">개별 읽기 저장소 또는 구체화된 뷰와 함께 이벤트 소싱을 사용하는 경우 데이터 읽기가 즉시 일치하지 않고 결과적 일관성만 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-247">When using event sourcing with a separate read store or materialized views, the read data won't be immediately consistent, instead it'll be only eventually consistent.</span></span> <span data-ttu-id="d3efb-248">분산 데이터에 대한 일관성 유지와 관련된 문제를 요약합니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-248">Summarizes the issues surrounding maintaining consistency over distributed data.</span></span>

- <span data-ttu-id="d3efb-249">[데이터 분할 지침](https://msdn.microsoft.com/library/dn589795.aspx).</span><span class="sxs-lookup"><span data-stu-id="d3efb-249">[Data Partitioning Guidance](https://msdn.microsoft.com/library/dn589795.aspx).</span></span> <span data-ttu-id="d3efb-250">이벤트 소싱을 사용하여 확장성을 향상하고, 경합을 줄이고, 성능을 최적화하는 경우 데이터가 분할되는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-250">Data is often partitioned when using event sourcing to improve scalability, reduce contention, and optimize performance.</span></span> <span data-ttu-id="d3efb-251">데이터를 개별 파티션으로 나누는 방법과 발생할 수 있는 문제에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="d3efb-251">Describes how to divide data into discrete partitions, and the issues that can arise.</span></span>
