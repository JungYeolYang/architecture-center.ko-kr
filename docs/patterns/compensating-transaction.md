---
title: "보정 트랜잭션"
description: "여러 단계로 나뉘어 있지만 결국에는 일관적인 작업을 정의하는 일련의 단계에서 수행한 작업을 실행 취소합니다."
keywords: "디자인 패턴"
author: dragon119
ms.date: 06/23/2017
pnp.series.title: Cloud Design Patterns
pnp.pattern.categories: resiliency
ms.openlocfilehash: a822de990d6ce933024207073b110e98f8da40bf
ms.sourcegitcommit: 8ab30776e0c4cdc16ca0dcc881960e3108ad3e94
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 12/08/2017
---
# <a name="compensating-transaction-pattern"></a><span data-ttu-id="136c5-104">보상 트랜잭션 패턴</span><span class="sxs-lookup"><span data-stu-id="136c5-104">Compensating Transaction pattern</span></span>

[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="136c5-105">결과적으로 함께 모여서 일관된 작업을 정의하는 일련의 단계 중에서 하나 이상이 실패할 경우 이러한 일련의 단계로 수행되는 작업의 실행을 취소합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-105">Undo the work performed by a series of steps, which together define an eventually consistent operation, if one or more of the steps fail.</span></span> <span data-ttu-id="136c5-106">최종 일관성 모델을 따르는 작업은 일반적으로 복잡한 비즈니스 프로세스 및 워크플로를 구현하는 클라우드 호스티드 응용 프로그램에서 흔히 발견됩니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-106">Operations that follow the eventual consistency model are commonly found in cloud-hosted applications that implement complex business processes and workflows.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="136c5-107">컨텍스트 및 문제점</span><span class="sxs-lookup"><span data-stu-id="136c5-107">Context and problem</span></span>

<span data-ttu-id="136c5-108">클라우드에서 실행하는 응용 프로그램은 데이터를 자주 수정합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-108">Applications running in the cloud frequently modify data.</span></span> <span data-ttu-id="136c5-109">이 데이터는 여러 다른 지리적 위치에 있는 다양한 데이터 원본으로 분산될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-109">This data might be spread across various data sources held in different geographic locations.</span></span> <span data-ttu-id="136c5-110">분산 환경에서 경합을 방지하고 성능을 향상시키기 위해 응용 프로그램은 강력한 트랜잭션 일관성을 제공하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-110">To avoid contention and improve performance in a distributed environment, an application shouldn't try to provide strong transactional consistency.</span></span> <span data-ttu-id="136c5-111">대신, 응용 프로그램은 최종 일관성을 구현하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-111">Rather, the application should implement eventual consistency.</span></span> <span data-ttu-id="136c5-112">이 모델에서는 일반적인 비즈니스 작업이 일련의 별도 단계로 이루어져 있습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-112">In this model, a typical business operation consists of a series of separate steps.</span></span> <span data-ttu-id="136c5-113">이러한 단계를 수행하는 동안 시스템 상태가 전반적으로 일관되게 표시되지 않을 수 있지만, 작업이 완료되거 모든 단계가 실행되면 시스템은 다시 일관된 상태가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-113">While these steps are being performed, the overall view of the system state might be inconsistent, but when the operation has completed and all of the steps have been executed the system should become consistent again.</span></span>

> <span data-ttu-id="136c5-114">[데이터 일관성 입문서](https://msdn.microsoft.com/library/dn589800.aspx)는 분산 트랜잭션이 잘 확장되지 않는 이유와 최종 일관성 모델의 원리에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-114">The [Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx) provides information about why distributed transactions don't scale well, and the principles of the eventual consistency model.</span></span>

<span data-ttu-id="136c5-115">최종 일관성 모델의 해결 과제는 실패한 단계를 처리하는 방법에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-115">A challenge in the eventual consistency model is how to handle a step that has failed.</span></span> <span data-ttu-id="136c5-116">이 경우 작업의 이전 단계에서 완료된 모든 작업을 실행 취소해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-116">In this case it might be necessary to undo all of the work completed by the previous steps in the operation.</span></span> <span data-ttu-id="136c5-117">그러나 응용 프로그램의 다른 동시 인스턴스가 데이터를 변경했을 수 있으므로 간단히 롤백하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-117">However, the data can't simply be rolled back because other concurrent instances of the application might have changed it.</span></span> <span data-ttu-id="136c5-118">데이터가 동시 인스턴스에 의해 변경되지 않은 경우에도, 한 단계를 실행 취소하는 것만으로 원래 상태를 간단히 복원할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-118">Even in cases where the data hasn't been changed by a concurrent instance, undoing a step might not simply be a matter of restoring the original state.</span></span> <span data-ttu-id="136c5-119">다양한 비즈니스 관련 규칙을 적용해야 할 수 있습니다("예제" 섹션에 설명된 여행 웹 사이트 참조).</span><span class="sxs-lookup"><span data-stu-id="136c5-119">It might be necessary to apply various business-specific rules (see the travel website described in the Example section).</span></span>

<span data-ttu-id="136c5-120">최종 일관성을 구현하는 작업이 여러 이기종 데이터 저장소에 걸쳐 있는 경우 작업의 단계를 실행 취소하기 위해 각 데이터 저장소를 차례대로 방문해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-120">If an operation that implements eventual consistency spans several heterogeneous data stores, undoing the steps in the operation will require visiting each data store in turn.</span></span> <span data-ttu-id="136c5-121">모든 데이터 저장소에서 수행되는 작업은 시스템이 일관된 상태를 유지하도록 하기 위해 실행 취소해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-121">The work performed in every data store must be undone reliably to prevent the system from remaining inconsistent.</span></span>

<span data-ttu-id="136c5-122">최종 일관성을 구현하는 작업의 영향을 받는 모든 데이터가 데이터베이스에 들어 있지 않을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-122">Not all data affected by an operation that implements eventual consistency might be held in a database.</span></span> <span data-ttu-id="136c5-123">SOA(서비스 지향 아키텍처) 환경에서 작업은 서비스의 동작을 호출하며, 해당 서비스의 상태를 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-123">In a service oriented architecture (SOA) environment an operation could invoke an action in a service, and cause a change in the state held by that service.</span></span> <span data-ttu-id="136c5-124">작업을 실행 취소하려면 이 상태 변경도 실행 취소해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-124">To undo the operation, this state change must also be undone.</span></span> <span data-ttu-id="136c5-125">이 과정에서 서비스가 다시 호출되고, 처음 작업의 결과를 되돌리는 다른 작업이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-125">This can involve invoking the service again and performing another action that reverses the effects of the first.</span></span>

## <a name="solution"></a><span data-ttu-id="136c5-126">해결 방법</span><span class="sxs-lookup"><span data-stu-id="136c5-126">Solution</span></span>

<span data-ttu-id="136c5-127">해결 방법은 보정 트랜잭션을 구현하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-127">The solution is to implement a compensating transaction.</span></span> <span data-ttu-id="136c5-128">보정 트랜잭션의 단계는 원래 작업 단계의 결과를 실행 취소해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-128">The steps in a compensating transaction must undo the effects of the steps in the original operation.</span></span> <span data-ttu-id="136c5-129">이 접근 방법은 응용 프로그램의 다른 동시 인스턴스가 수행한 변경 내용을 덮어쓸 수 있으므로, 보정 트랜잭션으로 현재 상태를 작업 시작 시의 시스템 상태로 간단히 바꾸지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-129">A compensating transaction might not be able to simply replace the current state with the state the system was in at the start of the operation because this approach could overwrite changes made by other concurrent instances of an application.</span></span> <span data-ttu-id="136c5-130">대신, 동시 인스턴스에 의해 수행된 작업을 고려하는 지능형 프로세스여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-130">Instead, it must be an intelligent process that takes into account any work done by concurrent instances.</span></span> <span data-ttu-id="136c5-131">이 프로세스는 일반적으로 원래 작업에 의해 수행된 작업 결과의 특성에 따라, 응용 프로그램마다 고유해집니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-131">This process will usually be application specific, driven by the nature of the work performed by the original operation.</span></span>

<span data-ttu-id="136c5-132">일반적인 방법은 워크플로를 사용하여 보정을 필요로 하는 최종적으로 일관된 작업을 구현하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-132">A common approach is to use a workflow to implement an eventually consistent operation that requires compensation.</span></span> <span data-ttu-id="136c5-133">원래 작업이 계속 진행될 때 시스템은 각 단계와 해당 단계가 수행한 작업을 실행 취소하는 방법에 대한 정보를 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-133">As the original operation proceeds, the system records information about each step and how the work performed by that step can be undone.</span></span> <span data-ttu-id="136c5-134">특정 시점에 작업이 실패하면 워크플로는 완료된 단계 이전으로 되돌아가고, 각 단계를 되돌리는 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-134">If the operation fails at any point, the workflow rewinds back through the steps it's completed and performs the work that reverses each step.</span></span> <span data-ttu-id="136c5-135">보정 트랜잭션은 원래 작업의 정확히 반대 순서로 작업을 실행 취소할 필요는 없으며, 일부 실행 취소 단계를 동시에 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-135">Note that a compensating transaction might not have to undo the work in the exact reverse order of the original operation, and it might be possible to perform some of the undo steps in parallel.</span></span>

> <span data-ttu-id="136c5-136">이 접근 방식은 [Clemens Vasters 블로그](http://vasters.com/clemensv/2012/09/01/Sagas.aspx)에 설명된 Sagas 전략과 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-136">This approach is similar to the Sagas strategy discussed in [Clemens Vasters’ blog](http://vasters.com/clemensv/2012/09/01/Sagas.aspx).</span></span>

<span data-ttu-id="136c5-137">보정 트랜잭션은 최종적으로 일관된 작업이며, 실패할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-137">A compensating transaction is also an eventually consistent operation and it could also fail.</span></span> <span data-ttu-id="136c5-138">시스템은 오류 발생 지점에서 보정 트랜잭션을 다시 시작하고 계속할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-138">The system should be able to resume the compensating transaction at the point of failure and continue.</span></span> <span data-ttu-id="136c5-139">보정 트랜잭션의 단계를 멱등원 명령으로 정의해야 하므로, 실패한 단계를 반복해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-139">It might be necessary to repeat a step that's failed, so the steps in a compensating transaction should be defined as idempotent commands.</span></span> <span data-ttu-id="136c5-140">자세한 내용은 Jonathan Oliver 블로그에서 [멱등원 패턴](http://blog.jonathanoliver.com/idempotency-patterns/)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="136c5-140">For more information, see [Idempotency Patterns](http://blog.jonathanoliver.com/idempotency-patterns/) on Jonathan Oliver’s blog.</span></span>

<span data-ttu-id="136c5-141">경우에 따라 수동 개입을 통한 경우를 제외하고, 실패한 단계에서 복구하지 못할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-141">In some cases it might not be possible to recover from a step that has failed except through manual intervention.</span></span> <span data-ttu-id="136c5-142">이러한 경우 시스템은 경고를 발생시키며, 실패 이유에 대한 가능한 많은 정보를 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-142">In these situations the system should raise an alert and provide as much information as possible about the reason for the failure.</span></span>

## <a name="issues-and-considerations"></a><span data-ttu-id="136c5-143">문제 및 고려 사항</span><span class="sxs-lookup"><span data-stu-id="136c5-143">Issues and considerations</span></span>

<span data-ttu-id="136c5-144">이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="136c5-144">Consider the following points when deciding how to implement this pattern:</span></span>

<span data-ttu-id="136c5-145">최종 일관성을 구현하는 작업의 단계가 실패했을 때를 파악하기가 쉽지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-145">It might not be easy to determine when a step in an operation that implements eventual consistency has failed.</span></span> <span data-ttu-id="136c5-146">단계가 즉시 실패하지 않고 대신, 차단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-146">A step might not fail immediately, but instead could block.</span></span> <span data-ttu-id="136c5-147">특정 형태의 제한 시간 메커니즘을 구현해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-147">It might be necessary to implement some form of time-out mechanism.</span></span>

<span data-ttu-id="136c5-148">-보정 논리는 쉽게 일반화되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-148">-Compensation logic isn't easily generalized.</span></span> <span data-ttu-id="136c5-149">보정 트랜잭션은 응용 프로그램마다 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-149">A compensating transaction is application specific.</span></span> <span data-ttu-id="136c5-150">실패한 작업에서 각 단계의 결과를 실행 취소하기에 충분한 정보가 있는 응용 프로그램에 의존합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-150">It relies on the application having sufficient information to be able to undo the effects of each step in a failed operation.</span></span>

<span data-ttu-id="136c5-151">보정 트랜잭션의 단계를 멱등원 명령으로 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-151">You should define the steps in a compensating transaction as idempotent commands.</span></span> <span data-ttu-id="136c5-152">이렇게 하면 보정 트랜잭션 자체가 실패하더라도 단계가 반복될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-152">This enables the steps to be repeated if the compensating transaction itself fails.</span></span>

<span data-ttu-id="136c5-153">원래 작업의 단계를 처리하는 인프라와 보정 트랜잭션은 복원될 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-153">The infrastructure that handles the steps in the original operation, and the compensating transaction, must be resilient.</span></span> <span data-ttu-id="136c5-154">실패한 단계를 보정하는 데 필요한 정보를 손실하지 않아야 하며, 보정 논리의 진행 상태를 안정적으로 모니터링할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-154">It must not lose the information required to compensate for a failing step, and it must be able to reliably monitor the progress of the compensation logic.</span></span>

<span data-ttu-id="136c5-155">보정 트랜잭션을 수행해도 시스템의 데이터가 반드시 원래 작업 시작 시의 시스템 상태로 돌아가는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-155">A compensating transaction doesn't necessarily return the data in the system to the state it was in at the start of the original operation.</span></span> <span data-ttu-id="136c5-156">대신, 작업이 실패하기 전에 성공적으로 완료된 단계에 의해 수행된 작업이 보정됩니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-156">Instead, it compensates for the work performed by the steps that completed successfully before the operation failed.</span></span>

<span data-ttu-id="136c5-157">보정 트랜잭션의 단계 순서가 원래 작업 단계의 정확히 반대일 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-157">The order of the steps in the compensating transaction doesn't necessarily have to be the exact opposite of the steps in the original operation.</span></span> <span data-ttu-id="136c5-158">예를 들어, 하나의 데이터 저장소가 다른 데이터 저장소보다 비일관성에 더 많이 민감할 수도 있으며, 이러한 경우에는 이 저장소에 대한 변경을 실행 취소하는 보정 트랜잭션의 단계가 먼저 수행되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-158">For example, one data store might be more sensitive to inconsistencies than another, and so the steps in the compensating transaction that undo the changes to this store should occur first.</span></span>

<span data-ttu-id="136c5-159">작업을 완료하는 데 필요한 각 리소스에 대해 단기 시간 제한 기반 잠금을 적용하고 이러한 리소스를 미리 획득하면, 전체 활동이 성공할 가능성이 높아질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-159">Placing a short-term timeout-based lock on each resource that's required to complete an operation, and obtaining these resources in advance, can help increase the likelihood that the overall activity will succeed.</span></span> <span data-ttu-id="136c5-160">작업은 모든 리소스를 획득한 후에만 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-160">The work should be performed only after all the resources have been acquired.</span></span> <span data-ttu-id="136c5-161">잠금이 만료되기 전에 모든 작업이 종료되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-161">All actions must be finalized before the locks expire.</span></span>

<span data-ttu-id="136c5-162">보정 트랜잭션을 트리거하는 오류를 최소화하려면 평소보다 좀 더 관대한 다시 시도 논리를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-162">Consider using retry logic that is more forgiving than usual to minimize failures that trigger a compensating transaction.</span></span> <span data-ttu-id="136c5-163">최종 일관성을 구현하는 작업의 단계가 실패하면 오류를 일시적인 예외로 처리하고 단계를 반복합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-163">If a step in an operation that implements eventual consistency fails, try handling the failure as a transient exception and repeat the step.</span></span> <span data-ttu-id="136c5-164">단계가 반복적으로 또는 복구 불가능하게 실패한 경우에만 작업을 중지하고 보정 트랜잭션을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-164">Only stop the operation and initiate a compensating transaction if a step fails repeatedly or irrecoverably.</span></span>

> <span data-ttu-id="136c5-165">보정 트랜잭션을 구현할 때의 여러 문제점은 최종 일관성을 구현할 때의 문제점과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-165">Many of the challenges of implementing a compensating transaction are the same as those with implementing eventual consistency.</span></span> <span data-ttu-id="136c5-166">자세한 내용은 [데이터 일관성 입문서](https://msdn.microsoft.com/library/dn589800.aspx)에서 “최종 일관성 구현에 대한 고려 사항” 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="136c5-166">See the section Considerations for Implementing Eventual Consistency in the [Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx) for more information.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="136c5-167">이 패턴을 사용해야 하는 경우</span><span class="sxs-lookup"><span data-stu-id="136c5-167">When to use this pattern</span></span>

<span data-ttu-id="136c5-168">이 패턴은 작업이 실패한 경우 실행 취소해야 하는 경우에만 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-168">Use this pattern only for operations that must be undone if they fail.</span></span> <span data-ttu-id="136c5-169">가능한 경우 보정 트랜잭션에 따른 복잡성을 피하도록 솔루션을 디자인합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-169">If possible, design solutions to avoid the complexity of requiring compensating transactions.</span></span>

## <a name="example"></a><span data-ttu-id="136c5-170">예</span><span class="sxs-lookup"><span data-stu-id="136c5-170">Example</span></span>

<span data-ttu-id="136c5-171">여행 웹 사이트에서 고객은 여행 일정을 예약할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-171">A travel website lets customers book itineraries.</span></span> <span data-ttu-id="136c5-172">단일 여행 일정은 일련의 항공편 및 호텔로 구성될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-172">A single itinerary might comprise a series of flights and hotels.</span></span> <span data-ttu-id="136c5-173">시애틀에서 런던으로 간 다음 파리로 이동하는 고객은 여행 일정을 만들 때 다음 단계를 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-173">A customer traveling from Seattle to London and then on to Paris could perform the following steps when creating an itinerary:</span></span>

1. <span data-ttu-id="136c5-174">시애틀-런던 F1 항공편에 좌석을 예약합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-174">Book a seat on flight F1 from Seattle to London.</span></span>
2. <span data-ttu-id="136c5-175">파리-런던 F2 항공편에 좌석을 예약합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-175">Book a seat on flight F2 from London to Paris.</span></span>
3. <span data-ttu-id="136c5-176">파리-시애틀 F3 항공편에 좌석을 예약합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-176">Book a seat on flight F3 from Paris to Seattle.</span></span>
4. <span data-ttu-id="136c5-177">런던의 호텔 H1에 객실을 예약합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-177">Reserve a room at hotel H1 in London.</span></span>
5. <span data-ttu-id="136c5-178">파리의 호텔 H2에 객실을 예약합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-178">Reserve a room at hotel H2 in Paris.</span></span>

<span data-ttu-id="136c5-179">각 단계는 별도 동작에 해당하지만, 다음 단계는 최종적으로 일관된 작업을 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-179">These steps constitute an eventually consistent operation, although each step is a separate action.</span></span> <span data-ttu-id="136c5-180">따라서 고객이 여행 일정을 취소하기로 결정하는 경우 시스템은 이러한 단계를 수행할 뿐만 아니라, 각 단계를 실행 취소하는 데 필요한 카운터 작업도 기록해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-180">Therefore, as well as performing these steps, the system must also record the counter operations necessary to undo each step in case the customer decides to cancel the itinerary.</span></span> <span data-ttu-id="136c5-181">그런 후에는 카운터 작업을 수행하는 데 필요한 단계를 보정 트랜잭션으로 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-181">The steps necessary to perform the counter operations can then run as a compensating transaction.</span></span>

<span data-ttu-id="136c5-182">보정 트랜잭션의 단계는 원래 단계의 정반대가 아닐 수 있으며, 보정 트랜잭션에서 각 단계의 논리는 모든 비즈니스 관련 규칙을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-182">Notice that the steps in the compensating transaction might not be the exact opposite of the original steps, and the logic in each step in the compensating transaction must take into account any business-specific rules.</span></span> <span data-ttu-id="136c5-183">예를 들어, 항공편에서 좌석 예약을 취소해도 고객은 지불한 금액을 완전히 환불 받을 자격이 없을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-183">For example, unbooking a seat on a flight might not entitle the customer to a complete refund of any money paid.</span></span> <span data-ttu-id="136c5-184">이 그림에서는 여행 일정을 예약하는 장기 실행 트랜잭션을 실행 취소하는 보정 트랜잭션을 생성하는 과정을 보여 합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-184">The figure illustrates generating a compensating transaction to undo a long-running transaction to book a travel itinerary.</span></span>

![여행 일정을 예약하는 장기 실행 트랜잭션을 실행 취소하는 보정 트랜잭션 생성](./_images/compensating-transaction-diagram.png)


> <span data-ttu-id="136c5-186">각 단계에 대해 보정 논리를 디자인한 방식에 따라, 보정 트랜잭션의 단계가 동시에 수행될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-186">It might be possible for the steps in the compensating transaction to be performed in parallel, depending on how you've designed the compensating logic for each step.</span></span>

<span data-ttu-id="136c5-187">많은 비즈니스 솔루션에서 단일 단계가 실패한다고 해서 반드시 보정 트랜잭션을 사용하여 시스템을 롤백해야 하는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-187">In many business solutions, failure of a single step doesn't always necessitate rolling the system back by using a compensating transaction.</span></span> <span data-ttu-id="136c5-188">예를 들어, 고객이 여행 웹 사이트 시나리오에서 항공편 F1, F2 및 F3를 예약한 후에 호텔 H1에서 객실을 예약할 수 없는 경우, 항공편을 취소하지 말고 같은 도시에 있는 다른 호텔의 객실을 고객에게 제공하는 것이 바람직할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-188">For example, if&mdash;after having booked flights F1, F2, and F3 in the travel website scenario&mdash;the customer is unable to reserve a room at hotel H1, it's preferable to offer the customer a room at a different hotel in the same city rather than canceling the flights.</span></span> <span data-ttu-id="136c5-189">고객은 여전히 취소하기로 결정할 수 있지만(이 경우 보정 트랜잭션이 실행되고 항공편 F1, F2 및 F3에 대한 예약을 실행 취소함) 이 결정은 시스템이 아닌 고객이 내려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-189">The customer can still decide to cancel (in which case the compensating transaction runs and undoes the bookings made on flights F1, F2, and F3), but this decision should be made by the customer rather than by the system.</span></span>

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="136c5-190">관련 패턴 및 지침</span><span class="sxs-lookup"><span data-stu-id="136c5-190">Related patterns and guidance</span></span>

<span data-ttu-id="136c5-191">이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-191">The following patterns and guidance might also be relevant when implementing this pattern:</span></span>

- <span data-ttu-id="136c5-192">[데이터 일관성 입문서](https://msdn.microsoft.com/library/dn589800.aspx).</span><span class="sxs-lookup"><span data-stu-id="136c5-192">[Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span> <span data-ttu-id="136c5-193">보정 트랜잭션 패턴은 종종 최종 일관성 모델이 구현하는 작업을 실행 취소하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-193">The Compensating Transaction pattern is often used to undo operations that implement the eventual consistency model.</span></span> <span data-ttu-id="136c5-194">이 입문서는 최종 일관성의 장단점에 대한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-194">This primer provides information on the benefits and tradeoffs of eventual consistency.</span></span>

- <span data-ttu-id="136c5-195">[스케줄러-에이전트-감독자 패턴](scheduler-agent-supervisor.md).</span><span class="sxs-lookup"><span data-stu-id="136c5-195">[Scheduler-Agent-Supervisor Pattern](scheduler-agent-supervisor.md).</span></span> <span data-ttu-id="136c5-196">분산 서비스 및 리소스를 사용하는 비즈니스 작업을 수행하는 복원력 있는 시스템을 구현하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-196">Describes how to implement resilient systems that perform business operations that use distributed services and resources.</span></span> <span data-ttu-id="136c5-197">경우에 따라 보정 트랜잭션을 사용하여 작업에 의해 수행된 결과를 실행 취소해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-197">Sometimes, it might be necessary to undo the work performed by an operation by using a compensating transaction.</span></span>

- <span data-ttu-id="136c5-198">[다시 시도 패턴](./retry.md).</span><span class="sxs-lookup"><span data-stu-id="136c5-198">[Retry Pattern](./retry.md).</span></span> <span data-ttu-id="136c5-199">보정 트랜잭션은 수행하는 데 비용이 많이 들 수 있으며, 다시 시도 패턴에 따라 실패한 작업을 다시 시도하는 효과적인 정책을 구현함으로써 보정 트랜잭션 사용을 최소화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="136c5-199">Compensating transactions can be expensive to perform, and it might be possible to minimize their use by implementing an effective policy of retrying failing operations by following the Retry pattern.</span></span>
