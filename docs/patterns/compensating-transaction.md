---
title: 보정 트랜잭션
description: 여러 단계로 나뉘어 있지만 결국에는 일관적인 작업을 정의하는 일련의 단계에서 수행한 작업을 실행 취소합니다.
keywords: 디자인 패턴
author: dragon119
ms.date: 06/23/2017
pnp.series.title: Cloud Design Patterns
pnp.pattern.categories:
- resiliency
ms.openlocfilehash: 3d58537d9c77b97332bcabf762b9af7ed2f20421
ms.sourcegitcommit: 94d50043db63416c4d00cebe927a0c88f78c3219
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/28/2018
ms.locfileid: "47428145"
---
# <a name="compensating-transaction-pattern"></a>보상 트랜잭션 패턴

[!INCLUDE [header](../_includes/header.md)]

결과적으로 함께 모여서 일관된 작업을 정의하는 일련의 단계 중에서 하나 이상이 실패할 경우 이러한 일련의 단계로 수행되는 작업의 실행을 취소합니다. 최종 일관성 모델을 따르는 작업은 일반적으로 복잡한 비즈니스 프로세스 및 워크플로를 구현하는 클라우드 호스티드 애플리케이션에서 흔히 발견됩니다.

## <a name="context-and-problem"></a>컨텍스트 및 문제점

클라우드에서 실행하는 애플리케이션은 데이터를 자주 수정합니다. 이 데이터는 여러 다른 지리적 위치에 있는 다양한 데이터 원본으로 분산될 수 있습니다. 분산 환경에서 경합을 방지하고 성능을 향상시키기 위해 애플리케이션은 강력한 트랜잭션 일관성을 제공하지 않을 수 있습니다. 대신, 애플리케이션은 최종 일관성을 구현하려고 합니다. 이 모델에서는 일반적인 비즈니스 작업이 일련의 별도 단계로 이루어져 있습니다. 이러한 단계를 수행하는 동안 시스템 상태가 전반적으로 일관되게 표시되지 않을 수 있지만, 작업이 완료되거 모든 단계가 실행되면 시스템은 다시 일관된 상태가 됩니다.

> [데이터 일관성 입문서](https://msdn.microsoft.com/library/dn589800.aspx)는 분산 트랜잭션이 잘 확장되지 않는 이유와 최종 일관성 모델의 원리에 대해 설명합니다.

최종 일관성 모델의 해결 과제는 실패한 단계를 처리하는 방법에 있습니다. 이 경우 작업의 이전 단계에서 완료된 모든 작업을 실행 취소해야 할 수 있습니다. 그러나 애플리케이션의 다른 동시 인스턴스가 데이터를 변경했을 수 있으므로 간단히 롤백하지 못할 수 있습니다. 데이터가 동시 인스턴스에 의해 변경되지 않은 경우에도, 한 단계를 실행 취소하는 것만으로 원래 상태를 간단히 복원할 수는 없습니다. 다양한 비즈니스 관련 규칙을 적용해야 할 수 있습니다("예제" 섹션에 설명된 여행 웹 사이트 참조).

최종 일관성을 구현하는 작업이 여러 이기종 데이터 저장소에 걸쳐 있는 경우 작업의 단계를 실행 취소하기 위해 각 데이터 저장소를 차례대로 방문해야 합니다. 모든 데이터 저장소에서 수행되는 작업은 시스템이 일관된 상태를 유지하도록 하기 위해 실행 취소해야 합니다.

최종 일관성을 구현하는 작업의 영향을 받는 모든 데이터가 데이터베이스에 들어 있지 않을 수도 있습니다. SOA(서비스 지향 아키텍처) 환경에서 작업은 서비스의 동작을 호출하며, 해당 서비스의 상태를 변경할 수 있습니다. 작업을 실행 취소하려면 이 상태 변경도 실행 취소해야 합니다. 이 과정에서 서비스가 다시 호출되고, 처음 작업의 결과를 되돌리는 다른 작업이 수행됩니다.

## <a name="solution"></a>해결 방법

해결 방법은 보정 트랜잭션을 구현하는 것입니다. 보정 트랜잭션의 단계는 원래 작업 단계의 결과를 실행 취소해야 합니다. 이 접근 방법은 애플리케이션의 다른 동시 인스턴스가 수행한 변경 내용을 덮어쓸 수 있으므로, 보정 트랜잭션으로 현재 상태를 작업 시작 시의 시스템 상태로 간단히 바꾸지 못할 수 있습니다. 대신, 동시 인스턴스에 의해 수행된 작업을 고려하는 지능형 프로세스여야 합니다. 이 프로세스는 일반적으로 원래 작업에 의해 수행된 작업 결과의 특성에 따라, 애플리케이션마다 고유해집니다.

일반적인 방법은 워크플로를 사용하여 보정을 필요로 하는 최종적으로 일관된 작업을 구현하는 것입니다. 원래 작업이 계속 진행될 때 시스템은 각 단계와 해당 단계가 수행한 작업을 실행 취소하는 방법에 대한 정보를 기록합니다. 특정 시점에 작업이 실패하면 워크플로는 완료된 단계 이전으로 되돌아가고, 각 단계를 되돌리는 작업을 수행합니다. 보정 트랜잭션은 원래 작업의 정확히 반대 순서로 작업을 실행 취소할 필요는 없으며, 일부 실행 취소 단계를 동시에 수행할 수 있습니다.

> 이 접근 방식은 [Clemens Vasters 블로그](https://vasters.com/clemensv/2012/09/01/Sagas.aspx)에 설명된 Sagas 전략과 비슷합니다.

보정 트랜잭션은 최종적으로 일관된 작업이며, 실패할 수도 있습니다. 시스템은 오류 발생 지점에서 보정 트랜잭션을 다시 시작하고 계속할 수 있어야 합니다. 보정 트랜잭션의 단계를 멱등원 명령으로 정의해야 하므로, 실패한 단계를 반복해야 할 수 있습니다. 자세한 내용은 Jonathan Oliver 블로그에서 [멱등원 패턴](https://blog.jonathanoliver.com/idempotency-patterns/)을 참조하세요.

경우에 따라 수동 개입을 통한 경우를 제외하고, 실패한 단계에서 복구하지 못할 수도 있습니다. 이러한 경우 시스템은 경고를 발생시키며, 실패 이유에 대한 가능한 많은 정보를 제공해야 합니다.

## <a name="issues-and-considerations"></a>문제 및 고려 사항

이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.

최종 일관성을 구현하는 작업의 단계가 실패했을 때를 파악하기가 쉽지 않을 수 있습니다. 단계가 즉시 실패하지 않고 대신, 차단될 수 있습니다. 특정 형태의 제한 시간 메커니즘을 구현해야 할 수도 있습니다.

-보정 논리는 쉽게 일반화되지 않습니다. 보정 트랜잭션은 애플리케이션마다 다릅니다. 실패한 작업에서 각 단계의 결과를 실행 취소하기에 충분한 정보가 있는 애플리케이션에 의존합니다.

보정 트랜잭션의 단계를 멱등원 명령으로 정의해야 합니다. 이렇게 하면 보정 트랜잭션 자체가 실패하더라도 단계가 반복될 수 있습니다.

원래 작업의 단계를 처리하는 인프라와 보정 트랜잭션은 복원될 수 있어야 합니다. 실패한 단계를 보정하는 데 필요한 정보를 손실하지 않아야 하며, 보정 논리의 진행 상태를 안정적으로 모니터링할 수 있어야 합니다.

보정 트랜잭션을 수행해도 시스템의 데이터가 반드시 원래 작업 시작 시의 시스템 상태로 돌아가는 것은 아닙니다. 대신, 작업이 실패하기 전에 성공적으로 완료된 단계에 의해 수행된 작업이 보정됩니다.

보정 트랜잭션의 단계 순서가 원래 작업 단계의 정확히 반대일 필요는 없습니다. 예를 들어, 하나의 데이터 저장소가 다른 데이터 저장소보다 비일관성에 더 많이 민감할 수도 있으며, 이러한 경우에는 이 저장소에 대한 변경을 실행 취소하는 보정 트랜잭션의 단계가 먼저 수행되어야 합니다.

작업을 완료하는 데 필요한 각 리소스에 대해 단기 시간 제한 기반 잠금을 적용하고 이러한 리소스를 미리 획득하면, 전체 활동이 성공할 가능성이 높아질 수 있습니다. 작업은 모든 리소스를 획득한 후에만 수행해야 합니다. 잠금이 만료되기 전에 모든 작업이 종료되어야 합니다.

보정 트랜잭션을 트리거하는 오류를 최소화하려면 평소보다 좀 더 관대한 다시 시도 논리를 사용하는 것이 좋습니다. 최종 일관성을 구현하는 작업의 단계가 실패하면 오류를 일시적인 예외로 처리하고 단계를 반복합니다. 단계가 반복적으로 또는 복구 불가능하게 실패한 경우에만 작업을 중지하고 보정 트랜잭션을 시작합니다.

> 보정 트랜잭션을 구현할 때의 여러 문제점은 최종 일관성을 구현할 때의 문제점과 같습니다. 자세한 내용은 [데이터 일관성 입문서](https://msdn.microsoft.com/library/dn589800.aspx)에서 “최종 일관성 구현에 대한 고려 사항” 섹션을 참조하세요.

## <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우

이 패턴은 작업이 실패한 경우 실행 취소해야 하는 경우에만 사용합니다. 가능한 경우 보정 트랜잭션에 따른 복잡성을 피하도록 솔루션을 디자인합니다.

## <a name="example"></a>예

여행 웹 사이트에서 고객은 여행 일정을 예약할 수 있습니다. 단일 여행 일정은 일련의 항공편 및 호텔로 구성될 수 있습니다. 시애틀에서 런던으로 간 다음 파리로 이동하는 고객은 여행 일정을 만들 때 다음 단계를 수행해야 합니다.

1. 시애틀-런던 F1 항공편에 좌석을 예약합니다.
2. 파리-런던 F2 항공편에 좌석을 예약합니다.
3. 파리-시애틀 F3 항공편에 좌석을 예약합니다.
4. 런던의 호텔 H1에 객실을 예약합니다.
5. 파리의 호텔 H2에 객실을 예약합니다.

각 단계는 별도 동작에 해당하지만, 다음 단계는 최종적으로 일관된 작업을 구성합니다. 따라서 고객이 여행 일정을 취소하기로 결정하는 경우 시스템은 이러한 단계를 수행할 뿐만 아니라, 각 단계를 실행 취소하는 데 필요한 카운터 작업도 기록해야 합니다. 그런 후에는 카운터 작업을 수행하는 데 필요한 단계를 보정 트랜잭션으로 실행할 수 있습니다.

보정 트랜잭션의 단계는 원래 단계의 정반대가 아닐 수 있으며, 보정 트랜잭션에서 각 단계의 논리는 모든 비즈니스 관련 규칙을 고려해야 합니다. 예를 들어, 항공편에서 좌석 예약을 취소해도 고객은 지불한 금액을 완전히 환불 받을 자격이 없을 수 있습니다. 이 그림에서는 여행 일정을 예약하는 장기 실행 트랜잭션을 실행 취소하는 보정 트랜잭션을 생성하는 과정을 보여 합니다.

![여행 일정을 예약하는 장기 실행 트랜잭션을 실행 취소하는 보정 트랜잭션 생성](./_images/compensating-transaction-diagram.png)


> 각 단계에 대해 보정 논리를 디자인한 방식에 따라, 보정 트랜잭션의 단계가 동시에 수행될 수도 있습니다.

많은 비즈니스 솔루션에서 단일 단계가 실패한다고 해서 반드시 보정 트랜잭션을 사용하여 시스템을 롤백해야 하는 것은 아닙니다. 예를 들어, 고객이 여행 웹 사이트 시나리오에서 항공편 F1, F2 및 F3를 예약한 후에 호텔 H1에서 객실을 예약할 수 없는 경우, 항공편을 취소하지 말고 같은 도시에 있는 다른 호텔의 객실을 고객에게 제공하는 것이 바람직할 수 있습니다. 고객은 여전히 취소하기로 결정할 수 있지만(이 경우 보정 트랜잭션이 실행되고 항공편 F1, F2 및 F3에 대한 예약을 실행 취소함) 이 결정은 시스템이 아닌 고객이 내려야 합니다.

## <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침

이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.

- [Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx)(데이터 일관성 입문서). 보정 트랜잭션 패턴은 종종 최종 일관성 모델이 구현하는 작업을 실행 취소하는 데 사용됩니다. 이 입문서는 최종 일관성의 장단점에 대한 정보를 제공합니다.

- [스케줄러-에이전트-감독자 패턴](scheduler-agent-supervisor.md). 분산 서비스 및 리소스를 사용하는 비즈니스 작업을 수행하는 복원력 있는 시스템을 구현하는 방법을 설명합니다. 경우에 따라 보정 트랜잭션을 사용하여 작업에 의해 수행된 결과를 실행 취소해야 할 수도 있습니다.

- [다시 시도 패턴](./retry.md). 보정 트랜잭션은 수행하는 데 비용이 많이 들 수 있으며, 다시 시도 패턴에 따라 실패한 작업을 다시 시도하는 효과적인 정책을 구현함으로써 보정 트랜잭션 사용을 최소화할 수 있습니다.
