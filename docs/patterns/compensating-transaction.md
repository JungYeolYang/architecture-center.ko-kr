---
title: Compensating Transaction
description: Undo the work performed by a series of steps, which together define an eventually consistent operation.
keywords: design pattern
author: dragon119
ms.service: guidance
ms.topic: article
ms.author: pnp
ms.date: 03/24/2017

pnp.series.title: Cloud Design Patterns
pnp.pattern.categories: [resiliency]
---

# 보상 트랜잭션

[!INCLUDE [header](../_includes/header.md)]

하나 이상의 단계가 실패하는 경우 여러 단계(결과적으로 일관성 있는 작업을 정의)를 거쳐 수행된 결과를 실행 취소합니다. 최종 일관성 모델을 따르는 작업은 복잡한 비즈니스 프로세스와 워크플로를 구현하는 클라우드 호스팅 응용 프로그램에 일반적으로 사용됩니다.

## 배경 및 문제

클라우드에서 실행되는 응용 프로그램은 데이터를 자주 수정합니다. 이런 데이터는 여러 지리적 위치에 있는 다양한 데이터 원본에 분산됩니다. 분산 환경에서 경합을 방지하고 성능을 향상시키기 위해 응용 프로그램은 강력한 트랜잭션 일관성을 제공하려고 하기보다 오히려 최종 일관성을 구현해야 합니다. 이 모델에서 일반적인 비즈니스 작업은 일련의 분리된 단계로 구성됩니다. 이런 단계를 수행하는 동안에는 시스템 상태의 전체 보기가 일관되지 않을 수 있지만, 작업이 완료되고 모든 단계가 실행되면 시스템의 일관성은 다시 유지되어야 합니다.

> [데이터 일관성 프라이머](https://msdn.microsoft.com/library/dn589800.aspx) 는 분산 트랜잭션의 크기를 조정하기 어려운 이유와 최종 일관성 모델의 원리에 대한 정보를 제공합니다.

최종 일관성 모델에서의 과제는 실패한 단계를 처리하는 방법에 있습니다. 이 경우 작업의 이전 단계에서 완료된 모든 결과의 실행 취소가 필요할 수 있는데 응용 프로그램의 다른 동시 인스턴스가 데이터를 변경했기 때문에, 데이터는 간단히 롤백할 수 없습니다. 동시 인스턴스가 데이터를 변경하지 않은 경우라도 단계의 실행 취소는 원본 상태를 복구하는 간단한 문제가 아닙니다. 이 경우 다양한 비즈니스에 고유한 규칙(예제 섹션에 설명된 여행 웹 사이트 참조)의 적용이 필요할 수 있습니다.

최종 일관성을 구현하는 작업이 다른 유형의 여러 데이터 저장소에 관련되면 작업의 단계를 실행 취소하기 위해 각 데이터 저장소를 차례대로 방문해야 합니다. 모든 데이터 저장소에서 수행된 작업은 시스템이 불일치 상태가 되지 않도록 확실하게 실행 취소되어야 합니다.

최종 일관성을 구현하는 작업에 영향을 받은 데이터는 데이터베이스에 보관되지 않습니다. 서비스 지향 아키텍처(SOA) 환경에서 작업은 서비스에서 동작을 호출할 수 있고, 그러면 동작을 호출한 서비스의 상태가 변하게 됩니다. 따라서 작업을 실행 취소하려면 이런 상태 변경도 실행 취소해야 하는데, 해당 서비스를 다시 호출하고 처음의 결과와 반대가 되는 다른 동작을 수행해 상태 변경을 실행 취소할 수 있습니다. 

## 해결책

해결책은 보상 트랜잭션을 구현하는 것입니다. 보상 트랜잭션의 단계는 원래 작업의 단계로 나타난 결과를 실행 취소해야 합니다. 보상 트랜잭션은 현재 상태를 작업을 시작할 때의 시스템 상태로 간단히 되돌릴 수 없는데, 그 이유는 이와 같은 방식으로 접근할 경우 응용 프로그램의 다른 동시 인스턴스가 수행한 변경 사항을 덮어쓸 수 있기 때문입니다. 대신 보상 트랜잭션은 동시 인스턴스가 수행한 작업을 고려하는 지능형 프로세스가 되어야 합니다. 보통 지능형 프로세스는 응용 프로그램에 따라 다르며 원래 작업이 수행한 결과의 특성으로 구동됩니다.

일반적인 접근 방식은 워크플로를 사용해 보상이 필요한 최종 일관성 작업을 구현하는 것입니다. 원래 작업이 진행되면 시스템은 각 단계의 대한 정보 및 해당 단계가 수행한 작업의 실행 취소 방법을 기록합니다. 작업이 특정 시점에 실패하면 워크플로는 완료된 단계를 역순으로 확인하고 각 단계에 반대가 되는 작업을 수행합니다. 보상 트랜잭션은 원래 작업과 똑같은 역순으로 작업을 실행 취소할 필요가 없으며 실행 취소한 단계의 일부를 동시에 수행할 수 있습니다.

> 이런 접근 방식은 [Clemens Vasters가 블로그](http://vasters.com/clemensv/2012/09/01/Sagas.aspx)에서 논의한 Sagas 전략과 비슷합니다.

또한 보상 트랜잭션은 결과적으로 일관성을 유지하는 작업이기도 한데, 실패할 수도 있습니다. 따라서 시스템은 보상 트랜잭션을 실패한 지점에서 다시 시작하고 계속할 수 있어야 합니다. 한편 실패한 단계의 반복이 필요할 수 있으므로 보상 트랜잭션의 단계는 멱등 명령으로 정의해야 합니다. 추가 정보는 Jonathan Oliver의 블로그에 포스팅된 [멱등성 패턴](http://blog.jonathanoliver.com/2010/04/idempotency-patterns/) 을 참조하시기 바랍니다.

일부의 경우 수동 작업을 통하지 않고는 실패한 단계를 복구하는 것이 불가능할 수 있습니다. 이런 상황에서 시스템은 경고를 발생시키고 실패 이유에 대한 최대한 많은 정보를 제공해야 합니다.

## 문제 및 고려 사항

이 패턴의 구현 방법을 결정할 때는 다음 사항을 고려합니다.

최종 일관성을 구현하는 작업의 단계가 실패한 시점을 결정하는 것은 쉽지 않습니다. 단계가 즉시 실패하는 대신 차단될 수 있기 때문입니다. 따라서 시간 제한 방식으로 일부 형태를 구현할 필요가 있습니다.

-보상 논리는 쉽게 일반화되지 않습니다. 보상 트랜잭션은 응용 프로그램에 따라 다릅니다. 보상 트랜잭션에는 실패한 작업에서 각 단계의 결과를 실행 취소할 정도로 충분한 정보를 보유한 응용 프로그램이 필요합니다.

사용자는 보상 트랜잭션의 단계를 멱등 명령으로 정의해야 합니다. 이렇게 하면 보상 트랜잭션 자체가 실패하는 경우 단계를 반복할 수 있습니다.

원래 작업의 단계와 보상 트랜잭션을 처리하는 인프라는 복원력이 있어야 합니다. 이런 인프라는 실패한 단계를 보상하는 데 필요한 정보를 잃어버리지 않아야 하며 보상 논리의 진행을 안정적으로 모니터링할 수 있어야 합니다.

보상 트랜잭션은 시스템의 데이터를 원래 작업을 시작할 때의 시스템 상태로 반드시 되돌린다기보다는 작업이 실패하기 전에 성공적으로 완료한 단계까지 수행된 결과를 보상합니다.

보상 트랜잭션의 단계 순서는 원래 작업의 단계와 똑같은 역순일 필요가 없습니다. 예를 들어 하나의 데이터 저장소는 다른 데이터 저장소보다 불일치에 더 민감할 수 있으므로 민감한 데이터 저장소의 변경 사항을 실행 취소하는 보상 트랜잭션의 단계가 먼저 수행되어야 합니다.

작업을 완료하는 데 필요한 각 리소스에 단기 시간 제한 기반 잠금을 적용하고 이런 리소스를 미리 가져오면 전체 작업이 성공할 가능성을 높일 수 있습니다. 작업은 리소스를 모두 가져온 후에 수행되어야 하고 모든 동작은 잠금이 만료되기 전에 완료되어야 합니다.

보상 트랜잭션을 트리거하는 실패를 최소화하기 위해 평소에 잘 사용하지 않는 다시 시도 논리의 사용을 고려합니다. 최종 일관성을 구현하는 작업의 단계가 실패하면 실패를 일시적인 예외로 처리하고 단계를 반복합니다. 단계가 반복적으로 또는 복구할 수 없게 실패하면 작업을 중지하고 보상 트랜잭션을 시작하기만 하면 됩니다.

> 보상 트랜잭션을 구현할 때 당면하는 많은 과제는 최종 일관성을 구현할 때의 과제와 동일합니다. 자세한 정보는 [데이터 일관성 프라이머](https://msdn.microsoft.com/library/dn589800.aspx) 에서 최종 일관성의 구현을 위한 고려 사항 섹션을 참조하시기 바랍니다.

## 패턴 사용 사례

이 패턴은 작업이 실패해 실행을 취소해야만 하는 작업에만 사용합니다. 가능한 경우 보상 트랜잭션이 필요하게 되는 복잡성을 피하는 솔루션을 설계합니다.

## 예제

여행 웹 사이트를 방문한 고객은 여행 계획을 예약할 수 있습니다. 하나의 여행 계획은 여러 항공편과 호텔로 구성될 수 있습니다. 시애틀에서 런던으로 갔다가 파리로 이동하는 고객은 여행 계획을 짤 때 다음과 같은 단계를 수행할 수 있습니다.

1. 시애틀에서 런던까지 항공편 F1의 좌석 1개를 예약합니다.
2. 런던에서 파리까지 항공편 F2의 좌석 1개를 예약합니다.
3. 파리에서 시애틀까지 항공편 F3의 좌석 1개를 예약합니다.
4. 런던에서 호텔 H1의 객실 1개를 예약합니다.
5. 파리에서 호텔 H2의 객실 1개를 예약합니다.

이런 단계는 각 단계가 별도의 동작이더라도 결과적으로는 일관성을 유지하는 작업을 구성합니다. 따라서 시스템은 이런 단계를 수행할 뿐만 아니라 고객이 여행 계획을 취소할 경우 각 단계를 실행 취소하는 데 필요한 상반되는 작업도 기록해야 합니다. 그러고 나서 상반되는 작업을 수행하는 데 필요한 단계는 보상 트랜잭션으로 실행할 수 있습니다.

보상 트랜잭션의 단계는 원래 단계를 그대로 되돌아가는 역순이 아닐 수 있으며, 보상 트랜잭션의 각 단계에 사용되는 논리는 비즈니스에 고유한 규칙을 고려해야 합니다. 예를 들어 항공편 좌석의 예약을 취소하면 고객은 지불한 금액의 일부만 환불받을 수 있습니다. 다음 그림은 여행 계획을 예약하는 장기 실행 트랜잭션을 실행 취소하기 위해 보상 트랜잭션을 생성하는 과정을 보여줍니다.

![Generating a compensating transaction to undo a long-running transaction to book a travel itinerary](./_images/compensating-transaction-diagram.png)


> 각 단계의 보상 논리를 설계하는 방법에 따라 보상 트랜잭션의 단계가 동시에 수행될 수도 있습니다.

대부분의 비즈니스 솔루션의 경우 단일 단계에서 실패했다고 해서 항상 보상 트랜잭션을 사용해 시스템을 다시 롤백해야 하는 것은 아닙니다. 예를 들면 여행 웹 사이트 시나리오에서 항공편 F1, F2, F3을 예약한 고객이 호텔 H1의 객실을 예약할 수 없는 경우에는 항공편을 취소하기보다 동일한 도시에 있는 다른 호텔의 객실을 고객에게 제안하는 것이 바람직할 수 있습니다. 고객은 여전히 취소하겠다고 결정할 수 있지만(취소하는 경우 보상 트랜잭션을 실행하고 항공편 F1, F2, F3의 예약을 실행 취소), 어쨌든 취소 결정은 시스템이 아닌 고객이 내려야 합니다.

## 관련 패턴 및 지침

이 패턴을 구현할 때 관련될 수 있는 패턴과 지침은 다음과 같습니다.

- [데이터 일관성 프라이머](https://msdn.microsoft.com/library/dn589800.aspx). 보상 트랜잭션 패턴은 종종 최종 일관성 모델을 구현하는 작업을 실행 취소하는 데 사용합니다. 이런 프라이머는 최종 일관성의 장점과 단점에 대한 정보를 제공합니다.

- [스케줄러 에이전트 감독자](scheduler-agent-supervisor.md). 분산된 서비스와 리소스를 사용해 비즈니스 작업을 수행하는 복원 시스템을 구현하는 방법을 설명합니다. 때로 보상 트랜잭션을 사용해 작업이 수행한 결과를 실행 취소할 필요가 있을 수 있습니다.

- [다시 시도 패턴](./retry.md). 보상 트랜잭션은 수행하는 데 비용이 많이 소요될 수 있으므로, 다시 시도 패턴에 따라 실패한 작업을 다시 시도하는 효과적인 정책을 구현해 보상 트랜잭션의 사용을 최소화할 수 있습니다.
