---
title: 복원 력 및 가용성을 위해 Azure 응용 프로그램 설계
description: 복원 력 및 가용성을 Azure 응용 프로그램 빌드
author: MikeWasson
ms.date: 04/10/2019
ms.topic: article
ms.service: architecture-center
ms.subservice: cloud-design-principles
ms.openlocfilehash: ee4bb5b4a85e48fe0ff017297c31823c93a48f04
ms.sourcegitcommit: 579c39ff4b776704ead17a006bf24cd4cdc65edd
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/17/2019
ms.locfileid: "59646669"
---
# <a name="architecting-azure-applications-for-resiliency-and-availability"></a><span data-ttu-id="88dfb-103">복원 력 및 가용성을 위해 Azure 응용 프로그램 설계</span><span class="sxs-lookup"><span data-stu-id="88dfb-103">Architecting Azure applications for resiliency and availability</span></span>

<span data-ttu-id="88dfb-104">응용 프로그램에 대 한 요구 사항의 개발한 후에 복원 력 및 가용성을 작성 하는 다음 단계가입니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-104">After you've developed the requirements for your application, the next step is to build resiliency and availability into it.</span></span> <span data-ttu-id="88dfb-105">이러한 품질 끝에 추가할 수 없습니다 &mdash; 아키텍처를 설계 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-105">These qualities can't be added at the end &mdash; you must design them into the architecture.</span></span>

## <a name="conduct-a-failure-mode-analysis"></a><span data-ttu-id="88dfb-106">실패 모드 분석 수행</span><span class="sxs-lookup"><span data-stu-id="88dfb-106">Conduct a failure mode analysis</span></span>

<span data-ttu-id="88dfb-107">*실패 모드 분석* (FMA) 시스템에 복원 력을 가능한 오류 지점을 식별 하 고 응용 프로그램이 이러한 오류에 반응 하는 방법을 정의 하 여 빌드합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-107">*Failure mode analysis* (FMA) builds resiliency into a system by identifying possible failure points and defining how the application responds to those failures.</span></span> <span data-ttu-id="88dfb-108">FMA는 오류 복구부터에서 시스템에 내장 되어 있으므로 아키텍처 및 디자인 단계는 포함 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-108">The FMA should be part of the architecture and design phases, so failure recovery is built into the system from the beginning.</span></span> <span data-ttu-id="88dfb-109">FMA의 목표는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-109">The goals of an FMA are to:</span></span>

- <span data-ttu-id="88dfb-110">응용 프로그램에서 발생할 수 어떤 유형의 오류 및 응용 프로그램에서 이러한 오류를 감지 하는 방법을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-110">Determine what types of failures an application might experience and how the application detects those failures.</span></span>
- <span data-ttu-id="88dfb-111">각 오류 유형의 잠재적 효과 캡처하고 앱이 응답 하는 방법을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-111">Capture the potential effects of each type of failure and determine how the app responds.</span></span>
- <span data-ttu-id="88dfb-112">로깅 및 오류를 모니터링에 대 한 계획 및 복구 전략을 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-112">Plan for logging and monitoring the failure and identify recovery strategies.</span></span>

<span data-ttu-id="88dfb-113">여기 일부의 예가 오류 모드 및 특정 오류 지점에 대 한 검색 전략 &mdash; 외부 웹 서비스를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-113">Here are some examples of failure modes and detection strategies for a specific failure point &mdash; a call to an external web service:</span></span>

| <span data-ttu-id="88dfb-114">오류 모드</span><span class="sxs-lookup"><span data-stu-id="88dfb-114">Failure mode</span></span>           | <span data-ttu-id="88dfb-115">감지 전략</span><span class="sxs-lookup"><span data-stu-id="88dfb-115">Detection strategy</span></span>           |
|------------------------|------------------------------|
| <span data-ttu-id="88dfb-116">서비스를 사용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="88dfb-116">Service is unavailable</span></span> | <span data-ttu-id="88dfb-117">HTTP 5xx</span><span class="sxs-lookup"><span data-stu-id="88dfb-117">HTTP 5xx</span></span>                     |
| <span data-ttu-id="88dfb-118">제한</span><span class="sxs-lookup"><span data-stu-id="88dfb-118">Throttling</span></span>             | <span data-ttu-id="88dfb-119">HTTP 429(요청이 너무 많음)</span><span class="sxs-lookup"><span data-stu-id="88dfb-119">HTTP 429 (Too Many Requests)</span></span> |
| <span data-ttu-id="88dfb-120">Authentication</span><span class="sxs-lookup"><span data-stu-id="88dfb-120">Authentication</span></span>         | <span data-ttu-id="88dfb-121">HTTP 401(권한 없음)</span><span class="sxs-lookup"><span data-stu-id="88dfb-121">HTTP 401 (Unauthorized)</span></span>      |
| <span data-ttu-id="88dfb-122">느린 응답 시간</span><span class="sxs-lookup"><span data-stu-id="88dfb-122">Slow response</span></span>          | <span data-ttu-id="88dfb-123">요청 시간 초과</span><span class="sxs-lookup"><span data-stu-id="88dfb-123">Request times out</span></span>            |

<span data-ttu-id="88dfb-124">Azure에 대 한 구체적인 권장 사항을 비롯 한 FMA 프로세스에 대 한 자세한 내용은 참조 하세요 [실패 모드 분석](../resiliency/failure-mode-analysis.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-124">For more information about the FMA process, with specific recommendations for Azure, see [Failure mode analysis](../resiliency/failure-mode-analysis.md).</span></span>

## <a name="plan-for-redundancy"></a><span data-ttu-id="88dfb-125">중복성에 대 한 계획</span><span class="sxs-lookup"><span data-stu-id="88dfb-125">Plan for redundancy</span></span>

<span data-ttu-id="88dfb-126">오류 영향의 범위에 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-126">Failures vary in scope of impact.</span></span> <span data-ttu-id="88dfb-127">실패 한 디스크와 같은 일부 하드웨어 오류, 단일 호스트 컴퓨터를 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-127">Some hardware failures, such as a failed disk, affect a single host machine.</span></span> <span data-ttu-id="88dfb-128">실패 한 네트워크 스위치는 전체 서버 랙에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-128">A failed network switch could affect an entire server rack.</span></span> <span data-ttu-id="88dfb-129">덜 일반적인 오류, 전원 손실 등 전체 데이터 센터를 방해합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-129">Less common failures, such as loss of power, disrupt a whole datacenter.</span></span> <span data-ttu-id="88dfb-130">거의 전체 지역이 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-130">Rarely, an entire region becomes unavailable.</span></span>

<span data-ttu-id="88dfb-131">중복은 복원 력 있는 응용 프로그램을 확인 하는 하나의 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-131">Redundancy is one way to make an application resilient.</span></span> <span data-ttu-id="88dfb-132">비즈니스 요구 사항에 중복 수준에 따라 달라 집니다 &mdash; 일부 응용 프로그램 지역 가동 중단 으로부터 보호 하도록 지역 중복성을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-132">The level of redundancy depends on your business requirements &mdash; not every application needs redundancy across regions to guard against a regional outage.</span></span> <span data-ttu-id="88dfb-133">일반적으로 중복 성과 안정성 및 더 높은 비용 및 복잡성 간에 균형을 유지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-133">In general, there's a tradeoff between greater redundancy and reliability versus higher costs and complexity.</span></span>

### <a name="review-azure-redundancy-features"></a><span data-ttu-id="88dfb-134">Azure 중복성 기능 검토</span><span class="sxs-lookup"><span data-stu-id="88dfb-134">Review Azure redundancy features</span></span>

<span data-ttu-id="88dfb-135">Azure 전체 지역의 개별 가상 컴퓨터 (VM)에서 실패의 모든 수준에서 다양 한 중복 기능에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-135">Azure has a number of redundancy features at every level of failure, from an individual virtual machine (VM) to an entire region.</span></span>

- <span data-ttu-id="88dfb-136">**단일 Vm** 가 [가동 시간 SLA (서비스 수준 계약)](https://azure.microsoft.com/support/legal/sla/virtual-machines) Azure에서 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-136">**Single VMs** have an [uptime service level agreement (SLA)](https://azure.microsoft.com/support/legal/sla/virtual-machines) provided by Azure.</span></span> <span data-ttu-id="88dfb-137">(VM 모든 운영 체제 디스크 및 데이터 디스크에 premium storage 사용 해야 합니다.) 둘 이상의 VM을 실행하여 SLA를 높일 수 있지만 단일 VM은 일부 워크로드에서 충분히 안정적일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-137">(The VM must use premium storage for all operating system disks and data disks.) Although you can get a higher SLA by running two or more VMs, a single VM may be reliable enough for some workloads.</span></span> <span data-ttu-id="88dfb-138">그러나 프로덕션 워크로드의 경우 중복성을 위해 둘 이상의 VM을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-138">For production workloads, however, we recommend using two or more VMs for redundancy.</span></span>
- <span data-ttu-id="88dfb-139">**가용성 집합** 디스크 등의 지역화 된 하드웨어 오류 로부터 보호 또는 네트워크 스위치 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-139">**Availability sets** protect against localized hardware failures, such as a disk or network switch failing.</span></span> <span data-ttu-id="88dfb-140">가용성 집합의 Vm은 최대 3 개 분산 *장애 도메인*합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-140">VMs in an availability set are distributed across up to three *fault domains*.</span></span> <span data-ttu-id="88dfb-141">장애 도메인 공통 전원 및 네트워크 스위치를 공유 하는 Vm 그룹을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-141">A fault domains defines a group of VMs that share a common power source and network switch.</span></span> <span data-ttu-id="88dfb-142">하드웨어 오류가 하나의 장애 도메인에 영향을 주는 경우 네트워크 트래픽은 다른 장애 도메인에 Vm에 라우팅됩니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-142">If a hardware failure affects one fault domain, network traffic is routed to VMs in the other fault domains.</span></span> <span data-ttu-id="88dfb-143">가용성 집합에 대 한 자세한 내용은 참조 하세요. [Azure에서 Windows 가상 머신의 가용성 관리](/azure/virtual-machines/windows/manage-availability)합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-143">For more information about availability sets, see [Manage the availability of Windows virtual machines in Azure](/azure/virtual-machines/windows/manage-availability).</span></span>
- <span data-ttu-id="88dfb-144">**가용성 영역** 은 Azure 지역 내에서 물리적으로 별도 영역입니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-144">**Availability Zones** are physically separate zones within an Azure region.</span></span> <span data-ttu-id="88dfb-145">각 가용성 영역에는 고유한 소스, 네트워크 및 냉각 장치가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-145">Each Availability Zone has a distinct power source, network, and cooling.</span></span> <span data-ttu-id="88dfb-146">가용성 영역에서 Vm을 배포할 데이터 센터 전체의 오류 로부터 응용 프로그램을 보호할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-146">Deploying VMs across Availability Zones helps to protect an application against datacenter-wide failures.</span></span> <span data-ttu-id="88dfb-147">모든 Azure 지역에서 가용성 영역을 지원하는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-147">Not all regions support Availability Zones.</span></span> <span data-ttu-id="88dfb-148">지원되는 Azure 지역 및 서비스 목록은 [Azure에서 가용성 영역이란?](/azure/availability-zones/az-overview)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="88dfb-148">For a list of supported regions and services, see [What are Availability Zones in Azure?](/azure/availability-zones/az-overview).</span></span>

    <span data-ttu-id="88dfb-149">배포에서 가용성 영역을 사용 하려는 경우 먼저 유효성을 검사 하는 응용 프로그램 아키텍처 코드 베이스에서이 구성을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-149">If you plan to use Availability Zones in your deployment, first validate that your application architecture and codebase support this configuration.</span></span> <span data-ttu-id="88dfb-150">상용 소프트웨어를 배포 하는 경우 소프트웨어 공급 업체에 문의 하 고 프로덕션에 배포 하기 전에 적절 하 게 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-150">If you deploy commercial software, consult with the software vendor and test adequately before deploying into production.</span></span> <span data-ttu-id="88dfb-151">응용 프로그램 상태를 유지 하 고 구성 된 영역 내에서 중단 시간 동안 데이터 손실을 방지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-151">An application must maintain state and prevent loss of data during an outage within the configured zone.</span></span> <span data-ttu-id="88dfb-152">응용 프로그램 없음 하드 코드 된 인프라 구성 요소를 사용 하 여 탄력적 이며 분산 인프라에서 실행을 지원 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-152">The application must support running in an elastic and distributed infrastructure with no hard-coded infrastructure components.</span></span>
- <span data-ttu-id="88dfb-153">**Azure Site Recovery** 복제 Azure Virtual Machines (BC) 비즈니스 연속성 및 재해 복구 (DR)에 대 한 다른 Azure 지역에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-153">**Azure Site Recovery** replicates Azure Virtual Machines to another Azure region for business continuity (BC) and disaster recovery (DR) needs.</span></span> <span data-ttu-id="88dfb-154">규정 준수 요구를 충족 하는지 확인 하려면 정기적인 DR 훈련을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-154">You can conduct periodic DR drills to ensure that you meet the compliance needs.</span></span> <span data-ttu-id="88dfb-155">VM은 원본 지역에서 중단이 발생할 경우 응용 프로그램을 복구할 수 있도록 선택한 영역에 지정 된 설정을 사용 하 여 복제 됩니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-155">The VM is replicated with the specified settings to the selected region so you can recover your applications in the event of outages in the source region.</span></span> <span data-ttu-id="88dfb-156">자세한 내용은 [Azure VM에 대 한 보조 Azure 지역에 재해 복구 설정](/azure/site-recovery/azure-to-azure-quickstart/)합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-156">For more information, see [Set up disaster recovery to a secondary Azure region for an Azure VM](/azure/site-recovery/azure-to-azure-quickstart/).</span></span>

    <span data-ttu-id="88dfb-157">테스트 중에 있는지를 확인 합니다 *복구 시간 목표* (RTO) 및 *복구 지점 목표* (RPO) 요구 사항을 충족 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-157">During testing, verify that the *recovery time objective* (RTO) and *recovery point objective* (RPO) meet your needs.</span></span> <span data-ttu-id="88dfb-158">RTO는 사고 발생 후 응용 프로그램을 사용할 수 없는 최대 시간 및 RPO는 재해 발생 시 데이터 손실의 최대 지속 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-158">RTO is the maximum time an application is unavailable after an incident, and RPO is the maximum duration of data loss during a disaster.</span></span>
- <span data-ttu-id="88dfb-159">**쌍을 이루는 지역** 지역 가동 중단 으로부터 응용 프로그램을 보호 하는 다른 지역에 인터넷 트래픽을 분산 하기 위해 Azure Traffic Manager를 사용 하 여 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-159">**Paired regions** are created using Azure Traffic Manager to distribute Internet traffic to different regions, protecting an application against a regional outage.</span></span> <span data-ttu-id="88dfb-160">각 Azure 지역은 다른 지역과 쌍을 이룹니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-160">Each Azure region is paired with another region.</span></span> <span data-ttu-id="88dfb-161">함께 이러한 지역 폼을 [ *지역 쌍*](/azure/best-practices-availability-paired-regions)합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-161">Together, these regions form a [*regional pair*](/azure/best-practices-availability-paired-regions).</span></span> <span data-ttu-id="88dfb-162">세금 및 법률 집행 관할 구역의 데이터 상주 요구 사항을 달성 하기 위해 지역 쌍은 동일한 지역 (브라질 남부 제외) 내에 위치 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-162">To meet data residency requirements for tax and law enforcement jurisdiction purposes, regional pairs are located within the same geography (with the exception of Brazil South).</span></span>

    <span data-ttu-id="88dfb-163">응용 프로그램 복원 력을 향상을 위해 Azure 쌍을 이루는 지역 한 번에 업데이트 됩니다 하나에 각 지역 쌍을 통해 플랫폼 업데이트 (계획 된 유지 관리)을 serialize 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-163">To improve application resiliency, Azure serializes platform updates (planned maintenance) across each region pair, so only one paired region is updated at a time.</span></span>
- <span data-ttu-id="88dfb-164">다중 지역 응용 프로그램을 디자인할 때 지역 간 네트워크 대기 시간 보다 크면 지역 내에서 점을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-164">When you design a multiregion application, take into account that network latency across regions is higher than within a region.</span></span> <span data-ttu-id="88dfb-165">예를 들어 장애 조치를 사용 하도록 설정 하려면 데이터베이스를 복제 하는 경우 사용 하 여 비동기 데이터 복제가 아니라 지역 내의 동기 데이터 복제 지역.</span><span class="sxs-lookup"><span data-stu-id="88dfb-165">For example, if you replicate a database to enable failover, use synchronous data replication within a region but asynchronous data replication across regions.</span></span>

<span data-ttu-id="88dfb-166">다음 표에서 몇 가지 복원 력 전략에서 중복 요소를 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-166">The following table compares the redundancy factors across several resiliency strategies:</span></span>

| &nbsp; | <span data-ttu-id="88dfb-167">가용성 집합</span><span class="sxs-lookup"><span data-stu-id="88dfb-167">Availability set</span></span> | <span data-ttu-id="88dfb-168">가용성 영역</span><span class="sxs-lookup"><span data-stu-id="88dfb-168">Availability Zone</span></span> | <span data-ttu-id="88dfb-169">Azure Site Recovery/페어링된 지역</span><span class="sxs-lookup"><span data-stu-id="88dfb-169">Azure Site Recovery/Paired region</span></span> |
|--------|------------------|-------------------|-----------------------------------|
| <span data-ttu-id="88dfb-170">오류의 범위</span><span class="sxs-lookup"><span data-stu-id="88dfb-170">Scope of failure</span></span> | <span data-ttu-id="88dfb-171">랙</span><span class="sxs-lookup"><span data-stu-id="88dfb-171">Rack</span></span>                  | <span data-ttu-id="88dfb-172">데이터 센터</span><span class="sxs-lookup"><span data-stu-id="88dfb-172">Datacenter</span></span>               | <span data-ttu-id="88dfb-173">지역</span><span class="sxs-lookup"><span data-stu-id="88dfb-173">Region</span></span>                               |
| <span data-ttu-id="88dfb-174">요청 라우팅</span><span class="sxs-lookup"><span data-stu-id="88dfb-174">Request routing</span></span>  | <span data-ttu-id="88dfb-175">Azure Load Balancer</span><span class="sxs-lookup"><span data-stu-id="88dfb-175">Azure Load Balancer</span></span>   | <span data-ttu-id="88dfb-176">영역 간 부하 분산 장치</span><span class="sxs-lookup"><span data-stu-id="88dfb-176">Cross-zone Load Balancer</span></span> | <span data-ttu-id="88dfb-177">Azure Traffic Manager</span><span class="sxs-lookup"><span data-stu-id="88dfb-177">Azure Traffic Manager</span></span>                |
| <span data-ttu-id="88dfb-178">네트워크 대기 시간</span><span class="sxs-lookup"><span data-stu-id="88dfb-178">Network latency</span></span>  | <span data-ttu-id="88dfb-179">매우 낮음</span><span class="sxs-lookup"><span data-stu-id="88dfb-179">Very low</span></span>              | <span data-ttu-id="88dfb-180">낮음</span><span class="sxs-lookup"><span data-stu-id="88dfb-180">Low</span></span>                      | <span data-ttu-id="88dfb-181">중간부터 높음</span><span class="sxs-lookup"><span data-stu-id="88dfb-181">Mid to high</span></span>                          |
| <span data-ttu-id="88dfb-182">가상 네트워크</span><span class="sxs-lookup"><span data-stu-id="88dfb-182">Virtual network</span></span>  | <span data-ttu-id="88dfb-183">Azure Virtual Network</span><span class="sxs-lookup"><span data-stu-id="88dfb-183">Azure Virtual Network</span></span> | <span data-ttu-id="88dfb-184">Azure Virtual Network</span><span class="sxs-lookup"><span data-stu-id="88dfb-184">Azure Virtual Network</span></span>          | <span data-ttu-id="88dfb-185">지역 간 가상 네트워크 피어 링</span><span class="sxs-lookup"><span data-stu-id="88dfb-185">Cross-region Virtual Network peering</span></span> |

### <a name="complete-azure-redundancy-tasks"></a><span data-ttu-id="88dfb-186">전체 Azure 중복성 작업</span><span class="sxs-lookup"><span data-stu-id="88dfb-186">Complete Azure redundancy tasks</span></span>

<span data-ttu-id="88dfb-187">다음 태스크를 사용 하 여 중복성 요구 사항을 충족 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-187">Use the following tasks to meet redundancy requirements:</span></span>

- <span data-ttu-id="88dfb-188">**서비스의 여러 인스턴스를 배포합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-188">**Deploy multiple instances of services.**</span></span> <span data-ttu-id="88dfb-189">애플리케이션이 서비스의 단일 인스턴스에 종속된 경우 단일 실패 지점이 생깁니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-189">If your application depends on a single instance of a service, it creates a single point of failure.</span></span> <span data-ttu-id="88dfb-190">여러 인스턴스를 프로비전하면 복원력 및 확장성이 모두 개선됩니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-190">Provisioning multiple instances improves both resiliency and scalability.</span></span> <span data-ttu-id="88dfb-191">[Azure App Service](/azure/app-service/app-service-value-prop-what-is/)의 경우 여러 인스턴스를 제공하는 [App Service 계획](/azure/app-service/azure-web-sites-web-hosting-plans-in-depth-overview/)을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-191">For [Azure App Service](/azure/app-service/app-service-value-prop-what-is/), select an [App Service plan](/azure/app-service/azure-web-sites-web-hosting-plans-in-depth-overview/) that offers multiple instances.</span></span> <span data-ttu-id="88dfb-192">에 대 한 [Azure Virtual Machines](/azure/virtual-machines/virtual-machines-windows-about/?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json), 아키텍처에 둘 이상의 VM 및 각 VM에 포함 되어 있는지 확인 한 [가용성 집합](/azure/virtual-machines/virtual-machines-windows-manage-availability/)합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-192">For [Azure Virtual Machines](/azure/virtual-machines/virtual-machines-windows-about/?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json), ensure that your architecture has more than one VM and that each VM is included in an [availability set](/azure/virtual-machines/virtual-machines-windows-manage-availability/).</span></span>

- <span data-ttu-id="88dfb-193">**Azure Site Recovery를 사용하여 VM 복제.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-193">**Replicate VMs using Azure Site Recovery.**</span></span> <span data-ttu-id="88dfb-194">사용 하 여 Azure Vm을 복제 하는 경우 [Site Recovery](/azure/site-recovery/), 모든 VM 디스크에 지속적으로 대상 지역에 비동기적으로 복제 됩니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-194">When you replicate Azure VMs using [Site Recovery](/azure/site-recovery/), all the VM disks are continuously replicated to the target region asynchronously.</span></span> <span data-ttu-id="88dfb-195">복구 지점이 몇 분 정도로 RPO를 제공 합니다. 몇 분 마다 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-195">The recovery points are created every few minutes, giving an RPO on the order of minutes.</span></span>

- <span data-ttu-id="88dfb-196">**여러 지역에 걸쳐 애플리케이션을 배포하는 것을 고려합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-196">**Consider deploying your application across multiple regions.**</span></span> <span data-ttu-id="88dfb-197">단일 지역에 응용 프로그램을 배포 하 고 지역을 사용할 수 없는 경우 응용 프로그램 에서도 사용할 수 없게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-197">If your application is deployed to a single region, and the region becomes unavailable, your application will also be unavailable.</span></span> <span data-ttu-id="88dfb-198">이러한 상황이 애플리케이션의 SLA의 조항에 따라 허용되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-198">This may be unacceptable under the terms of your application's SLA.</span></span> <span data-ttu-id="88dfb-199">그러한 경우 애플리케이션 및 해당 서비스를 여러 지역에 걸쳐 배포하는 것을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-199">If so, consider deploying your application and its services across multiple regions.</span></span> <span data-ttu-id="88dfb-200">다중 지역 배포를 사용할 수는 *액티브-액티브* 또는 *액티브-패시브* 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-200">A multiregion deployment can use an *active-active* or *active-passive* configuration.</span></span> <span data-ttu-id="88dfb-201">활성-활성 구성에는 여러 활성 지역에 걸쳐 요청을 분배합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-201">An active-active configuration distributes requests across multiple active regions.</span></span> <span data-ttu-id="88dfb-202">활성-수동 구성 보조 지역에서 웜 인스턴스를 유지 하면서 보내지 않습니다 트래픽을 있습니다 주 지역이 실패 하는 경우가 아니면.</span><span class="sxs-lookup"><span data-stu-id="88dfb-202">An active-passive configuration keeps warm instances in the secondary region, but doesn't send traffic there unless the primary region fails.</span></span> <span data-ttu-id="88dfb-203">다중 지역 배포의 경우 위에서 설명한 쌍을 이루는 지역에 배포 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-203">For multiregion deployments, we recommend deploying to paired regions, described above.</span></span> <span data-ttu-id="88dfb-204">자세한 내용은 [BCDR(비즈니스 연속성 및 재해 복구): Azure 쌍을 이루는 지역](/azure/best-practices-availability-paired-regions)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="88dfb-204">For more information, see [Business continuity and disaster recovery (BCDR): Azure Paired Regions](/azure/best-practices-availability-paired-regions).</span></span>

- <span data-ttu-id="88dfb-205">**Azure Traffic Manager를 사용하여 애플리케이션의 트래픽을 다른 지역으로 경로 설정합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-205">**Use Azure Traffic Manager to route your application's traffic to different regions.**</span></span> <span data-ttu-id="88dfb-206">[Azure Traffic Manager](/azure/traffic-manager/traffic-manager-overview/) DNS 수준에서 부하 분산을 수행 하 고 기반으로 하는 다른 지역으로 트래픽을 라우팅하는 [트래픽 라우팅](/azure/traffic-manager/traffic-manager-routing-methods/) 메서드 및 응용 프로그램 끝점의 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-206">[Azure Traffic Manager](/azure/traffic-manager/traffic-manager-overview/) performs load-balancing at the DNS level and routes traffic to different regions based on the [traffic routing](/azure/traffic-manager/traffic-manager-routing-methods/) method and the health of your application's endpoints.</span></span> <span data-ttu-id="88dfb-207">Traffic Manager가 없으면는 단일 지역으로 제한 크기를 제한 하 고 일부 사용자에 게 대기 시간이 증가 지역 전체의 서비스 중단의 경우 응용 프로그램 가동 중지 시간이 발생 하는 배포에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-207">Without Traffic Manager, you are limited to a single region for your deployment, which constrains scale, increases latency for some users, and causes application downtime, in the case of a region-wide service disruption.</span></span>

- <span data-ttu-id="88dfb-208">**여러 인스턴스를 사용 하도록 Azure Application Gateway를 구성 합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-208">**Configure Azure Application Gateway to use multiple instances.**</span></span> <span data-ttu-id="88dfb-209">애플리케이션의 요구 사항에 따라 [Azure Application Gateway](/azure/application-gateway/application-gateway-introduction/)가 요청을 애플리케이션의 서비스에 배포하기에 더 적합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-209">Depending on your application's requirements, an [Azure Application Gateway](/azure/application-gateway/application-gateway-introduction/) may be better suited to distributing requests to your application's services.</span></span> <span data-ttu-id="88dfb-210">그러나 응용 프로그램 게이트웨이 서비스의 단일 인스턴스는 응용 프로그램 응용 프로그램 게이트웨이 인스턴스가 실패 하는 경우 실패할 수 있으므로 SLA를 통해 보장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-210">However, single instances of the Application Gateway service are not guaranteed by an SLA, so it's possible that your application could fail if the Application Gateway instance fails.</span></span> <span data-ttu-id="88dfb-211">약관에 따라 서비스의 가용성을 보장 하기 위해 둘 이상의 중간 또는 큰 인스턴스가 프로 비전 합니다 [응용 프로그램 게이트웨이 SLA](https://azure.microsoft.com/support/legal/sla/application-gateway/)합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-211">Provision more than one medium or larger instance to guarantee availability of the service under the terms of the [Application Gateway SLA](https://azure.microsoft.com/support/legal/sla/application-gateway/).</span></span>

## <a name="design-for-scalability"></a><span data-ttu-id="88dfb-212">확장성을 위한 디자인</span><span class="sxs-lookup"><span data-stu-id="88dfb-212">Design for scalability</span></span>

<span data-ttu-id="88dfb-213">*확장성* 증가 된 부하를 처리 하는 시스템의 기능 이며 중 하나는 [소프트웨어 품질 핵심 요소](../guide/pillars.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-213">*Scalability* is the ability of a system to handle increased load and is one of the [pillars of software quality](../guide/pillars.md).</span></span> <span data-ttu-id="88dfb-214">설계 단계 중의 확장성 작업은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-214">Scalability tasks during the architecting phase include:</span></span>

- <span data-ttu-id="88dfb-215">**파티션 작업입니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-215">**Partition workloads.**</span></span> <span data-ttu-id="88dfb-216">프로세스의 각 부분을 불연속 및 분해되도록 디자인합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-216">Design parts of the process to be discrete and decomposable.</span></span> <span data-ttu-id="88dfb-217">각 부분의 크기를 최소화 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-217">Minimize the size of each part.</span></span> <span data-ttu-id="88dfb-218">이 구성 요소 부분을을 각 계산 단위의 사용을 극대화 하는 방식으로 분산 시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-218">This allows the component parts to be distributed in a way that maximizes use of each compute unit.</span></span> <span data-ttu-id="88dfb-219">특정 리소스의 인스턴스를 추가하여 애플리케이션을 보다 쉽게 확장할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-219">It also makes it easier to scale the application by adding instances of specific resources.</span></span> <span data-ttu-id="88dfb-220">복합 도메인의 경우 [마이크로 서비스 아키텍처](../guide/architecture-styles/microservices.md)를 도입하는 방안을 고려해 봅니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-220">For complex domains, consider adopting a [microservices architecture](../guide/architecture-styles/microservices.md).</span></span>
- <span data-ttu-id="88dfb-221">**크기 조정을 고려한 디자인 합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-221">**Design for scaling.**</span></span> <span data-ttu-id="88dfb-222">크기 조정 응용 프로그램을 역할, 큐 및 기타 서비스의 인스턴스 수를 늘리고 하 여 가변 부하에 대응할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-222">Scaling allows applications to react to variable load by increasing and decreasing the number of instances of roles, queues, and other services.</span></span> <span data-ttu-id="88dfb-223">그러나 이 점을 염두에 두고 애플리케이션을 디자인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-223">However, the application must be designed with this in mind.</span></span> <span data-ttu-id="88dfb-224">예를 들어, 응용 프로그램 및 사용 되는 서비스 요청이 모든 인스턴스로 라우팅될 수 있도록 상태 비저장 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-224">For example, the application and the services it uses must be stateless to allow requests to be routed to any instance.</span></span> <span data-ttu-id="88dfb-225">상태 비저장 서비스는 추가 또는 인스턴스를 제거 해도 나쁜 영향을 주지 않습니다 현재 사용자가 의미 이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-225">Having stateless services also means that adding or removing an instance does not adversely impact current users.</span></span>
- <span data-ttu-id="88dfb-226">**배율 단위를 사용 하 여 확장을 계획 합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-226">**Plan for growth with scale units.**</span></span> <span data-ttu-id="88dfb-227">각 리소스에 대 한 제한, 크기 조정 상한을 알고 있어야 하 고 분할 또는 분해를 사용 하 여 이러한 제한을 초과할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-227">For each resource, know the upper scaling limits, and use sharding or decomposition to go beyond those limits.</span></span> <span data-ttu-id="88dfb-228">하나 이상의 배율 단위를 추가하여 쉽게 확장할 수 있도록 애플리케이션을 디자인하세요.</span><span class="sxs-lookup"><span data-stu-id="88dfb-228">Design the application so that it's easily scaled by adding one or more scale units.</span></span> <span data-ttu-id="88dfb-229">잘 정의된 리소스 집합을 기준으로 시스템에 대한 배율 단위를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-229">Determine the scale units for the system in terms of well-defined sets of resources.</span></span> <span data-ttu-id="88dfb-230">이렇게 하면 적용 규모 확장 작업 보다 쉽고 전체 시스템의 일부 리소스가 부족으로 인해 발생 하는 부정적인 영향을 받기 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-230">This makes applying scale-out operations easier and less prone to negative impact caused by a lack of resources in some part of the overall system.</span></span> <span data-ttu-id="88dfb-231">예를 들어, 추가 *X* 프런트 엔드 Vm 수가 필요할 수 있습니다 *Y* 추가 큐 수와 *Z* 추가 워크 로드를 처리 하려면 저장소 계정 수입니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-231">For example, adding *X* number of front-end VMs might require *Y* number of additional queues and *Z* number of storage accounts to handle the additional workload.</span></span> <span data-ttu-id="88dfb-232">배율 단위 구성 될 수 있도록 *X* VM 인스턴스에 *Y* 큐 및 *Z* 저장소 계정입니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-232">So a scale unit could consist of *X* VM instances, *Y* queues, and *Z* storage accounts.</span></span>
- <span data-ttu-id="88dfb-233">**클라이언트 선호도 방지 합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-233">**Avoid client affinity.**</span></span> <span data-ttu-id="88dfb-234">가능한 경우 응용 프로그램이 선호도 필요로 하지 않습니다 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-234">Where possible, ensure that the application doesn't require affinity.</span></span> <span data-ttu-id="88dfb-235">요청이 모든 인스턴스로 라우팅할 수 있습니다 하 고 인스턴스 수는 관련이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-235">Requests can then be routed to any instance, and the number of instances is irrelevant.</span></span> <span data-ttu-id="88dfb-236">이는 각 사용자의 상태 정보에 대한 저장, 검색 및 유지 관리 오버헤드도 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-236">This also avoids the overhead of storing, retrieving, and maintaining state information for each user.</span></span>
- <span data-ttu-id="88dfb-237">**플랫폼 자동 크기 조정 기능을 활용할 수 있습니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-237">**Take advantage of platform autoscaling features.**</span></span> <span data-ttu-id="88dfb-238">가능한 경우 기본 제공 자동 크기 조정 기능을 사용 하는 대신 사용자 지정 또는 타사 메커니즘입니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-238">Use built-in autoscaling features when possible, rather than custom or third-party mechanisms.</span></span> <span data-ttu-id="88dfb-239">사용 하 여 예약 된 크기 조정 규칙을 리소스를 시작 지연 없이 사용할 수 있지만 반응 형 자동 크기 조정 규칙을 추가할 수 있는 경우 필요한 경우 예기치 않은 수요 변화에에서 대처 하기 위해.</span><span class="sxs-lookup"><span data-stu-id="88dfb-239">Use scheduled scaling rules, where possible, to ensure that resources are available without a startup delay, but add reactive autoscaling to the rules, where appropriate, to cope with unexpected changes in demand.</span></span> <span data-ttu-id="88dfb-240">자세한 내용은 [자동 크기 조정 지침](../best-practices/auto-scaling.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-240">For more information, see [Autoscaling guidance](../best-practices/auto-scaling.md).</span></span>  

  <span data-ttu-id="88dfb-241">응용 프로그램 부하 증가 함에 따라 자동으로 확장 되도록 구성 되어 있지 않으면, 사용자 요청으로 포화 되 면 응용 프로그램의 서비스가 실패할 가능성이 있는 가능한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-241">If your application isn't configured to scale out automatically as load increases, it's possible that your application's services will fail if they become saturated with user requests.</span></span> <span data-ttu-id="88dfb-242">자세한 내용은 다음 문서를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="88dfb-242">For more information, see the following articles:</span></span>

  - <span data-ttu-id="88dfb-243">일반: [확장성 검사 목록](../checklist/scalability.md)</span><span class="sxs-lookup"><span data-stu-id="88dfb-243">General: [Scalability checklist](../checklist/scalability.md)</span></span>
  - <span data-ttu-id="88dfb-244">Azure App Service: [수동 또는 자동으로 인스턴스 개수 조정](/azure/monitoring-and-diagnostics/insights-how-to-scale/)</span><span class="sxs-lookup"><span data-stu-id="88dfb-244">Azure App Service: [Scale instance count manually or automatically](/azure/monitoring-and-diagnostics/insights-how-to-scale/)</span></span>
  - <span data-ttu-id="88dfb-245">Cloud Services: [클라우드 서비스 크기 자동 조정 방법](/azure/cloud-services/cloud-services-how-to-scale/)</span><span class="sxs-lookup"><span data-stu-id="88dfb-245">Cloud Services: [How to autoscale a Cloud Service](/azure/cloud-services/cloud-services-how-to-scale/)</span></span>
  - <span data-ttu-id="88dfb-246">가상 머신: [자동 크기 조정 및 가상 머신 확장 집합](/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-autoscale-overview/)</span><span class="sxs-lookup"><span data-stu-id="88dfb-246">Virtual machines: [Automatic scaling and virtual machine scale sets](/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-autoscale-overview/)</span></span>

- <span data-ttu-id="88dfb-247">**집약적인 CPU/IO 작업을 백그라운드 작업으로 오프 로드 합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-247">**Offload intensive CPU/IO tasks as background tasks.**</span></span> <span data-ttu-id="88dfb-248">서비스에 요청을 실행 하려면 시간이 오래 걸릴 될 상당한 리소스가 사용 될 수 있습니다, 경우에 별도 작업을 처리 하는 오프 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-248">If a request to a service is expected to take a long time to run or may absorb considerable resources, offload the processing to a separate task.</span></span> <span data-ttu-id="88dfb-249">이러한 작업을 실행할 백그라운드 작업을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-249">Use background jobs to execute these tasks.</span></span> <span data-ttu-id="88dfb-250">이 전략에는 추가 요청을 수신 하려면 서비스를는 계속 응답할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-250">This strategy enables the service to continue receiving further requests and to remain responsive.</span></span> <span data-ttu-id="88dfb-251">자세한 내용은 [백그라운드 작업 지침](../best-practices/background-jobs.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="88dfb-251">For more information, see [Background jobs guidance](../best-practices/background-jobs.md).</span></span>
- <span data-ttu-id="88dfb-252">**백그라운드 작업에 대 한 부하를 분산 합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-252">**Distribute the workload for background tasks.**</span></span> <span data-ttu-id="88dfb-253">많은 백그라운드 작업이 있거나 상당한 시간 또는 리소스가 필요 하 고 작업 하는 경우 여러 계산 단위 작업을 분산 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-253">If there are many background tasks or if the tasks require considerable time or resources, spread the work across multiple compute units.</span></span> <span data-ttu-id="88dfb-254">한 가지 가능한 솔루션에 대해서는 [경쟁 소비자 패턴](../patterns/competing-consumers.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="88dfb-254">For one possible solution, see the [Competing Consumers pattern](../patterns/competing-consumers.md).</span></span>
- <span data-ttu-id="88dfb-255">**이동 하는 것이 좋습니다는 *비공유* 아키텍처입니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-255">**Consider moving toward a *shared-nothing* architecture.**</span></span> <span data-ttu-id="88dfb-256">이 아키텍처는 단일 (예: 공유 서비스 또는 저장소)는 경합 지점이 없는 독립적이 고 스스로 노드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-256">This architecture uses independent, self-sufficient nodes that have no single point of contention (such as shared services or storage).</span></span> <span data-ttu-id="88dfb-257">이론적으로 이러한 시스템은 거의 무제한적으로 확장될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-257">In theory, such a system can scale almost indefinitely.</span></span> <span data-ttu-id="88dfb-258">완벽 하 게 비공유 접근 방법은 것이 일반적으로 불가능 하지만 더 나은 확장성을 위한 디자인 기회를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-258">Although a fully shared-nothing approach is usually not practical, it may provide opportunities to design for better scalability.</span></span> <span data-ttu-id="88dfb-259">비공유 아키텍처 쪽으로 이동 하는 좋은 예에는 데이터를 분할 및 서버 쪽 세션 상태 및 클라이언트 선호도 사용 하지 마십시오 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-259">Good examples of moving toward a shared-nothing architecture include partitioning data and avoiding the use of server-side session state and client affinity.</span></span>
- <span data-ttu-id="88dfb-260">**Azure Storage 확장성 및 성능 목표에 속하는 응용 프로그램의 저장소 요구 사항을 디자인 합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-260">**Design your application's storage requirements to fall within Azure Storage scalability and performance targets.**</span></span> <span data-ttu-id="88dfb-261">Azure Storage는 하므로 이러한 목표 내에서 저장소를 사용 하도록 응용 프로그램을 디자인, 미리 정의 된 확장성 및 성능 목표 내에서 작동 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-261">Azure Storage is designed to function within predefined scalability and performance targets, so design your application to use storage within those targets.</span></span> <span data-ttu-id="88dfb-262">이러한 목표를 초과 하면 응용 프로그램 저장소 제한이 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-262">If you exceed these targets, your application will experience storage throttling.</span></span> <span data-ttu-id="88dfb-263">제한을 방지 하려면 추가 저장소 계정을 프로 비전 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-263">To avoid throttling, provision additional storage accounts.</span></span> <span data-ttu-id="88dfb-264">저장소 계정 제한에 대해 실행 하는 경우에 추가 Azure 구독을 프로 비전 하 고 거기서 추가 저장소 계정을 프로 비전 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-264">If you run up against the storage account limit, provision additional Azure subscriptions and then provision additional storage accounts there.</span></span> <span data-ttu-id="88dfb-265">자세한 내용은 [Azure Storage 확장성 및 성능 목표](/azure/storage/storage-scalability-targets/)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="88dfb-265">For more information, see [Azure Storage scalability and performance targets](/azure/storage/storage-scalability-targets/).</span></span>
- <span data-ttu-id="88dfb-266">**애플리케이션에 대한 올바른 VM 크기를 선택합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-266">**Select the right VM size for your application.**</span></span> <span data-ttu-id="88dfb-267">실제 CPU, 메모리, 디스크 및 프로덕션 환경에서는 Vm의 I/O를 측정 하 고 선택한 VM 크기가 충분 한지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-267">Measure the actual CPU, memory, disk, and I/O of your VMs in production, and verify that the VM size you've selected is sufficient.</span></span> <span data-ttu-id="88dfb-268">그렇지 않은 경우 VM이 제한에 근접하면 애플리케이션 용량 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-268">If not, your application may experience capacity issues as the VMs approach their limits.</span></span> <span data-ttu-id="88dfb-269">VM 크기는 [Azure의 가상 머신에 대한 크기](/azure/virtual-machines/virtual-machines-windows-sizes/?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json)에서 자세히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-269">VM sizes are described in detail in [Sizes for virtual machines in Azure](/azure/virtual-machines/virtual-machines-windows-sizes/?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).</span></span>

## <a name="determine-subscription-and-service-requirements"></a><span data-ttu-id="88dfb-270">구독 및 서비스 요구 사항 확인</span><span class="sxs-lookup"><span data-stu-id="88dfb-270">Determine subscription and service requirements</span></span>

<span data-ttu-id="88dfb-271">이러한 작업을 진행 하 여 앱에 대 한 올바른 구독 기능과 서비스를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-271">Choose the right subscription and service features for your app by working through these tasks:</span></span>

- <span data-ttu-id="88dfb-272">**요구 사항에 대해 평가할 [Azure 구독 및 서비스 제한](/azure/azure-subscription-service-limits/)합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-272">**Evaluate requirements against [Azure subscription and service limits](/azure/azure-subscription-service-limits/).**</span></span> <span data-ttu-id="88dfb-273">*Azure 구독* 코어, 저장소 계정 리소스 그룹의 번호와 같은 특정 리소스 유형에 대 한 제한을 둡니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-273">*Azure subscriptions* have limits on certain resource types, such as number of resource groups, cores, and storage accounts.</span></span> <span data-ttu-id="88dfb-274">애플리케이션 요구 사항이 Azure 구독 제한을 초과하는 경우 또 다른 Azure 구독을 만들고 거기에 충분한 리소스를 프로비전합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-274">If your application requirements exceed Azure subscription limits, create another Azure subscription and provision sufficient resources there.</span></span> <span data-ttu-id="88dfb-275">개별 Azure 서비스는 사용 제한을 둡니다. &mdash; 예들 들어 저장소, 처리량, 연결 수, 초당 요청 수 및 기타 메트릭에 대한 제한을 둡니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-275">Individual Azure services have consumption limits &mdash; for example, limits on storage, throughput, number of connections, requests per second, and other metrics.</span></span> <span data-ttu-id="88dfb-276">응용 프로그램 서비스 제한 및 가능한 가동 중지 시간이 발생 영향을 받는 사용자에 대 한 이러한 제한 초과 하는 리소스를 사용 하려고 하면 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-276">Your application will fail if it attempts to use resources beyond these limits, resulting in service throttling and possible downtime for affected users.</span></span> <span data-ttu-id="88dfb-277">특정 서비스 및 응용 프로그램 요구 사항에 따라 자주 여 방지할 수 있습니다 이러한 한도 (예: 다른 가격 책정 계층 선택) 강화 또는 규모 확장 (예: 새 인스턴스 추가).</span><span class="sxs-lookup"><span data-stu-id="88dfb-277">Depending on the specific service and your application requirements, you can often avoid these limits by scaling up (for example, choosing another pricing tier) or scaling out (such as adding new instances).</span></span>
- <span data-ttu-id="88dfb-278">**필요한 저장소 계정 수를 결정 합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-278">**Determine how many storage accounts you need.**</span></span> <span data-ttu-id="88dfb-279">Azure 구독 당 storage 계정의 특정 숫자를 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-279">Azure allows a specific number of storage accounts per subscription.</span></span> <span data-ttu-id="88dfb-280">자세한 내용은 [Azure 구독 및 서비스 제한, 할당량 및 제약 조건](/azure/azure-subscription-service-limits/#storage-limits)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="88dfb-280">For more information, see [Azure subscription and service limits, quotas, and constraints](/azure/azure-subscription-service-limits/#storage-limits).</span></span>
- <span data-ttu-id="88dfb-281">**Azure SQL Database에 적합한 서비스 계층을 선택합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-281">**Select the right service tier for Azure SQL Database.**</span></span> <span data-ttu-id="88dfb-282">응용 프로그램에서 Azure SQL Database를 사용 하는 경우 적절 한 서비스 계층을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-282">If your application uses Azure SQL Database, select the appropriate service tier.</span></span> <span data-ttu-id="88dfb-283">계층 응용 프로그램의 데이터베이스 트랜잭션 단위 (DTU) 요구 사항을 처리할 수 없는 경우 데이터 사용이 제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-283">If the tier cannot handle your application's database transaction unit (DTU) requirements, your data use will be throttled.</span></span> <span data-ttu-id="88dfb-284">올바른 서비스 계획 선택에 대한 자세한 내용은 [SQL Database 옵션 및 성능: 각 서비스 계층에서 사용할 수 있는 기능 이해](/azure/sql-database/sql-database-service-tiers/)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="88dfb-284">For more information on selecting the correct service plan, see [SQL Database options and performance: Understand what's available in each service tier](/azure/sql-database/sql-database-service-tiers/).</span></span>
- <span data-ttu-id="88dfb-285">**Azure Cosmos DB에서 충분 한 요청 단위 (Ru)를 프로 비전**합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-285">**Provision sufficient request units (RUs) in Azure Cosmos DB**.</span></span> <span data-ttu-id="88dfb-286">Azure Cosmos DB를 사용하면 프로비전하는 처리량 및 시간 단위로 사용하는 스토리지의 요금을 지불합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-286">With Azure Cosmos DB, you pay for the throughput you provision and the storage you consume on an hourly basis.</span></span> <span data-ttu-id="88dfb-287">모든 데이터베이스 작업의 비용을 CPU, IOPS 및 메모리 같은 시스템 리소스를 추상화 하는 Ru를으로 정규화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-287">The cost of all database operations is normalized as RUs, which abstracts the system resources such as CPU, IOPS, and memory.</span></span> <span data-ttu-id="88dfb-288">자세한 내용은 [Azure Cosmos DB의 요청 단위](/azure/cosmos-db/request-units)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="88dfb-288">For more information, see [Request Units in Azure Cosmos DB](/azure/cosmos-db/request-units).</span></span>

## <a name="load-balance-as-needed"></a><span data-ttu-id="88dfb-289">필요에 따라 부하 분산</span><span class="sxs-lookup"><span data-stu-id="88dfb-289">Load-balance as needed</span></span>

<span data-ttu-id="88dfb-290">적절 한 부하 분산을 사용 하면 가용성 요구 사항에 맞게 및 가용성과 관련 된 비용을 최소화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-290">Proper load-balancing allows you to meet availability requirements and to minimize costs associated with availability.</span></span>

- <span data-ttu-id="88dfb-291">**부하 분산을 사용 하 여 요청을 분산 합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-291">**Use load-balancing to distribute requests.**</span></span> <span data-ttu-id="88dfb-292">부하 분산 회전에서 비정상 인스턴스를 제거 하 여 응용 프로그램의 요청을 정상 서비스 인스턴스에 배포 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-292">Load-balancing distributes your application's requests to healthy service instances by removing unhealthy instances from rotation.</span></span> <span data-ttu-id="88dfb-293">서비스는 Azure App Service 또는 Azure Cloud Services를 사용 하는 경우 이미를 분산 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-293">If your service uses Azure App Service or Azure Cloud Services, it's already load-balanced for you.</span></span> <span data-ttu-id="88dfb-294">그러나 Azure Vm을 사용 하 여 응용 프로그램 부하 분산 장치를 프로 비전 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-294">However, if your application uses Azure VMs, you need to provision a load-balancer.</span></span> <span data-ttu-id="88dfb-295">자세한 내용은 참조 하세요. [Azure Load Balancer 란?](/azure/load-balancer/load-balancer-overview/)</span><span class="sxs-lookup"><span data-stu-id="88dfb-295">For more information, see [What is Azure Load Balancer?](/azure/load-balancer/load-balancer-overview/)</span></span>

  <span data-ttu-id="88dfb-296">Azure Load Balancer를 다음에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-296">You can use Azure Load Balancer to:</span></span>

  - <span data-ttu-id="88dfb-297">부하 분산 들어오는 인터넷 트래픽을 Vm에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-297">Load-balance incoming Internet traffic to your VMs.</span></span> <span data-ttu-id="88dfb-298">이 구성은 라고 한 [ *공용 Load Balancer*](/azure/load-balancer/load-balancer-overview#publicloadbalancer)합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-298">This configuration is known as a [*public Load Balancer*](/azure/load-balancer/load-balancer-overview#publicloadbalancer).</span></span>
  - <span data-ttu-id="88dfb-299">트래픽을 가상 네트워크 내 VM 전체에 부하 분산합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-299">Load-balance traffic across VMs inside a virtual network.</span></span> <span data-ttu-id="88dfb-300">하이브리드 시나리오의 온-프레미스 네트워크에서 Load Balancer 프런트 엔드에 연결할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-300">You can also reach a Load Balancer front end from an on-premises network in a hybrid scenario.</span></span> <span data-ttu-id="88dfb-301">두 시나리오 모두 이라고 하는 구성을 사용 하는 [ *내부 Load Balancer*](/azure/load-balancer/load-balancer-overview#internalloadbalancer)합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-301">Both scenarios use a configuration that is known as an [*internal Load Balancer*](/azure/load-balancer/load-balancer-overview#internalloadbalancer).</span></span>
  - <span data-ttu-id="88dfb-302">포트 항목별 포트 인바운드 network address translation (NAT) 규칙을 사용 하 여 특정 Vm에 트래픽을 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-302">Port forward traffic to an itemized port on specific VMs with inbound network address translation (NAT) rules.</span></span>
  - <span data-ttu-id="88dfb-303">공용 Load Balancer를 사용하여 가상 네트워크 내의 VM에 대해 [아웃바운드 연결](/azure/load-balancer/load-balancer-outbound-connections)을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-303">Provide [outbound connectivity](/azure/load-balancer/load-balancer-outbound-connections) for VMs inside your virtual network by using a public Load Balancer.</span></span>

- <span data-ttu-id="88dfb-304">**Azure Traffic Manager와 같은 트래픽 관리자를 사용 하 여 지역에 걸쳐 분산 로드합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-304">**Balance loads across regions with a traffic manager, such as Azure Traffic Manager.**</span></span> <span data-ttu-id="88dfb-305">부하 분산 지역에 걸쳐 트래픽의 하려면 트래픽 관리 솔루션을 및 Azure에서 제공 [Traffic Manager](https://azure.microsoft.com/services/traffic-manager/)합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-305">To load-balance traffic across regions requires a traffic management solution, and Azure provides [Traffic Manager](https://azure.microsoft.com/services/traffic-manager/).</span></span> <span data-ttu-id="88dfb-306">유사한 트래픽 관리 기능을 제공 하는 타사 서비스의 장점은 또한 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-306">You can also take advantage of third-party services that provide similar traffic-management capabilities.</span></span>

## <a name="implement-resiliency-strategies"></a><span data-ttu-id="88dfb-307">복원력 전략 구현</span><span class="sxs-lookup"><span data-stu-id="88dfb-307">Implement resiliency strategies</span></span>

<span data-ttu-id="88dfb-308">이 섹션에서는 몇 가지 일반적인 복원 력 전략을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-308">This section describes some common resiliency strategies.</span></span> <span data-ttu-id="88dfb-309">대부분 이러한 전략의 특정 기술에 제한 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-309">Most of these strategies are not limited to a particular technology.</span></span> <span data-ttu-id="88dfb-310">설명은 각 기술의 일반 개념을 요약 하 고 추가 정보에 대 한 링크를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-310">The descriptions summarize the general idea behind each technique and include links to further reading.</span></span>

- <span data-ttu-id="88dfb-311">**복원 력 패턴을 구현** 원격 작업에 대 한 적절 한 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-311">**Implement resiliency patterns** for remote operations, where appropriate.</span></span> <span data-ttu-id="88dfb-312">응용 프로그램이 원격 서비스 간의 통신에 의존 하는 경우에 따라 [디자인 패턴](../patterns/category/resiliency.md) 일시적 고장을 처리에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-312">If your application depends on communication between remote services, follow [design patterns](../patterns/category/resiliency.md) for dealing with transient failures.</span></span>

- <span data-ttu-id="88dfb-313">**일시적인 오류 다시 시도 하세요.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-313">**Retry transient failures.**</span></span> <span data-ttu-id="88dfb-314">이러한 서비스 사용량이 많을 때 손실로 순간적인 네트워크 연결, 삭제 된 데이터베이스 연결 또는 시간 초과가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-314">These can be caused by momentary loss of network connectivity, a dropped database connection, or a timeout when a service is busy.</span></span> <span data-ttu-id="88dfb-315">자주 요청을 다시 시도 하 여 일시적인 오류를 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-315">Often, a transient failure can be resolved by retrying the request.</span></span>

  - <span data-ttu-id="88dfb-316">여러 Azure 서비스에 대 한 클라이언트 소프트웨어 개발 키트 (SDK)는 호출자에 게 투명 한 방식으로 자동 재시도 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-316">For many Azure services, the client software development kit (SDK) implements automatic retries in a way that is transparent to the caller.</span></span> <span data-ttu-id="88dfb-317">참조 [특정 서비스에 대 한 지침을 다시 시도](../best-practices/retry-service-specific.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-317">See [Retry guidance for specific services](../best-practices/retry-service-specific.md).</span></span>
  - <span data-ttu-id="88dfb-318">구현 또는 합니다 [재시도 패턴](../patterns/retry.md) 는 응용 프로그램 서비스 또는 네트워크 리소스에 연결 하려고 할 때 예상 된 일시적 오류를 투명 하 게 처리할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-318">Or implement the [Retry pattern](../patterns/retry.md) to help the application handle anticipated, temporary failures transparently when it tries to connect to a service or network resource.</span></span>

- <span data-ttu-id="88dfb-319">**회로 차단기를 사용 하 여** 시간 문제를 해결 하려면 가변 크기를 많이 사용할 수 있는 오류를 처리 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-319">**Use a circuit breaker** to handle faults that might take a variable amount of time to fix.</span></span> <span data-ttu-id="88dfb-320">합니다 [회로 차단기 패턴](../patterns/circuit-breaker.md) 실패할 가능성이 있는 작업을 반복적으로 시도에서 응용 프로그램을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-320">The [Circuit Breaker pattern](../patterns/circuit-breaker.md) can prevent an application from repeatedly trying an operation that is likely to fail.</span></span> <span data-ttu-id="88dfb-321">회로 차단기는 서비스에 대한 호출을 래핑하고 최근 실패 횟수를 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-321">The circuit breaker wraps calls to a service and tracks the number of recent failures.</span></span> <span data-ttu-id="88dfb-322">실패 횟수가 임계값을 초과하면 차단기는 서비스를 호출하지 않고 오류 코드를 반환하기 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-322">If the failure count exceeds a threshold, the circuit breaker starts returning an error code without calling the service.</span></span> <span data-ttu-id="88dfb-323">이 복구 서비스에 제공 및 연속 오류를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-323">This gives the service time to recover and helps avoid cascading failures.</span></span>
- <span data-ttu-id="88dfb-324">**중요 한 리소스를 격리 합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-324">**Isolate critical resources.**</span></span> <span data-ttu-id="88dfb-325">실패 한 하위 시스템에 가끔 응용 프로그램의 다른 부분에서 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-325">Failures in one subsystem can sometimes cascade, resulting in failures in other parts of the application.</span></span> <span data-ttu-id="88dfb-326">이 방지 한 경우 오류가 스레드 또는 소켓 같은 리소스 중 해제에 리소스 소모에 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-326">This can happen if a failure prevents resources such as threads or sockets from being freed, leading to resource exhaustion.</span></span> <span data-ttu-id="88dfb-327">이 방지 하려면 한 파티션의 오류 전체 시스템이 중단 시 키 지 있도록 격리 된 그룹에 시스템을 분할할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-327">To avoid this, you can partition a system into isolated groups so that a failure in one partition does not bring down the entire system.</span></span>

    <span data-ttu-id="88dfb-328">여기 일부의 예가이 기법을 라고도 하는 [격 벽 패턴](../patterns/bulkhead.md):</span><span class="sxs-lookup"><span data-stu-id="88dfb-328">Here are some examples of this technique, which is sometimes called the [Bulkhead pattern](../patterns/bulkhead.md):</span></span>

  - <span data-ttu-id="88dfb-329">(예를 들어, 테 넌 트)에서 데이터베이스를 분할 하 고 각 파티션에 대 한 웹 서버 인스턴스는 별도 풀을 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-329">Partition a database (for example, by tenant), and assign a separate pool of web server instances for each partition.</span></span>
  - <span data-ttu-id="88dfb-330">별도의 스레드 풀을 사용하여 호출을 서로 다른 서비스에 격리합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-330">Use separate thread pools to isolate calls to different services.</span></span> <span data-ttu-id="88dfb-331">이렇게 하면 서비스 중 하나가 실패하더라도 연쇄 오류가 발생하지 않도록 방지하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-331">This helps to prevent cascading failures if one of the services fails.</span></span> <span data-ttu-id="88dfb-332">예를 들어, 참조는 Netflix [Hystrix 라이브러리](https://medium.com/netflix-techblog/introducing-hystrix-for-resiliency-engineering-13531c1ab362)합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-332">For an example, see the Netflix [Hystrix library](https://medium.com/netflix-techblog/introducing-hystrix-for-resiliency-engineering-13531c1ab362).</span></span>
  - <span data-ttu-id="88dfb-333">사용 하 여 [컨테이너](https://en.wikipedia.org/wiki/Operating-system-level_virtualization) 특정 하위 시스템에 사용할 수 있는 리소스를 제한 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-333">Use [containers](https://en.wikipedia.org/wiki/Operating-system-level_virtualization) to limit the resources available to a particular subsystem.</span></span>

      ![격벽 패턴의 다이어그램](_images/bulkhead.png)

- <span data-ttu-id="88dfb-335">**적용 [ *보정 트랜잭션을*](../patterns/compensating-transaction.md)** 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-335">**Apply [*compensating transactions*](../patterns/compensating-transaction.md)**.</span></span> <span data-ttu-id="88dfb-336">보정 트랜잭션은 완료된 다른 트랜잭션의 효과를 실행 취소하는 트랜잭션입니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-336">A compensating transaction is a transaction that undoes the effects of another completed transaction.</span></span> <span data-ttu-id="88dfb-337">분산 시스템에서는 강력한 트랜잭션 일관성을 확보 하는 것이 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-337">In a distributed system, it can be difficult to achieve strong transactional consistency.</span></span> <span data-ttu-id="88dfb-338">보정 트랜잭션을 일련의 각 단계에서 실행 취소할 수 있는 소규모의 개별 트랜잭션 사용 하 여 일관성을 달성 하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-338">Compensating transactions help to achieve consistency by using a series of smaller, individual transactions that can be undone at each step.</span></span> <span data-ttu-id="88dfb-339">예를 들어 출장을 준비하려면 고객은 자동차, 호텔 객실 및 항공편을 예약해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-339">For example, to book a trip, a customer might reserve a car, a hotel room, and a flight.</span></span> <span data-ttu-id="88dfb-340">다음이 단계 중 하나가 실패 하면 전체 작업이 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-340">If one of these steps fails, the entire operation fails.</span></span> <span data-ttu-id="88dfb-341">전체 작업에 단일 분산 트랜잭션을 사용하는 대신, 각 단계에 대한 보정 트랜잭션을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-341">Instead of trying to use a single distributed transaction for the entire operation, you can define a compensating transaction for each step.</span></span>
- <span data-ttu-id="88dfb-342">**가능한 비동기 작업을 구현 합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-342">**Implement asynchronous operations, whenever possible.**</span></span> <span data-ttu-id="88dfb-343">동기 작업은 프로세스가 완료될 때까지 호출자가 대기하는 동안 리소스를 독점하고 다른 작업을 차단할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-343">Synchronous operations can monopolize resources and block other operations while the caller waits for the process to complete.</span></span> <span data-ttu-id="88dfb-344">가능한 비동기 작업을 허용 하도록 응용 프로그램의 각 파트를 디자인 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-344">Design each part of your application to allow for asynchronous operations, whenever possible.</span></span> <span data-ttu-id="88dfb-345">C에서 비동기 프로그래밍을 구현 하는 방법에 대 한 자세한 내용은\#를 참조 하세요 [비동기 프로그래밍](/dotnet/articles/csharp/async)합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-345">For more information on how to implement asynchronous programming in C\#, see [Asynchronous Programming](/dotnet/articles/csharp/async).</span></span>

## <a name="ensure-that-availability-meets-slas"></a><span data-ttu-id="88dfb-346">가용성 Sla를 충족 하는지 확인</span><span class="sxs-lookup"><span data-stu-id="88dfb-346">Ensure that availability meets SLAs</span></span>

<span data-ttu-id="88dfb-347">*가용성* 는 시스템의 기능 및 작업 하는 시간의 비율을 이며 중 하나인 합니다 [소프트웨어 품질 핵심 요소](../guide/pillars.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-347">*Availability* is the proportion of time that a system is functional and working, and it is one of the [pillars of software quality](../guide/pillars.md).</span></span> <span data-ttu-id="88dfb-348">이 섹션에서는 작업을 사용 하 여 가용성 Sla를 충족 하는지 확인 하 여 가용성 관점에서 응용 프로그램 아키텍처를 검토 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-348">Use the tasks in this section to review your application architecture from an availability standpoint to make sure that your availability meets your SLAs.</span></span>

- <span data-ttu-id="88dfb-349">**모든 단일 지점 장애를 방지합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-349">**Avoid any single point of failure.**</span></span> <span data-ttu-id="88dfb-350">모든 구성 요소, 서비스, 리소스 및 컴퓨팅 인스턴스는 여러 인스턴스로 배포하여 단일 실패 지점이 가용성에 영향을 주지 않도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-350">All components, services, resources, and compute instances should be deployed as multiple instances to prevent a single point of failure from affecting availability.</span></span> <span data-ttu-id="88dfb-351">인증 메커니즘에는 단일 실패 지점이 될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-351">Authentication mechanisms can also be a single point of failure.</span></span> <span data-ttu-id="88dfb-352">구성 가능 하도록 여러 인스턴스를 사용 하 고을 자동으로 오류를 감지 하 고 실패 하지 않은 인스턴스에 요청을 리디렉션할 플랫폼 자동으로 수행 하지 않습니다 하는 경우 응용 프로그램을 디자인 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-352">Design the application to be configurable to use multiple instances and to automatically detect failures and redirect requests to non-failed instances, if the platform doesn't do this automatically.</span></span>
- <span data-ttu-id="88dfb-353">**서비스 수준 목적별로 워크로드를 분해합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-353">**Decompose workloads by service-level objective.**</span></span> <span data-ttu-id="88dfb-354"> 서비스가 중요하고 덜 중요한 워크로드로 구성되면 다르게 관리하도록 하고 해당 가용성 요구 사항에 맞게 서비스 기능 및 인스턴스 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-354">If a service is composed of critical and less-critical workloads, manage them differently and specify the service features and number of instances to meet their availability requirements.</span></span>
- <span data-ttu-id="88dfb-355">**서비스 종속성을 최소화하고 이해합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-355">**Minimize and understand service dependencies.**</span></span> <span data-ttu-id="88dfb-356">사용 가능한 경우 다른 서비스의 수를 최소화 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-356">Minimize the number of different services used, where possible.</span></span> <span data-ttu-id="88dfb-357">모든 기능과 서비스가 존재 하는 종속성 시스템에서을 알고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-357">Ensure that you understand all the feature and service dependencies that exist in the system.</span></span> <span data-ttu-id="88dfb-358">특히, 실패 또는 각 종속성에 대 한 성능 저하의 전체적인 영향을 이해 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-358">In particular, understand the overall impact of failure or reduced performance in each dependency.</span></span>
- <span data-ttu-id="88dfb-359">**작업 및 메시지 설계 *idempotent*, 가능한 경우.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-359">**Design tasks and messages to be *idempotent*, where possible.**</span></span> <span data-ttu-id="88dfb-360">작업을 수차례 반복해도 동일한 결과를 내놓는다면 idempotent 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-360">An operation is idempotent if it can be repeated multiple times and produce the same result.</span></span> <span data-ttu-id="88dfb-361">이 중복 된 요청 문제를 유발 하지 하는지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-361">This can ensure that duplicated requests don't cause problems.</span></span> <span data-ttu-id="88dfb-362">소비자와 소비자가 수행하는 작업은 idempotent하므로 이전에 실행된 작업을 반복하는 것이 잘못된 결과를 렌더링하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-362">Message consumers and the operations they carry out should be idempotent so that repeating a previously executed operation does not render the results invalid.</span></span> <span data-ttu-id="88dfb-363">이 메시지를 중복 감지 또는 충돌 처리에 대해 낙관적 접근법을 사용 하 여 일관성을 보장을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-363">This may mean detecting duplicated messages or ensuring consistency by using an optimistic approach to handling conflicts.</span></span>
- <span data-ttu-id="88dfb-364">**요청 시간 제한 구성.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-364">**Configure request timeouts.**</span></span> <span data-ttu-id="88dfb-365">서비스 및 리소스는 실패한 요청을 발생시켜 사용할 수 없게 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-365">Services and resources may become unavailable, causing requests to fail.</span></span> <span data-ttu-id="88dfb-366">적용 한 시간 제한이 각 서비스 또는 리소스에 적합 한 클라이언트는 액세스 하는 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-366">Ensure that the timeouts you apply are appropriate for each service or resource and for the client that is accessing them.</span></span> <span data-ttu-id="88dfb-367">경우에 따라, 클라이언트가 수행하는 컨텍스트 및 기타 작업에 따라 클라이언트의 특정 인스턴스에 대해 더 긴 시간 제한을 허용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-367">In some cases, you might allow a longer timeout for a particular instance of a client, depending on the context and other actions that the client is performing.</span></span> <span data-ttu-id="88dfb-368">짧은 시간 제한에는 서비스 및 리소스에 상당한 대기 시간에 대 한 과도 한 다시 시도 작업이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-368">Short timeouts may cause excessive retry operations for services and resources that have considerable latency.</span></span> <span data-ttu-id="88dfb-369">서비스 또는 리소스 응답을 기다리는 많은 수의 요청 대기 중인 경우 차단 긴 시간 제한이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-369">Long timeouts can cause blocking, if a large number of requests are queued, waiting for a service or resource to respond.</span></span>
- <span data-ttu-id="88dfb-370">**중요한 트랜잭션에 대한 고가용성을 구현하는 메시지 브로커를 사용합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-370">**Use a message broker that implements high availability for critical transactions.**</span></span> <span data-ttu-id="88dfb-371">많은 클라우드 응용 프로그램 메시징을 사용 하 여 비동기 작업을 트리거합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-371">Many cloud applications use messaging to trigger asynchronous tasks.</span></span> <span data-ttu-id="88dfb-372">메시지 배달을 보장하려면 메시징 시스템이 고가용성을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-372">To guarantee delivery of messages, the messaging system should provide high availability.</span></span> <span data-ttu-id="88dfb-373">[Azure Service Bus 메시징](/azure/service-bus-messaging) 구현 *한 번 이상* 의미 체계는 메시지를 한 번 이상 전달할 보장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-373">[Azure Service Bus messaging](/azure/service-bus-messaging) implements *at least once* semantics, which means that a message is guaranteed to be delivered at least once.</span></span> <span data-ttu-id="88dfb-374">특정 상황에서 중복 메시지를 배달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-374">Duplicate messages may be delivered under certain circumstances.</span></span> <span data-ttu-id="88dfb-375">메시지 처리가 멱등 상태이면(이전 항목 참조) 반복된 배달이 문제가 아니어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-375">If message processing is idempotent (see the previous item), repeated delivery should not be a problem.</span></span>
- <span data-ttu-id="88dfb-376">**대규모 사용자 제한입니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-376">**Throttle high-volume users.**</span></span> <span data-ttu-id="88dfb-377">때로는 소수의 사용자가 과도 한 로드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-377">Sometimes, a small number of users creates excessive load.</span></span> <span data-ttu-id="88dfb-378">이 다른 사용자에 게 영향을 줄을 포함할 수 있으며 응용 프로그램의 전반적인 가용성을 낮출 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-378">This can have an impact on other users and can reduce the overall availability of your application.</span></span> <span data-ttu-id="88dfb-379">단일 클라이언트 요청 수가 너무 많으면 하면 응용 프로그램 특정 기간 동안 클라이언트를 제한할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-379">When a single client makes an excessive number of requests, the application might throttle the client for a certain period.</span></span> <span data-ttu-id="88dfb-380">제한 기간 동안 응용 프로그램에서 일부 또는 모든 요청이 해당 클라이언트에서 거부합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-380">During the throttling period, the application refuses some or all of the requests from that client.</span></span> <span data-ttu-id="88dfb-381">종종 임계값 제한에 대 한 고객의 서비스 계층에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-381">The threshold for throttling often depends on the customer's service tier.</span></span> <span data-ttu-id="88dfb-382">자세한 내용은 [조정 패턴](../patterns/throttling.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-382">For more information, see [Throttling pattern](../patterns/throttling.md).</span></span>

    <span data-ttu-id="88dfb-383">제한 함을 뜻하지는지 않습니다는 클라이언트 작업이 반드시 악의적 &mdash; 서비스 할당량을 초과 한다는 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-383">Throttling does not imply that the client was necessarily acting maliciously &mdash; only that it exceeded its service quota.</span></span> <span data-ttu-id="88dfb-384">경우에 따라 소비자가 지속적으로 할당량을 초과하거나 악의적으로 행동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-384">In some cases, a consumer might consistently exceed their quota or otherwise behave badly.</span></span> <span data-ttu-id="88dfb-385">이 경우 더 나아가서 해당 사용자를 차단할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-385">In that case, you might go further and block the user.</span></span> <span data-ttu-id="88dfb-386">일반적으로 사용자 차단은 API 키 또는 IP 주소 범위를 차단하여 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-386">Typically, this is done by blocking an API key or an IP address range.</span></span>
- <span data-ttu-id="88dfb-387">**애플리케이션이 무리 없이 성능이 저하되도록 설계합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-387">**Design applications to gracefully degrade.**</span></span> <span data-ttu-id="88dfb-388">애플리케이션에서 부하가 하나 이상의 부분 용량을 초과하여 가용성을 감소시키고 연결이 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-388">The load on an application may exceed the capacity of one or more parts, causing reduced availability and failed connections.</span></span> <span data-ttu-id="88dfb-389">이 문제를 완화할 수 크기 조정 되지만 리소스 가용성 또는 비용 같은 다른 요인에 의해 제한에 도달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-389">Scaling can mitigate this problem, but it may reach a limit imposed by other factors, such as resource availability or cost.</span></span> <span data-ttu-id="88dfb-390">애플리케이션이 리소스 제한에 도달한 경우 해당 사용자에게 충격을 최소화할 수 있는 조치를 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-390">When an application reaches a resource limit, it should take appropriate action to minimize the impact for the user.</span></span> <span data-ttu-id="88dfb-391">예를 들어 전자 상거래 시스템에서 주문 처리 하위 시스템은 부담을 받거나 실패 하는 경우이 임시로 해제할 수 있습니다 제품 카탈로그를 검색 하는 등의 다른 기능을 허용 하는 동안.</span><span class="sxs-lookup"><span data-stu-id="88dfb-391">For example, in an e-commerce system, if the order-processing subsystem is under strain or fails, it can be temporarily disabled while allowing other functionality, such as browsing the product catalog.</span></span> <span data-ttu-id="88dfb-392">결함이 있는 하위 시스템에 대 한 요청을 연기 하려면 적합할 &mdash; 예를 들어 고객이 주문을 제출할 수를 여전히 사용 되지만 주문 하위 시스템을 다시 사용할 수 있는 경우 나중에 처리에 대 한 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-392">It might be appropriate to postpone requests to a failing subsystem &mdash; for example, still enabling customers to submit orders but saving them for later processing, when the orders subsystem is available again.</span></span>
- <span data-ttu-id="88dfb-393">**빠른 버스트 이벤트를 정상적으로 처리 합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-393">**Gracefully handle rapid burst events.**</span></span> <span data-ttu-id="88dfb-394">대부분 애플리케이션은 시간에 따라 변화하는 워크로드를 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-394">Most applications need to handle varying workloads over time.</span></span> <span data-ttu-id="88dfb-395">자동 크기 조정은 부하를 처리 하는 데 도움이 되지만 약간의 추가 인스턴스를 온라인 상태로 전환 하 고 요청을 처리 시간이 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-395">Autoscaling can help to handle the load, but it may take some time for additional instances to come online and handle requests.</span></span> <span data-ttu-id="88dfb-396">응용 프로그램을 부담 활동 버스트를 방지 하려면 큐 요청 큐 용량을 나갈 때 정상적으로 성능 저하를 사용 하 여 서비스를 디자인 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-396">To prevent bursts of activity from overwhelming the application, design it to queue requests to the services it uses and to degrade gracefully when queues are near capacity.</span></span> <span data-ttu-id="88dfb-397">한지 확인 합니다. 충분 한 성능 및 용량 버스트 하지 않은 큐를 비우고 처리 중인 요청을 처리 하는 조건을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-397">Ensure there is sufficient performance and capacity available under non-burst conditions to drain the queues and handle outstanding requests.</span></span> <span data-ttu-id="88dfb-398">자세한 내용은 [큐 기반 부하 평준화 패턴](../patterns/queue-based-load-leveling.md)을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="88dfb-398">For more information, see the [Queue-Based Load Leveling pattern](../patterns/queue-based-load-leveling.md).</span></span>
- <span data-ttu-id="88dfb-399">**작성 하거나 여러 구성 요소를 다시 실패 합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-399">**Compose or fail back to multiple components.**</span></span> <span data-ttu-id="88dfb-400">가능한 경우에 영향을 주는 작업 및 기존 연결 하지 않고 여러 인스턴스를 사용 하도록 응용 프로그램을 디자인 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-400">Design applications to use multiple instances without affecting operation and existing connections, where possible.</span></span> <span data-ttu-id="88dfb-401">가용성을 최대화 하려면 여러 인스턴스를 사용 하면 간에 요청을 분산 및 검색 및 실패 한 인스턴스에 요청을 보내는 것을 방지 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-401">To maximize availability, use multiple instances and distribute requests between them, and detect and avoid sending requests to failed instances.</span></span>
- <span data-ttu-id="88dfb-402">**다른 서비스 또는 워크플로를 다시 실패 합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-402">**Fail back to a different service or workflow.**</span></span> <span data-ttu-id="88dfb-403">예를 들어, SQL Database에 쓰기 실패를 임시로 저장 데이터 Blob storage 또는 Redis Cache에 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-403">For example, if writing to SQL Database fails, temporarily store data in Blob storage or Redis Cache.</span></span> <span data-ttu-id="88dfb-404">서비스를 사용할 수 있을 때 SQL Database에 쓰기를 재생하는 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-404">Provide a way to replay the writes to SQL Database when the service becomes available.</span></span> <span data-ttu-id="88dfb-405">경우에 따라 실패 한 작업을 계속 정상적으로 작동도 구성 요소 또는 서비스에 실패 한 경우 응용 프로그램을 허용 하는 대체 동작이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-405">In some cases, a failed operation may have an alternative action that allows the application to continue to work, even when a component or service fails.</span></span> <span data-ttu-id="88dfb-406">가능한 경우 오류를 감지 하 고 기본 서비스가 오프 라인일 때 다른 서비스에 요청을 리디렉션하십시오.</span><span class="sxs-lookup"><span data-stu-id="88dfb-406">If possible, detect failures and redirect requests to other services while the primary service is offline.</span></span>
- <span data-ttu-id="88dfb-407">**트래픽이 급증 부하 평준화를 사용 합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-407">**Use load leveling to smooth out spikes in traffic.**</span></span> <span data-ttu-id="88dfb-408">응용 프로그램의 서비스 백 엔드를 지나치게 사용 될 수 있는 트래픽이 갑자기 치 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-408">Applications may experience sudden spikes in traffic, which can overwhelm services on the back end.</span></span> <span data-ttu-id="88dfb-409">백 엔드 서비스를 신속 하 게 요청에 응답할 수 없습니다. 보류 중인 요청 누적 할 수 있습니다 하거나 서비스 응용 프로그램을 제한할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-409">If a back-end service cannot respond to requests quickly enough, the pending requests may accumulate or the service may throttle the application.</span></span> <span data-ttu-id="88dfb-410">큐를 버퍼로 사용하면 이 상황을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-410">To avoid this, you can use a queue as a buffer.</span></span> <span data-ttu-id="88dfb-411">백 엔드 서비스를 즉시 호출 하는 대신 새 작업 항목을 때 응용 프로그램 큐 작업 항목을 비동기적으로 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-411">When there is a new work item, instead of calling the back-end service immediately, the application queues a work item to run asynchronously.</span></span> <span data-ttu-id="88dfb-412">큐는 피크 부하를 매끄럽게 하는 버퍼 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-412">The queue acts as a buffer that smooths out peaks in the load.</span></span> <span data-ttu-id="88dfb-413">자세한 내용은 [큐 기반 부하 평준화 패턴](../patterns/queue-based-load-leveling.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-413">For more information, see [Queue-Based Load Leveling pattern](../patterns/queue-based-load-leveling.md).</span></span>

## <a name="manage-your-data"></a><span data-ttu-id="88dfb-414">데이터 관리</span><span class="sxs-lookup"><span data-stu-id="88dfb-414">Manage your data</span></span>

<span data-ttu-id="88dfb-415">응용 프로그램의 가용성에 직접 재생 데이터를 관리 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-415">How you manage your data plays directly into the availability of your application.</span></span> <span data-ttu-id="88dfb-416">이 섹션에서는 작업의 가용성을 보장 하는 데 관리 계획을 만들 수 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-416">The tasks in this section can help you create a management plan to help ensure availability.</span></span>

- <span data-ttu-id="88dfb-417">**데이터를 복제 하 고 응용 프로그램의 데이터 저장소에 대 한 복제 방법을 이해 합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-417">**Replicate data and understand the replication methods for your application's data stores.**</span></span> <span data-ttu-id="88dfb-418">데이터 복제는 데이터 저장소의 일시적이지 않은 오류를 처리하는 일반적인 전략입니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-418">Replicating data is a general strategy for handling non-transient failures in a data store.</span></span> <span data-ttu-id="88dfb-419">읽기 및 쓰기 경로 두는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-419">Consider both the read and write paths.</span></span> <span data-ttu-id="88dfb-420">저장소 기술에 따라 여러 쓰기 가능한 복제본 있거나 단일 쓰기 가능한 복제본 및 읽기 전용 복제본을 여러 개 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-420">Depending on the storage technology, you might have multiple writable replicas or you might have a single writable replica and multiple read-only replicas.</span></span> <span data-ttu-id="88dfb-421">가용성을 최대화하기 위해 복제본을 여러 영역에 배치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-421">To maximize availability, replicas can be placed in multiple regions.</span></span> <span data-ttu-id="88dfb-422">그러나이 방법은 데이터를 복제할 때 대기 시간이 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-422">However, this approach increases the latency when replicating the data.</span></span> <span data-ttu-id="88dfb-423">일반적으로 지역 간 복제는 비동기적으로 수행되며, 이는 복제본 오류가 발생할 경우 궁극적으로 일관성 모델 및 데이터 손실 가능성이 있다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-423">Typically, replicating across regions is done asynchronously, which implies an eventual consistency model and potential data loss if a replica fails.</span></span>  

  <span data-ttu-id="88dfb-424">사용할 수 있습니다 [Azure Site Recovery](/azure/site-recovery/azure-to-azure-quickstart/) 를 다른 지역 간에 Azure Virtual Machines를 복제 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-424">You can use [Azure Site Recovery](/azure/site-recovery/azure-to-azure-quickstart/) to replicate Azure Virtual Machines from one region to another.</span></span> <span data-ttu-id="88dfb-425">Site Recovery는 지속적으로 대상 지역에 데이터를 복제합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-425">Site Recovery replicates data continuously to the target region.</span></span> <span data-ttu-id="88dfb-426">기본 사이트에서 중단이 발생 하는 경우 장애 조치를 보조 위치.</span><span class="sxs-lookup"><span data-stu-id="88dfb-426">When an outage occurs at your primary site, you fail over to a secondary location.</span></span>

- <span data-ttu-id="88dfb-427">**프로덕션 및 백업 데이터 둘 다에 대해 액세스 권한을 가진 단일 사용자 계정이 없는지 확인합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-427">**Ensure that no single user account has access to both production and backup data.**</span></span> <span data-ttu-id="88dfb-428">단일 사용자 계정 하나가 프로덕션 및 백업 원본 둘 다에 대한 쓰기 권한을 가진 경우 데이터 백업이 손상됩니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-428">Your data backups are compromised if one single user account has permission to write to both production and backup sources.</span></span> <span data-ttu-id="88dfb-429">악의적인 사용자는 모든 데이터를 고의로 삭제할 수 및 일반 사용자를 실수로 삭제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-429">A malicious user could purposely delete all your data, and a regular user could accidentally delete it.</span></span> <span data-ttu-id="88dfb-430">각 사용자 계정의 권한을 제한 하는 응용 프로그램을 디자인 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-430">Design your application to limit the permissions of each user account.</span></span> <span data-ttu-id="88dfb-431">만 필요로 하는 사용자에 게 쓰기 권한을 부여 하 고 프로덕션 또는 백업 하지만 둘 다에 대 한 액세스를 부여 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-431">Only grant write access to users who require it, and grant access to either production or backup, but not both.</span></span>
- <span data-ttu-id="88dfb-432">**문서 및 데이터 저장소 장애 조치 및 장애 복구 프로세스를 테스트 합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-432">**Document and test your data store failover and failback process.**</span></span> <span data-ttu-id="88dfb-433">데이터 저장소 치명적 오류가 발생 하면 운영자는 새 데이터 저장소로 장애 조치 문서화 된 지침의 집합을 따라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-433">If a data store fails catastrophically, a human operator must follow a set of documented instructions to fail over to a new data store.</span></span> <span data-ttu-id="88dfb-434">문서화 된 단계를 오류가 발생 하는 경우에 운영자를 성공적으로 수행 하 고 리소스를 장애 조치할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-434">If the documented steps have errors, an operator won't be able to successfully follow them and to fail over the resource.</span></span> <span data-ttu-id="88dfb-435">정기적으로 설명서를 따르는 운영자 수 성공적으로 장애 조치 및 장애 복구를 확인 하는 명령 단계를 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-435">Regularly test the instruction steps to verify that an operator who follows the documentation can successfully fail over and fail back.</span></span>
- <span data-ttu-id="88dfb-436">**데이터를 백업 하 고 데이터 백업이 유효성을 검사 합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-436">**Back up your data and validate your data backups.**</span></span> <span data-ttu-id="88dfb-437">데이터 무결성, 스키마 및 백업 데이터가 예상 대로 인지 확인 하는 쿼리를 유효성을 검사 하는 스크립트를 정기적으로 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-437">Regularly run a script to validate data integrity, schema, and queries to ensure that backup data is what you expect.</span></span> <span data-ttu-id="88dfb-438">백업 서비스를 수리할 수 있도록 모순점을 기록하고 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-438">Log and report any inconsistencies so the backup service can be repaired.</span></span>
- <span data-ttu-id="88dfb-439">**정기적인 백업 및 지정 시간 복원을 사용 합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-439">**Use periodic backup and point-in-time restore.**</span></span> <span data-ttu-id="88dfb-440">자동으로 정기적으로 다른 곳에서 보존 되지 않은 데이터를 백업 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-440">Regularly and automatically back up data that is not preserved elsewhere.</span></span> <span data-ttu-id="88dfb-441">복원할 수 있습니다 안정적으로 데이터와 응용 프로그램 자체 오류가 발생 하는 경우를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-441">Verify that you can reliably restore both the data and the application itself if failure occurs.</span></span> <span data-ttu-id="88dfb-442">백업이 RPO를 충족 하는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-442">Ensure that backups meet your RPO.</span></span> <span data-ttu-id="88dfb-443">데이터 복제 인간적 오류나 악의적인 작업 모든 복제본에서 데이터가 손상 될 수 있으므로 백업 기능이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-443">Data replication isn't a backup feature, because human error or malicious operations can corrupt data across all the replicas.</span></span> <span data-ttu-id="88dfb-444">전송 중 및 저장소에 있는 데이터를 보호하려면 백업 프로세스가 안전해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-444">The backup process must be secure to protect the data in transit and in storage.</span></span> <span data-ttu-id="88dfb-445">데이터베이스는 일반적으로 복구할 수 있습니다를 이전 시점으로에서 트랜잭션 로그를 사용 하 여.</span><span class="sxs-lookup"><span data-stu-id="88dfb-445">Databases can usually be recovered to a previous point in time by using transaction logs.</span></span> <span data-ttu-id="88dfb-446">자세한 내용은 [데이터 손상 또는 우발적 삭제 로부터 복구](../resiliency/recovery-data-corruption.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-446">For more information, see [Recover from data corruption or accidental deletion](../resiliency/recovery-data-corruption.md).</span></span>
- <span data-ttu-id="88dfb-447">**지역 중복 저장소 계정을 사용 하는 것이 좋습니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-447">**Consider using a geo-redundant storage account.**</span></span> <span data-ttu-id="88dfb-448">Azure 저장소 계정에 저장된 데이터는 항상 로컬로 복제됩니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-448">Data stored in an Azure Storage account is always replicated locally.</span></span> <span data-ttu-id="88dfb-449">그러나 저장소 계정이 프로 비전 될 때 선택할 수 있는 여러 복제 전략이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-449">However, there are multiple replication strategies to choose from when a storage account is provisioned.</span></span> <span data-ttu-id="88dfb-450">전체 지역이 사용할 수 없게 되는 드문 경우 응용 프로그램 데이터를 보호, 선택 [Azure 읽기 액세스 지역 중복 저장소 (RA-GRS)](/azure/storage/storage-redundancy/#read-access-geo-redundant-storage)합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-450">To protect your application data against the rare case when an entire region becomes unavailable, select [Azure Read-Access Geo-Redundant Storage (RA-GRS)](/azure/storage/storage-redundancy/#read-access-geo-redundant-storage).</span></span>  

    > [!NOTE]
    > <span data-ttu-id="88dfb-451">VM의 경우 VM 디스크(VHD 파일)를 복원하기 위해 RA-GRS 복제에 의존하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="88dfb-451">For VMs, do not rely on RA-GRS replication to restore the VM disks (VHD files).</span></span> <span data-ttu-id="88dfb-452">그 대신 [Azure Backup](/azure/backup)을 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="88dfb-452">Instead, use [Azure Backup](/azure/backup).</span></span>

- <span data-ttu-id="88dfb-453">**여러 지역에 참조 데이터를 배포 하는 것이 좋습니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-453">**Consider deploying reference data to multiple regions.**</span></span> <span data-ttu-id="88dfb-454">참조 데이터는 애플리케이션 기능을 지원하는 읽기 전용 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-454">Reference data is read-only data that supports application functionality.</span></span> <span data-ttu-id="88dfb-455">일반적으로 바뀌지 않습니다 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-455">It typically doesn't change often.</span></span> <span data-ttu-id="88dfb-456">백업에서 복원 지역 전체의 서비스 중단을 처리 하는 방법은 되어도 RTO는 비교적 깁니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-456">Although restoring from backup is one way to handle region-wide service disruptions, the RTO is relatively long.</span></span> <span data-ttu-id="88dfb-457">보조 지역에 애플리케이션을 배포할 경우 몇 가지 전략을 통해 참조 데이터에 대한 RTO를 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-457">When you deploy the application to a secondary region, some strategies can improve the RTO for reference data.</span></span>

    <span data-ttu-id="88dfb-458">때문에 참조 데이터 변경 내용을 자주 보조 지역에서 영구 복사본을 유지 하 여 RTO를 개선할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-458">Because reference data changes infrequently, you can improve the RTO by maintaining a permanent copy in the secondary region.</span></span> <span data-ttu-id="88dfb-459">이렇게 하면 재해 발생 후 백업을 복원 하는 데 필요한 시간이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-459">This eliminates the time required to restore backups after a disaster.</span></span> <span data-ttu-id="88dfb-460">여러 지역 재해 복구 요구 사항을 충족하려면 여러 지역에 애플리케이션 및 참조 데이터를 함께 배포해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-460">To meet the multiple-region disaster recovery requirements, you must deploy the application and the reference data together in multiple regions.</span></span>

- <span data-ttu-id="88dfb-461">**낙관적 동시성 및 결과적 일관성을 사용 합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-461">**Use optimistic concurrency and eventual consistency.**</span></span> <span data-ttu-id="88dfb-462">잠금을 통해 리소스에 대 한 액세스를 차단 하는 트랜잭션 (*비관적 동시성*) 성능 저하의 원인이 되 고 가용성을 저하 시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-462">Transactions that block access to resources through locking (*pessimistic concurrency*) can cause poor performance and reduce availability.</span></span> <span data-ttu-id="88dfb-463">이러한 문제는 특히 분산된 시스템에서 심각할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-463">These problems can become especially acute in distributed systems.</span></span> <span data-ttu-id="88dfb-464">대부분의 경우에서 신중 하 게 디자인 하 고 분할 하는 등 기술이 발생 하는 업데이트 충돌 가능성을 최소화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-464">In many cases, careful design and techniques, such as partitioning, can minimize the chances of conflicting updates occurring.</span></span> <span data-ttu-id="88dfb-465">데이터를 복제 하거나 개별적으로 업데이트 된 저장소에서 읽기를 하는 경우 데이터를 최종적으로 일치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-465">If data is replicated or read from a separately updated store, the data will only be eventually consistent.</span></span> <span data-ttu-id="88dfb-466">하지만 장점 일반적으로 즉각적인 일관성을 보장 하려면 트랜잭션을 사용 하 여 가용성에 영향을 능가 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-466">But the advantages usually outweigh the impact on availability of using transactions to ensure immediate consistency.</span></span>
- <span data-ttu-id="88dfb-467">**SQL Database에 대 한 활성 지역 복제를 사용 하 여 보조 데이터베이스에 변경 내용을 복제할 수 있습니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-467">**Use active geo-replication for SQL Database to replicate changes to a secondary database.**</span></span> <span data-ttu-id="88dfb-468">SQL Database에 대 한 활성 지역 복제는 동일한 지역 이나 다른 지역에서 보조 데이터베이스에 데이터베이스 변경 내용을 자동으로 복제합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-468">Active geo-replication for SQL Database automatically replicates database changes to secondary databases in the same region or a different region.</span></span> <span data-ttu-id="88dfb-469">자세한 내용은 [만들기 및 활성 지역 복제를 사용 하 여](/azure/sql-database/sql-database-active-geo-replication)입니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-469">For more information, see [Creating and using active geo-replication](/azure/sql-database/sql-database-active-geo-replication).</span></span>

  <span data-ttu-id="88dfb-470">수동 접근 방식을 사용 하 여 수행할 수는 또는 **데이터베이스 복사본** 트랜잭션 일관성을 사용 하 여 데이터베이스의 백업 복사본을 만드는 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-470">Alternatively, you can take a more manual approach by using the **DATABASE COPY** command to create a backup copy of the database with transactional consistency.</span></span> <span data-ttu-id="88dfb-471">Azure Blob Storage에 저장된 BACPAC 파일(데이터베이스 스키마 및 연결된 데이터가 들어 있는 압축된 파일)에 데이터베이스 내보내기를 지원하는 Azure SQL Database의 가져오기/내보내기 서비스를 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-471">You can also use the import/export service of Azure SQL Database, which supports exporting databases to BACPAC files (compressed files containing your database schema and associated data) that are stored in Azure Blob storage.</span></span> <span data-ttu-id="88dfb-472">Azure Storage는 동일한 지역에 두 개의 백업 파일 복제본을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-472">Azure Storage creates two replicas of the backup file in the same region.</span></span> <span data-ttu-id="88dfb-473">그러나 백업 프로세스의 빈도 재해 시나리오에서 손실 될 데이터의 양을 RPO를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-473">However, the frequency of the backup process determines your RPO, which is the amount of data you might lose in disaster scenarios.</span></span> <span data-ttu-id="88dfb-474">예를 들어 매시간 데이터를 백업 하는 경우 재해가 발생 2 분 동안 백업 데이터의 58 분 손실 됩니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-474">For example, if you back up data every hour, and a disaster occurs two minutes before the backup, you will lose 58 minutes of data.</span></span> <span data-ttu-id="88dfb-475">또한 지역 전체 서비스 중단을 방지하려면 대체 지역에 BACPAC 파일을 복사해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-475">Also, to protect against a region-wide service disruption, you should copy the BACPAC files to an alternate region.</span></span> <span data-ttu-id="88dfb-476">자세한 내용은 [Azure SQL Database를 사용 하 여 비즈니스 연속성 개요](/azure/sql-database/sql-database-business-continuity)합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-476">For more information, see [Overview of business continuity with Azure SQL Database](/azure/sql-database/sql-database-business-continuity).</span></span>

- <span data-ttu-id="88dfb-477">**SQL Data Warehouse에 대 한 지역 백업을 사용 합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-477">**Use geo-backups for SQL Data Warehouse.**</span></span> <span data-ttu-id="88dfb-478">SQL Data warehouse의 경우 [지역 백업](/azure/sql-data-warehouse/backup-and-restore)을 사용하여 재해 복구에 대해 페어링된 지역으로 복원합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-478">For SQL Data Warehouse, use [geo-backups](/azure/sql-data-warehouse/backup-and-restore) to restore to a paired region for disaster recovery.</span></span> <span data-ttu-id="88dfb-479">이러한 백업은 24 시간 마다 수행 됩니다 및 쌍을 이루는 지역에서 20 분 이내 복원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-479">These backups are taken every 24 hours and can be restored within 20 minutes in the paired region.</span></span> <span data-ttu-id="88dfb-480">이 기능은 모든 SQL Data Warehouse 인스턴스에 대 한 기본적으로 켜 집니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-480">This feature is on by default for all SQL Data Warehouse instances.</span></span> <span data-ttu-id="88dfb-481">데이터 웨어하우스를 복원 하는 방법에 대 한 자세한 내용은 참조 하세요. [PowerShell을 사용 하 여 Azure 지역에서 복원 합니다.](/azure/sql-data-warehouse/sql-data-warehouse-restore)</span><span class="sxs-lookup"><span data-stu-id="88dfb-481">For more information on how to restore your data warehouse, see [Restore from an Azure geographical region using PowerShell.](/azure/sql-data-warehouse/sql-data-warehouse-restore)</span></span>

- <span data-ttu-id="88dfb-482">**Azure Site Recovery를 사용하여 VM 디스크 복제.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-482">**Replicate VM disks using Azure Site Recovery.**</span></span> <span data-ttu-id="88dfb-483">사용 하 여 Azure Vm을 복제 하는 경우 [Site Recovery](/azure/site-recovery/), 모든 VM 디스크에 지속적으로 대상 지역에 비동기적으로 복제 됩니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-483">When you replicate Azure VMs using [Site Recovery](/azure/site-recovery/), all the VM disks are continuously replicated to the target region asynchronously.</span></span> <span data-ttu-id="88dfb-484">복구 지점은 몇 분 간격으로 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-484">The recovery points are created every few minutes.</span></span> <span data-ttu-id="88dfb-485">몇 분 정도로 RPO를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-485">This gives you an RPO on the order of minutes.</span></span>
- <span data-ttu-id="88dfb-486">**SQL Server Vm에서 실행 중인 백업 또는 로그 전달 세션을 구성 합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-486">**Back up SQL Server running on VMs or configure a log-shipping session.**</span></span> <span data-ttu-id="88dfb-487">Vm에서 실행되는 SQL Server의 경우 두 가지 옵션이 있습니다. 전통적인 백업과 로그 전달입니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-487">For SQL Server running on VMs, there are two options: traditional backups and log shipping.</span></span> <span data-ttu-id="88dfb-488">전통적인 백업을 시간 내에 특정 시점으로 복원할 수 있지만 복구 프로세스가 느립니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-488">Traditional backups enable you to restore to a specific point in time, but the recovery process is slow.</span></span> <span data-ttu-id="88dfb-489">전통적인 백업을 복원 초기 전체 백업으로 시작 하 고 다음 이후에 수행 된 모든 백업을 적용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-489">Restoring traditional backups requires that you start with an initial full backup and then apply any backups taken after that.</span></span> <span data-ttu-id="88dfb-490">두 번째 옵션 (예: 2 시간)에서 로그 백업의 복원을 지연 하도록 로그 전달 세션을 구성 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-490">The second option is to configure a log-shipping session to delay the restore of log backups (for example, by two hours).</span></span> <span data-ttu-id="88dfb-491">주 서버에서 일어난 오류로부터 복구하도록 창을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-491">This provides a window to recover from errors made on the primary.</span></span>
- <span data-ttu-id="88dfb-492">**Azure Storage 백업에 대 한 사용자 지정 프로세스 또는 타사 도구를 사용 합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-492">**Use a custom process or third-party tool for Azure Storage backup.**</span></span> <span data-ttu-id="88dfb-493">Azure Storage에 대 한 사용자 지정 백업 프로세스를 개발 하거나 타사 백업 도구를 사용 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-493">For Azure Storage, you can develop a custom backup process or use a third-party backup tool.</span></span> <span data-ttu-id="88dfb-494">대부분의 응용 프로그램 설계는 저장소 리소스 참조 서로 추가 복잡성을 경우</span><span class="sxs-lookup"><span data-stu-id="88dfb-494">Most application designs have additional complexities, in which storage resources reference each other.</span></span> <span data-ttu-id="88dfb-495">예를 들어 열을 사용 하 여 SQL database를 Azure Storage에서 blob에에서 연결 되는 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-495">For example, consider a SQL database with a column that links to a blob in Azure Storage.</span></span> <span data-ttu-id="88dfb-496">백업이 동시에 발생하지 않는 경우 데이터베이스에는 실패하기 전에 백업되지 않은 Blob에 대한 포인터가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-496">If the backups do not happen simultaneously, the database might have a pointer to a blob that was not backed up before the failure.</span></span> <span data-ttu-id="88dfb-497">애플리케이션 또는 재해 복구 계획은 복구 후에 이러한 불일치를 처리하는 프로세스를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-497">The application or disaster recovery plan must implement processes to handle this inconsistency after a recovery.</span></span>
- <span data-ttu-id="88dfb-498">**Vm에서 호스팅되는 다른 데이터 플랫폼에 대 한 기본 복제 또는 스냅숏 기능을 사용 합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-498">**Use the native replication or snapshot capabilities for other data platforms hosted on VMs.**</span></span> <span data-ttu-id="88dfb-499">Elasticsearch 또는 MongoDB와 같은 다른 데이터 플랫폼 자체 기능 및 고려 사항에 통합된 백업을 만들 때 있고 복원 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-499">Other data platforms, such as Elasticsearch or MongoDB, have their own capabilities and considerations when creating an integrated backup and restore process.</span></span> <span data-ttu-id="88dfb-500">이러한 데이터 플랫폼을 위한 일반적인 권장 사항 네이티브 또는 사용 가능한 통합 기반 복제 또는 스냅숏 기능을 사용 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-500">For these data platforms, the general recommendation is to use any native or available integration-based replication or snapshot capabilities.</span></span> <span data-ttu-id="88dfb-501">해당 기능이 존재 하지 않거나 적합 하지, Azure 백업 또는 디스크 스냅숏을 사용 하 여 응용 프로그램 데이터의 지정 시간 복사본을 만드는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-501">If those capabilities don't exist or aren't suitable, consider using Azure Backup or disk snapshots to create a point-in-time copy of application data.</span></span> <span data-ttu-id="88dfb-502">모든 경우에 여러 파일 시스템에 걸쳐 응용 프로그램 데이터 또는 여러 드라이브는 단일 파일 시스템이 결합 되는 경우에 특히 일관 된 백업을 수행 하는 방법을 결정 하는 것이 반드시 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-502">In all cases, it's important to determine how to achieve consistent backups, especially when application data spans multiple files systems or multiple drives are combined into a single file system.</span></span>
- <span data-ttu-id="88dfb-503">**애플리케이션의 데이터 원본에 대한 복제 방법을 이해합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-503">**Understand the replication methods for your application's data sources.**</span></span> <span data-ttu-id="88dfb-504">응용 프로그램 데이터 서로 다른 데이터 원본에 저장 됩니다 및 가용성 요구 사항에 따라 있는 집니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-504">Your application data will be stored in different data sources and will have varied availability requirements.</span></span> <span data-ttu-id="88dfb-505">Azure에서 데이터 저장소의 각 형식에 대 한 복제 방법을 평가 등 [Azure Storage 중복](/azure/storage/storage-redundancy/) 하 고 [SQL Database 활성 지역 복제](/azure/sql-database/sql-database-geo-replication-overview/) 응용 프로그램의 되도록 데이터 요구 사항은 충족 합니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-505">Evaluate the replication methods for each type of data storage in Azure, including [Azure Storage redundancy](/azure/storage/storage-redundancy/) and [SQL Database active geo-replication](/azure/sql-database/sql-database-geo-replication-overview/) to ensure that your application's data requirements are satisfied.</span></span> <span data-ttu-id="88dfb-506">사용 하 여 Azure Vm을 복제 하는 경우 [Site Recovery](/azure/site-recovery/), 모든 VM 디스크에 지속적으로 대상 지역에 비동기적으로 복제 됩니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-506">If you replicate Azure VMs using [Site Recovery](/azure/site-recovery/), all the VM disks are continuously replicated to the target region asynchronously.</span></span> <span data-ttu-id="88dfb-507">복구 지점은 몇 분 간격으로 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-507">The recovery points are created every few minutes.</span></span>
- <span data-ttu-id="88dfb-508">**재해 복구를 위한 데이터 전략을 설정 합니다.**</span><span class="sxs-lookup"><span data-stu-id="88dfb-508">**Establish data strategies for disaster recovery.**</span></span> <span data-ttu-id="88dfb-509">적절 한 데이터 처리는 재해 복구 계획의 어려운 측면입니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-509">Proper data handling is a challenging aspect of any disaster recovery plan.</span></span> <span data-ttu-id="88dfb-510">복구 프로세스 중 데이터 복원에 일반적으로 가장 많은 시간이 소요됩니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-510">During the recovery process, data restoration typically takes the most time.</span></span> <span data-ttu-id="88dfb-511">다른 선택 사항은 기능 제한에 대 한 데이터 복구 및 일관성에 대 한 어려운 과제를 발생 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="88dfb-511">Different choices for reducing functionality result in difficult challenges for data recovery and consistency.</span></span>

## <a name="next-steps"></a><span data-ttu-id="88dfb-512">다음 단계</span><span class="sxs-lookup"><span data-stu-id="88dfb-512">Next steps</span></span>

> [!div class="nextstepaction"]
> [<span data-ttu-id="88dfb-513">복원 력 및 가용성에 대 한 테스트</span><span class="sxs-lookup"><span data-stu-id="88dfb-513">Test for resiliency and availability</span></span>](./testing.md)
