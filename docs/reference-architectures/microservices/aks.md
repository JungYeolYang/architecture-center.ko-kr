---
title: AKS(Azure Kubernetes Service)의 마이크로 서비스 아키텍처
description: AKS(Azure Kubernetes Service)에 마이크로 서비스 아키텍처 배포
author: MikeWasson
ms.date: 12/10/2018
ms.topic: reference-architecture
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: microservices
ms.openlocfilehash: f3b637d61c929e5523ea5409426f3d7a72096dfa
ms.sourcegitcommit: 1b50810208354577b00e89e5c031b774b02736e2
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/23/2019
ms.locfileid: "54484128"
---
# <a name="microservices-architecture-on-azure-kubernetes-service-aks"></a><span data-ttu-id="374c1-103">AKS(Azure Kubernetes Service)의 마이크로 서비스 아키텍처</span><span class="sxs-lookup"><span data-stu-id="374c1-103">Microservices architecture on Azure Kubernetes Service (AKS)</span></span>

<span data-ttu-id="374c1-104">이 참조 아키텍처는 AKS(Azure Kubernetes Service)에 배포된 마이크로 서비스 애플리케이션을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-104">This reference architectures shows a microservices application deployed to Azure Kubernetes Service (AKS).</span></span> <span data-ttu-id="374c1-105">대부분의 배포에서 시작점으로 사용할 수 있는 기본 AKS 구성을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-105">It shows a basic AKS configuration that can be the starting point for most deployments.</span></span> <span data-ttu-id="374c1-106">고급 네트워킹 옵션을 비롯한 고급 옵션은 별도의 참조 아키텍처에서 다룰 것입니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-106">More advanced options, including advanced networking options, will be covered in a separate reference architecture.</span></span>

<span data-ttu-id="374c1-107">이 문서에서는 Kubernetes에 대한 기본 지식을 다룹니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-107">This article assumes basic knowledge of Kubernetes.</span></span> <span data-ttu-id="374c1-108">이 문서는 AKS에서 마이크로 서비스 아키텍처를 실행하기 위한 인프라 및 DevOps 고려 사항에 중점을 둡니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-108">The article focuses mainly on the infrastructure and DevOps considerations of running a microservices architecture on AKS.</span></span> <span data-ttu-id="374c1-109">DDD(도메인 중심 디자인) 관점에서 마이크로 서비스를 디자인하는 방법에 대한 지침은 [Azure에서 마이크로 서비스 설계, 빌드 및 운영](/azure/architecture/microservices)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="374c1-109">For guidance on how to design microservices from a Domain Driven Design (DDD) perspective, see [Designing, building, and operating microservices on Azure](/azure/architecture/microservices).</span></span>

> [!NOTE]
> <span data-ttu-id="374c1-110">이 문서와 함께 제공할 RI(참조 구현)를 현재 만드는 중이며, 2019년 초에 게시할 예정입니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-110">We are working on a reference implementation (RI) to accompany this article, which we expect to publish in early 2019.</span></span> <span data-ttu-id="374c1-111">이 문서는 이 RI의 추가 모범 사례를 포함하도록 업데이트될 것입니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-111">This article will be updated to incorporate additional best practices from that RI.</span></span>

![AKS 참조 아키텍처](./_images/aks.png)

## <a name="architecture"></a><span data-ttu-id="374c1-113">아키텍처</span><span class="sxs-lookup"><span data-stu-id="374c1-113">Architecture</span></span>

<span data-ttu-id="374c1-114">이 아키텍처는 다음 구성 요소로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-114">The architecture consists of the following components.</span></span>

<span data-ttu-id="374c1-115">**AKS(Azure Kubernetes Service)**.</span><span class="sxs-lookup"><span data-stu-id="374c1-115">**Azure Kubernetes Service** (AKS).</span></span> <span data-ttu-id="374c1-116">AKS는 관리되는 Kubernetes 클러스터를 배포하는 Azure 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-116">AKS is an Azure service that deploys a managed Kubernetes cluster.</span></span> 

<span data-ttu-id="374c1-117">**Kubernetes 클러스터**.</span><span class="sxs-lookup"><span data-stu-id="374c1-117">**Kubernetes cluster**.</span></span> <span data-ttu-id="374c1-118">AKS는 Kubernetes 클러스터를 배포하고 Kubernetes 마스터를 관리하는 역할을 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-118">AKS is responsible for deploying the Kubernetes cluster and for managing the Kubernetes masters.</span></span> <span data-ttu-id="374c1-119">고객은 에이전트 노드만 관리하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-119">You only manage the agent nodes.</span></span>

<span data-ttu-id="374c1-120">**가상 네트워크**.</span><span class="sxs-lookup"><span data-stu-id="374c1-120">**Virtual network**.</span></span> <span data-ttu-id="374c1-121">기본적으로 AKS는 에이전트 노드를 배포할 가상 네트워크를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-121">By default, AKS creates a virtual network to deploy the agent nodes into.</span></span> <span data-ttu-id="374c1-122">고급 시나리오에서는 먼저 가상 네트워크를 만들어서 서브넷 구성 방법, 온-프레미스 연결, IP 주소 지정 등을 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-122">For more advanced scenarios, you can create the virtual network first, which lets you control things like how the subnets are configured, on-premises connectivity, and IP addressing.</span></span> <span data-ttu-id="374c1-123">자세한 내용은 [AKS(Azure Kubernetes Service)에서 고급 네트워킹 구성](/azure/aks/configure-advanced-networking)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="374c1-123">For more information, see [Configure advanced networking in Azure Kubernetes Service (AKS)](/azure/aks/configure-advanced-networking).</span></span>

<span data-ttu-id="374c1-124">**수신**.</span><span class="sxs-lookup"><span data-stu-id="374c1-124">**Ingress**.</span></span> <span data-ttu-id="374c1-125">수신은 클러스터 내부의 서비스에 대한 HTTP(S) 경로를 공개합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-125">An ingress exposes HTTP(S) routes to services inside the cluster.</span></span> <span data-ttu-id="374c1-126">자세한 내용은 아래의 [API 게이트웨이](#api-gateway)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="374c1-126">For more information, see the section [API Gateway](#api-gateway) below.</span></span>

<span data-ttu-id="374c1-127">**외부 데이터 저장소**.</span><span class="sxs-lookup"><span data-stu-id="374c1-127">**External data stores**.</span></span> <span data-ttu-id="374c1-128">마이크로 서비스는 일반적으로 상태 비저장이며 Azure SQL Database 또는 Cosmos DB 같은 외부 데이터 저장소에 상태를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-128">Microservices are typically stateless and write state to external data stores, such as Azure SQL Database or Cosmos DB.</span></span>

<span data-ttu-id="374c1-129">**Azure Active Directory**</span><span class="sxs-lookup"><span data-stu-id="374c1-129">**Azure Active Directory**.</span></span> <span data-ttu-id="374c1-130">AKS는 Azure AD(Azure Active Directory) ID를 사용하여 Azure 부하 분산 장치와 같은 다른 Azure 리소스를 만들고 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-130">AKS uses an Azure Active Directory (Azure AD) identity to create and manage other Azure resources such as Azure load balancers.</span></span> <span data-ttu-id="374c1-131">클라이언트 애플리케이션의 사용자 인증에도 Azure AD를 권장합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-131">Azure AD is also recommended for user authentication in client applications.</span></span>

<span data-ttu-id="374c1-132">**Azure Container Registry**.</span><span class="sxs-lookup"><span data-stu-id="374c1-132">**Azure Container Registry**.</span></span> <span data-ttu-id="374c1-133">Container Registry를 사용하여 클러스터에 배포되는 비공개 Docker 이미지를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-133">Use Container Registry to store private Docker images, which are deployed to the cluster.</span></span> <span data-ttu-id="374c1-134">AKS는 Azure AD ID를 사용하여 Container Registry를 인증할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-134">AKS can authenticate with Container Registry using its Azure AD identity.</span></span> <span data-ttu-id="374c1-135">AKS는 Azure Container Registry가 필요 없습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-135">Note that AKS does not require Azure Container Registry.</span></span> <span data-ttu-id="374c1-136">Docker 허브 같은 다른 컨테이너 레지스트리를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-136">You can use other container registries, such as Docker Hub.</span></span>

<span data-ttu-id="374c1-137">**Azure Pipelines**.</span><span class="sxs-lookup"><span data-stu-id="374c1-137">**Azure Pipelines**.</span></span> <span data-ttu-id="374c1-138">파이프라인은 Azure DevOps 서비스의 일부이며 자동화된 빌드, 테스트 및 배포를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-138">Pipelines is part of Azure DevOps Services and runs automated builds, tests, and deployments.</span></span> <span data-ttu-id="374c1-139">Jenkins 같은 타사 CI/CD 솔루션도 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-139">You can also use third-party CI/CD solutions such as Jenkins.</span></span> 

<span data-ttu-id="374c1-140">**Helm**.</span><span class="sxs-lookup"><span data-stu-id="374c1-140">**Helm**.</span></span> <span data-ttu-id="374c1-141">Helm은 Kubernetes용 패키지 관리자로써 Kubernetes 개체를 게시, 배포, 버전 관리 및 업데이트 가능한 단일 단위로 번들링하는 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-141">Helm is as a package manager for Kubernetes &mdash; a way to bundle Kubernetes objects into a single unit that you can publish, deploy, version, and update.</span></span>

<span data-ttu-id="374c1-142">**Azure Monitor**</span><span class="sxs-lookup"><span data-stu-id="374c1-142">**Azure Monitor**.</span></span> <span data-ttu-id="374c1-143">Azure Monitor는 솔루션 및 애플리케이션 원격 분석의 Azure 서비스에 대한 플랫폼 메트릭을 포함하여 메트릭 및 로그를 수집 및 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-143">Azure Monitor collects and stores metrics and logs, including platform metrics for the Azure services in the solution and application telemetry.</span></span> <span data-ttu-id="374c1-144">이 데이터를 사용하여 애플리케이션을 모니터링하고, 경고 및 대시보드를 설정하고, 오류의 근본 원인을 분석할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-144">Use this data to monitor the application, set up alerts and dashboards, and perform root cause analysis of failures.</span></span> <span data-ttu-id="374c1-145">Azure Monitor는 AKS와 통합되어 컨트롤러, 노드, 컨테이너의 메트릭뿐 아니라 컨테이너 로그와 마스터 노드 로그도 수집합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-145">Azure Monitor integrates with AKS to collect metrics from controllers, nodes, and containers, as well as container logs and master node logs.</span></span>

## <a name="design-considerations"></a><span data-ttu-id="374c1-146">디자인 고려 사항</span><span class="sxs-lookup"><span data-stu-id="374c1-146">Design considerations</span></span>

<span data-ttu-id="374c1-147">AKS에서 실행되는 다른 워크로드에 적용되는 여러 권장 모범 사례가 있지만, 이 참조 아키텍처는 마이크로 서비스 아키텍처에 집중되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-147">This reference architecture is focused on microservices architectures, although many of the recommended practices will apply to other workloads running on AKS.</span></span>

### <a name="microservices"></a><span data-ttu-id="374c1-148">마이크로 서비스</span><span class="sxs-lookup"><span data-stu-id="374c1-148">Microservices</span></span>

<span data-ttu-id="374c1-149">Kubernetes 서비스 개체는 Kubernetes에서 마이크로 서비스를 모델링하는 자연스러운 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-149">The Kubernetes Service object is a natural way to model microservices in Kubernetes.</span></span> <span data-ttu-id="374c1-150">마이크로 서비스는 느슨하게 결합되며, 독립적으로 배포 가능한 코드 단위입니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-150">A microservice is a loosely coupled, independently deployable unit of code.</span></span> <span data-ttu-id="374c1-151">마이크로 서비스는 일반적으로 잘 정의된 API를 통해 통신하며, 특정 형태의 서비스 검색을 통해 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-151">Microservices typically communicate through well-defined APIs, and are discoverable through some form of service discovery.</span></span> <span data-ttu-id="374c1-152">Kubernetes 서비스 개체는 이러한 요구 사항을 충족하는 기능 세트를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-152">The Kubernetes Service object provides a set of capabilities that match these requirements:</span></span>

- <span data-ttu-id="374c1-153">IP 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-153">IP address.</span></span> <span data-ttu-id="374c1-154">서비스 개체는 Pod 그룹(ReplicaSet)에 대한 고정 내부 IP 주소를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-154">The Service object provides a static internal IP address for a group of pods (ReplicaSet).</span></span> <span data-ttu-id="374c1-155">Pod가 만들어지거나 이동되면 이 내부 IP 주소에서 항상 서비스에 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-155">As pods are created or moved around, the service is always reachable at this internal IP address.</span></span>

- <span data-ttu-id="374c1-156">부하 분산 -</span><span class="sxs-lookup"><span data-stu-id="374c1-156">Load balancing.</span></span> <span data-ttu-id="374c1-157">서비스의 IP 주소로 전송된 트래픽은 Pod에 부하 분산됩니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-157">Traffic sent to the service's IP address is load balanced to the pods.</span></span> 

- <span data-ttu-id="374c1-158">서비스 검색.</span><span class="sxs-lookup"><span data-stu-id="374c1-158">Service discovery.</span></span> <span data-ttu-id="374c1-159">서비스는 Kubernetes DNS 서비스를 통해 내부 DNS 항목에 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-159">Services are assigned internal DNS entries by the Kubernetes DNS service.</span></span> <span data-ttu-id="374c1-160">즉, API 게이트웨이가 DNS 이름을 사용하여 백 엔드 서비스를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-160">That means the API gateway can call a backend service using the DNS name.</span></span> <span data-ttu-id="374c1-161">서비스 간 통신에도 동일한 메커니즘을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-161">The same mechanism can be used for service-to-service communication.</span></span> <span data-ttu-id="374c1-162">DNS 항목은 네임스페이스를 기준으로 구성되므로 네임스페이스가 제한된 컨텍스트에 해당하는 경우 서비스의 DNS 이름이 자연스럽게 애플리케이션 도메인에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-162">The DNS entries are organized by namespace, so if your namespaces correspond to bounded contexts, then the DNS name for a service will map naturally to the application domain.</span></span>

<span data-ttu-id="374c1-163">다음 다이어그램은 서비스와 Pod 간의 개념적 관계를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-163">The following diagram show the conceptual relation between services and pods.</span></span> <span data-ttu-id="374c1-164">엔드포인트 IP 주소 및 포트에 대한 실제 매핑은 Kubernetes 네트워크 프록시인 kube-proxy를 통해 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-164">The actual mapping to endpoint IP addresses and ports is done by kube-proxy, the Kubernetes network proxy.</span></span>

![서비스 및 Pod](./_images/aks-services.png)

### <a name="api-gateway"></a><span data-ttu-id="374c1-166">API Gateway</span><span class="sxs-lookup"><span data-stu-id="374c1-166">API Gateway</span></span>

<span data-ttu-id="374c1-167">*API 게이트웨이*는 외부 클라이언트와 마이크로 서비스 사이에 위치하는 게이트웨이입니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-167">An *API gateway* is a gateway that sits between external clients and the microservices.</span></span> <span data-ttu-id="374c1-168">역방향 프록시로 작동하면서 클라이언트에서 마이크로 서비스로 요청을 라우팅합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-168">It acts as a reverse proxy, routing requests from clients to microservices.</span></span> <span data-ttu-id="374c1-169">또한 인증, SSL 종료 및 속도 제한과 같은 다양한 교차 작업을 수행할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-169">It may also perform various cross-cutting tasks such as authentication, SSL termination, and rate limiting.</span></span> 

<span data-ttu-id="374c1-170">게이트웨이에서 제공하는 기능을 다음과 같이 그룹화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-170">Functionality provided by a gateway can be grouped as follows:</span></span>

- <span data-ttu-id="374c1-171">[게이트웨이 라우팅](../../patterns/gateway-routing.md): 클라이언트 요청을 적절한 백 엔드 서비스로 라우팅.</span><span class="sxs-lookup"><span data-stu-id="374c1-171">[Gateway Routing](../../patterns/gateway-routing.md): Routing client requests to the right backend services.</span></span> <span data-ttu-id="374c1-172">이렇게 하여 클라이언트용 단일 엔드포인트를 제공하고 서비스에서 클라이언트를 분리하는 데 도움을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-172">This provides a single endpoint for clients, and helps to decouple clients from services.</span></span>

- <span data-ttu-id="374c1-173">[게이트웨이 집계](../../patterns/gateway-aggregation.md): 여러 요청을 단일 요청으로 집계하여 클라이언트와 백 엔드 사이의 전송량을 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-173">[Gateway Aggregation](../../patterns/gateway-aggregation.md): Aggregation of multiple requests into a single request, to reduce chattiness between the client and the backend.</span></span>

- <span data-ttu-id="374c1-174">[게이트웨이 오프로딩](../../patterns/gateway-offloading.md).</span><span class="sxs-lookup"><span data-stu-id="374c1-174">[Gateway Offloading](../../patterns/gateway-offloading.md).</span></span> <span data-ttu-id="374c1-175">게이트웨이는 백 엔드 서비스에서 SSL 종료, 인증, IP 허용 목록 또는 클라이언트 속도 제한(제한) 등의 기능을 오프로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-175">A gateway can offload functionality from the backend services, such as SSL termination, authentication, IP whitelisting, or client rate limiting (throttling).</span></span>

<span data-ttu-id="374c1-176">API 게이트웨이는 일반적인 [마이크로 서비스 설계 패턴](https://microservices.io/patterns/apigateway.html)입니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-176">API gateways are a general [microservices design pattern](https://microservices.io/patterns/apigateway.html).</span></span> <span data-ttu-id="374c1-177">다양한 기술을 사용하여 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-177">They can be implemented using a number of different technologies.</span></span> <span data-ttu-id="374c1-178">아마도 가장 일반적인 구현은 에지 라우터 또는 Nginx, HAProxy, Traefik 같은 역방향 프록시를 클러스터 내부에 배포하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-178">Probably the most common implementation is to deploy an edge router or reverse proxy, such as Nginx, HAProxy, or Traefik, inside the cluster.</span></span> 

<span data-ttu-id="374c1-179">그 외에도 다음과 같은 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-179">Other options include:</span></span>

- <span data-ttu-id="374c1-180">Azure Application Gateway 및/또는 Azure API-Management - 둘 다 클러스터 외부에 상주하는 관리형 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-180">Azure Application Gateway and/or Azure API-Management, which are both managed services that reside outside of the cluster.</span></span> <span data-ttu-id="374c1-181">Application Gateway 수신 컨트롤러는 현재 베타 버전입니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-181">An Application Gateway Ingress Controller is currently in beta.</span></span>

- <span data-ttu-id="374c1-182">Azure Functions 프록시.</span><span class="sxs-lookup"><span data-stu-id="374c1-182">Azure Functions Proxies.</span></span> <span data-ttu-id="374c1-183">프록시는 URL을 기반으로 요청 및 응답을 수정하고 요청을 라우팅할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-183">Proxies can modify requests and responses and route requests based on URL.</span></span>

<span data-ttu-id="374c1-184">리소스 종류 중 Kubernetes **수신**은 프록시 서버의 구성 설정을 추상화합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-184">The Kubernetes **Ingress** resource type abstracts the configuration settings for a proxy server.</span></span> <span data-ttu-id="374c1-185">수신 컨트롤러와 함께 작동하여 수신의 기본 구현을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-185">It works in conjunction with an ingress controller, which provides the underlying implementation of the Ingress.</span></span> <span data-ttu-id="374c1-186">Nginx, HAProxy, Traefik 및 Application Gateway(미리 보기)용 수신 컨트롤러가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-186">There are ingress controllers for Nginx, HAProxy, Traefik, and Application Gateway (preview), among others.</span></span>

<span data-ttu-id="374c1-187">수신 컨트롤러는 프록시 서버 구성을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-187">The ingress controller handles configuring the proxy server.</span></span> <span data-ttu-id="374c1-188">종종 복잡한 구성 파일이 필요하며, 전문가가 아니면 튜닝하기 쉽지 않으므로 수신 컨트롤러를 사용하면 편리합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-188">Often these require complex configuration files, which can be hard to tune if you aren't an expert, so the ingress controller is a nice abstraction.</span></span> <span data-ttu-id="374c1-189">또한 수신 컨트롤러는 Kubernetes API에 액세스할 수 있으므로 라우팅 및 부하 분산에 대한 합리적인 의사 결정을 내릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-189">In addition, the Ingress Controller has access to the Kubernetes API, so it can make intelligent decisions about routing and load balancing.</span></span> <span data-ttu-id="374c1-190">예를 들어 Nginx 수신 컨트롤러는 kube-proxy 네트워크 프록시를 우회합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-190">For example, the Nginx ingress controller bypasses the kube-proxy network proxy.</span></span>

<span data-ttu-id="374c1-191">한편, 설정을 완전하게 제어해야 하는 경우 이 추상화를 우회하고 프록시 서버를 수동으로 구성하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-191">On the other hand, if you need complete control over the settings, you may want to bypass this abstraction and configure the proxy server manually.</span></span> 

<span data-ttu-id="374c1-192">역방향 프록시 서버는 잠재적인 병목 상태 또는 단일 실패 지점이므로 고가용성을 위해 항상 두 개 이상의 복제본을 배포해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-192">A reverse proxy server is a potential bottleneck or single point of failure, so always deploy at least two replicas for high availability.</span></span>

### <a name="data-storage"></a><span data-ttu-id="374c1-193">데이터 저장소</span><span class="sxs-lookup"><span data-stu-id="374c1-193">Data storage</span></span>

<span data-ttu-id="374c1-194">마이크로 서비스 아키텍처에서는 서비스가 데이터 스토리지를 공유하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-194">In a microservices architecture, services should not share data storage.</span></span> <span data-ttu-id="374c1-195">서비스 간에 숨겨진 종속성이 없도록 각 서비스는 별도의 논리 스토리지에 자체 비공개 데이터를 소유해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-195">Each service should own its own private data in a separate logical storage, to avoid hidden dependencies among services.</span></span> <span data-ttu-id="374c1-196">여러 서비스가 동일한 기본 데이터 스키마를 공유할 때 발생할 수 있는 서비스 간의 의도치 않은 결합을 방지하는 것이 목적입니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-196">The reason is to avoid unintentional coupling between services, which can happen when services share the same underlying data schemas.</span></span> <span data-ttu-id="374c1-197">또한 서비스에서 자체 데이터 저장소를 관리하는 경우 특정 요구 사항에 적합한 데이터 저장소를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-197">Also, when services manage their own data stores, they can use the right data store for their particular requirements.</span></span> <span data-ttu-id="374c1-198">자세한 내용은 [마이크로 서비스 설계: 데이터 고려 사항](/azure/architecture/microservices/data-considerations)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="374c1-198">For more information, see [Designing microservices: Data considerations](/azure/architecture/microservices/data-considerations).</span></span>

<span data-ttu-id="374c1-199">로컬 클러스터 스토리지에 영구 데이터를 저장하지 마세요. 이렇게 하면 데이터가 노드에 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-199">Avoid storing persistent data in local cluster storage, because that ties the data to the node.</span></span> <span data-ttu-id="374c1-200">대신,</span><span class="sxs-lookup"><span data-stu-id="374c1-200">Instead,</span></span> 

- <span data-ttu-id="374c1-201">Azure SQL Database나 Cosmos DB 같은 외부 서비스를 사용하거나 *또는*</span><span class="sxs-lookup"><span data-stu-id="374c1-201">Use an external service such as Azure SQL Database or Cosmos DB, *or*</span></span>

- <span data-ttu-id="374c1-202">Azure Disks 또는 Azure Files를 사용하여 영구 볼륨을 탑재합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-202">Mount a persistent volume using Azure Disks or Azure Files.</span></span> <span data-ttu-id="374c1-203">동일한 볼륨을 여러 Pod가 공유해야 하는 경우 Azure Files를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-203">Use Azure Files if the same volume needs to be shared by multiple pods.</span></span>

### <a name="namespaces"></a><span data-ttu-id="374c1-204">네임스페이스</span><span class="sxs-lookup"><span data-stu-id="374c1-204">Namespaces</span></span>

<span data-ttu-id="374c1-205">네임스페이스를 사용하여 클러스터 내에서 서비스 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-205">Use namespaces to organize services within the cluster.</span></span> <span data-ttu-id="374c1-206">Kubernetes 클러스터의 모든 개체는 네임스페이스에 속합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-206">Every object in a Kubernetes cluster belongs to a namespace.</span></span> <span data-ttu-id="374c1-207">기본적으로 새 개체를 만들면 해당 개체는 `default` 네임스페이스로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-207">By default, when you create a new object, it goes into the `default` namespace.</span></span> <span data-ttu-id="374c1-208">하지만 클러스터의 리소스를 구성하는 데 도움이 되도록 보다 구체적인 이름의 네임스페이스를 만드는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-208">But it's a good practice to create namespaces that are more descriptive to help organize the resources in the cluster.</span></span>

<span data-ttu-id="374c1-209">첫째, 네임스페이스는 이름 충돌을 방지하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-209">First, namespaces help prevent naming collisions.</span></span> <span data-ttu-id="374c1-210">여러 팀이 동일한 클러스터에 수백 개의 마이크로 서비스를 배포하고 모든 마이크로 서비스가 동일한 네임스페이스로 이동하면 관리가 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-210">When multiple teams deploy microservices into the same cluster, with possibly hundreds of microservices, it gets hard to manage if they all go into the same namespace.</span></span> <span data-ttu-id="374c1-211">또한 네임스페이스를 통해 다음과 같은 일을 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-211">In addition, namespaces allow you to:</span></span>

- <span data-ttu-id="374c1-212">네임스페이스에 할당된 Pod의 전체 세트가 해당 네임스페이스의 리소스 할당량을 초과할 수 없도록 네임스페이스에 리소스 제약 조건을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-212">Apply resource constraints to a namespace, so that the total set of pods assigned to that namespace cannot exceed the resource quota of the namespace.</span></span>

- <span data-ttu-id="374c1-213">네임스페이스 수준에서 RBAC 및 보안 정책을 비롯한 정책을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-213">Apply policies at the namespace level, including RBAC and security policies.</span></span>

<span data-ttu-id="374c1-214">마이크로 서비스 아키텍처의 경우 마이크로 서비스를 제한된 컨텍스트로 구성하고 각각의 제한된 컨텍스트에 대한 네임스페이스를 만드는 방안을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-214">For a microservices architecture, considering organizing the microservices into bounded contexts, and creating namespaces for each bounded context.</span></span> <span data-ttu-id="374c1-215">예를 들어 제한된 컨텍스트 "주문 이행"과 관련된 모든 마이크로 서비스가 동일한 네임스페이스로 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-215">For example, all microservices related to the "Order Fulfillment" bounded context could go into the same namespace.</span></span> <span data-ttu-id="374c1-216">또는 개발 팀마다 네임스페이스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-216">Alternatively, create a namespace for each development team.</span></span>

<span data-ttu-id="374c1-217">각 개발 팀의 자체 별도 네임스페이스에 유틸리티 서비스를 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-217">Place utility services into their own separate namespace.</span></span> <span data-ttu-id="374c1-218">예를 들어 클러스터 모니터링용 Elasticsearch 또는 Prometheus를 배포하거나 Helm용 Tiller를 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-218">For example, you might deploy Elasticsearch or Prometheus for cluster monitoring, or Tiller for Helm.</span></span>

## <a name="scalability-considerations"></a><span data-ttu-id="374c1-219">확장성 고려 사항</span><span class="sxs-lookup"><span data-stu-id="374c1-219">Scalability considerations</span></span>

<span data-ttu-id="374c1-220">Kubernetes는 다음과 같은 두 수준에서 스케일 아웃을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-220">Kubernetes supports scale-out at two levels:</span></span>

- <span data-ttu-id="374c1-221">배포에 할당된 Pod 수를 조정합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-221">Scale the number of pods allocated to a deployment.</span></span>
- <span data-ttu-id="374c1-222">클러스터의 노드 수를 조정하여 클러스터에서 사용할 수 있는 총 계산 리소스를 늘립니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-222">Scale the nodes in the cluster, to increase the total compute resources available to the cluster.</span></span>

<span data-ttu-id="374c1-223">Pod 및 노드를 수동으로 스케일 아웃할 수 있지만, 고부하 시 서비스 리소스가 부족하지 않도록 자동 크기 조정을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-223">Although you can scale out pods and nodes manually, we recommend using autoscaling, to minimize the chance that services will become resource starved under high load.</span></span> <span data-ttu-id="374c1-224">자동 크기 조정 전략은 Pod와 노드를 모두 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-224">An autoscaling strategy must take both pods and nodes into account.</span></span> <span data-ttu-id="374c1-225">Pod만 스케일 아웃하면 결국 노드의 리소스 제한에 도달하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-225">If you just scale out the pods, eventually you will reach the resource limits of the nodes.</span></span> 

### <a name="pod-autoscaling"></a><span data-ttu-id="374c1-226">Pod 자동 크기 조정</span><span class="sxs-lookup"><span data-stu-id="374c1-226">Pod autoscaling</span></span>

<span data-ttu-id="374c1-227">HPA(Horizontal Pod Autoscaler)는 관찰된 CPU, 메모리 또는 사용자 지정 메트릭에 따라 Pod를 조정합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-227">The Horizontal Pod Autoscaler (HPA) scales pods based on observed CPU, memory, or custom metrics.</span></span> <span data-ttu-id="374c1-228">수평 Pod 크기 조정을 구성하려면 목표 메트릭(예: CPU의 70%)과 최소 및 최대 복제본 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-228">To configure horizontal pod scaling, you specify a target metric (for example, 70% of CPU), and the minimum and maximum number of replicas.</span></span> <span data-ttu-id="374c1-229">이러한 수치를 제공하려면 서비스 부하 테스트를 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-229">You should load test your services to derive these numbers.</span></span>

<span data-ttu-id="374c1-230">자동 크기 조정의 부작용으로 스케일 아웃 및 스케일 인 이벤트가 발생할 때 Pod가 좀 더 자주 생성 또는 제거될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-230">A side-effect of autoscaling is that pods may be created or evicted more frequently, as scale-out and scale-in events happen.</span></span> <span data-ttu-id="374c1-231">이러한 부작용을 완화하려면:</span><span class="sxs-lookup"><span data-stu-id="374c1-231">To mitigate the effects of this:</span></span>

- <span data-ttu-id="374c1-232">새 Pod가 트래픽을 허용할 준비가 완료되면 준비 상태 프로브를 사용하여 Kubernetes에 그 사실을 알립니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-232">Use readiness probes to let Kubernetes know when a new pod is ready to accept traffic.</span></span>
- <span data-ttu-id="374c1-233">Pod 중단 예산을 사용하여 서비스에서 한 번에 제거할 수 있는 Pod 수를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-233">Use pod disruption budgets to limit how many pods can be evicted from a service at a time.</span></span>

### <a name="cluster-autoscaling"></a><span data-ttu-id="374c1-234">클러스터 자동 크기 조정</span><span class="sxs-lookup"><span data-stu-id="374c1-234">Cluster autoscaling</span></span>

<span data-ttu-id="374c1-235">클러스터 자동 크기 조정기는 노드 수를 자동으로 조정합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-235">The cluster autoscaler scales the number of nodes.</span></span> <span data-ttu-id="374c1-236">리소스 제약으로 인해 Pod를 예약할 수 없으면 클러스터 자동 크기 조정기가 추가 노드를 프로비전합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-236">If pods can't be scheduled because of resource constraints, the cluster autoscaler will provision more nodes.</span></span>  <span data-ttu-id="374c1-237">(참고: AKS와 클러스터 자동 크기 조정기의 통합은 현재 미리 보기입니다.)</span><span class="sxs-lookup"><span data-stu-id="374c1-237">(Note: Integration between AKS and the cluster autoscaler is currently in preview.)</span></span>

<span data-ttu-id="374c1-238">HPA는 사용된 실제 리소스 또는 실행 중인 Pod의 다른 메트릭을 살펴보는 반면, 클러스터 자동 크기 조정기는 아직 예약되지 않은 Pod의 노드를 프로비전합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-238">Whereas HPA looks at actual resources consumed or other metrics from running pods, the cluster autoscaler is provisioning nodes for pods that aren't scheduled yet.</span></span> <span data-ttu-id="374c1-239">따라서 배포를 위한 Kubernetes Pod 사양에 지정된 대로, 요청된 리소스를 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-239">Therefore, it looks at the requested resources, as specified in the Kubernetes pod spec for a deployment.</span></span> <span data-ttu-id="374c1-240">부하 테스트를 사용하여 이러한 값을 미세 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-240">Use load testing to fine-tune these values.</span></span>

<span data-ttu-id="374c1-241">클러스터를 만든 후에는 VM 크기를 변경할 수 없으므로 클러스터를 만들 때 에이전트 노드에 적절한 VM 크기를 선택하려면 초기 용량 계획을 세워야 합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-241">You can't change the VM size after you create the cluster, so you should do some initial capacity planning to choose an appropriate VM size for the agent nodes when you create the cluster.</span></span> 

## <a name="availability-considerations"></a><span data-ttu-id="374c1-242">가용성 고려 사항</span><span class="sxs-lookup"><span data-stu-id="374c1-242">Availability considerations</span></span>

### <a name="health-probes"></a><span data-ttu-id="374c1-243">상태 프로브</span><span class="sxs-lookup"><span data-stu-id="374c1-243">Health probes</span></span>

<span data-ttu-id="374c1-244">Kubernetes는 Pod에서 공개할 수 있는 두 가지 유형의 상태 프로브를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-244">Kubernetes defines two types of health probe that a pod can expose:</span></span>

- <span data-ttu-id="374c1-245">준비 상태 프로브: Pod가 요청을 수락할 준비가 완료되었는지 여부를 Kubernetes에 알려줍니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-245">Readiness probe: Tells Kubernetes whether the pod is ready to accept requests.</span></span>

- <span data-ttu-id="374c1-246">활동성 프로브: Pod를 제거하고 새 인스턴스를 시작해야 하는지 여부를 Kubernetes에 알려줍니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-246">Liveness probe: Tells Kubernetes whether a pod should be removed and a new instance started.</span></span>

<span data-ttu-id="374c1-247">프로브에 대해 생각할 때 Kubernetes에서 서비스가 작동하는 방식을 떠올리면 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-247">When thinking about probes, it's useful to recall how a service works in Kubernetes.</span></span> <span data-ttu-id="374c1-248">서비스에는 Pod 세트(0개 이상)와 일치하는 레이블 선택기가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-248">A service has a label selector that matches a set of (zero or more) pods.</span></span> <span data-ttu-id="374c1-249">Kubernetes는 선택기와 일치하는 Pod에 트래픽을 부하 분산합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-249">Kubernetes load balances traffic to the pods that match the selector.</span></span> <span data-ttu-id="374c1-250">성공적으로 시작되고 상태가 정상인 Pod만 트래픽을 수신합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-250">Only pods that started successfully and are healthy receive traffic.</span></span> <span data-ttu-id="374c1-251">컨테이너가 충돌하면 Kubernetes는 Pod를 종료하고 대체 Pod를 예약합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-251">If a container crashes, Kubernetes kills the pod and schedules a replacement.</span></span>

<span data-ttu-id="374c1-252">Pod가 성공적으로 시작되더라도 트래픽을 받을 준비가 완료되지 않은 경우가 가끔 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-252">Sometimes, a pod may not be ready to receive traffic, even though the pod started successfully.</span></span> <span data-ttu-id="374c1-253">컨테이너에서 실행 중인 애플리케이션이 메모리에 무언가를 로드하거나 구성 데이터를 읽는 초기화 작업을 예로 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-253">For example, there may be initialization tasks, where the application running in the container loads things into memory or reads configuration data.</span></span> <span data-ttu-id="374c1-254">Pod가 정상이지만 트래픽을 받을 준비가 완료되지 않았음을 나타내려면 준비 상태 프로브를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-254">To indicate that a pod is healthy but not ready to receive traffic, define a readiness probe.</span></span> 

<span data-ttu-id="374c1-255">활동성 프로브는 Pod가 여전히 실행 중이지만 정상 상태가 아니고 재활용해야 하는 상황을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-255">Liveness probes handle the case where a pod is still running, but is unhealthy and should be recycled.</span></span> <span data-ttu-id="374c1-256">예를 들어 HTTP 요청을 처리하는 컨테이너가 어떤 이유로 중단되었다고 가정해 봅시다.</span><span class="sxs-lookup"><span data-stu-id="374c1-256">For example, suppose that a container is serving HTTP requests but hangs for some reason.</span></span> <span data-ttu-id="374c1-257">컨테이너는 충돌을 일으키지는 않지만 모든 요청 처리를 중단했습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-257">The container doesn't crash, but it has stopped serving any requests.</span></span> <span data-ttu-id="374c1-258">HTTP 활동성 프로브를 정의하면 프로브가 응답을 중지할 경우 Kubernetes에 Pod를 다시 시작하라고 알립니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-258">If you define an HTTP liveness probe, the probe will stop responding and that informs Kubernetes to restart the pod.</span></span>

<span data-ttu-id="374c1-259">프로브를 설계할 때 몇 가지 사항을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-259">Here are some considerations when designing probes:</span></span>

- <span data-ttu-id="374c1-260">코드의 시작 시간이 긴 경우 시작이 완료되기 전에 활동성 프로브가 실패를 보고할 위험이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-260">If your code has a long startup time, there is a danger that a liveness probe will report failure before the startup completes.</span></span> <span data-ttu-id="374c1-261">이를 방지하려면 프로브 시작을 지연하는 initialDelaySeconds 설정을 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="374c1-261">To prevent this, use the initialDelaySeconds setting, which delays the probe from starting.</span></span>

- <span data-ttu-id="374c1-262">Pod를 다시 시작하면 정상 상태로 복원되지 않는 한, 활동성 프로브는 도움이 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-262">A liveness probe doesn't help unless restarting the pod is likely to restore it to a healthy state.</span></span> <span data-ttu-id="374c1-263">활동성 프로브를 사용하여 메모리 누수 또는 예기치 않은 교착 상태를 완화할 수 있지만, 즉시 다시 실패하는 Pod를 다시 시작해 봐야 아무 소용이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-263">You can use a liveness probe to mitigate against memory leaks or unexpected deadlocks, but there's no point in restarting a pod that's going to immediately fail again.</span></span>

- <span data-ttu-id="374c1-264">때때로 준비 상태 프로브는 종속 서비스를 확인하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-264">Sometimes readiness probes are used to check dependent services.</span></span> <span data-ttu-id="374c1-265">예를 들어 Pod가 데이터베이스에 종속된 경우 활동성 프로브가 데이터베이스 연결을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-265">For example, if a pod has a dependency on a database, the liveness probe might check the database connection.</span></span> <span data-ttu-id="374c1-266">그러나 이 방법은 예기치 않은 문제를 일으킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-266">However, this approach can create unexpected problems.</span></span> <span data-ttu-id="374c1-267">어떤 이유로 외부 서비스를 일시적으로 사용할 수 없게 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-267">An external service might be temporarily unavailable for some reason.</span></span> <span data-ttu-id="374c1-268">그러면 서비스의 모든 Pod에 대해 준비 상태 프로브가 실패하고 모든 Pod가 부하 분산에서 제거되므로 연속 실패 업스트림이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-268">That will cause the readiness probe to fail for all the pods in your service, causing all of them to be removed from load balancing, and thus creating cascading failures upstream.</span></span> <span data-ttu-id="374c1-269">서비스가 일시적인 장애로부터 올바르게 복구될 수 있도록 서비스 내에서 재시도 처리를 구현하는 것이 더 좋은 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-269">A better approach is to implement retry handling within your service, so that your service can recover correctly from transient failures.</span></span>

### <a name="resource-constraints"></a><span data-ttu-id="374c1-270">리소스 제약 조건</span><span class="sxs-lookup"><span data-stu-id="374c1-270">Resource constraints</span></span>

<span data-ttu-id="374c1-271">리소스 경합은 서비스의 가용성에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-271">Resource contention can affect the availability of a service.</span></span> <span data-ttu-id="374c1-272">단일 컨테이너가 클러스터 리소스(메모리 및 CPU)를 모두 사용할 수 없도록 컨테이너에 대한 리소스 제약 조건을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-272">Define resource constraints for containers, so that a single container cannot overwhelm the cluster resources (memory and CPU).</span></span> <span data-ttu-id="374c1-273">스레드 또는 네트워크 연결 같은 컨테이너 이외 리소스는 [격벽 패턴](/azure/architecture/patterns/bulkhead)을 사용하여 리소스를 격리하는 방안을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-273">For non-container resources, such as threads or network connections, consider using the [Bulkhead Pattern](/azure/architecture/patterns/bulkhead) to isolate resources.</span></span>

<span data-ttu-id="374c1-274">리소스 할당량을 사용하여 네임스페이스에 허용되는 총 리소스를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-274">Use resource quotas to limit the total resources allowed for a namespace.</span></span> <span data-ttu-id="374c1-275">이렇게 하면 프런트 엔드가 리소스의 백 엔드 서비스를 고갈시킬 수 없으며 그 반대도 마찬가지입니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-275">That way, the front end can't starve the backend services for resources or vice-versa.</span></span>

## <a name="security-considerations"></a><span data-ttu-id="374c1-276">보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="374c1-276">Security considerations</span></span>

### <a name="role-based-access-control-rbac"></a><span data-ttu-id="374c1-277">RBAC(역할 기반 액세스 제어)</span><span class="sxs-lookup"><span data-stu-id="374c1-277">Role based access control (RBAC)</span></span>

<span data-ttu-id="374c1-278">Kubernetes와 Azure 둘 다 RBAC(역할 기반 액세스 제어)에 대한 메커니즘을 갖고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-278">Kubernetes and Azure both have mechanisms for role-based access control (RBAC):</span></span>

- <span data-ttu-id="374c1-279">Azure RBAC는 새 Azure 리소스를 만드는 기능을 포함하여 Azure의 리소스에 대한 액세스를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-279">Azure RBAC controls access to resources in Azure, including the ability to create new Azure resources.</span></span> <span data-ttu-id="374c1-280">사용자, 그룹 또는 서비스 주체에 권한을 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-280">Permissions can be assigned to users, groups, or service principals.</span></span> <span data-ttu-id="374c1-281">(서비스 주체는 애플리케이션에서 사용하는 보안 ID입니다.)</span><span class="sxs-lookup"><span data-stu-id="374c1-281">(A service principal is a security identity used by applications.)</span></span>

- <span data-ttu-id="374c1-282">Kubernetes RBAC는 Kubernetes API 권한을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-282">Kubernetes RBAC controls permissions to the Kubernetes API.</span></span> <span data-ttu-id="374c1-283">예를 들어 Pod 만들기 및 Pod 나열은 RBAC를 통해 사용자에게 권한을 부여(또는 거부)할 수 있는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-283">For example, creating pods and listing pods are actions that can be authorized (or denied) to a user through RBAC.</span></span> <span data-ttu-id="374c1-284">사용자에게 Kubernetes 권한을 할당하려면 *역할* 및 *역할 바인딩*을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-284">To assign Kubernetes permissions to users, you create *roles* and *role bindings*:</span></span>

  - <span data-ttu-id="374c1-285">역할은 네임스페이스 내에서 적용되는 권한 세트입니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-285">A Role is a set of permissions that apply within a namespace.</span></span> <span data-ttu-id="374c1-286">권한은 리소스(Pod, 배포 등)에 대한 동사(가져오기, 업데이트, 만들기, 삭제)로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-286">Permissions are defined as verbs (get, update, create, delete) on resources (pods, deployments, etc.).</span></span>

  - <span data-ttu-id="374c1-287">RoleBinding은 사용자 또는 그룹을 역할에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-287">A RoleBinding assigns users or groups to a Role.</span></span>

  - <span data-ttu-id="374c1-288">역할과 비슷하지만 모든 네임스페이스에서 전체 클러스터에 적용되는 ClusterRole 개체도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-288">There is also a ClusterRole object, which is like a Role but applies to the entire cluster, across all namespaces.</span></span> <span data-ttu-id="374c1-289">사용자 또는 그룹을 ClusterRole에 할당하려면 ClusterRoleBinding를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-289">To assign users or groups to a ClusterRole, create a ClusterRoleBinding.</span></span>

<span data-ttu-id="374c1-290">AKS는 이러한 두 가지 RBAC 메커니즘을 통합합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-290">AKS integrates these two RBAC mechanisms.</span></span> <span data-ttu-id="374c1-291">AKS 클러스터를 만들 때 사용자 인증에 Azure AD를 사용하도록 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-291">When you create an AKS cluster, you can configure it to use Azure AD for user authentication.</span></span> <span data-ttu-id="374c1-292">이렇게 설정하는 방법에 대한 자세한 내용은 [Azure Kubernetes Service와 Azure Active Directory 통합](/azure/aks/aad-integration)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="374c1-292">For details on how to set this up, see [Integrate Azure Active Directory with Azure Kubernetes Service](/azure/aks/aad-integration).</span></span>

<span data-ttu-id="374c1-293">이 구성을 마치면 Kubernetes API에 액세스하려는 사용자는(예: kubectl를 통해) Azure AD 자격 증명을 사용하여 로그인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-293">Once this is configured, a user who wants to access the Kubernetes API (for example, through kubectl) must sign in using their Azure AD credentials.</span></span>

<span data-ttu-id="374c1-294">기본적으로 Azure AD 사용자는 클러스터에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-294">By default, an Azure AD user has no access to the cluster.</span></span> <span data-ttu-id="374c1-295">액세스 권한을 부여하려면 클러스터 관리자는 Azure AD 사용자 또는 그룹을 참조하는 RoleBindings를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-295">To grant access, the cluster administrator creates RoleBindings that refer to Azure AD users or groups.</span></span> <span data-ttu-id="374c1-296">사용자가 특정 작업에 대한 권한이 없는 경우 해당 작업이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-296">If a user doesn't have permissions for a particular operation, it will fail.</span></span>

<span data-ttu-id="374c1-297">사용자가 기본적으로 액세스 권한이 없다면 클러스터 관리자는 어떻게 역할 바인딩을 만드는 권한을 갖게 되는 걸까요?</span><span class="sxs-lookup"><span data-stu-id="374c1-297">If users have no access by default, how does the cluster admin have permission to create the role bindings in the first place?</span></span> <span data-ttu-id="374c1-298">AKS 클러스터에는 Kubernetes API 서버를 호출하는 두 가지 자격 증명이 있는데, 하나는 클러스터 사용자이고 다른 하나는 클러스터 관리자입니다. 클러스터 관리자 자격 증명은 클러스터에 대한 전체 액세스 권한을 부여합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-298">An AKS cluster actually has two types of credentials for calling the Kubernetes API server: cluster user and cluster admin. The cluster admin credentials grant full access to the cluster.</span></span> <span data-ttu-id="374c1-299">Azure CLI 명령 `az aks get-credentials --admin`은 클러스터 관리자 자격 증명을 다운로드하여 kubeconfig 파일로 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-299">The Azure CLI command `az aks get-credentials --admin` downloads the cluster admin credentials and saves them into your kubeconfig file.</span></span> <span data-ttu-id="374c1-300">클러스터 관리자는 이 kubeconfig 파일을 사용하여 역할 및 역할 바인딩을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-300">The cluster administrator can use this kubeconfig to create roles and role bindings.</span></span>

<span data-ttu-id="374c1-301">클러스터 관리자 자격 증명은 아주 강력하므로 Azure RBAC를 사용하여 액세스를 제한해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-301">Because the cluster admin credentials are so powerful, use Azure RBAC to restrict access to them:</span></span>

- <span data-ttu-id="374c1-302">"Azure Kubernetes 서비스 클러스터 관리자 역할"은 클러스터 관리자 자격 증명을 다운로드하는 권한을 갖고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-302">The "Azure Kubernetes Service Cluster Admin Role" has permission to download the cluster admin credentials.</span></span> <span data-ttu-id="374c1-303">클러스터 관리자에게만 이 역할을 할당해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-303">Only cluster administrators should be assigned to this role.</span></span>

- <span data-ttu-id="374c1-304">"Azure Kubernetes 서비스 클러스터 사용자 역할"은 클러스터 사용자 자격 증명을 다운로드하는 권한을 갖고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-304">The "Azure Kubernetes Service Cluster User Role" has permission to download the cluster user credentials.</span></span> <span data-ttu-id="374c1-305">관리자가 아닌 사용자에게 이 역할을 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-305">Non-admin users can be assigned to this role.</span></span> <span data-ttu-id="374c1-306">이 역할은 클러스터 내부의 Kubernetes 리소스에 대한 특정 권한을 제공하지 않고, 사용자가 API 서버에 연결하는 것만 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-306">This role does not give any particular permissions on Kubernetes resources inside the cluster &mdash; it just allows a user to connect to the API server.</span></span> 

<span data-ttu-id="374c1-307">RBAC 정책을 정의할 때(Kubernetes 및 Azure 둘 다) 조직의 역할에 대해 고민해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-307">When you define your RBAC policies (both Kubernetes and Azure), think about the roles in your organization:</span></span>

- <span data-ttu-id="374c1-308">AKS 클러스터를 생성 또는 삭제하고 관리자 자격 증명을 다운로드할 수 있는 사람은 누구입니까?</span><span class="sxs-lookup"><span data-stu-id="374c1-308">Who can create or delete an AKS cluster and download the admin credentials?</span></span>
- <span data-ttu-id="374c1-309">클러스터를 관리할 수 있는 사람은 누구입니까?</span><span class="sxs-lookup"><span data-stu-id="374c1-309">Who can administer a cluster?</span></span>
- <span data-ttu-id="374c1-310">네임스페이스 내에서 리소스를 만들고 업데이트할 수 있는 사람은 누구입니까?</span><span class="sxs-lookup"><span data-stu-id="374c1-310">Who can create or update resources within a namespace?</span></span>

<span data-ttu-id="374c1-311">ClusterRoles 및 ClusterRoleBindings보다는 역할 및 RoleBindings를 사용하여 네임스페이스별로 Kubernetes RBAC 권한 범위를 지정하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-311">It's a good practice to scope Kubernetes RBAC permissions by namespace, using Roles and RoleBindings, rather than ClusterRoles and ClusterRoleBindings.</span></span>

<span data-ttu-id="374c1-312">마지막으로, AKS 클러스터가 부하 분산 장치, 네트워킹, 스토리지 등의 Azure 리소스를 만들고 관리하려면 어떤 권한이 필요한지 결정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-312">Finally, there is the question of what permissions the AKS cluster has to create and manage Azure resources, such as load balancers, networking, or storage.</span></span> <span data-ttu-id="374c1-313">클러스터는 Azure API에 인증하기 위해 Azure AD 서비스 주체를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-313">To authenticate itself with Azure APIs, the cluster uses an Azure AD service principal.</span></span> <span data-ttu-id="374c1-314">클러스터를 만들 때 서비스 주체를 지정하지 않으면 자동으로 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-314">If you don't specify a service principal when you create the cluster, one is created automatically.</span></span> <span data-ttu-id="374c1-315">하지만 먼저 서비스 주체를 만든 후 최소한의 RBAC 권한을 할당하는 것이 보안상 좋은 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-315">However, it's a good security practice to create the service principal first and assign the minimal RBAC permissions to it.</span></span> <span data-ttu-id="374c1-316">자세한 내용은 [Azure Kubernetes Service를 사용하는 서비스 주체](/azure/aks/kubernetes-service-principal)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="374c1-316">For more information, see [Service principals with Azure Kubernetes Service](/azure/aks/kubernetes-service-principal).</span></span>

### <a name="secrets-management-and-application-credentials"></a><span data-ttu-id="374c1-317">비밀 관리 및 애플리케이션 자격 증명</span><span class="sxs-lookup"><span data-stu-id="374c1-317">Secrets management and application credentials</span></span>

<span data-ttu-id="374c1-318">애플리케이션 및 서비스가 Azure Storage 또는 SQL Database 같은 외부 서비스에 연결할 수 있는 자격 증명이 필요한 경우가 종종 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-318">Applications and services often need credentials that allow them to connect to external services such as Azure Storage or SQL Database.</span></span> <span data-ttu-id="374c1-319">문제는 이러한 자격 증명이 유출되지 않도록 안전하게 보호하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-319">The challenge is to keep these credentials safe and not leak them.</span></span> 

<span data-ttu-id="374c1-320">Azure 리소스의 경우 관리 ID를 사용하는 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-320">For Azure resources, one option is to use managed identities.</span></span> <span data-ttu-id="374c1-321">애플리케이션 또는 서비스가 Azure AD에 ID를 저장하고, 이 ID를 사용하여 Azure 서비스를 인증한다는 것이 관리 ID의 개념입니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-321">The idea of a managed identity is that an application or service has an identity stored in Azure AD, and uses this identity to authenticate with an Azure service.</span></span> <span data-ttu-id="374c1-322">애플리케이션 또는 서비스는 생성한 서비스 주체를 Azure AD에 저장하고, OAuth 2.0 토큰을 사용하여 인증합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-322">The application or service has a Service Principal created for it in Azure AD, and authenticates using OAuth 2.0 tokens.</span></span> <span data-ttu-id="374c1-323">실행 프로세스는 localhost 주소를 호출하여 토큰을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-323">The executing process calls a localhost address to get the token.</span></span> <span data-ttu-id="374c1-324">이 방식을 사용하면 암호 또는 연결 문자열을 저장할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-324">That way, you don't need to store any passwords or connection strings.</span></span> <span data-ttu-id="374c1-325">[aad-pod-identity](https://github.com/Azure/aad-pod-identity) 프로젝트를 사용하여 개별 Pod에 ID를 할당하면 AKS에서 관리 ID를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-325">You can use managed identities in AKS by assigning identities to individual pods, using the [aad-pod-identity](https://github.com/Azure/aad-pod-identity) project.</span></span>

<span data-ttu-id="374c1-326">현재 일부 Azure 서비스는 관리 ID를 사용한 인증을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-326">Currently, not all Azure services support authentication using managed identities.</span></span> <span data-ttu-id="374c1-327">목록은 [Azure AD 인증을 지원하는 Azure 서비스](/azure/active-directory/managed-identities-azure-resources/services-support-msi)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="374c1-327">For a list, see [Azure services that support Azure AD authentication](/azure/active-directory/managed-identities-azure-resources/services-support-msi).</span></span>

<span data-ttu-id="374c1-328">관리 ID를 사용하더라도 관리 ID를 지원하지 않는 Azure 서비스, 타사 서비스, API 키 등에 대한 일부 자격 증명 또는 기타 애플리케이션 비밀을 저장해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-328">Even with managed identities, you'll probably need to store some credentials or other application secrets, whether for Azure services that don't support managed identities, third-party services, API keys, and so on.</span></span> <span data-ttu-id="374c1-329">다음은 비밀을 안전하게 저장하기 위한 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-329">Here are some options for storing secrets securely:</span></span>

- <span data-ttu-id="374c1-330">Azure Key Vault.</span><span class="sxs-lookup"><span data-stu-id="374c1-330">Azure Key Vault.</span></span> <span data-ttu-id="374c1-331">AKS에서는 Key Vault에서 하나 이상의 비밀을 볼륨으로 탑재할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-331">In AKS, you can mount one or more secrets from Key Vault as a volume.</span></span> <span data-ttu-id="374c1-332">볼륨은 Key Vault에서 비밀을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-332">The volume reads the secrets from Key Vault.</span></span> <span data-ttu-id="374c1-333">그러면 Pod가 마치 정규 볼륨처럼 비밀을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-333">The pod can then read the secrets just like a regular volume.</span></span> <span data-ttu-id="374c1-334">자세한 내용은 GitHub의 [FlexVolume-KeyVault-Kubernetes](https://github.com/Azure/kubernetes-keyvault-flexvol) 프로젝트를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="374c1-334">For more information, see the [Kubernetes-KeyVault-FlexVolume](https://github.com/Azure/kubernetes-keyvault-flexvol) project on GitHub.</span></span>

    <span data-ttu-id="374c1-335">Pod는 위에서 설명한 Pod ID를 사용하거나 클라이언트 비밀과 함께 Azure AD 서비스 주체를 사용하여 자신을 인증합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-335">The pod authenticates itself by using either a pod identity (described above) or by using an Azure AD Service Principal along with a client secret.</span></span> <span data-ttu-id="374c1-336">이 경우 클라이언트 비밀이 필요 없으므로 Pod ID를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-336">Using pod identities is recommended because the client secret isn't needed in that case.</span></span> 

- <span data-ttu-id="374c1-337">HashiCorp Vault.</span><span class="sxs-lookup"><span data-stu-id="374c1-337">HashiCorp Vault.</span></span> <span data-ttu-id="374c1-338">Kubernetes 애플리케이션은 Azure AD 관리 ID를 사용하여 HashiCorp Vault를 인증할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-338">Kubernetes applications can authenticate with HashiCorp Vault using Azure AD managed identities.</span></span> <span data-ttu-id="374c1-339">[HashiCorp Vault에서 말하는 Azure Active Directory](https://open.microsoft.com/2018/04/10/scaling-tips-hashicorp-vault-azure-active-directory/)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="374c1-339">See [HashiCorp Vault speaks Azure Active Directory](https://open.microsoft.com/2018/04/10/scaling-tips-hashicorp-vault-azure-active-directory/).</span></span> <span data-ttu-id="374c1-340">Vault 자체를 Kubernetes에 배포할 수는 있지만, 애플리케이션 클러스터에 준비된 별도의 전용 클러스터에서 실행하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-340">You can deploy Vault itself to Kubernetes, but it's recommend to run it in a separate dedicated cluster from your application cluster.</span></span> 

- <span data-ttu-id="374c1-341">Kubernetes 비밀.</span><span class="sxs-lookup"><span data-stu-id="374c1-341">Kubernetes secrets.</span></span> <span data-ttu-id="374c1-342">또 다른 옵션은 간단하게 Kubernetes 비밀을 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-342">Another option is simply to use Kubernetes secrets.</span></span> <span data-ttu-id="374c1-343">이 옵션은 구성 방법이 가장 간단하지만 몇 가지 문제가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-343">This option is the easiest to configure but has some challenges.</span></span> <span data-ttu-id="374c1-344">분산 키-값 저장소인 etcd에 비밀이 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-344">Secrets are stored in etcd, which is a distributed key-value store.</span></span> <span data-ttu-id="374c1-345">AKS가 [미사용 etcd를 암호화합니다](https://github.com/Azure/kubernetes-kms#azure-kubernetes-service-aks).</span><span class="sxs-lookup"><span data-stu-id="374c1-345">AKS [encrypts etcd at rest](https://github.com/Azure/kubernetes-kms#azure-kubernetes-service-aks).</span></span> <span data-ttu-id="374c1-346">Microsoft에서 암호화 키를 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-346">Microsoft manages the encryption keys.</span></span>

<span data-ttu-id="374c1-347">HashiCorp Vault 또는 Azure Key Vault 같은 시스템을 사용하면 다음과 같은 장점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-347">Using a system like HashiCorp Vault or Azure Key Vault provides several advantages, such as:</span></span>

- <span data-ttu-id="374c1-348">비밀을 중앙에서 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-348">Centralized control of secrets.</span></span>
- <span data-ttu-id="374c1-349">모든 미사용 비밀이 암호화됩니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-349">Ensuring that all secrets are encrypted at rest.</span></span>
- <span data-ttu-id="374c1-350">키를 중앙에서 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-350">Centralized key management.</span></span>
- <span data-ttu-id="374c1-351">비밀 액세스를 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-351">Access control of secrets.</span></span>
- <span data-ttu-id="374c1-352">감사</span><span class="sxs-lookup"><span data-stu-id="374c1-352">Auditing</span></span>

### <a name="pod-and-container-security"></a><span data-ttu-id="374c1-353">Pod 및 컨테이너 보안</span><span class="sxs-lookup"><span data-stu-id="374c1-353">Pod and container security</span></span>

<span data-ttu-id="374c1-354">이 목록은 물론 최종 목록이 아니지만, Pod 및 컨테이너를 보호하는 몇 가지 모범 사례를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-354">This list is certainly not exhaustive, but here are some recommended practices for securing your pods and containers:</span></span> 

<span data-ttu-id="374c1-355">컨테이너를 권한 있는 모드로 실행하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="374c1-355">Don't run containers in privileged mode.</span></span> <span data-ttu-id="374c1-356">권한 있는 모드는 호스트의 모든 디바이스에 컨테이너 액세스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-356">Privileged mode gives a container access to all devices on the host.</span></span> <span data-ttu-id="374c1-357">컨테이너를 권한 모드에서 실행하는 것을 허용하지 않는 Pod 보안 정책을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-357">You can set Pod Security Policy to disallow containers from running in privileged mode.</span></span> 

<span data-ttu-id="374c1-358">되도록이면 프로세스를 컨테이너 내부에서 루트로 실행하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="374c1-358">When possible, avoid running processes as root inside containers.</span></span> <span data-ttu-id="374c1-359">컨테이너는 보안의 관점에서 완전한 격리를 제공하지 않으므로 컨테이너 프로세스를 권한 없는 사용자로 실행하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-359">Containers do not provide complete isolation from a security standpoint, so it's better to run a container process as a non-privileged user.</span></span> 

<span data-ttu-id="374c1-360">Azure Container Registry 또는 Docker Trusted Registry 같은 신뢰할 수 있는 비공개 레지스트리에 이미지를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-360">Store images in a trusted private registry, such as Azure Container Registry or Docker Trusted Registry.</span></span> <span data-ttu-id="374c1-361">Pod가 신뢰할 수 있는 레지스트리의 이미지만 끌어오도록 유효성 검사 허가 webhook를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-361">Use a validating admission webhook in Kubernetes to ensure that pods can only pull images from the trusted registry.</span></span>

<span data-ttu-id="374c1-362">Azure Marketplace를 통해 제공되는 Twistlock 및 Aqua 같은 검색 솔루션으로 이미지를 검사하여 알려진 취약성을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-362">Scan images for known vulnerabilities, using a scanning solution such as Twistlock and Aqua, which are available through the Azure Marketplace.</span></span>

<span data-ttu-id="374c1-363">Azure Container Registry의 기능인 ACR 작업을 사용하여 패치를 자동화합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-363">Automate image patching using ACR Tasks, a feature of Azure Container Registry.</span></span> <span data-ttu-id="374c1-364">컨테이너 이미지는 레이어에서 빌드됩니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-364">A container image is built up from layers.</span></span> <span data-ttu-id="374c1-365">기본 레이어에는 ASP.NET Core 또는 Node.js 같은 OS 이미지 및 애플리케이션 프레임워크 이미지가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-365">The base layers include the OS image and application framework images, such as ASP.NET Core or Node.js.</span></span> <span data-ttu-id="374c1-366">기본 이미지는 일반적으로 업스트림에서 애플리케이션 개발자가 생성하고, 다른 프로젝트 관리자가 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-366">The base images are typically created upstream from the application developers, and are maintained by other project maintainers.</span></span> <span data-ttu-id="374c1-367">이러한 이미지가 업스트림에서 패치될 때 알려진 보안 취약성이 남아 있지 않도록 이미지를 업데이트, 테스트 및 재배포해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-367">When these images are patched upstream, it's important to update, test, and redeploy your own images, so that you don't leave any known security vulnerabilities.</span></span> <span data-ttu-id="374c1-368">ACR 작업은 이 프로세스를 자동화하는 데 도움이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-368">ACR Tasks can help to automate this process.</span></span>

## <a name="deployment-cicd-considerations"></a><span data-ttu-id="374c1-369">배포(CI/CD) 고려 사항</span><span class="sxs-lookup"><span data-stu-id="374c1-369">Deployment (CI/CD) considerations</span></span>

<span data-ttu-id="374c1-370">마이크로 서비스 아키텍처에 대한 강력한 CI/CD 프로세스의 목표는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-370">Here are some goals of a robust CI/CD process for a microservices architecture:</span></span>

- <span data-ttu-id="374c1-371">각 팀은 다른 팀에 영향을 주거나 방해하지 않고 독립적으로 소유한 서비스를 빌드하여 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-371">Each team can build and deploy the services that it owns independently, without affecting or disrupting other teams.</span></span>

- <span data-ttu-id="374c1-372">새 버전의 서비스를 프로덕션 환경에 배포하기 전에 개발/테스트/QA 환경에 배포하여 유효성을 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-372">Before a new version of a service is deployed to production, it gets deployed to dev/test/QA environments for validation.</span></span> <span data-ttu-id="374c1-373">각 단계에서 품질 게이트를 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-373">Quality gates are enforced at each stage.</span></span>

- <span data-ttu-id="374c1-374">새 버전의 서비스를 이전 버전과 함께 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-374">A new version of a service can be deployed side-by-side with the previous version.</span></span>

- <span data-ttu-id="374c1-375">충분한 액세스 제어 정책을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-375">Sufficient access control policies are in place.</span></span>

- <span data-ttu-id="374c1-376">프로덕션 환경에 배포된 컨테이너 이미지를 신뢰할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-376">You can trust the container images that are deployed to production.</span></span>

### <a name="isolation-of-environments"></a><span data-ttu-id="374c1-377">환경 격리</span><span class="sxs-lookup"><span data-stu-id="374c1-377">Isolation of environments</span></span>

<span data-ttu-id="374c1-378">고객은 개발, 스모크 테스트, 통합 테스트, 부하 테스트 및 프로덕션 환경을 비롯한 여러 환경에 서비스를 배포할 것입니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-378">You will have multiple environments where you deploy services, including environments for development, smoke testing, integration testing, load testing, and finally production.</span></span> <span data-ttu-id="374c1-379">이러한 환경에는 일정 수준의 격리가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-379">These environments need some level of isolation.</span></span> <span data-ttu-id="374c1-380">Kubernetes에서는 물리적 격리와 논리적 격리 중에서 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-380">In Kubernetes, you have a choice between physical isolation and logical isolation.</span></span> <span data-ttu-id="374c1-381">물리적 격리는 별도의 클러스터에 배포하는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-381">Physical isolation means deploying to separate clusters.</span></span> <span data-ttu-id="374c1-382">논리적 격리는 앞에서 설명한 것처럼 네임스페이스와 정책을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-382">Logical isolation makes use of namespaces and policies, as described earlier.</span></span>

<span data-ttu-id="374c1-383">개발/테스트 환경에 사용할 별도의 클러스터와 함께 전용 프로덕션 클러스터를 만드는 방법을 권장합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-383">Our recommendation is to create a dedicated production cluster along with a separate cluster for your dev/test environments.</span></span> <span data-ttu-id="374c1-384">논리적 격리를 사용하여 개발/테스트 클러스터 내에서 별도의 환경을 격리하세요.</span><span class="sxs-lookup"><span data-stu-id="374c1-384">Use logical isolation to separate environments within the dev/test cluster.</span></span> <span data-ttu-id="374c1-385">개발/테스트 클러스터에 배포된 서비스는 비즈니스 데이터를 보관하는 데이터 저장소에 절대로 액세스하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-385">Services deployed to the dev/test cluster should never have access to data stores that hold business data.</span></span> 

### <a name="helm"></a><span data-ttu-id="374c1-386">Helm</span><span class="sxs-lookup"><span data-stu-id="374c1-386">Helm</span></span>

<span data-ttu-id="374c1-387">Helm을 사용하여 서비스를 빌드하고 배포하는 방안을 고려해 보세요.</span><span class="sxs-lookup"><span data-stu-id="374c1-387">Consider using Helm to manage building and deploying services.</span></span> <span data-ttu-id="374c1-388">다음은 CI/CD를 도와주는 Helm의 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-388">Some of the features of Helm that help with CI/CD include:</span></span>

- <span data-ttu-id="374c1-389">특정 마이크로 서비스의 모든 Kubernetes 개체를 단일 Helm 차트에 구성.</span><span class="sxs-lookup"><span data-stu-id="374c1-389">Organizing all of the Kubernetes objects for a particular microservice into a single Helm chart.</span></span>
- <span data-ttu-id="374c1-390">차트를 일련의 kubectl 명령이 아닌 단일 helm 명령으로 배포.</span><span class="sxs-lookup"><span data-stu-id="374c1-390">Deploying the chart as a single helm command, rather than a series of kubectl commands.</span></span>
- <span data-ttu-id="374c1-391">이전 버전으로 롤백하는 기능과 함께 의미 체계 버전 관리를 사용하여 업데이트 및 수정 버전 추적.</span><span class="sxs-lookup"><span data-stu-id="374c1-391">Tracking updates and revisions, using semantic versioning, along with the ability to roll back to a previous version.</span></span>
- <span data-ttu-id="374c1-392">템플릿을 사용하여 여러 파일에서 레이블, 선택기 등의 정보가 중복되지 않도록 방지.</span><span class="sxs-lookup"><span data-stu-id="374c1-392">The use of templates to avoid duplicating information, such as labels and selectors, across many files.</span></span>
- <span data-ttu-id="374c1-393">차트 간 종속성 관리.</span><span class="sxs-lookup"><span data-stu-id="374c1-393">Managing dependencies between charts.</span></span>
- <span data-ttu-id="374c1-394">Azure Container Registry 같은 Helm 리포지토리에 차트를 게시하고 빌드 파이프라인과 통합.</span><span class="sxs-lookup"><span data-stu-id="374c1-394">Publishing charts to a Helm repository, such as Azure Container Registry, and integrating them with the build pipeline.</span></span>

<span data-ttu-id="374c1-395">Container Registry를 Helm 리포지토리로 사용하는 방법에 대한 자세한 내용은 [애플리케이션 차트용 Helm 리포지토리로 Azure Container Registry 사용](/azure/container-registry/container-registry-helm-repos)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="374c1-395">For more information about using Container Registry as a Helm repository, see [Use Azure Container Registry as a Helm repository for your application charts](/azure/container-registry/container-registry-helm-repos).</span></span>

### <a name="cicd-workflow"></a><span data-ttu-id="374c1-396">CI/CD 워크플로</span><span class="sxs-lookup"><span data-stu-id="374c1-396">CI/CD workflow</span></span>

<span data-ttu-id="374c1-397">CI/CD 워크플로를 만들기 전에 코드 베이스가 구조화되고 관리되는 방법을 알아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-397">Before creating a CI/CD workflow, you must know how the code base will be structured and managed.</span></span>

- <span data-ttu-id="374c1-398">팀이 별도의 리포지토리에서 작업합니까, 아니면 단일 리포지토리에서 작업합니까?</span><span class="sxs-lookup"><span data-stu-id="374c1-398">Do teams work in separate respositories or in a monorepo (single respository)?</span></span>
- <span data-ttu-id="374c1-399">분기 전략은 무엇입니까?</span><span class="sxs-lookup"><span data-stu-id="374c1-399">What is your branching strategy?</span></span>
- <span data-ttu-id="374c1-400">프로덕션 환경에 코드를 푸시할 수 있는 사람은 누구입니까?</span><span class="sxs-lookup"><span data-stu-id="374c1-400">Who can push code to production?</span></span> <span data-ttu-id="374c1-401">릴리스 관리자 역할이 있습니까?</span><span class="sxs-lookup"><span data-stu-id="374c1-401">Is there a release manager role?</span></span>

<span data-ttu-id="374c1-402">단일 리포지토리 접근법이 지지를 받고 있지만 두 방식에는 모두 장단점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-402">The monorepo approach has been gaining favor but there are advantages and disadvantages to both.</span></span>

| &nbsp; | <span data-ttu-id="374c1-403">단일 리포지토리</span><span class="sxs-lookup"><span data-stu-id="374c1-403">Monorepo</span></span> | <span data-ttu-id="374c1-404">다중 리포지토리</span><span class="sxs-lookup"><span data-stu-id="374c1-404">Multiple repos</span></span> |
|--------|----------|----------------|
| <span data-ttu-id="374c1-405">**장점**</span><span class="sxs-lookup"><span data-stu-id="374c1-405">**Advantages**</span></span> | <span data-ttu-id="374c1-406">코드 공유</span><span class="sxs-lookup"><span data-stu-id="374c1-406">Code sharing</span></span><br/><span data-ttu-id="374c1-407">코드 및 도구 표준화 용이</span><span class="sxs-lookup"><span data-stu-id="374c1-407">Easier to standardize code and tooling</span></span><br/><span data-ttu-id="374c1-408">코드 리팩터링 용이</span><span class="sxs-lookup"><span data-stu-id="374c1-408">Easier to refactor code</span></span><br/><span data-ttu-id="374c1-409">검색 기능 - 코드의 단일 보기</span><span class="sxs-lookup"><span data-stu-id="374c1-409">Discoverability - single view of the code</span></span><br/> | <span data-ttu-id="374c1-410">팀별로 명확한 소유권</span><span class="sxs-lookup"><span data-stu-id="374c1-410">Clear ownership per team</span></span><br/><span data-ttu-id="374c1-411">잠재적으로 더 적은 병합 충돌</span><span class="sxs-lookup"><span data-stu-id="374c1-411">Potentially fewer merge conflicts</span></span><br/><span data-ttu-id="374c1-412">마이크로 서비스를 강제로 분리하는 데 유용</span><span class="sxs-lookup"><span data-stu-id="374c1-412">Helps to enforce decoupling of microservices</span></span> |
| <span data-ttu-id="374c1-413">**과제**</span><span class="sxs-lookup"><span data-stu-id="374c1-413">**Challenges**</span></span> | <span data-ttu-id="374c1-414">공유 코드에 대한 변경 사항이 여러 마이크로 서비스에 영향을 줄 수 있음</span><span class="sxs-lookup"><span data-stu-id="374c1-414">Changes to shared code can affect multiple microservices</span></span><br/><span data-ttu-id="374c1-415">병합 충돌 가능성 증가</span><span class="sxs-lookup"><span data-stu-id="374c1-415">Greater potential for merge conflicts</span></span><br/><span data-ttu-id="374c1-416">대규모 코드 베이스에 맞게 도구를 확장해야 함</span><span class="sxs-lookup"><span data-stu-id="374c1-416">Tooling must scale to a large code base</span></span><br/><span data-ttu-id="374c1-417">Access Control</span><span class="sxs-lookup"><span data-stu-id="374c1-417">Access control</span></span><br/><span data-ttu-id="374c1-418">더 복잡한 배포 프로세스</span><span class="sxs-lookup"><span data-stu-id="374c1-418">More complex deployment process</span></span> | <span data-ttu-id="374c1-419">코드를 공유하기가 더 어려움</span><span class="sxs-lookup"><span data-stu-id="374c1-419">Harder to share code</span></span><br/><span data-ttu-id="374c1-420">코딩 표준을 적용하기가 더 어려움</span><span class="sxs-lookup"><span data-stu-id="374c1-420">Harder to enforce coding standards</span></span><br/><span data-ttu-id="374c1-421">종속성 관리</span><span class="sxs-lookup"><span data-stu-id="374c1-421">Dependency management</span></span><br/><span data-ttu-id="374c1-422">분산된 코드 베이스, 검색 기능 저하</span><span class="sxs-lookup"><span data-stu-id="374c1-422">Diffuse code base, poor discoverability</span></span><br/><span data-ttu-id="374c1-423">공유 인프라 결여</span><span class="sxs-lookup"><span data-stu-id="374c1-423">Lack of shared infrastructure</span></span>

<span data-ttu-id="374c1-424">이 섹션에서는 다음과 같은 가정에 따라 가능한 CI/CD 워크플로를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-424">In this section, we present a possible CI/CD workflow, based on the following assumptions:</span></span>

- <span data-ttu-id="374c1-425">코드 리포지토리는 마이크로 서비스별로 정리된 폴더를 사용하는 단일 리포지토리입니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-425">The code repository is monorepo, with folders organized by microservice.</span></span>
- <span data-ttu-id="374c1-426">팀의 분기 전략이 [트렁크 기반 개발](https://trunkbaseddevelopment.com/)을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-426">The team's branching strategy is based on [trunk-based development](https://trunkbaseddevelopment.com/).</span></span>
- <span data-ttu-id="374c1-427">팀이 [Azure Pipelines](/azure/devops/pipelines)를 사용하여 CI/CD 프로세스를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-427">The team uses [Azure Pipelines](/azure/devops/pipelines) to run the CI/CD process.</span></span>
- <span data-ttu-id="374c1-428">팀이 Azure Container Registry에서 [네임스페이스](/azure/container-registry/container-registry-best-practices#repository-namespaces)를 사용하여 아직 테스트 중인 이미지에서 프로덕션용으로 승인된 이미지를 분리합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-428">The team uses [namespaces](/azure/container-registry/container-registry-best-practices#repository-namespaces) in Azure Container Registry to isolate images that are approved for production from images that are still being tested.</span></span>

<span data-ttu-id="374c1-429">이 예에서는 개발자가 Delivery Service라는 마이크로 서비스를 작업합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-429">In this example, a developer is working on a microservice called Delivery Service.</span></span> <span data-ttu-id="374c1-430">(이 이름은 [여기](../../microservices/index.md#the-drone-delivery-application)에 설명된 참조 구현에서 따온 것입니다.) 개발자는 새 기능을 개발할 때 기능 분기에 코드를 체크 인합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-430">(The name comes from the reference implementation described [here](../../microservices/index.md#the-drone-delivery-application).) While developing a new feature, the developer checks code into a feature branch.</span></span>

![CI/CD 워크플로](./_images/aks-cicd-1.png)

<span data-ttu-id="374c1-432">이 분기에 대한 커밋을 푸시하면 마이크로 서비스에 대한 CI 빌드가 트리거됩니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-432">Pushing commits to this branch tiggers a CI build for the microservice.</span></span> <span data-ttu-id="374c1-433">관례상 기능 분기는 `feature/*`로 명명합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-433">By convention, feature branches are named `feature/*`.</span></span> <span data-ttu-id="374c1-434">[빌드 정의 파일](/azure/devops/pipelines/yaml-schema)에는 분기 이름과 원본 경로로 필터링되는 트리거가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-434">The [build definition file](/azure/devops/pipelines/yaml-schema) includes a trigger that filters by the branch name and the source path.</span></span> <span data-ttu-id="374c1-435">각 팀은 이러한 접근법을 사용하여 자체 빌드 파이프라인을 구축할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-435">Using this approach, each team can have its own build pipeline.</span></span>

```yaml
trigger:
  batch: true
  branches:
    include:
    - master
    - feature/*

    exclude:
    - feature/experimental/*

  paths:
     include:
     - /src/shipping/delivery/
```

<span data-ttu-id="374c1-436">워크플로의 이 시점에서 CI 빌드는 최소한의 코드 확인을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-436">At this point in the workflow, the CI build runs some minimal code verification:</span></span>

1. <span data-ttu-id="374c1-437">코드 빌드</span><span class="sxs-lookup"><span data-stu-id="374c1-437">Build code</span></span>
1. <span data-ttu-id="374c1-438">단위 테스트 실행</span><span class="sxs-lookup"><span data-stu-id="374c1-438">Run unit tests</span></span>

<span data-ttu-id="374c1-439">개발자가 신속한 피드백을 얻을 수 있도록 빌드 시간을 짧게 유지하자는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-439">The idea here is to keep the build times short so the developer can get quick feedback.</span></span> <span data-ttu-id="374c1-440">기능을 마스터에 병합할 준비가 되면 개발자는 PR을 엽니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-440">When the feature is ready to merge into master, the developer opens a PR.</span></span> <span data-ttu-id="374c1-441">그러면 일부 추가 검사를 수행하는 다른 CI 빌드가 트리거됩니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-441">This triggers another CI build that performs some additional checks:</span></span>

1. <span data-ttu-id="374c1-442">코드 빌드</span><span class="sxs-lookup"><span data-stu-id="374c1-442">Build code</span></span>
1. <span data-ttu-id="374c1-443">단위 테스트 실행</span><span class="sxs-lookup"><span data-stu-id="374c1-443">Run unit tests</span></span>
1. <span data-ttu-id="374c1-444">런타임 컨테이너 이미지 빌드</span><span class="sxs-lookup"><span data-stu-id="374c1-444">Build the runtime container image</span></span>
1. <span data-ttu-id="374c1-445">이미지에 대한 취약성 검사 실행</span><span class="sxs-lookup"><span data-stu-id="374c1-445">Run vulnerability scans on the image</span></span>

![CI/CD 워크플로](./_images/aks-cicd-2.png)

> [!NOTE]
> <span data-ttu-id="374c1-447">Azure Repos에서 분기를 보호하는 [정책](/azure/devops/repos/git/branch-policies)을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-447">In Azure Repos, you can define [policies](/azure/devops/repos/git/branch-policies) to protect branches.</span></span> <span data-ttu-id="374c1-448">예를 들어 마스터에 병합하려면 정책에 승인자의 서명과 성공적인 CI 빌드가 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-448">For example, the policy could require a successful CI build plus a sign-off from an approver in order to merge into master.</span></span>

<span data-ttu-id="374c1-449">어느 시점이 되면 팀은 새 버전의 Delivery Service를 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-449">At some point, the team is ready to deploy a new version of the Delivery service.</span></span> <span data-ttu-id="374c1-450">이를 위해 릴리스 관리자는 `release/<microservice name>/<semver>`와 같은 명명 패턴을 사용하여 마스터에서 분기를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-450">To do so, the release manager creates a branch from master with this naming pattern: `release/<microservice name>/<semver>`.</span></span> <span data-ttu-id="374c1-451">예: `release/delivery/v1.0.2`</span><span class="sxs-lookup"><span data-stu-id="374c1-451">For example, `release/delivery/v1.0.2`.</span></span>
<span data-ttu-id="374c1-452">이는 이전의 모든 단계와 다음 작업을 실행하는 완전한 CI 빌드를 트리거합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-452">This triggers a full CI build that runs all the previous steps plus:</span></span>

1. <span data-ttu-id="374c1-453">Azure Container Registry로 Docker 이미지를 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-453">Push the Docker image to Azure Container Registry.</span></span> <span data-ttu-id="374c1-454">분기 이름에서 가져온 버전 번호로 이미지에 태그가 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-454">The image is tagged with the version number taken from the branch name.</span></span>
2. <span data-ttu-id="374c1-455">`helm package`를 실행하여 Helm 차트 패키징</span><span class="sxs-lookup"><span data-stu-id="374c1-455">Run `helm package` to package the Helm chart</span></span>
3. <span data-ttu-id="374c1-456">`az acr helm push`를 실행하여 Container Registry에 Helm 패키지를 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-456">Push the Helm package to Container Registry by running `az acr helm push`.</span></span>

<span data-ttu-id="374c1-457">이 빌드가 성공할 경우 Azure Pipelines [릴리스 파이프라인](/azure/devops/pipelines/release/what-is-release-management)을 사용하여 배포 프로세스가 트리거됩니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-457">Assuming this build succeeds, it triggers a deployment process using an Azure Pipelines [release pipeline](/azure/devops/pipelines/release/what-is-release-management).</span></span> <span data-ttu-id="374c1-458">이 파이프라인</span><span class="sxs-lookup"><span data-stu-id="374c1-458">This pipeline</span></span>

1. <span data-ttu-id="374c1-459">`helm upgrade`를 실행하여 QA 환경에 Helm 차트를 배포합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-459">Run `helm upgrade` to deploy the Helm chart to a QA environment.</span></span>
1. <span data-ttu-id="374c1-460">승인자가 서명한 후 패키지가 프로덕션 단계로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-460">An approver signs off before the package moves to production.</span></span> <span data-ttu-id="374c1-461">[승인을 통해 릴리스 배포 제어](/azure/devops/pipelines/release/approvals/approvals)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="374c1-461">See [Release deployment control using approvals](/azure/devops/pipelines/release/approvals/approvals).</span></span>
1. <span data-ttu-id="374c1-462">Azure Container Registry에서 프로덕션 네임스페이스용 Docker 이미지에 다시 태그를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-462">Re-tag the Docker image for the production namespace in Azure Container Registry.</span></span> <span data-ttu-id="374c1-463">예를 들어 현재 태그가 `myrepo.azurecr.io/delivery:v1.0.2`라면 프로덕션 태그는 `reponame.azurecr.io/prod/delivery:v1.0.2`입니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-463">For example, if the current tag is `myrepo.azurecr.io/delivery:v1.0.2`, the production tag is `reponame.azurecr.io/prod/delivery:v1.0.2`.</span></span>
1. <span data-ttu-id="374c1-464">`helm upgrade`를 실행하여 프로덕션 환경에 Helm 차트를 배포합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-464">Run `helm upgrade` to deploy the Helm chart to the production environment.</span></span>

![CI/CD 워크플로](./_images/aks-cicd-3.png)

<span data-ttu-id="374c1-466">팀이 빠른 개발속도로 배포할 수 있도록 단일 리포지토리에서도 이러한 작업의 범위를 개별 마이크로 서비스로 지정할 수 있다는 사실을 기억하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-466">It's important to remember that even in a monorepo, these tasks can be scoped to individual microservices, so that teams can deploy with high velocity.</span></span> <span data-ttu-id="374c1-467">이 프로세스에는 몇 가지 수동 단계가 있습니다. PR 승인, 릴리스 분기 만들기, 프로덕션 클러스터에 배포 승인.</span><span class="sxs-lookup"><span data-stu-id="374c1-467">There are some manual steps in the process: Approving PRs, creating release branches, and approving deployments into the production cluster.</span></span> <span data-ttu-id="374c1-468">이러한 단계는 정책에 따라 수동으로 실행합니다. 조직에서 선호하는 경우 이러한 단계를 완전히 자동화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="374c1-468">These steps are manual by policy &mdash; they could be completely automated if the organization prefers.</span></span>
