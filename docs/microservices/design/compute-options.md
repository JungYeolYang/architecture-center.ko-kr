# <a name="choosing-a-compute-option-for-microservices"></a><span data-ttu-id="5047e-101">마이크로 서비스에 대 한 계산 옵션 선택</span><span class="sxs-lookup"><span data-stu-id="5047e-101">Choosing a compute option for microservices</span></span>

<span data-ttu-id="5047e-102">*계산*이라는 용어는 애플리케이션이 실행되는 계산 리소스의 호스팅 모델을 말합니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-102">The term *compute* refers to the hosting model for the computing resources that your application runs on.</span></span> <span data-ttu-id="5047e-103">마이크로 서비스 아키텍처의 경우 두 가지 접근 방식이 특히 많이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-103">For a microservices architecture, two approaches are especially popular:</span></span>

- <span data-ttu-id="5047e-104">전용 노드(VM)에서 실행되는 서비스를 관리하는 서비스 오케스트레이터</span><span class="sxs-lookup"><span data-stu-id="5047e-104">A service orchestrator that manages services running on dedicated nodes (VMs).</span></span>
- <span data-ttu-id="5047e-105">FaaS(functions as a service)를 사용하고 서버를 사용하지 않는 아키텍처</span><span class="sxs-lookup"><span data-stu-id="5047e-105">A serverless architecture using functions as a service (FaaS).</span></span>

<span data-ttu-id="5047e-106">이것이 유일한 옵션은 아니지만, 마이크로 서비스 구축을 위해 검증된 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-106">While these aren't the only options, they are both proven approaches to building microservices.</span></span> <span data-ttu-id="5047e-107">애플리케이션에 두 가지 방법이 모두 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-107">An application might include both approaches.</span></span>

## <a name="service-orchestrators"></a><span data-ttu-id="5047e-108">서비스 오케스트레이터</span><span class="sxs-lookup"><span data-stu-id="5047e-108">Service orchestrators</span></span>

<span data-ttu-id="5047e-109">오케스트레이터는 서비스 집합 배포 및 관리와 관련된 작업을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-109">An orchestrator handles tasks related to deploying and managing a set of services.</span></span> <span data-ttu-id="5047e-110">이러한 작업에는 노드에 서비스 배치, 서비스 상태 모니터링, 비정상 서비스 다시 시작, 서비스 인스턴스 사이에서 네트워크 트래픽 부하 조정, 서비스 검색, 서비스 인스턴스 수의 규모 조정, 구성 업데이트 적용이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-110">These tasks include placing services on nodes, monitoring the health of services, restarting unhealthy services, load balancing network traffic across service instances, service discovery, scaling the number of instances of a service, and applying configuration updates.</span></span> <span data-ttu-id="5047e-111">많이 사용되는 오케스트레이터에는 Kubernetes, Service Fabric, DC/OS, Docker Swarm 등이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-111">Popular orchestrators include Kubernetes, Service Fabric, DC/OS, and Docker Swarm.</span></span>

<span data-ttu-id="5047e-112">Azure 플랫폼에서 다음 옵션을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-112">On the Azure platform, consider the following options:</span></span>

- <span data-ttu-id="5047e-113">[AKS(Azure Kubernetes Service)](/azure/aks/)는 관리되는 Kubernetes 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-113">[Azure Kubernetes Service](/azure/aks/) (AKS) is a managed Kubernetes service.</span></span> <span data-ttu-id="5047e-114">AKS는 Kubernetes를 프로비전하고 Kubernetes API 엔드포인트를 노출하지만 Kubernetes 제어 플레인을 호스트 및 관리하고 자동 업그레이드, 자동 패치 적용, 자동 크기 조정 및 기타 관리 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-114">AKS provisions Kubernetes and exposes the Kubernetes API endpoints, but hosts and manages the Kubernetes control plane, performing automated upgrades, automated patching, autoscaling, and other management tasks.</span></span> <span data-ttu-id="5047e-115">AKS를 "서비스로 제공되는 Kubernetes API"라고 생각할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-115">You can think of AKS as being "Kubernetes APIs as a service."</span></span>

- <span data-ttu-id="5047e-116">[Service Fabric](/azure/service-fabric/)은 마이크로 서비스를 패키징, 배포 및 관리하기 위한 분산 시스템 플랫폼입니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-116">[Service Fabric](/azure/service-fabric/) is a distributed systems platform for packaging, deploying, and managing microservices.</span></span> <span data-ttu-id="5047e-117">마이크로 서비스는 Service Fabric에 컨테이너, 이진 실행 파일 또는 [Reliable Services](/azure/service-fabric/service-fabric-reliable-services-introduction)로 배포될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-117">Microservices can be deployed to Service Fabric as containers, as binary executables, or as [Reliable Services](/azure/service-fabric/service-fabric-reliable-services-introduction).</span></span> <span data-ttu-id="5047e-118">Reliable Services 프로그래밍 모델을 사용하면, 서비스에서 Service Fabric 프로그래밍 API를 직접 사용하여 시스템을 쿼리하고, 상태를 보고하고, 구성 및 코드 변경에 대한 알림을 받고, 다른 서비스를 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-118">Using the Reliable Services programming model, services can directly use Service Fabric programming APIs to query the system, report health, receive notifications about configuration and code changes, and discover other services.</span></span> <span data-ttu-id="5047e-119">Service Fabric을 통한 주요 차별화는 [Reliable Collections](/azure/service-fabric/service-fabric-reliable-services-reliable-collections)를 사용하여 상태 저장 서비스를 구축하는 데 강력하게 집중하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-119">A key differentiation with Service Fabric is its strong focus on building stateful services using [Reliable Collections](/azure/service-fabric/service-fabric-reliable-services-reliable-collections).</span></span>

- <span data-ttu-id="5047e-120">Docker Enterprise Edition 및 Mesosphere DC/OS 등의 다른 옵션은 Azure에서 IaaS 환경에서 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-120">Other options such as Docker Enterprise Edition and Mesosphere DC/OS can run in an IaaS environment on Azure.</span></span> <span data-ttu-id="5047e-121">배포 템플릿을 찾을 수 있습니다 [Azure Marketplace](https://azuremarketplace.microsoft.com)합니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-121">You can find deployment templates on [Azure Marketplace](https://azuremarketplace.microsoft.com).</span></span>

## <a name="containers"></a><span data-ttu-id="5047e-122">컨테이너</span><span class="sxs-lookup"><span data-stu-id="5047e-122">Containers</span></span>

<span data-ttu-id="5047e-123">컨테이너와 마이크로 서비스가 같은 것처럼 말하는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-123">Sometimes people talk about containers and microservices as if they were the same thing.</span></span> <span data-ttu-id="5047e-124">그것은 사실이 아니며 &mdash;마이크로 서비스를 만드는 데는 컨테이너가 필요하지 않습니다.&mdash; 컨테이너에는 마이크로 서비스에 특히 적합한 다음과 같은 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-124">While that's not true &mdash; you don't need containers to build microservices &mdash; containers do have some benefits that are particularly relevant to microservices, such as:</span></span>

- <span data-ttu-id="5047e-125">**이식성**.</span><span class="sxs-lookup"><span data-stu-id="5047e-125">**Portability**.</span></span> <span data-ttu-id="5047e-126">컨테이너 이미지는 라이브러리나 다른 종속성을 설치할 필요 없이 실행되는 독립 실행형 패키지입니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-126">A container image is a standalone package that runs without needing to install libraries or other dependencies.</span></span> <span data-ttu-id="5047e-127">따라서 배포가 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-127">That makes them easy to deploy.</span></span> <span data-ttu-id="5047e-128">컨테이너는 신속하게 시작하고 중지할 수 있기 때문에 부하를 더 많이 처리하거나 노드 장애를 복구하도록 새로운 인스턴스를 스핀업할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-128">Containers can be started and stopped quickly, so you can spin up new instances to handle more load or to recover from node failures.</span></span>

- <span data-ttu-id="5047e-129">**밀도**.</span><span class="sxs-lookup"><span data-stu-id="5047e-129">**Density**.</span></span> <span data-ttu-id="5047e-130">컨테이너는 OS 리소스를 공유하기 때문에 가상 머신을 실행하는 것보다 경량입니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-130">Containers are lightweight compared with running a virtual machine, because they share OS resources.</span></span> <span data-ttu-id="5047e-131">여러 컨테이너를 단일 노드로 묶는 것이 가능하기 때문에 다수의 소규모 서비스로 구성된 애플리케이션에 특히 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-131">That makes it possible to pack multiple containers onto a single node, which is especially useful when the application consists of many small services.</span></span>

- <span data-ttu-id="5047e-132">**리소스 격리**.</span><span class="sxs-lookup"><span data-stu-id="5047e-132">**Resource isolation**.</span></span> <span data-ttu-id="5047e-133">컨테이너에서 사용할 수 있는 메모리 및 CPU 양을 제한할 수 있기 때문에 런어웨이 프로세스가 호스트 리소스를 소진하지 않도록 하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-133">You can limit the amount of memory and CPU that is available to a container, which can help to ensure that a runaway process doesn't exhaust the host resources.</span></span> <span data-ttu-id="5047e-134">자세한 내용은 [격벽 패턴](../../patterns/bulkhead.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5047e-134">See the [Bulkhead pattern](../../patterns/bulkhead.md) for more information.</span></span>

## <a name="serverless-functions-as-a-service"></a><span data-ttu-id="5047e-135">서버리스(Functions as a Service)</span><span class="sxs-lookup"><span data-stu-id="5047e-135">Serverless (Functions as a Service)</span></span>

<span data-ttu-id="5047e-136">[서버리스](https://azure.microsoft.com/solutions/serverless/) 아키텍처를 사용하면 VM 또는 가상 네트워크 인프라를 관리할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-136">With a [serverless](https://azure.microsoft.com/solutions/serverless/) architecture, you don't manage the VMs or the virtual network infrastructure.</span></span> <span data-ttu-id="5047e-137">대신, 사용자가 코드를 배포하면 호스팅 서비스가 해당 코드를 VM에 넣고 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-137">Instead, you deploy code and the hosting service handles putting that code onto a VM and executing it.</span></span> <span data-ttu-id="5047e-138">이 방법은 이벤트 기반 트리거를 사용하여 조율하는 소규모의 세분화된 함수를 선호하는 경향이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-138">This approach tends to favor small granular functions that are coordinated using event-based triggers.</span></span> <span data-ttu-id="5047e-139">예를 들어 큐에 배치된 메시지는 큐에서 읽고 메시지를 처리하는 함수를 트리거 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-139">For example, a message being placed onto a queue might trigger a function that reads from the queue and processes the message.</span></span>

<span data-ttu-id="5047e-140">[Azure Functions](/azure/azure-functions/) 를 HTTP 요청, Service Bus 큐 및 Event Hubs 이벤트를 비롯 한 다양 한 함수 트리거를 지 원하는 서버 리스 계산 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-140">[Azure Functions](/azure/azure-functions/) is a serverless compute service that supports various function triggers, including HTTP requests, Service Bus queues, and Event Hubs events.</span></span> <span data-ttu-id="5047e-141">전체 목록을 참조 하세요 [Azure Functions 트리거 및 바인딩 개념](/azure/azure-functions/functions-triggers-bindings)합니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-141">For a complete list, see [Azure Functions triggers and bindings concepts](/azure/azure-functions/functions-triggers-bindings).</span></span> <span data-ttu-id="5047e-142">수도 [Azure Event Grid](/azure/event-grid/), Azure에서 관리 되는 이벤트 라우팅 서비스인 합니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-142">Also consider [Azure Event Grid](/azure/event-grid/), which is a managed event routing service in Azure.</span></span>

<!-- markdownlint-disable MD026 -->

## <a name="orchestrator-or-serverless"></a><span data-ttu-id="5047e-143">오케스트레이터 또는 서버리스</span><span class="sxs-lookup"><span data-stu-id="5047e-143">Orchestrator or serverless?</span></span>

<!-- markdownlint-enable MD026 -->

<span data-ttu-id="5047e-144">오케스트레이터 방식과 서버리스 방식 중에서 선택할 때 고려해야 할 몇 가지 요소가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-144">Here are some factors to consider when choosing between an orchestrator approach and a serverless approach.</span></span>

<span data-ttu-id="5047e-145">**관리 효율성** 플랫폼이 모든 계산 리소스를 관리하기 때문에 서버리스 애플리케이션은 관리가 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-145">**Manageability** A serverless application is easy to manage, because the platform manages all the of compute resources for you.</span></span> <span data-ttu-id="5047e-146">오케스트레이터는 클러스터 관리 및 구성의 일부 측면을 추상화하지만 기본 VM은 완전히 숨기지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-146">While an orchestrator abstracts some aspects of managing and configuring a cluster, it does not completely hide the underlying VMs.</span></span> <span data-ttu-id="5047e-147">오케스트레이터를 사용하면 부하 분산, CPU 및 메모리 사용량 및 네트워킹과 같은 문제에 대해 생각해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-147">With an orchestrator, you will need to think about issues such as load balancing, CPU and memory usage, and networking.</span></span>

<span data-ttu-id="5047e-148">**유연성 및 제어**.</span><span class="sxs-lookup"><span data-stu-id="5047e-148">**Flexibility and control**.</span></span> <span data-ttu-id="5047e-149">오케스트레이터를 사용하면 서비스와 클러스터를 구성하고 관리하는 데 있어 많은 제어가 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-149">An orchestrator gives you a great deal of control over configuring and managing your services and the cluster.</span></span> <span data-ttu-id="5047e-150">단점은 복잡성이 추가되는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-150">The tradeoff is additional complexity.</span></span> <span data-ttu-id="5047e-151">서버리스 아키텍처를 사용하면 이러한 세부 사항이 추상화되기 때문에 제어를 어느 정도 포기해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-151">With a serverless architecture, you give up some degree of control because these details are abstracted.</span></span>

<span data-ttu-id="5047e-152">**이식성**.</span><span class="sxs-lookup"><span data-stu-id="5047e-152">**Portability**.</span></span> <span data-ttu-id="5047e-153">여기에 나열된 모든 오케스트레이터(Kubernetes, DC/OS, Docker Swarm 및 Service Fabric)는 온-프레미스 또는 다수의 공용 클라우드에서 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-153">All of the orchestrators listed here (Kubernetes, DC/OS, Docker Swarm, and Service Fabric) can run on-premises or in multiple public clouds.</span></span>

<span data-ttu-id="5047e-154">**애플리케이션 통합**.</span><span class="sxs-lookup"><span data-stu-id="5047e-154">**Application integration**.</span></span> <span data-ttu-id="5047e-155">서버리스 아키텍처를 사용하면 복잡한 애플리케이션을 개발하기 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-155">It can be challenging to build a complex application using a serverless architecture.</span></span> <span data-ttu-id="5047e-156">Azure의 한 가지 옵션은 [Azure Logic Apps](/azure/logic-apps/)를 사용하여 Azure Functions 집합을 조정하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-156">One option in Azure is to use [Azure Logic Apps](/azure/logic-apps/) to coordinate a set of Azure Functions.</span></span> <span data-ttu-id="5047e-157">이러한 방법에 대한 예제는 [Azure Logic Apps와 통합하는 함수 만들기](/azure/azure-functions/functions-twitter-email)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5047e-157">For an example of this approach, see [Create a function that integrates with Azure Logic Apps](/azure/azure-functions/functions-twitter-email).</span></span>

<span data-ttu-id="5047e-158">**비용**.</span><span class="sxs-lookup"><span data-stu-id="5047e-158">**Cost**.</span></span> <span data-ttu-id="5047e-159">오케스트레이터를 사용하면 클러스터에서 실행 중인 VM에 대한 비용을 지불합니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-159">With an orchestrator, you pay for the VMs that are running in the cluster.</span></span> <span data-ttu-id="5047e-160">서버리스 애플리케이션을 사용하면 소비한 실제 계산 리소스에 대해서만 비용을 지불합니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-160">With a serverless application, you pay only for the actual compute resources consumed.</span></span> <span data-ttu-id="5047e-161">두 경우 모두 저장소, 데이터베이스 및 메시징 서비스와 같은 추가 서비스에 대한 비용을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-161">In both cases, you need to factor in the cost of any additional services, such as storage, databases, and messaging services.</span></span>

<span data-ttu-id="5047e-162">**확장성**.</span><span class="sxs-lookup"><span data-stu-id="5047e-162">**Scalability**.</span></span> <span data-ttu-id="5047e-163">Azure Functions는 들어오는 이벤트 수를 기반으로 수요에 맞게 자동으로 규모가 조정됩니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-163">Azure Functions scales automatically to meet demand, based on the number of incoming events.</span></span> <span data-ttu-id="5047e-164">오케스트레이터를 사용하면 클러스터에서 실행 중인 서비스 인스턴스의 수를 늘려서 규모를 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-164">With an orchestrator, you can scale out by increasing the number of service instances running in the cluster.</span></span> <span data-ttu-id="5047e-165">클러스터에 VM을 더 추가하여 확장할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-165">You can also scale by adding additional VMs to the cluster.</span></span>

<span data-ttu-id="5047e-166">참조 구현에는 주로 Kubernetes를 사용했지만 한 가지 서비스 즉, Delivery History(배달 기록) 서비스에 대해서는 Azure Functions를 사용했습니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-166">Our reference implementation primarily uses Kubernetes, but we did use Azure Functions for one service, namely the Delivery History service.</span></span> <span data-ttu-id="5047e-167">Azure Functions는 이벤트 기반 워크로드이기 때문에 이러한 특정 서비스에 적합합니다</span><span class="sxs-lookup"><span data-stu-id="5047e-167">Azure Functions was a good fit for this particular service, because it's is an event-driven workload.</span></span> <span data-ttu-id="5047e-168">Event Hubs 트리거를 사용하여 함수를 호출하면 서비스에 최소한의 코드만 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-168">By using an Event Hubs trigger to invoke the function, the service needed a minimal amount of code.</span></span> <span data-ttu-id="5047e-169">Delivery History(배달 기록) 서비스는 기본 워크플로에 속하지 않으므로 Kubernetes 클러스터 외부에서 실행하면 사용자가 시작한 작업의 종단 간 대기 시간에 영향을 미치지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5047e-169">Also, the Delivery History service is not part of the main workflow, so running it outside of the Kubernetes cluster doesn't affect the end-to-end latency of user-initiated operations.</span></span>

## <a name="next-steps"></a><span data-ttu-id="5047e-170">다음 단계</span><span class="sxs-lookup"><span data-stu-id="5047e-170">Next steps</span></span>

> [!div class="nextstepaction"]
> [<span data-ttu-id="5047e-171">서비스 간 통신</span><span class="sxs-lookup"><span data-stu-id="5047e-171">Interservice communication</span></span>](./interservice-communication.md)
