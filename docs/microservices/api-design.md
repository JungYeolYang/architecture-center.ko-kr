---
title: API 디자인
description: 마이크로 서비스에 대한 API 디자인
author: MikeWasson
ms.date: 10/23/2018
ms.openlocfilehash: 80e8e081384a7806880878ae95fbdbc2bb6cc440
ms.sourcegitcommit: 1f4cdb08fe73b1956e164ad692f792f9f635b409
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/08/2019
ms.locfileid: "54111044"
---
# <a name="designing-microservices-api-design"></a><span data-ttu-id="45ad7-103">마이크로서비스 디자인: API 디자인</span><span class="sxs-lookup"><span data-stu-id="45ad7-103">Designing microservices: API design</span></span>

<span data-ttu-id="45ad7-104">서비스 간의 모든 데이터 교환은 메시지 또는 API 호출을 통해 발생하므로 마이크로 서비스 아키텍처에서 좋은 API 디자인은 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-104">Good API design is important in a microservices architecture, because all data exchange between services happens either through messages or API calls.</span></span> <span data-ttu-id="45ad7-105">API는 [번잡한 I/O](../antipatterns/chatty-io/index.md) 만들기를 방지하는 데 효율적이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-105">APIs must be efficient to avoid creating [chatty I/O](../antipatterns/chatty-io/index.md).</span></span> <span data-ttu-id="45ad7-106">서비스는 독립적으로 작업하는 팀에서 디자인되므로 업데이트가 다른 서비스를 중단하지 않도록 API에는 잘 정의된 의미 체계 및 버전 지정 체계가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-106">Because services are designed by teams working independently, APIs must have well-defined semantics and versioning schemes, so that updates don't break other services.</span></span>

![마이크로서비스에 대한 API 디자인](./images/api-design.png)

<span data-ttu-id="45ad7-108">두 가지 유형의 API를 구분하는 것은 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-108">It's important to distinguish between two types of API:</span></span>

- <span data-ttu-id="45ad7-109">클라이언트 애플리케이션을 호출하는 공용 API</span><span class="sxs-lookup"><span data-stu-id="45ad7-109">Public APIs that client applications call.</span></span>
- <span data-ttu-id="45ad7-110">서비스 간 통신에 사용되는 백 엔드 API</span><span class="sxs-lookup"><span data-stu-id="45ad7-110">Backend APIs that are used for interservice communication.</span></span>

<span data-ttu-id="45ad7-111">이러한 두 가지 사용 사례에는 약간 다른 요구 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-111">These two use cases have somewhat different requirements.</span></span> <span data-ttu-id="45ad7-112">공용 API는 클라이언트 애플리케이션, 일반적으로 브라우저 애플리케이션 또는 네이티브 모바일 애플리케이션과 호환되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-112">A public API must be compatible with client applications, typically browser applications or native mobile applications.</span></span> <span data-ttu-id="45ad7-113">대부분의 경우 공용 API가 HTTP를 통해 공용 REST를 사용하는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-113">Most of the time, that means the public API will use REST over HTTP.</span></span> <span data-ttu-id="45ad7-114">그러나 백 엔드 API의 경우 네트워크 성능을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-114">For the backend APIs, however, you need to take network performance into account.</span></span> <span data-ttu-id="45ad7-115">서비스의 세분성에 따라 서비스 간 통신은 많은 네트워크 트래픽을 발생시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-115">Depending on the granularity of your services, interservice communication can result in a lot of network traffic.</span></span> <span data-ttu-id="45ad7-116">서비스는 빠르게 I/O 바인딩될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-116">Services can quickly become I/O bound.</span></span> <span data-ttu-id="45ad7-117">이런 이유로 serialization 속도 및 페이로드 크기와 같은 고려 사항은 더욱 중요해집니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-117">For that reason, considerations such as serialization speed and payload size become more important.</span></span> <span data-ttu-id="45ad7-118">HTTP를 통한 REST 사용에 대한 인기 있는 몇 가지 대안에는 gRPC, Apache Avro 및 Apache Thrift가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-118">Some popular alternatives to using REST over HTTP include gRPC, Apache Avro, and Apache Thrift.</span></span> <span data-ttu-id="45ad7-119">이러한 프로토콜은 이진 serialization을 지원하고 일반적으로 HTTP보다 더 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-119">These protocols support binary serialization and are generally more efficient than HTTP.</span></span>

## <a name="considerations"></a><span data-ttu-id="45ad7-120">고려 사항</span><span class="sxs-lookup"><span data-stu-id="45ad7-120">Considerations</span></span>

<span data-ttu-id="45ad7-121">API를 구현하는 방법을 선택할 때 고려할 몇 가지 사항은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-121">Here are some things to think about when choosing how to implement an API.</span></span>

<span data-ttu-id="45ad7-122">**REST 및 RPC**</span><span class="sxs-lookup"><span data-stu-id="45ad7-122">**REST vs RPC**.</span></span> <span data-ttu-id="45ad7-123">REST 스타일 인터페이스와 RPC 스타일 인터페이스 사용 간의 장단점을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-123">Consider the tradeoffs between using a REST-style interface versus an RPC-style interface.</span></span>

- <span data-ttu-id="45ad7-124">자연스러운 방법이 될 수 있는 REST 모델 리소스는 도메인 모델을 표현합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-124">REST models resources, which can be a natural way express your domain model.</span></span> <span data-ttu-id="45ad7-125">진화 능력을 장려하는 HTTP 동사에 따라 일관된 인터페이스를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-125">It defines a uniform interface based on HTTP verbs, which encourages evolvability.</span></span> <span data-ttu-id="45ad7-126">멱등성, 부작용 및 응답 코드 면에서 잘 정의된 의미 체계를 가지고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-126">It has well-defined semantics in terms of idempotency, side effects, and response codes.</span></span> <span data-ttu-id="45ad7-127">또한 확장성을 개선하는 상태 비저장 통신을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-127">And it enforces stateless communication, which improves scalability.</span></span>

- <span data-ttu-id="45ad7-128">RPC는 작업 또는 명령을 더 지향합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-128">RPC is more oriented around operations or commands.</span></span> <span data-ttu-id="45ad7-129">RPC 인터페이스는 로컬 메서드 호출과 같기 때문에 지나치게 번잡한 API를 디자인하게 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-129">Because RPC interfaces look like local method calls, it may lead you to design overly chatty APIs.</span></span> <span data-ttu-id="45ad7-130">그러나 RPC가 번잡해야 함을 의미하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-130">However, that doesn't mean RPC must be chatty.</span></span> <span data-ttu-id="45ad7-131">단지 인터페이스를 디자인할 때 주의해야 함을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-131">It just means you need to use care when designing the interface.</span></span>

<span data-ttu-id="45ad7-132">RESTful 인터페이스의 경우 가장 일반적인 선택은 JSON을 사용하는 HTTP를 통한 REST입니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-132">For a RESTful interface, the most common choice is REST over HTTP using JSON.</span></span> <span data-ttu-id="45ad7-133">RPC 스타일 인터페이스의 경우 gRPC, Apache Avro 및 Apache Thrift 등의 여러 인기 있는 프레임워크가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-133">For an RPC-style interface, there are several popular frameworks, including gRPC, Apache Avro, and Apache Thrift.</span></span>

<span data-ttu-id="45ad7-134">**효율성**</span><span class="sxs-lookup"><span data-stu-id="45ad7-134">**Efficiency**.</span></span> <span data-ttu-id="45ad7-135">속도, 메모리 및 페이로드 크기 측면에서 효율성을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-135">Consider efficiency in terms of speed, memory, and payload size.</span></span> <span data-ttu-id="45ad7-136">일반적으로 gRPC 기반 인터페이스는 HTTP를 통한 REST보다 빠릅니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-136">Typically a gRPC-based interface is faster than REST over HTTP.</span></span>

<span data-ttu-id="45ad7-137">**IDL(인터페이스 정의 언어)**</span><span class="sxs-lookup"><span data-stu-id="45ad7-137">**Interface definition language (IDL)**.</span></span> <span data-ttu-id="45ad7-138">IDL은 메서드, 매개 변수 및 API의 반환 값을 정의하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-138">An IDL is used to define the methods, parameters, and return values of an API.</span></span> <span data-ttu-id="45ad7-139">IDL은 클라이언트 코드, serialization 코드 및 API 설명서를 생성하는 데 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-139">An IDL can be used to generate client code, serialization code, and API documentation.</span></span> <span data-ttu-id="45ad7-140">IDL은 또한 Postman과 같은 API 테스트 도구로 사용될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-140">IDLs can also be consumed by API testing tools such as Postman.</span></span> <span data-ttu-id="45ad7-141">gRPC, Avro 및 Thrift 등의 프레임워크는 자체 IDL 사양을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-141">Frameworks such as gRPC, Avro, and Thrift define their own IDL specifications.</span></span> <span data-ttu-id="45ad7-142">HTTP를 통한 REST는 표준 IDL 형식을 갖지 않지만 일반적인 선택은 OpenAPI(이전의 Swagger)입니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-142">REST over HTTP does not have a standard IDL format, but a common choice is OpenAPI (formerly Swagger).</span></span> <span data-ttu-id="45ad7-143">또한 형식 정의 언어를 사용하지 않고 HTTP REST API를 만들 수도 있지만 코드 생성 및 테스트의 이점을 손실합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-143">You can also create an HTTP REST API without using a formal definition language, but then you lose the benefits of code generation and testing.</span></span>

<span data-ttu-id="45ad7-144">**직렬화**</span><span class="sxs-lookup"><span data-stu-id="45ad7-144">**Serialization**.</span></span> <span data-ttu-id="45ad7-145">개체는 연결을 통해 어떻게 직렬화되나요?</span><span class="sxs-lookup"><span data-stu-id="45ad7-145">How are objects serialized over the wire?</span></span> <span data-ttu-id="45ad7-146">옵션으로는 텍스트 기반 형식(주로 JSON) 및 프로토콜 버퍼와 같은 이진 형식이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-146">Options include text-based formats (primarily JSON) and binary formats such as protocol buffer.</span></span> <span data-ttu-id="45ad7-147">이진 형식은 일반적으로 텍스트 기반 형식보다 빠릅니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-147">Binary formats are generally faster than text-based formats.</span></span> <span data-ttu-id="45ad7-148">그러나 대부분의 언어 및 프레임워크는 JSON serialization을 지원하므로 JSON은 상호 운용성 면에서도 이점을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-148">However, JSON has advantages in terms of interoperability, because most languages and frameworks support JSON serialization.</span></span> <span data-ttu-id="45ad7-149">일부 serialization 형식은 고정된 스키마가 필요하고 일부는 스키마 정의 파일 컴파일이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-149">Some serialization formats require a fixed schema, and some require compiling a schema definition file.</span></span> <span data-ttu-id="45ad7-150">이 경우 이 단계를 빌드 프로세스로 통합해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-150">In that case, you'll need to incorporate this step into your build process.</span></span>

<span data-ttu-id="45ad7-151">**프레임워크 및 언어 지원**</span><span class="sxs-lookup"><span data-stu-id="45ad7-151">**Framework and language support**.</span></span> <span data-ttu-id="45ad7-152">HTTP는 거의 모든 프레임워크와 언어에서 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-152">HTTP is supported in nearly every framework and language.</span></span> <span data-ttu-id="45ad7-153">gRPC, Avro 및 Thrift 모두는 C++, C#, Java 및 Python에 대한 라이브러리를 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-153">gRPC, Avro, and Thrift all have libraries for C++, C#, Java, and Python.</span></span> <span data-ttu-id="45ad7-154">Thrift 및 gRPC도 Go를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-154">Thrift and gRPC also support Go.</span></span>

<span data-ttu-id="45ad7-155">**호환성 및 상호 운용성**</span><span class="sxs-lookup"><span data-stu-id="45ad7-155">**Compatibility and interoperability**.</span></span> <span data-ttu-id="45ad7-156">gRPC와 같은 프로토콜을 선택하는 경우 공용 API와 백 엔드 간에 프로토콜 변환 계층이 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-156">If you choose a protocol like gRPC, you may need a protocol translation layer between the public API and the back end.</span></span> <span data-ttu-id="45ad7-157">[게이트웨이](./gateway.md)는 해당 기능을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-157">A [gateway](./gateway.md) can perform that function.</span></span> <span data-ttu-id="45ad7-158">서비스 메시를 사용하는 경우 서비스 메시와 호환되는 프로토콜을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-158">If you are using a service mesh, consider which protocols are compatible with the service mesh.</span></span> <span data-ttu-id="45ad7-159">예를 들어 linkerd는 HTTP, Thrift 및 gRPC를 기본적으로 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-159">For example, linkerd has built-in support for HTTP, Thrift, and gRPC.</span></span>

<span data-ttu-id="45ad7-160">초기 권장 사항은 이진 프로토콜의 성능 이점이 필요한 경우가 아니면 HTTP를 통한 REST를 선택하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-160">Our baseline recommendation is to choose REST over HTTP unless you need the performance benefits of a binary protocol.</span></span> <span data-ttu-id="45ad7-161">HTTP를 통한 REST에는 특수 라이브러리가 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-161">REST over HTTP requires no special libraries.</span></span> <span data-ttu-id="45ad7-162">호출자는 서비스와 통신하는 클라이언트 스텁이 필요하지 않으므로 최소 결합을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-162">It creates minimal coupling, because callers don't need a client stub to communicate with the service.</span></span> <span data-ttu-id="45ad7-163">스키마 정의, 테스트 및 RESTful HTTP 엔드포인트의 모니터링을 지원하는 도구의 풍부한 에코 시스템이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-163">There is rich ecosystems of tools to support schema definitions, testing, and monitoring of RESTful HTTP endpoints.</span></span> <span data-ttu-id="45ad7-164">마지막으로 HTTP는 브라우저 클라이언트와 호환되므로 클라이언트와 백 엔드 간에 프로토콜 변환 계층이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-164">Finally, HTTP is compatible with browser clients, so you don't need a protocol translation layer between the client and the backend.</span></span>

<span data-ttu-id="45ad7-165">그러나 HTTP를 통한 REST를 선택하는 경우 시나리오에 적절하게 수행하는지 여부를 확인하도록 개발 프로세스 초기에 성능 및 부하 테스트를 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-165">However, if you choose REST over HTTP, you should do performance and load testing early in the development process, to validate whether it performs well enough for your scenario.</span></span>

## <a name="restful-api-design"></a><span data-ttu-id="45ad7-166">RESTful API 디자인</span><span class="sxs-lookup"><span data-stu-id="45ad7-166">RESTful API design</span></span>

<span data-ttu-id="45ad7-167">RESTful API를 디자인하기 위한 여러 리소스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-167">There are many resources for designing RESTful APIs.</span></span> <span data-ttu-id="45ad7-168">다음은 도움이 될 수 있는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-168">Here are some that you might find helpful:</span></span>

- [<span data-ttu-id="45ad7-169">API 디자인</span><span class="sxs-lookup"><span data-stu-id="45ad7-169">API design</span></span>](../best-practices/api-design.md)

- [<span data-ttu-id="45ad7-170">API 구현</span><span class="sxs-lookup"><span data-stu-id="45ad7-170">API implementation</span></span>](../best-practices/api-implementation.md)

- [<span data-ttu-id="45ad7-171">Microsoft REST API 지침</span><span class="sxs-lookup"><span data-stu-id="45ad7-171">Microsoft REST API Guidelines</span></span>](https://github.com/Microsoft/api-guidelines)

<span data-ttu-id="45ad7-172">다음은 염두에 두어야 할 몇 가지 특정 고려 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-172">Here are some specific considerations to keep in mind.</span></span>

- <span data-ttu-id="45ad7-173">내부 구현 세부 정보를 누출하거나 단순히 내부 데이터베이스 스키마를 반영하는 API를 주의하세요.</span><span class="sxs-lookup"><span data-stu-id="45ad7-173">Watch out for APIs that leak internal implementation details or simply mirror an internal database schema.</span></span> <span data-ttu-id="45ad7-174">API는 도메인을 모델링해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-174">The API should model the domain.</span></span> <span data-ttu-id="45ad7-175">서비스 간의 계약이며 이상적으로 일부 코드를 리팩터링했거나 데이터베이스 테이블을 정규화했기 때문이 아니라 새 기능이 추가되었을 때만 변경해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-175">It's a contract between services, and ideally should only change when new functionality is added, not just because you refactored some code or normalized a database table.</span></span>

- <span data-ttu-id="45ad7-176">모바일 애플리케이션 및 데스크톱 웹 브라우저와 같은 다양한 유형의 클라이언트에는 다른 페이로드 크기 또는 상호 작용 패턴이 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-176">Different types of client, such as mobile application and desktop web browser, may require different payload sizes or interaction patterns.</span></span> <span data-ttu-id="45ad7-177">해당 클라이언트에 대한 최적의 인터페이스를 노출하는 각 클라이언트에 대한 별도 백 엔드를 만드는 데 [프런트 엔드에 대한 백 엔드 패턴](../patterns/backends-for-frontends.md)을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-177">Consider using the [Backends for Frontends pattern](../patterns/backends-for-frontends.md) to create separate backends for each client, that expose an optimal interface for that client.</span></span>

- <span data-ttu-id="45ad7-178">부작용이 있는 작업의 경우 멱등원이 되도록 하고 PUT 메서드로 구현하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-178">For operations with side effects, consider making them idempotent and implementing them as PUT methods.</span></span> <span data-ttu-id="45ad7-179">안전한 재시도를 활성화하고 탄력성을 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-179">That will enable safe retries and can improve resiliency.</span></span> <span data-ttu-id="45ad7-180">[수집 및 워크플로](./ingestion-workflow.md#idempotent-vs-non-idempotent-operations)와 [서비스 간 통신](./interservice-communication.md) 챕터는 이 문제를 자세히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-180">The chapters [Ingestion and workflow](./ingestion-workflow.md#idempotent-vs-non-idempotent-operations) and [Interservice communication](./interservice-communication.md) discuss this issue in more detail.</span></span>

- <span data-ttu-id="45ad7-181">HTTP 메서드는 메서드가 응답을 즉시 반환하지만 서비스가 작업을 비동기적으로 수행하는 비동기 의미 체계를 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-181">HTTP methods can have asynchronous semantics, where the method returns a response immediately, but the service carries out the operation asynchronously.</span></span> <span data-ttu-id="45ad7-182">이 경우 메서드는 [HTTP 202](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) 응답 코드를 반환해야 합니다. 이는 요청이 처리를 위해 허용되었지만 처리가 아직 완료되지 않음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-182">In that case, the method should return an [HTTP 202](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) response code, which indicates the request was accepted for processing, but the processing is not yet completed.</span></span>

## <a name="mapping-rest-to-ddd-patterns"></a><span data-ttu-id="45ad7-183">DDD 패턴에 REST 매핑</span><span class="sxs-lookup"><span data-stu-id="45ad7-183">Mapping REST to DDD patterns</span></span>

<span data-ttu-id="45ad7-184">엔터티, 집계 및 값 개체와 같은 패턴은 도메인 모델의 개체에 특정 제약 조건을 넣도록 디자인되었습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-184">Patterns such as entity, aggregate, and value object are designed to place certain constraints on the objects in your domain model.</span></span> <span data-ttu-id="45ad7-185">DDD에 대한 많은 논의에서 패턴은 생성자 또는 속성 getter 및 setter와 같은 OO(개체 지향) 언어 개념을 사용하여 모델링됩니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-185">In many discussions of DDD, the patterns are modeled using object-oriented (OO) language concepts like constructors or property getters and setters.</span></span> <span data-ttu-id="45ad7-186">예를 들어 *값 개체*는 변경이 불가능해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-186">For example, *value objects* are supposed to be immutable.</span></span> <span data-ttu-id="45ad7-187">OO 프로그래밍 언어에서는 생성자에 값을 할당하고 속성을 읽기 전용으로 설정하여 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-187">In an OO programming language, you would enforce this by assigning the values in the constructor and making the properties read-only:</span></span>

```ts
export class Location {
    readonly latitude: number;
    readonly longitude: number;

    constructor(latitude: number, longitude: number) {
        if (latitude < -90 || latitude > 90) {
            throw new RangeError('latitude must be between -90 and 90');
        }
        if (longitude < -180 || longitude > 180) {
            throw new RangeError('longitude must be between -180 and 180');
        }
        this.latitude = latitude;
        this.longitude = longitude;
    }
}
```

<span data-ttu-id="45ad7-188">이러한 종류의 코딩 방법은 기존 모놀리식 애플리케이션을 빌드하는 경우에 특히 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-188">These sorts of coding practices are particularly important when building a traditional monolithic application.</span></span> <span data-ttu-id="45ad7-189">큰 코드 베이스와 함께 많은 하위 시스템은 `Location` 개체를 사용할 수 있으므로 개체에 대해 올바른 동작을 적용하는 것은 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-189">With a large code base, many subsystems might use the `Location` object, so it's important for the object to enforce correct behavior.</span></span>

<span data-ttu-id="45ad7-190">또 다른 예로 다른 부분의 애플리케이션이 데이터 저장소에 대해 직접 읽거나 쓰지 않도록 하는 리포지토리 패턴이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-190">Another example is the Repository pattern, which ensures that other parts of the application do not make direct reads or writes to the data store:</span></span>

<span data-ttu-id="45ad7-191">드론 리포지토리의 다이어그램[](./images/repository.png)</span><span class="sxs-lookup"><span data-stu-id="45ad7-191">!Diagram of a Drone Repository[](./images/repository.png)</span></span>

<span data-ttu-id="45ad7-192">그러나 마이크로 서비스 아키텍처에서 서비스는 동일한 코드 베이스를 공유하지 않고 데이터 저장소를 공유하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-192">In a microservices architecture, however, services don't share the same code base and don't share data stores.</span></span> <span data-ttu-id="45ad7-193">대신 API를 통해 통신합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-193">Instead, they communicate through APIs.</span></span> <span data-ttu-id="45ad7-194">Scheduler 서비스가 드론 서비스에서 드론에 대한 정보를 요청하는 경우를 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-194">Consider the case where the Scheduler service requests information about a drone from the Drone service.</span></span> <span data-ttu-id="45ad7-195">드론 서비스에는 코드를 통해 표시되는 드론의 내부 모델이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-195">The Drone service has its internal model of a drone, expressed through code.</span></span> <span data-ttu-id="45ad7-196">하지만 Scheduler는 이를 참조하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-196">But the Scheduler doesn't see that.</span></span> <span data-ttu-id="45ad7-197">대신 드론 엔터티의 *표현* &mdash; 아마도 HTTP 응답에서 JSON 개체를 다시 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-197">Instead, it gets back a *representation* of the drone entity &mdash; perhaps a JSON object in an HTTP response.</span></span>

![드론 서비스의 다이어그램](./images/ddd-rest.png)

<span data-ttu-id="45ad7-199">Scheduler 서비스는 드론 서비스의 내부 모델을 수정하거나 드론 서비스의 데이터 저장소에 작성할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-199">The Scheduler service can't modify the Drone service's internal models, or write to the Drone service's data store.</span></span> <span data-ttu-id="45ad7-200">즉, 드론 서비스를 구현하는 코드에는 기존 모놀리스의 코드와 비교하여 더 작은 노출된 노출 영역이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-200">That means the code that implements the Drone service has a smaller exposed surface area, compared with code in a traditional monolith.</span></span> <span data-ttu-id="45ad7-201">드론 서비스가 Location 클래스를 정의하는 경우 해당 클래스의 범위는 제한됩니다. &mdash; 다른 서비스는 클래스를 직접 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-201">If the Drone service defines a Location class, the scope of that class is limited &mdash; no other service will directly consume the class.</span></span>

<span data-ttu-id="45ad7-202">이러한 이유로, 전술적 DDD 패턴과 관련되어 있으므로 이 설명서는 코딩 방법에 많이 집중하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-202">For these reasons, this guidance doesn't focus much on coding practices as they relate to the tactical DDD patterns.</span></span> <span data-ttu-id="45ad7-203">그러나 사실상 REST API를 통해 많은 DDD 패턴을 모델링할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-203">But it turns out that you can also model many of the DDD patterns through REST APIs.</span></span>

<span data-ttu-id="45ad7-204">예: </span><span class="sxs-lookup"><span data-stu-id="45ad7-204">For example:</span></span>

- <span data-ttu-id="45ad7-205">집계는 REST에서 *리소스*에 자연스럽게 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-205">Aggregates map naturally to *resources* in REST.</span></span> <span data-ttu-id="45ad7-206">예를 들어 Delivery 집계는 Delivery API로 리소스로 노출되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-206">For example, the Delivery aggregate would be exposed as a resource by the Delivery API.</span></span>

- <span data-ttu-id="45ad7-207">집계는 일관성 경계입니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-207">Aggregates are consistency boundaries.</span></span> <span data-ttu-id="45ad7-208">집계에 대한 작업은 항상 일관성 없는 상태의 집계를 유지해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-208">Operations on aggregates should never leave an aggregate in an inconsistent state.</span></span> <span data-ttu-id="45ad7-209">따라서 클라이언트가 집계의 내부 상태를 조작하도록 허용하는 API를 작성하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="45ad7-209">Therefore, you should avoid creating APIs that allow a client to manipulate the internal state of an aggregate.</span></span> <span data-ttu-id="45ad7-210">대신 리소스 그룹으로 집계를 노출하는 정교하지 않은 API를 선호합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-210">Instead, favor coarse-grained APIs that expose aggregates as resources.</span></span>

- <span data-ttu-id="45ad7-211">엔터티는 고유한 ID를 가집니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-211">Entities have unique identities.</span></span> <span data-ttu-id="45ad7-212">REST에서 리소스는 URL의 형식으로 고유 식별자를 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-212">In REST, resources have unique identifiers in the form of URLs.</span></span> <span data-ttu-id="45ad7-213">엔터티의 도메인 ID에 해당하는 리소스 URL을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-213">Create resource URLs that correspond to an entity's domain identity.</span></span> <span data-ttu-id="45ad7-214">URL에서 도메인 ID로의 매핑은 클라이언트에 불투명할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-214">The mapping from URL to domain identity may be opaque to client.</span></span>

- <span data-ttu-id="45ad7-215">집계의 자식 엔터티는 루트 엔터티를 탐색하여 도달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-215">Child entities of an aggregate can be reached by navigating from the root entity.</span></span> <span data-ttu-id="45ad7-216">[HATEOAS](https://en.wikipedia.org/wiki/HATEOAS) 원칙을 따르는 경우 자식 엔터티는 부모 엔터티의 표현에서 링크를 통해 도달될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-216">If you follow [HATEOAS](https://en.wikipedia.org/wiki/HATEOAS) principles, child entities can be reached via links in the representation of the parent entity.</span></span>

- <span data-ttu-id="45ad7-217">값 개체를 변경할 수 없기 때문에 업데이트는 전체 값 개체를 대체하여 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-217">Because value objects are immutable, updates are performed by replacing the entire value object.</span></span> <span data-ttu-id="45ad7-218">REST에서 구현은 PUT 또는 PATCH 요청을 통해 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-218">In REST, implement updates through PUT or PATCH requests.</span></span>

- <span data-ttu-id="45ad7-219">리포지토리는 클라이언트가 기본 데이터 저장소의 세부 정보를 추상화하여 컬렉션의 개체를 쿼리, 추가 또는 제거할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-219">A repository lets clients query, add, or remove objects in a collection, abstracting the details of the underlying data store.</span></span> <span data-ttu-id="45ad7-220">REST에서 컬렉션은 컬렉션을 쿼리하거나 컬렉션에 새 엔터티를 추가하기 위한 메서드를 사용하여 고유한 리소스가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-220">In REST, a collection can be a distinct resource, with methods for querying the collection or adding new entities to the collection.</span></span>

<span data-ttu-id="45ad7-221">API를 디자인할 때 도메인 모델을 표현하는 방법, 모델 내의 데이터뿐 아니라 비즈니스 작업 및 데이터에 대한 제약 조건을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-221">When you design your APIs, think about how they express the domain model, not just the data inside the model, but also the business operations and the constraints on the data.</span></span>

| <span data-ttu-id="45ad7-222">DDD 개념</span><span class="sxs-lookup"><span data-stu-id="45ad7-222">DDD concept</span></span> | <span data-ttu-id="45ad7-223">REST 해당 항목</span><span class="sxs-lookup"><span data-stu-id="45ad7-223">REST equivalent</span></span> | <span data-ttu-id="45ad7-224">예</span><span class="sxs-lookup"><span data-stu-id="45ad7-224">Example</span></span> |
|-------------|-----------------|---------|
| <span data-ttu-id="45ad7-225">집계</span><span class="sxs-lookup"><span data-stu-id="45ad7-225">Aggregate</span></span> | <span data-ttu-id="45ad7-226">리소스</span><span class="sxs-lookup"><span data-stu-id="45ad7-226">Resource</span></span> | `{ "1":1234, "status":"pending"... }` |
| <span data-ttu-id="45ad7-227">ID</span><span class="sxs-lookup"><span data-stu-id="45ad7-227">Identity</span></span> | <span data-ttu-id="45ad7-228">URL</span><span class="sxs-lookup"><span data-stu-id="45ad7-228">URL</span></span> | `https://delivery-service/deliveries/1` |
| <span data-ttu-id="45ad7-229">자식 엔터티</span><span class="sxs-lookup"><span data-stu-id="45ad7-229">Child entities</span></span> | <span data-ttu-id="45ad7-230">링크</span><span class="sxs-lookup"><span data-stu-id="45ad7-230">Links</span></span> | `{ "href": "/deliveries/1/confirmation" }` |
| <span data-ttu-id="45ad7-231">업데이트 값 개체</span><span class="sxs-lookup"><span data-stu-id="45ad7-231">Update value objects</span></span> | <span data-ttu-id="45ad7-232">PUT 또는 PATCH</span><span class="sxs-lookup"><span data-stu-id="45ad7-232">PUT or PATCH</span></span> | `PUT https://delivery-service/deliveries/1/dropoff` |
| <span data-ttu-id="45ad7-233">리포지토리</span><span class="sxs-lookup"><span data-stu-id="45ad7-233">Repository</span></span> | <span data-ttu-id="45ad7-234">컬렉션</span><span class="sxs-lookup"><span data-stu-id="45ad7-234">Collection</span></span> | `https://delivery-service/deliveries?status=pending` |

## <a name="api-versioning"></a><span data-ttu-id="45ad7-235">API 버전 관리</span><span class="sxs-lookup"><span data-stu-id="45ad7-235">API versioning</span></span>

<span data-ttu-id="45ad7-236">API는 서비스와 클라이언트 또는 해당 서비스의 소비자 간의 계약입니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-236">An API is a contract between a service and clients or consumers of that service.</span></span> <span data-ttu-id="45ad7-237">API가 변경되는 경우 API, 외부 클라이언트 또는 다른 마이크로 서비스인지 여부에 따라 클라이언트 손상의 위험이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-237">If an API changes, there is a risk of breaking clients that depend on the API, whether those are external clients or other microservices.</span></span> <span data-ttu-id="45ad7-238">따라서 API 변경 내용의 수를 최소화하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-238">Therefore, it's a good idea to minimize the number of API changes that you make.</span></span> <span data-ttu-id="45ad7-239">대개 기본 구현의 변경 내용은 API에 대한 변경 내용이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-239">Often, changes in the underlying implementation don't require any changes to the API.</span></span> <span data-ttu-id="45ad7-240">그러나 실제적으로 일부 시점에서 기존 API를 변경해야 하는 새 기능을 추가하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-240">Realistically, however, at some point you will want to add new features or new capabilities that require changing an existing API.</span></span>

<span data-ttu-id="45ad7-241">가능할 때마다 API 변경 내용을 이전 버전과 호환되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-241">Whenever possible, make API changes backward compatible.</span></span> <span data-ttu-id="45ad7-242">예를 들어 필드가 해당 위치에 있기를 예상하는 클라이언트를 손상시킬 수 있기 때문에 모델에서 필드를 제거하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="45ad7-242">For example, avoid removing a field from a model, because that can break clients that expect the field to be there.</span></span> <span data-ttu-id="45ad7-243">클라이언트는 응답에서 인식하지 않는 모든 필드를 무시해야 하기 때문에 필드 추가는 호환성을 손상시키지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-243">Adding a field does not break compatibility, because clients should ignore any fields they don't understand in a response.</span></span> <span data-ttu-id="45ad7-244">그러나 서비스는 이전 클라이언트가 요청에서 새 필드를 생략하는 경우를 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-244">However, the service must handle the case where an older client omits the new field in a request.</span></span>

<span data-ttu-id="45ad7-245">API 계약의 버전 관리를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-245">Support versioning in your API contract.</span></span> <span data-ttu-id="45ad7-246">주요 API 변경 내용을 도입하는 경우 새로운 API 버전을 소개합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-246">If you introduce a breaking API change, introduce a new API version.</span></span> <span data-ttu-id="45ad7-247">이전 버전을 계속해서 지원하고 클라이언트가 호출할 버전을 선택하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-247">Continue to support the previous version, and let clients select which version to call.</span></span> <span data-ttu-id="45ad7-248">이 작업을 수행하는 몇 가지 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-248">There are a couple of ways to do this.</span></span> <span data-ttu-id="45ad7-249">하나는 단순히 동일한 서비스에서 두 버전을 노출하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-249">One is simply to expose both versions in the same service.</span></span> <span data-ttu-id="45ad7-250">다른 옵션은 서비스의 두 버전을 나란히 실행하고 HTTP 라우팅 규칙에 따라 하나 또는 다른 버전에 대한 요청을 라우팅하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-250">Another option is to run two versions of the service side-by-side, and route requests to one or the other version, based on HTTP routing rules.</span></span>

![버전 관리](./images/versioning1.svg)

<span data-ttu-id="45ad7-252">개발자 시간, 테스트 및 작업 오버헤드 측면에서 여러 버전을 지원하는 데 비용이 듭니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-252">There's a cost to supporting multiple versions, in terms of developer time, testing, and operational overhead.</span></span> <span data-ttu-id="45ad7-253">따라서 가능한 빨리 이전 버전을 사용할 수 없게 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-253">Therefore, it's good to deprecate old versions as quickly as possible.</span></span> <span data-ttu-id="45ad7-254">내부 API의 경우 API를 소유하는 팀은 다른 팀이 새 버전으로 마이그레이션하는 것을 돕도록 함께 작업할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-254">For internal APIs, the team that owns the API can work with other teams to help them migrate to the new version.</span></span> <span data-ttu-id="45ad7-255">이는 팀 간 거버넌스 프로세스를 수행하는 것이 유용한 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-255">This is when having a cross-team governance process is useful.</span></span> <span data-ttu-id="45ad7-256">외부(공용) API의 경우 특히 타사 또는 네이티브 클라이언트 애플리케이션에서 API를 사용하는 경우 API 버전을 사용할 수 없도록 하는 것은 더 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-256">For external (public) APIs, it can be harder to deprecate an API version, especially if the API is consumed by third parties or by native client applications.</span></span>

<span data-ttu-id="45ad7-257">서비스 구현이 변경되면 버전으로 변경 내용을 태그하는 것은 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-257">When a service implementation changes, it's useful to tag the change with a version.</span></span> <span data-ttu-id="45ad7-258">버전은 오류 문제를 해결할 때 중요한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-258">The version provides important information when troubleshooting errors.</span></span> <span data-ttu-id="45ad7-259">근본 원인 분석이 호출된 서비스의 버전을 정확하게 아는 데 매우 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-259">It can be very helpful for root cause analysis to know exactly which version of the service was called.</span></span> <span data-ttu-id="45ad7-260">서비스 버전에 대해 [의미 체계 버전 관리](https://semver.org/)를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-260">Consider using [semantic versioning](https://semver.org/) for service versions.</span></span> <span data-ttu-id="45ad7-261">의미 체계 버전 관리는 *MAJOR.MINOR.PATCH* 형식을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-261">Semantic versioning uses a *MAJOR.MINOR.PATCH* format.</span></span> <span data-ttu-id="45ad7-262">그러나 클라이언트는 부 버전 간에 상당한(하지만 주요하지 않은) 변경 내용이 있는 경우 주 버전 번호 또는 가능한 부 버전으로 API를 선택해야만 합니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-262">However, clients should only select an API by the major version number, or possibly the minor version if there are significant (but non-breaking) changes between minor versions.</span></span> <span data-ttu-id="45ad7-263">즉, 클라이언트는 버전 2.1.3을 선택하지 않고 API의 버전 1과 2 사이에서 선택하는 것이 합리적입니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-263">In other words, it's reasonable for clients to select between version 1 and version 2 of an API, but not to select version 2.1.3.</span></span> <span data-ttu-id="45ad7-264">해당 수준의 세분성을 허용하는 경우 버전의 환산을 지원해야 하는 위험이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="45ad7-264">If you allow that level of granularity, you risk having to support a proliferation of versions.</span></span>

<span data-ttu-id="45ad7-265">API 버전 관리에 대한 자세한 내용은 [RESTful 웹 API 버전 관리](../best-practices/api-design.md#versioning-a-restful-web-api)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="45ad7-265">For further discussion of API versioning, see [Versioning a RESTful web API](../best-practices/api-design.md#versioning-a-restful-web-api).</span></span>

> [!div class="nextstepaction"]
> [<span data-ttu-id="45ad7-266">수집 및 워크플로</span><span class="sxs-lookup"><span data-stu-id="45ad7-266">Ingestion and workflow</span></span>](./ingestion-workflow.md)