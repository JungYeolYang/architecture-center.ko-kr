---
title: 마이크로 서비스에 대한 CI/CD
description: 마이크로서비스에 대한 지속적인 통합 및 지속적인 전송
author: MikeWasson
ms.date: 03/27/2019
ms.topic: guide
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: microservices
ms.openlocfilehash: c52ff3d0a330f564e5f7e9b0b07f0ba84c328c8b
ms.sourcegitcommit: 579c39ff4b776704ead17a006bf24cd4cdc65edd
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/17/2019
ms.locfileid: "59639787"
---
# <a name="cicd-for-microservices-architectures"></a>마이크로 서비스 아키텍처의 CI/CD

더 빠른 릴리스 주기는 마이크로 서비스 아키텍처의 주요 이점 중 하나입니다. 하지만 좋은 CI/CD 프로세스 없이 마이크로 서비스가 약속 하는 민첩성을 달성 하지 않습니다. 이 문서는 문제를 설명 하 고 문제에 몇 가지 접근 방식을 권장 합니다.

## <a name="what-is-cicd"></a>CI/CD 란?

CI/CD를 말할 때 실제로 얘기 하 고 여러 관련된 프로세스에 대 한 합니다. 지속적인 통합, 지속적인 전송 및 지속적인 배포.

- **연속 통합**합니다. 코드 변경 내용이 주 분기로 자주 병합 됩니다. 빌드 자동화 된 테스트 프로세스 main 분기의 코드는 프로덕션 품질 항상 확인 합니다.

- **지속적인**합니다. CI 프로세스를 통과 하는 모든 코드 변경 내용은 프로덕션 환경과 유사한 환경에 자동으로 게시 됩니다. 라이브 프로덕션 환경으로 배포에는 수동 승인이 필요할 수 있지만 그렇지 않은 경우 자동화됩니다. 목표는 코드가 항상 프로덕션 환경으로 배포될 *준비*가 되어야 하는 것입니다.

- **연속 배포**. 코드 변경 이전의 두 단계를 자동으로 배포 성공 *프로덕션 환경에*입니다.

마이크로 서비스 아키텍처에 대한 강력한 CI/CD 프로세스의 목표는 다음과 같습니다.

- 각 팀은 다른 팀에 영향을 주거나 방해하지 않고 독립적으로 소유한 서비스를 빌드하여 배포할 수 있습니다.

- 새 버전의 서비스를 프로덕션 환경에 배포하기 전에 개발/테스트/QA 환경에 배포하여 유효성을 검사합니다. 각 단계에서 품질 게이트를 적용합니다.

- 서비스의 새 버전은 이전 버전과 함께 배포할 수 있습니다.

- 충분한 액세스 제어 정책을 적용합니다.

- 컨테이너 화 된 워크 로드의 경우 프로덕션에 배포 된 컨테이너 이미지를 신뢰할 수 있습니다.

## <a name="why-a-robust-cicd-pipeline-matters"></a>강력한 CI/CD 파이프라인을 중요 한 이유

기존의 모놀리식 응용 프로그램에서 해당 출력에는 응용 프로그램의 실행은 단일 빌드 파이프라인이 있습니다. 모든 개발 작업은 이 파이프라인으로 피드합니다. 우선 순위가 높은 버그가 발견되는 경우 수정은 통합, 테스트 및 게시되어야 합니다. 이는 새로운 기능의 릴리스를 지연시킬 수 있습니다. 잘 구성 된 모듈 및 코드 변경 내용의 영향을 최소화 하도록 기능 분기를 사용 하 여 이러한 문제를 완화할 수 있습니다. 하지만 애플리케이션 증가가 더욱 복잡해지고 더 많은 기능이 추가될수록 모놀리식에 대한 릴리스 프로세스는 더욱 불안정해지고 손상될 가능성이 많아지는 경향이 있습니다.

마이크로 서비스 기본 원칙을 따르면 모든 팀이 줄을 서야 하는 긴 릴리스 기차가 없어야 합니다. 서비스 "A"를 빌드하는 팀은 병합, 테스트 및 배포될 서비스 "B"의 변경 내용을 기다릴 필요 없이 언제든지 업데이트를 릴리스할 수 있습니다.

![CI/CD 모놀리식의 다이어그램](./images/cicd-monolith.png)

높은 릴리스 개발 속도 위해 릴리스 파이프라인 자동화 되 고 위험을 최소화 하기 위해 매우 안정적 이어야 합니다. 매일 또는 하루에 여러 번 프로덕션에 릴리스, 재발 또는 서비스 중단 매우 드물어 야 합니다. 동시에 잘못된 업데이트가 배포되는 경우 이전 버전의 서비스로 롤백하거나 롤포워드하는 신뢰할 수 있는 방법이 있어야 합니다.

## <a name="challenges"></a>과제

- **다수의 작은 독립적인 코드 베이스** 각 팀은 자체 빌드 파이프라인으로 자체 서비스 구축을 담당합니다. 일부 조직에서 팀은 별도 코드 리포지토리를 사용할 수 있습니다. 별도 저장소 시스템을 구축 하는 방법의 기술 팀 간에 분산 되 고 전체 응용 프로그램을 배포 하는 방법을 알고 있는 조직에서 아무도 있는 상황이 발생할 수 있습니다. 예를 들어 새 클러스터에 빠르게 배포해야 하는 경우 재해 복구 시나리오에서 무슨 일이 발생하나요?

    **해결 방법**: 이 기술 숨겨져 있지 않으면"" 각 팀 내에서 되도록 빌드 서비스를 배포 하는 통합 및 자동화 된 파이프라인 경우

- **여러 언어 및 프레임워크** 자체 기술 조합을 사용하는 각 팀과 함께 조직 전체에서 작동하는 단일 빌드 프로세스를 만드는 것은 어려울 수 있습니다. 빌드 프로세스는 모든 팀이 언어 또는 프레임워크의 선택으로 채택할 만큼 충분히 유연해야 합니다.

    **해결 방법**: 각 서비스에 대 한 빌드 프로세스를 컨테이너 화 합니다. 이런 방식으로 빌드 시스템만 해야 컨테이너를 실행할 수 있도록 합니다.

- **통합 및 부하 테스트** 팀의 페이스로 업데이트를 릴리스하는 팀과 함께 특히 서비스에 다른 서비스에 대한 종속성이 있는 경우 강력한 종단 간 테스트를 디자인하는 것은 어려울 수 있습니다. 또한 전체 프로덕션 클러스터를 실행 부담이 클 수 있으므로 모든 팀 단지 테스트만 위해 프로덕션 규모에서 자체 전체 클러스터를 실행 되는 가능성이 없습니다.

- **릴리스 관리** 모든 팀 프로덕션에 업데이트를 배포할 수 있어야 합니다. 모든 팀 멤버가 그렇게 할 권한이 있음을 의미하는 것은 아닙니다. 하지만 중앙 집중식 릴리스 관리자 역할을 가지면 배포의 개발 속도를 줄일 수 있습니다.

    **해결 방법**: CI/CD 프로세스가 더욱 자동화되고 안정적이 될수록 중앙 기관에 대한 필요가 적어져야 합니다. 즉, 주요 기능 업데이트와 사소한 버그 수정 릴리스에 대해 다른 정책을 가질 수 있습니다. 분산 되는 0 거 버 넌 스를 의미 하지 않습니다.

- **서비스 업데이트** 서비스를 새 버전으로 업데이트하는 경우 종속된 다른 서비스를 중단하지 않아야 합니다.

    **해결 방법**: 사소한 변경 내용에 대 한 파란색 녹색 또는 카나리아 릴리스 같은 배포 기술을 사용 합니다. 주요 API 변경 내용에 대 한 이전 버전과 함께 새 버전을 배포 합니다. 이런 방식으로 이전 API를 사용 하는 서비스 업데이트 및 테스트할 수 새로운 API에 대 한 합니다. 참조 [서비스 업데이트](#updating-services)아래.

## <a name="monorepo-vs-multi-repo"></a>Monorepo vs 여러 리포지토리

CI/CD 워크플로를 만들기 전에 코드 베이스가 구조화되고 관리되는 방법을 알아야 합니다.

- 팀을 monorepo (단일 리포지토리) 또는 별도 저장소에서 작동 하나요?
- 분기 전략은 무엇입니까?
- 프로덕션 환경에 코드를 푸시할 수 있는 사람은 누구입니까? 릴리스 관리자 역할이 있습니까?

단일 리포지토리 접근법이 지지를 받고 있지만 두 방식에는 모두 장단점이 있습니다.

| &nbsp; | 단일 리포지토리 | 다중 리포지토리 |
|--------|----------|----------------|
| **장점** | 코드 공유<br/>코드 및 도구 표준화 용이<br/>코드 리팩터링 용이<br/>검색 기능 - 코드의 단일 보기<br/> | 팀별로 명확한 소유권<br/>잠재적으로 더 적은 병합 충돌<br/>마이크로 서비스를 강제로 분리하는 데 유용 |
| **과제** | 공유 코드에 대한 변경 사항이 여러 마이크로 서비스에 영향을 줄 수 있음<br/>병합 충돌 가능성 증가<br/>대규모 코드 베이스에 맞게 도구를 확장해야 함<br/>액세스 제어<br/>더 복잡한 배포 프로세스 | 코드를 공유하기가 더 어려움<br/>코딩 표준을 적용하기가 더 어려움<br/>종속성 관리<br/>분산된 코드 베이스, 검색 기능 저하<br/>공유 인프라 결여

## <a name="updating-services"></a>서비스 업데이트

이미 프로덕션 환경에 있는 서비스를 업데이트하기 위한 다양한 전략이 있습니다. 여기에서는 다음과 같은 세 가지 일반 옵션을 설명합니다. 롤링 업데이트, 청록색 배포 및 카나리아 릴리스.

### <a name="rolling-updates"></a>롤링 업데이트

롤링 업데이트에서 서비스의 새 인스턴스를 배포하고 새 인스턴스는 즉시 요청 수신을 시작합니다. 새 인스턴스가 나타나면 이전 인스턴스가 제거됩니다.

**예제.** Kubernetes의 경우에서 롤링 업데이트는 배포의 pod 사양을 업데이트할 때 기본 동작입니다. 배포 컨트롤러는 업데이트된 Pod에 대한 새 ReplicaSet를 만듭니다. 그런 다음 원하는 복제본 수를 유지하도록 기존 것을 축소하는 동안 새 ReplicaSet를 확장합니다. 새 것이 준비될 때까지 이전 Pod를 삭제하지 않습니다. Kubernetes 롤업할 수 있도록 다시 업데이트 필요한 경우 업데이트의 기록을 유지 합니다.

롤링 업데이트의 한 가지 문제는 업데이트 프로세스 중 이전 버전과 새 버전의 혼합이 실행되고 트래픽을 수신한다는 것입니다. 이 기간 동안 모든 요청은 두 버전 중 하나로 라우팅될 수 있습니다.

주요 API 변경 내용에 대 한 이전 버전의 모든 클라이언트가 업데이트 될 때까지 두 버전 모두 나란히 지원 하는 것이 좋습니다. 참조 [API 버전 관리](./design/api-design.md#api-versioning)합니다.

### <a name="blue-green-deployment"></a>청록색 배포

청록색 배포에서 이전 버전과 함께 새 버전을 배포합니다. 새 버전의 유효성을 검사한 후 이전 버전에서 새 버전으로 모든 트래픽을 한 번에 전환합니다. 전환 후 모든 문제에 대해 애플리케이션을 모니터링합니다. 문제가 발생하는 경우 이전 버전으로 바꿀 수 있습니다. 문제가 없는 경우 이전 버전을 삭제할 수 있습니다.

더 일반적인 모놀리식 또는 N 계층 애플리케이션으로 청록색 배포는 일반적으로 두 개의 동일한 환경 프로비전을 의미했습니다. 스테이징 환경에 새 버전을 배포한 다음 스테이징 환경에 클라이언트 트래픽을 리디렉션합니다. &mdash; 예를 들어 VIP 주소를 교환하여 리디렉션합니다. 일반적으로 동일한 환경에 업데이트를 배포 하는 서비스 검색 메커니즘을 사용 하 여 교환할 수 있도록 업데이트는 마이크로 서비스 아키텍처에서 마이크로 서비스 수준에서 발생 합니다.

**예제**. Kubernetes에서는 청록색 배포를 수행하기 위해 별도 클러스터를 프로비전할 필요가 없습니다. 대신 선택기를 활용할 수 있습니다. 새 Pod 사양 및 다른 집합의 레이블을 사용하여 새 배포 리소스를 만듭니다. 이전 배포를 삭제하거나 이를 가리키는 서비스를 수정하지 않고 이 배포를 만듭니다. 새 Pod가 실행되면 새 배포에 맞게 해당 서비스의 선택기를 업데이트할 수 있습니다.

청록색 배포의 한 가지 단점은 업데이트 중를 실행 하는 배의 서비스에 대해 pod (현재 및 다음) 됩니다. Pod에 CPU 또는 메모리 리소스가 많이 필요한 경우 리소스 사용을 처리하기 위해 클러스터를 일시적으로 확장해야 합니다.

### <a name="canary-release"></a>카나리아 릴리스

카나리아 릴리스에서는 업데이트된 버전을 적은 수의 클라이언트로 롤아웃합니다. 그런 다음 모든 클라이언트에 롤아웃하기 전에 새로운 서비스의 동작을 모니터링합니다. 이를 통해 제어된 방식으로 느린 출시를 수행하고, 모든 고객이 영향을 받기 전에 실제 데이터와 스폿 문제를 확인할 수 있습니다.

카나리아 릴리스는 요청을 서로 다른 버전의 서비스로 동적으로 라우팅해야 하기 때문에 청록색 또는 롤링 업데이트보다 관리하기가 복잡합니다.

**예제**. Kubernetes에서는 두 개의 복제본 세트(각 버전에 대해 하나씩)를 확장하고 복제본 수를 수동으로 조정하도록 서비스를 구성할 수 있습니다. 그러나 이 방법은 Kubernetes가 Pod에 대해 부하를 분산하는 방식으로 인해 정교하지 않습니다. 예를 들어, 총 10 개의 복제본의 경우 10% 단위로 트래픽을 이동할 수 있습니다. 서비스 메시를 사용하는 경우 서비스 메시 라우팅 규칙을 사용하여 보다 정교한 카나리아 릴리스 전략을 구현할 수 있습니다.

## <a name="next-steps"></a>다음 단계

Kubernetes에서 실행 되는 마이크로 서비스에 대 한 특정 CI/CD 사례를 알아봅니다.

- [Kubernetes에서 마이크로 서비스에 대 한 CI/CD](./ci-cd-kubernetes.md)