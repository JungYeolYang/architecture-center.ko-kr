---
title: 마이크로 서비스에 대한 CI/CD
description: 마이크로서비스에 대한 지속적인 통합 및 지속적인 전송
author: MikeWasson
ms.date: 03/27/2019
ms.topic: guide
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: microservices
ms.openlocfilehash: f7f3f3d48087db51c40f134e3e4cf11ec58501bb
ms.sourcegitcommit: d58e6b2b891c9c99e951c59f15fce71addcb96b1
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/12/2019
ms.locfileid: "59533093"
---
# <a name="cicd-for-microservices-architectures"></a><span data-ttu-id="aed82-103">마이크로 서비스 아키텍처의 CI/CD</span><span class="sxs-lookup"><span data-stu-id="aed82-103">CI/CD for microservices architectures</span></span>

<span data-ttu-id="aed82-104">더 빠른 릴리스 주기는 마이크로 서비스 아키텍처의 주요 이점 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-104">Faster release cycles are one of the major advantages of microservices architectures.</span></span> <span data-ttu-id="aed82-105">하지만 좋은 CI/CD 프로세스 없이 마이크로 서비스가 약속 하는 민첩성을 달성 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-105">But without a good CI/CD process, you won't achieve the agility that microservices promise.</span></span> <span data-ttu-id="aed82-106">이 문서는 문제를 설명 하 고 문제에 몇 가지 접근 방식을 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-106">This article describes the challenges and recommends some approaches to the problem.</span></span>

## <a name="what-is-cicd"></a><span data-ttu-id="aed82-107">CI/CD 란?</span><span class="sxs-lookup"><span data-stu-id="aed82-107">What is CI/CD?</span></span>

<span data-ttu-id="aed82-108">CI/CD를 말할 때 실제로 얘기 하 고 여러 관련된 프로세스에 대 한 합니다. 지속적인 통합, 지속적인 전송 및 지속적인 배포.</span><span class="sxs-lookup"><span data-stu-id="aed82-108">When we talk about CI/CD, we're really talking about several related processes: Continuous integration, continuous delivery, and continuous deployment.</span></span>

- <span data-ttu-id="aed82-109">**연속 통합**합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-109">**Continuous integration**.</span></span> <span data-ttu-id="aed82-110">코드 변경 내용이 주 분기로 자주 병합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-110">Code changes are frequently merged into the main branch.</span></span> <span data-ttu-id="aed82-111">빌드 자동화 된 테스트 프로세스 main 분기의 코드는 프로덕션 품질 항상 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-111">Automated build and test processes ensure that code in the main branch is always production-quality.</span></span>

- <span data-ttu-id="aed82-112">**지속적인**합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-112">**Continuous delivery**.</span></span> <span data-ttu-id="aed82-113">CI 프로세스를 통과 하는 모든 코드 변경 내용은 프로덕션 환경과 유사한 환경에 자동으로 게시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-113">Any code changes that pass the CI process are automatically published to a production-like environment.</span></span> <span data-ttu-id="aed82-114">라이브 프로덕션 환경으로 배포에는 수동 승인이 필요할 수 있지만 그렇지 않은 경우 자동화됩니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-114">Deployment into the live production environment may require manual approval, but is otherwise automated.</span></span> <span data-ttu-id="aed82-115">목표는 코드가 항상 프로덕션 환경으로 배포될 *준비*가 되어야 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-115">The goal is that your code should always be *ready* to deploy into production.</span></span>

- <span data-ttu-id="aed82-116">**연속 배포**.</span><span class="sxs-lookup"><span data-stu-id="aed82-116">**Continuous deployment**.</span></span> <span data-ttu-id="aed82-117">코드 변경 이전의 두 단계를 자동으로 배포 성공 *프로덕션 환경에*입니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-117">Code changes that pass the previous two steps are automatically deployed *into production*.</span></span>

<span data-ttu-id="aed82-118">마이크로 서비스 아키텍처에 대한 강력한 CI/CD 프로세스의 목표는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-118">Here are some goals of a robust CI/CD process for a microservices architecture:</span></span>

- <span data-ttu-id="aed82-119">각 팀은 다른 팀에 영향을 주거나 방해하지 않고 독립적으로 소유한 서비스를 빌드하여 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-119">Each team can build and deploy the services that it owns independently, without affecting or disrupting other teams.</span></span>

- <span data-ttu-id="aed82-120">새 버전의 서비스를 프로덕션 환경에 배포하기 전에 개발/테스트/QA 환경에 배포하여 유효성을 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-120">Before a new version of a service is deployed to production, it gets deployed to dev/test/QA environments for validation.</span></span> <span data-ttu-id="aed82-121">각 단계에서 품질 게이트를 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-121">Quality gates are enforced at each stage.</span></span>

- <span data-ttu-id="aed82-122">서비스의 새 버전은 이전 버전과 함께 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-122">A new version of a service can be deployed side by side with the previous version.</span></span>

- <span data-ttu-id="aed82-123">충분한 액세스 제어 정책을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-123">Sufficient access control policies are in place.</span></span>

- <span data-ttu-id="aed82-124">컨테이너 화 된 워크 로드의 경우 프로덕션에 배포 된 컨테이너 이미지를 신뢰할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-124">For containerized workloads, you can trust the container images that are deployed to production.</span></span>

## <a name="why-a-robust-cicd-pipeline-matters"></a><span data-ttu-id="aed82-125">강력한 CI/CD 파이프라인을 중요 한 이유</span><span class="sxs-lookup"><span data-stu-id="aed82-125">Why a robust CI/CD pipeline matters</span></span>

<span data-ttu-id="aed82-126">기존의 모놀리식 응용 프로그램에서 해당 출력에는 응용 프로그램의 실행은 단일 빌드 파이프라인이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-126">In a traditional monolithic application, there is a single build pipeline whose output is the application executable.</span></span> <span data-ttu-id="aed82-127">모든 개발 작업은 이 파이프라인으로 피드합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-127">All development work feeds into this pipeline.</span></span> <span data-ttu-id="aed82-128">우선 순위가 높은 버그가 발견되는 경우 수정은 통합, 테스트 및 게시되어야 합니다. 이는 새로운 기능의 릴리스를 지연시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-128">If a high-priority bug is found, a fix must be integrated, tested, and published, which can delay the release of new features.</span></span> <span data-ttu-id="aed82-129">잘 구성 된 모듈 및 코드 변경 내용의 영향을 최소화 하도록 기능 분기를 사용 하 여 이러한 문제를 완화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-129">You can mitigate these problems by having well-factored modules and using feature branches to minimize the impact of code changes.</span></span> <span data-ttu-id="aed82-130">하지만 애플리케이션 증가가 더욱 복잡해지고 더 많은 기능이 추가될수록 모놀리식에 대한 릴리스 프로세스는 더욱 불안정해지고 손상될 가능성이 많아지는 경향이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-130">But as the application grows more complex, and more features are added, the release process for a monolith tends to become more brittle and likely to break.</span></span>

<span data-ttu-id="aed82-131">마이크로 서비스 기본 원칙을 따르면 모든 팀이 줄을 서야 하는 긴 릴리스 기차가 없어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-131">Following the microservices philosophy, there should never be a long release train where every team has to get in line.</span></span> <span data-ttu-id="aed82-132">서비스 "A"를 빌드하는 팀은 병합, 테스트 및 배포될 서비스 "B"의 변경 내용을 기다릴 필요 없이 언제든지 업데이트를 릴리스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-132">The team that builds service "A" can release an update at any time, without waiting for changes in service "B" to be merged, tested, and deployed.</span></span>

![CI/CD 모놀리식의 다이어그램](./images/cicd-monolith.png)

<span data-ttu-id="aed82-134">높은 릴리스 개발 속도 위해 릴리스 파이프라인 자동화 되 고 위험을 최소화 하기 위해 매우 안정적 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-134">To achieve a high release velocity, your release pipeline must be automated and highly reliable, to minimize risk.</span></span> <span data-ttu-id="aed82-135">매일 또는 하루에 여러 번 프로덕션에 릴리스, 재발 또는 서비스 중단 매우 드물어 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-135">If you release to production daily or multiple times a day, regressions or service disruptions must be very rare.</span></span> <span data-ttu-id="aed82-136">동시에 잘못된 업데이트가 배포되는 경우 이전 버전의 서비스로 롤백하거나 롤포워드하는 신뢰할 수 있는 방법이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-136">At the same time, if a bad update does get deployed, you must have a reliable way to quickly roll back or roll forward to a previous version of a service.</span></span>

## <a name="challenges"></a><span data-ttu-id="aed82-137">과제</span><span class="sxs-lookup"><span data-stu-id="aed82-137">Challenges</span></span>

- <span data-ttu-id="aed82-138">**다수의 작은 독립적인 코드 베이스**</span><span class="sxs-lookup"><span data-stu-id="aed82-138">**Many small independent code bases**.</span></span> <span data-ttu-id="aed82-139">각 팀은 자체 빌드 파이프라인으로 자체 서비스 구축을 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-139">Each team is responsible for building its own service, with its own build pipeline.</span></span> <span data-ttu-id="aed82-140">일부 조직에서 팀은 별도 코드 리포지토리를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-140">In some organizations, teams may use separate code repositories.</span></span> <span data-ttu-id="aed82-141">별도 저장소 시스템을 구축 하는 방법의 기술 팀 간에 분산 되 고 전체 응용 프로그램을 배포 하는 방법을 알고 있는 조직에서 아무도 있는 상황이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-141">Separate repositories can lead to a situation where the knowledge of how to build the system is spread across teams, and nobody in the organization knows how to deploy the entire application.</span></span> <span data-ttu-id="aed82-142">예를 들어 새 클러스터에 빠르게 배포해야 하는 경우 재해 복구 시나리오에서 무슨 일이 발생하나요?</span><span class="sxs-lookup"><span data-stu-id="aed82-142">For example, what happens in a disaster recovery scenario, if you need to quickly deploy to a new cluster?</span></span>

    <span data-ttu-id="aed82-143">**해결 방법**: 이 기술 숨겨져 있지 않으면"" 각 팀 내에서 되도록 빌드 서비스를 배포 하는 통합 및 자동화 된 파이프라인 경우</span><span class="sxs-lookup"><span data-stu-id="aed82-143">**Mitigation**: Have a unified and automated pipeline to build and deploy services, so that this knowledge is not "hidden" within each team.</span></span>

- <span data-ttu-id="aed82-144">**여러 언어 및 프레임워크**</span><span class="sxs-lookup"><span data-stu-id="aed82-144">**Multiple languages and frameworks**.</span></span> <span data-ttu-id="aed82-145">자체 기술 조합을 사용하는 각 팀과 함께 조직 전체에서 작동하는 단일 빌드 프로세스를 만드는 것은 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-145">With each team using its own mix of technologies, it can be difficult to create a single build process that works across the organization.</span></span> <span data-ttu-id="aed82-146">빌드 프로세스는 모든 팀이 언어 또는 프레임워크의 선택으로 채택할 만큼 충분히 유연해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-146">The build process must be flexible enough that every team can adapt it for their choice of language or framework.</span></span>

    <span data-ttu-id="aed82-147">**해결 방법**: 각 서비스에 대 한 빌드 프로세스를 컨테이너 화 합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-147">**Mitigation**: Containerize the build process for each service.</span></span> <span data-ttu-id="aed82-148">이런 방식으로 빌드 시스템만 해야 컨테이너를 실행할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-148">That way, the build system just needs to be able to run the containers.</span></span>

- <span data-ttu-id="aed82-149">**통합 및 부하 테스트**</span><span class="sxs-lookup"><span data-stu-id="aed82-149">**Integration and load testing**.</span></span> <span data-ttu-id="aed82-150">팀의 페이스로 업데이트를 릴리스하는 팀과 함께 특히 서비스에 다른 서비스에 대한 종속성이 있는 경우 강력한 종단 간 테스트를 디자인하는 것은 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-150">With teams releasing updates at their own pace, it can be challenging to design robust end-to-end testing, especially when services have dependencies on other services.</span></span> <span data-ttu-id="aed82-151">또한 전체 프로덕션 클러스터를 실행 부담이 클 수 있으므로 모든 팀 단지 테스트만 위해 프로덕션 규모에서 자체 전체 클러스터를 실행 되는 가능성이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-151">Moreover, running a full production cluster can be expensive, so it's unlikely that every team will run its own full cluster at production scales, just for testing.</span></span>

- <span data-ttu-id="aed82-152">**릴리스 관리**</span><span class="sxs-lookup"><span data-stu-id="aed82-152">**Release management**.</span></span> <span data-ttu-id="aed82-153">모든 팀 프로덕션에 업데이트를 배포할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-153">Every team should be able to deploy an update to production.</span></span> <span data-ttu-id="aed82-154">모든 팀 멤버가 그렇게 할 권한이 있음을 의미하는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-154">That doesn't mean that every team member has permissions to do so.</span></span> <span data-ttu-id="aed82-155">하지만 중앙 집중식 릴리스 관리자 역할을 가지면 배포의 개발 속도를 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-155">But having a centralized Release Manager role can reduce the velocity of deployments.</span></span>

    <span data-ttu-id="aed82-156">**Migitation**: CI/CD 프로세스가 더욱 자동화되고 안정적이 될수록 중앙 기관에 대한 필요가 적어져야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-156">**Migitation**: The more that your CI/CD process is automated and reliable, the less there should be a need for a central authority.</span></span> <span data-ttu-id="aed82-157">즉, 주요 기능 업데이트와 사소한 버그 수정 릴리스에 대해 다른 정책을 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-157">That said, you might have different policies for releasing major feature updates versus minor bug fixes.</span></span> <span data-ttu-id="aed82-158">분산 되는 0 거 버 넌 스를 의미 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-158">Being decentralized doesn't mean zero governance.</span></span>

- <span data-ttu-id="aed82-159">**서비스 업데이트**</span><span class="sxs-lookup"><span data-stu-id="aed82-159">**Service updates**.</span></span> <span data-ttu-id="aed82-160">서비스를 새 버전으로 업데이트하는 경우 종속된 다른 서비스를 중단하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-160">When you update a service to a new version, it shouldn't break other services that depend on it.</span></span>

    <span data-ttu-id="aed82-161">**해결 방법**: 사소한 변경 내용에 대 한 파란색 녹색 또는 카나리아 릴리스 같은 배포 기술을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-161">**Mitigation**: Use deployment techniques such as blue-green or canary release for non-breaking changes.</span></span> <span data-ttu-id="aed82-162">주요 API 변경 내용에 대 한 이전 버전과 함께 새 버전을 배포 합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-162">For breaking API changes, deploy the new version side by side with the previous version.</span></span> <span data-ttu-id="aed82-163">이런 방식으로 이전 API를 사용 하는 서비스 업데이트 및 테스트할 수 새로운 API에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-163">That way, services that consume the previous API can be updated and tested for the new API.</span></span> <span data-ttu-id="aed82-164">참조 [서비스 업데이트](#updating-services)아래.</span><span class="sxs-lookup"><span data-stu-id="aed82-164">See [Updating services](#updating-services), below.</span></span>

## <a name="monorepo-vs-multi-repo"></a><span data-ttu-id="aed82-165">Monorepo vs 여러 리포지토리</span><span class="sxs-lookup"><span data-stu-id="aed82-165">Monorepo vs multi-repo</span></span>

<span data-ttu-id="aed82-166">CI/CD 워크플로를 만들기 전에 코드 베이스가 구조화되고 관리되는 방법을 알아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-166">Before creating a CI/CD workflow, you must know how the code base will be structured and managed.</span></span>

- <span data-ttu-id="aed82-167">팀이 별도의 리포지토리에서 작업합니까, 아니면 단일 리포지토리에서 작업합니까?</span><span class="sxs-lookup"><span data-stu-id="aed82-167">Do teams work in separate respositories or in a monorepo (single respository)?</span></span>
- <span data-ttu-id="aed82-168">분기 전략은 무엇입니까?</span><span class="sxs-lookup"><span data-stu-id="aed82-168">What is your branching strategy?</span></span>
- <span data-ttu-id="aed82-169">프로덕션 환경에 코드를 푸시할 수 있는 사람은 누구입니까?</span><span class="sxs-lookup"><span data-stu-id="aed82-169">Who can push code to production?</span></span> <span data-ttu-id="aed82-170">릴리스 관리자 역할이 있습니까?</span><span class="sxs-lookup"><span data-stu-id="aed82-170">Is there a release manager role?</span></span>

<span data-ttu-id="aed82-171">단일 리포지토리 접근법이 지지를 받고 있지만 두 방식에는 모두 장단점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-171">The monorepo approach has been gaining favor but there are advantages and disadvantages to both.</span></span>

| &nbsp; | <span data-ttu-id="aed82-172">단일 리포지토리</span><span class="sxs-lookup"><span data-stu-id="aed82-172">Monorepo</span></span> | <span data-ttu-id="aed82-173">다중 리포지토리</span><span class="sxs-lookup"><span data-stu-id="aed82-173">Multiple repos</span></span> |
|--------|----------|----------------|
| <span data-ttu-id="aed82-174">**장점**</span><span class="sxs-lookup"><span data-stu-id="aed82-174">**Advantages**</span></span> | <span data-ttu-id="aed82-175">코드 공유</span><span class="sxs-lookup"><span data-stu-id="aed82-175">Code sharing</span></span><br/><span data-ttu-id="aed82-176">코드 및 도구 표준화 용이</span><span class="sxs-lookup"><span data-stu-id="aed82-176">Easier to standardize code and tooling</span></span><br/><span data-ttu-id="aed82-177">코드 리팩터링 용이</span><span class="sxs-lookup"><span data-stu-id="aed82-177">Easier to refactor code</span></span><br/><span data-ttu-id="aed82-178">검색 기능 - 코드의 단일 보기</span><span class="sxs-lookup"><span data-stu-id="aed82-178">Discoverability - single view of the code</span></span><br/> | <span data-ttu-id="aed82-179">팀별로 명확한 소유권</span><span class="sxs-lookup"><span data-stu-id="aed82-179">Clear ownership per team</span></span><br/><span data-ttu-id="aed82-180">잠재적으로 더 적은 병합 충돌</span><span class="sxs-lookup"><span data-stu-id="aed82-180">Potentially fewer merge conflicts</span></span><br/><span data-ttu-id="aed82-181">마이크로 서비스를 강제로 분리하는 데 유용</span><span class="sxs-lookup"><span data-stu-id="aed82-181">Helps to enforce decoupling of microservices</span></span> |
| <span data-ttu-id="aed82-182">**과제**</span><span class="sxs-lookup"><span data-stu-id="aed82-182">**Challenges**</span></span> | <span data-ttu-id="aed82-183">공유 코드에 대한 변경 사항이 여러 마이크로 서비스에 영향을 줄 수 있음</span><span class="sxs-lookup"><span data-stu-id="aed82-183">Changes to shared code can affect multiple microservices</span></span><br/><span data-ttu-id="aed82-184">병합 충돌 가능성 증가</span><span class="sxs-lookup"><span data-stu-id="aed82-184">Greater potential for merge conflicts</span></span><br/><span data-ttu-id="aed82-185">대규모 코드 베이스에 맞게 도구를 확장해야 함</span><span class="sxs-lookup"><span data-stu-id="aed82-185">Tooling must scale to a large code base</span></span><br/><span data-ttu-id="aed82-186">Access Control</span><span class="sxs-lookup"><span data-stu-id="aed82-186">Access control</span></span><br/><span data-ttu-id="aed82-187">더 복잡한 배포 프로세스</span><span class="sxs-lookup"><span data-stu-id="aed82-187">More complex deployment process</span></span> | <span data-ttu-id="aed82-188">코드를 공유하기가 더 어려움</span><span class="sxs-lookup"><span data-stu-id="aed82-188">Harder to share code</span></span><br/><span data-ttu-id="aed82-189">코딩 표준을 적용하기가 더 어려움</span><span class="sxs-lookup"><span data-stu-id="aed82-189">Harder to enforce coding standards</span></span><br/><span data-ttu-id="aed82-190">종속성 관리</span><span class="sxs-lookup"><span data-stu-id="aed82-190">Dependency management</span></span><br/><span data-ttu-id="aed82-191">분산된 코드 베이스, 검색 기능 저하</span><span class="sxs-lookup"><span data-stu-id="aed82-191">Diffuse code base, poor discoverability</span></span><br/><span data-ttu-id="aed82-192">공유 인프라 결여</span><span class="sxs-lookup"><span data-stu-id="aed82-192">Lack of shared infrastructure</span></span>

## <a name="updating-services"></a><span data-ttu-id="aed82-193">서비스 업데이트</span><span class="sxs-lookup"><span data-stu-id="aed82-193">Updating services</span></span>

<span data-ttu-id="aed82-194">이미 프로덕션 환경에 있는 서비스를 업데이트하기 위한 다양한 전략이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-194">There are various strategies for updating a service that's already in production.</span></span> <span data-ttu-id="aed82-195">여기에서는 다음과 같은 세 가지 일반 옵션을 설명합니다. 롤링 업데이트, 청록색 배포 및 카나리아 릴리스.</span><span class="sxs-lookup"><span data-stu-id="aed82-195">Here we discuss three common options: Rolling update, blue-green deployment, and canary release.</span></span>

### <a name="rolling-updates"></a><span data-ttu-id="aed82-196">롤링 업데이트</span><span class="sxs-lookup"><span data-stu-id="aed82-196">Rolling updates</span></span>

<span data-ttu-id="aed82-197">롤링 업데이트에서 서비스의 새 인스턴스를 배포하고 새 인스턴스는 즉시 요청 수신을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-197">In a rolling update, you deploy new instances of a service, and the new instances start receiving requests right away.</span></span> <span data-ttu-id="aed82-198">새 인스턴스가 나타나면 이전 인스턴스가 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-198">As the new instances come up, the previous instances are removed.</span></span>

<span data-ttu-id="aed82-199">**예제.**</span><span class="sxs-lookup"><span data-stu-id="aed82-199">**Example.**</span></span> <span data-ttu-id="aed82-200">Kubernetes의 경우에서 롤링 업데이트는 배포의 pod 사양을 업데이트할 때 기본 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-200">In Kubernetes, rolling updates are the default behavior when you update the pod spec for a Deployment.</span></span> <span data-ttu-id="aed82-201">배포 컨트롤러는 업데이트된 Pod에 대한 새 ReplicaSet를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-201">The Deployment controller creates a new ReplicaSet for the updated pods.</span></span> <span data-ttu-id="aed82-202">그런 다음 원하는 복제본 수를 유지하도록 기존 것을 축소하는 동안 새 ReplicaSet를 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-202">Then it scales up the new ReplicaSet while scaling down the old one, to maintain the desired replica count.</span></span> <span data-ttu-id="aed82-203">새 것이 준비될 때까지 이전 Pod를 삭제하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-203">It doesn't delete old pods until the new ones are ready.</span></span> <span data-ttu-id="aed82-204">Kubernetes 롤업할 수 있도록 다시 업데이트 필요한 경우 업데이트의 기록을 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-204">Kubernetes keeps a history of the update, so you can roll back an update if needed.</span></span>

<span data-ttu-id="aed82-205">롤링 업데이트의 한 가지 문제는 업데이트 프로세스 중 이전 버전과 새 버전의 혼합이 실행되고 트래픽을 수신한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-205">One challenge of rolling updates is that during the update process, a mix of old and new versions are running and receiving traffic.</span></span> <span data-ttu-id="aed82-206">이 기간 동안 모든 요청은 두 버전 중 하나로 라우팅될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-206">During this period, any request could get routed to either of the two versions.</span></span>

<span data-ttu-id="aed82-207">주요 API 변경 내용에 대 한 이전 버전의 모든 클라이언트가 업데이트 될 때까지 두 버전 모두 나란히 지원 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-207">For breaking API changes, a good practice is to support both versions side by side, until all clients of the previous version are updated.</span></span> <span data-ttu-id="aed82-208">참조 [API 버전 관리](./design/api-design.md#api-versioning)합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-208">See [API versioning](./design/api-design.md#api-versioning).</span></span>

### <a name="blue-green-deployment"></a><span data-ttu-id="aed82-209">청록색 배포</span><span class="sxs-lookup"><span data-stu-id="aed82-209">Blue-green deployment</span></span>

<span data-ttu-id="aed82-210">청록색 배포에서 이전 버전과 함께 새 버전을 배포합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-210">In a blue-green deployment, you deploy the new version alongside the previous version.</span></span> <span data-ttu-id="aed82-211">새 버전의 유효성을 검사한 후 이전 버전에서 새 버전으로 모든 트래픽을 한 번에 전환합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-211">After you validate the new version, you switch all traffic at once from the previous version to the new version.</span></span> <span data-ttu-id="aed82-212">전환 후 모든 문제에 대해 애플리케이션을 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-212">After the switch, you monitor the application for any problems.</span></span> <span data-ttu-id="aed82-213">문제가 발생하는 경우 이전 버전으로 바꿀 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-213">If something goes wrong, you can swap back to the old version.</span></span> <span data-ttu-id="aed82-214">문제가 없는 경우 이전 버전을 삭제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-214">Assuming there are no problems, you can delete the old version.</span></span>

<span data-ttu-id="aed82-215">더 일반적인 모놀리식 또는 N 계층 애플리케이션으로 청록색 배포는 일반적으로 두 개의 동일한 환경 프로비전을 의미했습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-215">With a more traditional monolithic or N-tier application, blue-green deployment generally meant provisioning two identical environments.</span></span> <span data-ttu-id="aed82-216">스테이징 환경에 새 버전을 배포한 다음 스테이징 환경에 클라이언트 트래픽을 리디렉션합니다. &mdash; 예를 들어 VIP 주소를 교환하여 리디렉션합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-216">You would deploy the new version to a staging environment, then redirect client traffic to the staging environment &mdash; for example, by swapping VIP addresses.</span></span> <span data-ttu-id="aed82-217">일반적으로 동일한 환경에 업데이트를 배포 하는 서비스 검색 메커니즘을 사용 하 여 교환할 수 있도록 업데이트는 마이크로 서비스 아키텍처에서 마이크로 서비스 수준에서 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-217">In a microservices architecture, updates happen at the microservice level, so you would typically deploy the update into the same environment and use a service discovery mechanism to swap.</span></span>

<span data-ttu-id="aed82-218">**예제**.</span><span class="sxs-lookup"><span data-stu-id="aed82-218">**Example**.</span></span> <span data-ttu-id="aed82-219">Kubernetes에서는 청록색 배포를 수행하기 위해 별도 클러스터를 프로비전할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-219">In Kubernetes, you don't need to provision a separate cluster to do blue-green deployments.</span></span> <span data-ttu-id="aed82-220">대신 선택기를 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-220">Instead, you can take advantage of selectors.</span></span> <span data-ttu-id="aed82-221">새 Pod 사양 및 다른 집합의 레이블을 사용하여 새 배포 리소스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-221">Create a new Deployment resource with a new pod spec and a different set of labels.</span></span> <span data-ttu-id="aed82-222">이전 배포를 삭제하거나 이를 가리키는 서비스를 수정하지 않고 이 배포를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-222">Create this deployment, without deleting the previous deployment or modifying the service that points to it.</span></span> <span data-ttu-id="aed82-223">새 Pod가 실행되면 새 배포에 맞게 해당 서비스의 선택기를 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-223">Once the new pods are running, you can update the service's selector to match the new deployment.</span></span>

<span data-ttu-id="aed82-224">청록색 배포의 한 가지 단점은 업데이트 중를 실행 하는 배의 서비스에 대해 pod (현재 및 다음) 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-224">One drawback of blue-green deployment is that during the update, you are running twice as many pods for the service (current and next).</span></span> <span data-ttu-id="aed82-225">Pod에 CPU 또는 메모리 리소스가 많이 필요한 경우 리소스 사용을 처리하기 위해 클러스터를 일시적으로 확장해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-225">If the pods require a lot of CPU or memory resources, you may need to scale out the cluster temporarily to handle the resource consumption.</span></span>

### <a name="canary-release"></a><span data-ttu-id="aed82-226">카나리아 릴리스</span><span class="sxs-lookup"><span data-stu-id="aed82-226">Canary release</span></span>

<span data-ttu-id="aed82-227">카나리아 릴리스에서는 업데이트된 버전을 적은 수의 클라이언트로 롤아웃합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-227">In a canary release, you roll out an updated version to a small number of clients.</span></span> <span data-ttu-id="aed82-228">그런 다음 모든 클라이언트에 롤아웃하기 전에 새로운 서비스의 동작을 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-228">Then you monitor the behavior of the new service before rolling it out to all clients.</span></span> <span data-ttu-id="aed82-229">이를 통해 제어된 방식으로 느린 출시를 수행하고, 모든 고객이 영향을 받기 전에 실제 데이터와 스폿 문제를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-229">This lets you do a slow rollout in a controlled fashion, observe real data, and spot problems before all customers are affected.</span></span>

<span data-ttu-id="aed82-230">카나리아 릴리스는 요청을 서로 다른 버전의 서비스로 동적으로 라우팅해야 하기 때문에 청록색 또는 롤링 업데이트보다 관리하기가 복잡합니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-230">A canary release is more complex to manage than either blue-green or rolling update, because you must dynamically route requests to different versions of the service.</span></span>

<span data-ttu-id="aed82-231">**예제**.</span><span class="sxs-lookup"><span data-stu-id="aed82-231">**Example**.</span></span> <span data-ttu-id="aed82-232">Kubernetes에서는 두 개의 복제본 세트(각 버전에 대해 하나씩)를 확장하고 복제본 수를 수동으로 조정하도록 서비스를 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-232">In Kubernetes, you can configure a Service to span two replica sets (one for each version) and adjust the replica counts manually.</span></span> <span data-ttu-id="aed82-233">그러나 이 방법은 Kubernetes가 Pod에 대해 부하를 분산하는 방식으로 인해 정교하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-233">However, this approach is rather coarse-grained, because of the way Kubernetes load balances across pods.</span></span> <span data-ttu-id="aed82-234">예를 들어, 총 10 개의 복제본의 경우 10% 단위로 트래픽을 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-234">For example, if you have a total of 10 replicas, you can only shift traffic in 10% increments.</span></span> <span data-ttu-id="aed82-235">서비스 메시를 사용하는 경우 서비스 메시 라우팅 규칙을 사용하여 보다 정교한 카나리아 릴리스 전략을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-235">If you are using a service mesh, you can use the service mesh routing rules to implement a more sophisticated canary release strategy.</span></span>

## <a name="next-steps"></a><span data-ttu-id="aed82-236">다음 단계</span><span class="sxs-lookup"><span data-stu-id="aed82-236">Next steps</span></span>

<span data-ttu-id="aed82-237">Kubernetes에서 실행 되는 마이크로 서비스에 대 한 특정 CI/CD 사례를 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="aed82-237">Learn specific CI/CD practices for microservices running on Kubernetes.</span></span>

- [<span data-ttu-id="aed82-238">Kubernetes에서 마이크로 서비스에 대 한 CI/CD</span><span class="sxs-lookup"><span data-stu-id="aed82-238">CI/CD for microservices on Kubernetes</span></span>](./ci-cd-kubernetes.md)